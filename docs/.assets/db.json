{"ai\\DeepSeek 多轮对话和使用流模式输出.md":"#DeepSeek多轮对话和使用流模式输出-从官方文档得知API是一个“无状态”API，即服务端不记录用户请求的上下文，用户在每次请求时，需将之前所有对话历史拼接好后，传递给对话API。以两次会话为例：第一次```js;[{role:'system',content:'你是一个知识渊博的助手，请帮助用户解答问题'},{role:'user',content:'1+1等于几'},]```第二次，注意要把assistant的回复也加进去```js;[{role:'system',content:'你是一个知识渊博的助手，请帮助用户解答问题'},{role:'user',content:'1+1等于几'},{role:'assistant',content:'1+1等于2。这是基本的数学加法运算。'},{role:'user',content:'2+2等于几'},]```-如此重复循环就可以完成任意轮对话，并且模型可以“记住”前面的对话，附关键代码片段（使用流模式输出，提升用户体验）````Pythonmessages=[{\"role\":\"system\",\"content\":\"你是一个知识渊博的助手，请帮助用户解答问题\"},]i=0print(\"请输入任意问题后开始对话，输入exit退出。\")whileTrue:assistantOutput=\"\"i=i+1userInput=input(f\"{i}.问：\")ifuserInput.lower()==\"exit\":break;else:messages.append({\"role\":\"user\",\"content\":userInput})response=client.chat.completions.create(model=\"deepseek-chat\",messages=messages,stream=True,#流式)print(f\"{i}.答：\",end=\"\",flush=True)forchunkinresponse:assistantOutput+=chunk.choices[0].delta.contentprint(chunk.choices[0].delta.content,end='',flush=True)#输出实时刷新print(\"\")messages.append({\"role\":\"assistant\",\"content\":assistantOutput})```````","ai\\index.md":"#AI","ai\\langchain.md":"#langchain<https://github.com/alphasecio/langchain-examples><https://github.com/open-webui/open-webui>##[langchain](https://js.langchain.com/docs/how_to/#retrievers)<https://js.langchain.com/docs/how_to/installation/>","ai\\ollama.md":"#ollama-<https://ollama.com/download/windows>##ollama关闭退出-关闭OLLAMA的方法1:-在网页版OLLAMA中，点击页面右上角的“退出”按钮或选择“文件”菜单，然后选择“退出”选项。-查看是否有预设的快捷键，例如Ctrl+Q。-如果需要先保存工作再退出，先保存文档内容，然后按照上述步骤关闭窗口。-如果需要停止OLLAMA服务，可以使用以下命令：`sudosystemctlstopollama.service`","ai\\open-webui.md":"#open-webui<https://github.com/open-webui/open-webui?tab=BSD-3-Clause-1-ov-file><https://docs.openwebui.com/getting-started/api-endpoints/>","Back-End\\C语言\\C++\\C++basic.md":"#C++basic##前言>-C++是一种中级语言，它是由BjarneStroustrup于1979年在贝尔实验室开始设计开发的。>-C++进一步扩充和完善了C语言，是一种面向对象的程序设计语言。>-C++可运行于多种平台上，如Windows、MAC操作系统以及UNIX的各种版本。>-源码文件通用使用拓展名.cpp,.cp或.c###四大特性>-封装>-抽象>-继承>-多态###标准库>-三个重要部分组成>-核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。>-C++标准库，提供了大量的函数，用于操作文件、字符串等。>-标准模板库（STL），提供了大量的方法，用于操作数据结构等。##基础>-**对象-**对象具有状态和行为。例如：一只狗的状态-颜色、名称、品种，行为-摇动、叫唤、吃。对象是类的实例。>-**类-**类可以定义为描述对象行为/状态的模板/蓝图。>-**方法-**从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。>-**即时变量-**每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。```c++#include<iostream>//定义头文件usingnamespacestd;//告诉编译器使用std命名空间//main()是程序开始执行的地方intmain(){cout<<\"HelloWorld\";//输出HelloWorldreturn0;}```###关键词|asm|else|new|this||------------|---------|----------------|--------||auto|enum|operator|throw||bool|explicit|private|true||break|export|protected|try||case|extern|public|typedef||catch|false|register|typeid||char|float|reinterpret_cast|typename||class|for|return|union||const|friend|short|unsigned||const_cast|goto|signed|using||continue|if|sizeof|virtual||default|inline|static|void||delete|int|static_cast|volatile||do|long|struct|wchar_t||double|mutable|switch|while||dynamic_cast|namespace|template||###数据结构|类型|关键字||:-------|:------------------------------------||布尔型|bool||字符型|char||整型|int||浮点型|float||双浮点型|double||无类型|void||宽字符型|wchar_t(`typedefshortintwchar_t;`)||类型|位|范围||:-----------------|:------------|:----------------------------------------------------------------||char|1个字节|-128到127或者0到255||unsignedchar|1个字节|0到255||signedchar|1个字节|-128到127||int|4个字节|-2147483648到2147483647||unsignedint|4个字节|0到4294967295||signedint|4个字节|-2147483648到2147483647||shortint|2个字节|-32768到32767||unsignedshortint|2个字节|0到65,535||signedshortint|2个字节|-32768到32767||longint|8个字节|-9,223,372,036,854,775,808到9,223,372,036,854,775,807||signedlongint|8个字节|-9,223,372,036,854,775,808到9,223,372,036,854,775,807||unsignedlongint|8个字节|0到18,446,744,073,709,551,615||float|4个字节|精度型占4个字节（32位）内存空间，+/-3.4e+/-38(~7个数字)||double|8个字节|双精度型占8个字节（64位）内存空间，+/-1.7e+/-308(~15个数字)||longdouble|16个字节|长双精度型16个字节（128位）内存空间，可提供18-19位有效数字。||wchar_t|2或4个字节|1个宽字符|####typedef声明>给已有的类型取一个新的名字```c++#include<iostream>usingnamespacestd;typedefintnewname;intmain(){newnamea=1;cout<<a<<endl;return0;}//1```####枚举类型```c++enum枚举名{标识符[=整型常数],标识符[=整型常数],...标识符[=整型常数]}枚举变量;```eg:```c++enumcolor{red,green,blue}c;c=blue;//2//可以自己赋值enumcolor{red,green=5,blue};```#####初始值```c++enumweek{Mon=1,Tues,Wed,Thurs=6,Fri,Sat,Sun}day;day=Wed;//3day=Fri;//7```>-默认值(但是前面的值没有赋值的情况下,有则是往后加一)>-第一个名称为0>-第二个名称为1>-以此类推<https://www.runoob.com/cplusplus/cpp-variable-types.html><http://c.biancheng.net/view/1367.html>","Back-End\\Database\\MongoDB\\mongo.md":"#Mongo##查询find方法,db.collection_name.find();查询所有的结果：select\\*fromusers;db.users.find();指定返回那些列（键）：selectname,skillsfromusers;db.users.find({},{'name':1,'skills':1});补充说明：第一个{}放where条件第二个{}指定那些列显示和不显示（0表示不显示1表示显示)where条件：1.简单的等于:selectname,age,skillsfromuserswherename='hurry';db.users.find({'name':'hurry'},{'name':1,'age':1,'skills':1});2.使用andselectname,age,skillsfromuserswherename='hurry'andage=18;db.users.find({'name':'hurry','age':18},{'name':1,'age':1,'skills':1});3.使用orselectname,age,skillsfromuserswherename='hurry'orage=18;db.users.find({'$or':[{'name':'hurry'},{'age':18}]},{'name':1,'age':1,'skills':1});4.<,<=,>,>=($lt,$lte,$gt,$gte)select\\*fromuserswhereage>=20andage<=30;db.users.find({'age':{'$gte':20,'$lte':30}});5.使用in,notin($in,$nin)select\\*fromuserswhereagein(10,22,26);db.users.find({'age':{'$in':[10,22,26]}});6.匹配nullselect\\*fromuserswhereageisnull;db.users.find({'age':null);7.like(mongoDB支持正则表达式)select\\*fromuserswherenamelike\"%hurry%\";db.users.find({name:/hurry/});select\\*fromuserswherenamelike\"hurry%\";db.users.find({name:/^hurry/});8.使用distinctselectdistinct(name)fromusers;db.users.distinct('name');9.使用countselectcount(\\*)fromusers;db.users.count();10.数组查询（mongoDB自己特有的）如果skills是['java','python']db.users.find({'skills':'java'});该语句可以匹配成功$alldb.users.find({'skills':{'$all':['java','python']}})skills中必须同时包含java和python$sizedb.users.find({'skills':{'$size':2}})遗憾的是$size不能与$lt等组合使用$slicedb.users.find({'skills':{'$slice:[1,1]}})两个参数分别是偏移量和返回的数量11.查询内嵌文档12.强大的$where查询db.foo.find();{\"\\_id\":ObjectId(\"4e17ce0ac39f1afe0ba78ce4\"),\"a\":1,\"b\":3,\"c\":10}{\"\\_id\":ObjectId(\"4e17ce13c39f1afe0ba78ce5\"),\"a\":1,\"b\":6,\"c\":6}如果要查询b=c的文档怎么办？\\>db.foo.find({\"$where\":function(){for(varcurrentinthis){​for(varotherinthis){​if(current!=other&&this[current]==this[other]){​returntrue;​}​}}returnfalse;}});{\"\\_id\":ObjectId(\"4e17ce13c39f1afe0ba78ce5\"),\"a\":1,\"b\":6,\"c\":6}1).大于，小于，大于或等于，小于或等于$gt:大于$lt:小于$gte:大于或等于$lte:小于或等于例子：db.collection.find({\"field\":{$gt:value}});//greaterthan:field>valuedb.collection.find({\"field\":{$lt:value}});//lessthan:field<valuedb.collection.find({\"field\":{$gte:value}});//greaterthanorequalto:field>=valuedb.collection.find({\"field\":{$lte:value}});//lessthanorequalto:field<=value如查询j大于3,小于4:db.things.find({j:{$lt:3}});db.things.find({j:{$gte:4}});也可以合并在一条语句内:db.collection.find({\"field\":{$gt:value1,$lt:value2}});//value1<field<value\\2)不等于$ne例子：db.things.find({x:{$ne:3}});\\3)in和notin($in$nin)语法：db.collection.find({\"field\":{$in:array}});例子：db.things.find({j:{$in:[2,4,6]}});db.things.find({j:{$nin:[2,4,6]}});\\4)取模运算$mod如下面的运算：db.things.find(\"this.a%10==1\")可用$mod代替：db.things.find({a:{$mod:[10,1]}})\\5)$all$all和$in类似，但是他需要匹配条件内所有的值：如有一个对象：{a:[1,2,3]}下面这个条件是可以匹配的：db.things.find({a:{$all:[2,3]}});但是下面这个条件就不行了：db.things.find({a:{$all:[2,3,4]}});\\6)$size$size是匹配数组内的元素数量的，如有一个对象：{a:[\"foo\"]}，他只有一个元素：下面的语句就可以匹配：db.things.find({a:{$size:1}});官网上说不能用来匹配一个范围内的元素，如果想找$size<5之类的，他们建议创建一个字段来保存元素的数量。Youcannotuse$sizetofindarangeofsizes(forexample:arrayswithmorethan1element).Ifyouneedtoqueryforarange,createanextrasizefieldthatyouincrementwhenyouaddelements.7）$exists$exists用来判断一个元素是否存在：如：db.things.find({a:{$exists:true}});//如果存在元素a,就返回db.things.find({a:{$exists:false}});//如果不存在元素a，就返回\\8)$type$type基于bsontype来匹配一个元素的类型，像是按照类型ID来匹配类型和ID对应列表如下：http://www.w3cschool.cc/mongodb/mongodb-operators-type.html更改字段类型如下：http://loo2k.com/blog/mongodb-change-field-type/http://blog.chinaunix.net/uid-15795819-id-3873422.html类型和java类型对比如下：http://docs.mongodb.org/ecosystem/drivers/java-types/http://docs.mongodb.org/manual/reference/bson-types/db.things.find({a:{$type:2}});//matchesifaisastringdb.things.find({a:{$type:16}});//matchesifaisanint9）正则表达式mongo支持正则表达式，如：db.customers.find({name:/acme.\\*corp/i});//后面的i的意思是区分大小写\\10)查询数据内的值下面的查询是查询colors内red的记录，如果colors元素是一个数据,数据库将遍历这个数组的元素来查询。db.things.find({colors:\"red\"});\\11)$elemMatch如果对象有一个元素是数组，那么$elemMatch可以匹配内数组内的元素：\\>t.find({x:{$elemMatch:{a:1,b:{$gt:1}}}}){\"\\_id\":ObjectId(\"4b5783300334000000000aa9\"),\"x\":[{\"a\":1,\"b\":3},7,{\"b\":99},{\"a\":11}]}$elemMatch:{a:1,b:{$gt:1}}所有的条件都要匹配上才行。注意，上面的语句和下面是不一样的。\\>t.find({\"x.a\":1,\"x.b\":{$gt:1}})$elemMatch是匹配{\"a\":1,\"b\":3}，而后面一句是匹配{\"b\":99},{\"a\":11}\\12)查询嵌入对象的值db.postings.find({\"author.name\":\"joe\"});注意用法是author.name，用一个点就行了。更详细的可以看这个链接：dotnotation举个例子：\\>db.blog.save({title:\"MyFirstPost\",author:{name:\"Jane\",id:1}})如果我们要查询authorsname是Jane的,我们可以这样：\\>db.blog.findOne({\"author.name\":\"Jane\"})如果不用点，那就需要用下面这句才能匹配：db.blog.findOne({\"author\":{\"name\":\"Jane\",\"id\":1}})下面这句：db.blog.findOne({\"author\":{\"name\":\"Jane\"}})是不能匹配的，因为mongodb对于子对象，他是精确匹配。\\13)元操作符$not取反如：db.customers.find({name:{$not:/acme.\\*corp/i}});db.things.find({a:{$not:{$mod:[10,1]}}});mongodb还有很多函数可以用，如排序，统计等，请参考原文。mongodb目前没有或(or)操作符，只能用变通的办法代替，可以参考下面的链接：http://www.mongodb.org/display/DOCS/OR+operations+in+query+expressions分类:MongoDB二、更新mongodb更新有两个命令：1).update()命令db.collection.update(criteria,objNew,upsert,multi)criteria:update的查询条件，类似sqlupdate查询内where后面的objNew:update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sqlupdate查询内set后面的upsert:这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。multi:mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。例：db.test0.update({\"count\":{$gt:1}},{$set:{\"test2\":\"OK\"}});只更新了第一条记录db.test0.update({\"count\":{$gt:3}},{$set:{\"test2\":\"OK\"}},false,true);全更新了db.test0.update({\"count\":{$gt:4}},{$set:{\"test5\":\"OK\"}},true,false);只加进去了第一条db.test0.update({\"count\":{$gt:5}},{$set:{\"test5\":\"OK\"}},true,true);全加进去了db.test0.update({\"count\":{$gt:15}},{$inc:{\"count\":1}},false,true);全更新了db.test0.update({\"count\":{$gt:10}},{$inc:{\"count\":1}},false,false);只更新了第一条2).save()命令db.collection.save(x)x就是要更新的对象，只能是单条记录。如果在collection内已经存在一个和x对象相同的\"\\_id\"的记录。mongodb就会把x对象替换collection内已经存在的记录，否则将会插入x对象，如果x内没有\\_id,系统会自动生成一个再插入。相当于上面update语句的upsert=true,multi=false的情况。例：db.test0.save({count:40,test1:\"OK\"});#\\_id系统会生成db.test0.save({\\_id:40,count:40,test1:\"OK\"});#如果test0内有\\_id等于40的，会替换，否则插入。mongodb的更新操作符：\\1)$inc用法：{$inc:{field:value}}意思对一个数字字段field增加value，例：\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":16,\"test1\":\"TESTTEST\",\"test2\":\"OK\",\"test3\":\"TESTTEST\",\"test4\":\"OK\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$inc:{\"count\":1}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":17,\"test1\":\"TESTTEST\",\"test2\":\"OK\",\"test3\":\"TESTTEST\",\"test4\":\"OK\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$inc:{\"count\":2}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":19,\"test1\":\"TESTTEST\",\"test2\":\"OK\",\"test3\":\"TESTTEST\",\"test4\":\"OK\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$inc:{\"count\":-1}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":\"TESTTEST\",\"test2\":\"OK\",\"test3\":\"TESTTEST\",\"test4\":\"OK\",\"test5\":\"OK\"}\\2)$set用法：{$set:{field:value}}就是相当于sql的setfield=value，全部数据类型都支持$set。例：\\>db.test0.update({\"\\_id\":15},{$set:{\"test1\":\"testv1\",\"test2\":\"testv2\",\"test3\":\"testv3\",\"test4\":\"testv4\"}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":\"testv1\",\"test2\":\"testv2\",\"test3\":\"testv3\",\"test4\":\"testv4\",\"test5\":\"OK\"}\\3)$unset用法：{$unset:{field:1}}顾名思义，就是删除字段了。例：\\>db.test0.update({\"\\_id\":15},{$unset:{\"test1\":1}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test2\":\"testv2\",\"test3\":\"testv3\",\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$unset:{\"test2\":0}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test3\":\"testv3\",\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$unset:{\"test3\":asdfasf}});FriMay1416:17:38JSError:ReferenceError:asdfasfisnotdefined(shell):0\\>db.test0.update({\"\\_id\":15},{$unset:{\"test3\":\"test\"}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test4\":\"testv4\",\"test5\":\"OK\"}没看出field:1里面的1是干什么用的，反正只要有东西就行。\\4)$push用法：{$push:{field:value}}把value追加到field里面去，field一定要是数组类型才行，如果field不存在，会新增一个数组类型加进去。例：\\>db.test0.update({\"\\_id\":15},{$set:{\"test1\":[\"aaa\",\"bbb\"]}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$push:{\"test1\":\"ccc\"}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$push:{\"test2\":\"ccc\"}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\"],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$push:{\"test1\":[\"ddd\",\"eee\"]}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}5)$pushAll\\5)$pushAll用法：{$pushAll:{field:value_array}}同$push,只是一次可以追加多个值到一个数组字段内。例：\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$pushAll:{\"test1\":[\"fff\",\"ggg\"]}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\"],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\6)$addToSet用法：{$addToSet:{field:value}}增加一个值到数组内，而且只有当这个值不在数组内才增加。例：\\>db.test0.update({\"\\_id\":15},{$addToSet:{\"test1\":{$each:[\"444\",\"555\"]}}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\",\"555\"],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$addToSet:{\"test1\":{$each:[\"444\",\"555\"]}}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\",\"555\"],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$addToSet:{\"test1\":[\"444\",\"555\"]}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\",\"555\",[\"444\",\"555\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$addToSet:{\"test1\":[\"444\",\"555\"]}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\",\"555\",[\"444\",\"555\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\7)$pop删除数组内的一个值用法：删除最后一个值：{$pop:{field:1}}删除第一个值：{$pop:{field:-1}}注意，只能删除一个值，也就是说只能用1或-1，而不能用2或-2来删除两条。mongodb1.1及以后的版本才可以用，例：\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\"],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$pop:{\"test1\":-1}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\"],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$pop:{\"test1\":1}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\8)$pull用法：$pull:{field:value}}从数组field内删除一个等于value值。例：\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$pull:{\"test1\":\"ggg\"}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"ccc\",[\"ddd\",\"eee\"],\"fff\",[\"111\",\"222\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\9)$pullAll用法：{$pullAll:{field:value_array}}同$pull,可以一次删除数组内的多个值。例：\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[\"ccc\",[\"ddd\",\"eee\"],\"fff\",[\"111\",\"222\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\>db.test0.update({\"\\_id\":15},{$pullAll:{\"test1\":[\"ccc\",\"fff\"]}});\\>db.test0.find({\"\\_id\":15});{\"\\_id\":{\"floatApprox\":15},\"count\":18,\"test1\":[[\"ddd\",\"eee\"],[\"111\",\"222\"]],\"test2\":[\"ccc\"],\"test4\":\"testv4\",\"test5\":\"OK\"}\\10)$操作符$是他自己的意思，代表按条件找出的数组里面某项他自己。呵呵，比较坳口。看一下官方的例子：\\>t.find(){\"\\_id\":ObjectId(\"4b97e62bf1d8c7152c9ccb74\"),\"title\":\"ABC\",\"comments\":[{\"by\":\"joe\",\"votes\":3},{\"by\":\"jane\",\"votes\":7}]}\\>t.update({'comments.by':'joe'},{$inc:{'comments.$.votes':1}},false,true)\\>t.find(){\"\\_id\":ObjectId(\"4b97e62bf1d8c7152c9ccb74\"),\"title\":\"ABC\",\"comments\":[{\"by\":\"joe\",\"votes\":4},{\"by\":\"jane\",\"votes\":7}]}需要注意的是，$只会应用找到的第一条数组项，后面的就不管了。还是看例子：\\>t.find();{\"\\_id\":ObjectId(\"4b9e4a1fc583fa1c76198319\"),\"x\":[1,2,3,2]}\\>t.update({x:2},{$inc:{\"x.$\":1}},false,true);\\>t.find();还有注意的是$配合$unset使用的时候，会留下一个null的数组项，不过可以用{$pull:{x:null}}删除全部是null的数组项。例：\\>t.insert({x:[1,2,3,4,3,2,3,4]})\\>t.find(){\"\\_id\":ObjectId(\"4bde2ad3755d00000000710e\"),\"x\":[1,2,3,4,3,2,3,4]}\\>t.update({x:3},{$unset:{\"x.$\":1}})\\>t.find(){\"\\_id\":ObjectId(\"4bde2ad3755d00000000710e\"),\"x\":[1,2,null,4,3,2,3,4]}{\"\\_id\":ObjectId(\"4b9e4a1fc583fa1c76198319\"),\"x\":[1,3,3,2]}============数组元素操作示例================\\>db.arraytest.insert({id:2,name:'leon',comments:[{id:'011',content:'cmt11'},{id:'012',content:'cmt12'},{id:'013',content:'cmt13'}]})\\1.数组内的元素可以直接查询\\>db.arraytest.find({'comments.id':'002'})\\2.更新数组中的某个节点的值,用$符号db.arraytest.update({'comments.id':'012'},{$set:{'comments.$.content':'cmtttt012'}})\\3.删除数组中的某一列，变成null\\>db.arraytest.update({'comments.id':'012'},{$unset:{'comments.$':1}})\\4.向数组中添加一个元素，如果之前没有元素则会新建数组\\>db.arraytest.update({'comments.id':'112'},{$push:{'comments.$.reply':{'rid':'r21',content:'reply22'}}})","Back-End\\Database\\MongoDB\\mongodb-basic.md":"#MongoDB>[MongoDB安装](https://blog.csdn.net/weixin_41466575/article/details/105326230)##启动与关闭```js//启动.\\bin\\mongod-dbpathC:\\RUIHUA\\env\\MongoDB\\data\\db//关闭.\\bin\\mongolocalhost:27017useadmin;db.shutdownServer();exit```","Back-End\\Database\\MongoDB\\mongodb-node.md":"#Node.js连接MongoDB>[Mongoosev5.13.2:APIdocs(mongoosejs.com)](https://mongoosejs.com/docs/api.html)>>MongoDB是一种文档导向数据库管理系统，由C++撰写而成。###安装驱动```shellcnpminstallmongodb```---##创建数据库要在MongoDB中创建一个数据库，首先我们需要创建一个MongoClient对象，然后配置好指定的URL和端口号。如果数据库不存在，MongoDB将创建数据库并建立连接。##创建连接```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/runoob'MongoClient.connect(url,function(err,db){if(err)throwerrconsole.log('数据库已创建!')db.close()})```---##创建集合我们可以使用createCollection()方法来创建集合：##创建集合```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/runoob'MongoClient.connect(url,function(err,db){if(err)throwerrconsole.log('数据库已创建')vardbase=db.db('runoob')dbase.createCollection('site',function(err,res){if(err)throwerrconsole.log('创建集合!')db.close()})})```---##数据库操作(CURD)与MySQL不同的是MongoDB会自动创建数据库和集合，所以使用前我们不需要手动去创建。###插入数据以下实例我们连接数据库runoob的site表，并插入一条数据条数据，使用**insertOne()**：##插入一条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('site')varmyobj={name:'grh',url:'ruihua'}dbo.collection('site').insertOne(myobj,function(err,res){if(err)throwerrconsole.log('文档插入成功')db.close()})})```执行以下命令输出就结果为：```shell$nodetest.js文档插入成功```从输出结果来看，数据已插入成功。我们也可以打开MongoDB的客户端查看数据，如：```shell>showdbsrunoob0.000GB#自动创建了runoob数据库>showtablessite#自动创建了site集合（数据表）>db.site.find(){\"_id\":ObjectId(\"5a794e36763eb821b24db854\"),\"name\":\"菜鸟教程\",\"url\":\"www.runoob\"}>```如果要插入多条数据可以使用**insertMany()**：##插入多条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('koadb')varmyobj=[{name:'grh',url:'https://github.com',type:'cn'},{name:'Google',url:'https://www.google.com',type:'en'},{name:'Facebook',url:'https://www.google.com',type:'en'},]dbo.collection('site').insertMany(myobj,function(err,res){if(err)throwerrconsole.log('插入的文档数量为:'+res.insertedCount)db.close()})})```res.insertedCount为插入的条数。###查询数据可以使用find()来查找数据,find()可以返回匹配条件的所有数据。如果未指定条件，find()返回集合中的所有数据。##find()```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('koadb')dbo.collection('site').find({}).toArray(function(err,result){//返回集合中所有数据if(err)throwerrconsole.log(result)db.close()})})```以下实例检索name为\"菜鸟教程\"的实例：##查询指定条件的数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('koadb')varwhereStr={name:'菜鸟教程'}//查询条件dbo.collection('site').find(whereStr).toArray(function(err,result){if(err)throwerrconsole.log(result)db.close()})})```执行以下命令输出就结果为：```shell[{_id:5a794e36763eb821b24db854,name:'菜鸟教程',url:'www.runoob'}]```###更新数据我们也可以对数据库的数据进行修改，以下实例将name为\"菜鸟教程\"的url改为<https://www.runoob.com>：##更新一条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('runoob')varwhereStr={name:'菜鸟教程'}//查询条件varupdateStr={$set:{url:'https://www.runoob.com'}}dbo.collection('site').updateOne(whereStr,updateStr,function(err,res){if(err)throwerrconsole.log('文档更新成功')db.close()})})```执行成功后，进入mongo管理工具查看数据已修改：```shell>db.site.find().pretty(){\"_id\":ObjectId(\"5a794e36763eb821b24db854\"),\"name\":\"菜鸟教程\",\"url\":\"https://www.runoob.com\"//已修改为https}```如果要更新所有符合条的文档数据可以使用**updateMany()**：##更新多条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('runoob')varwhereStr={type:'en'}//查询条件varupdateStr={$set:{url:'https://www.runoob.com'}}dbo.collection('site').updateMany(whereStr,updateStr,function(err,res){if(err)throwerrconsole.log(res.result.nModified+'条文档被更新')db.close()})})```result.nModified为更新的条数。###删除数据以下实例将name为\"菜鸟教程\"的数据删除:##删除一条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('runoob')varwhereStr={name:'菜鸟教程'}//查询条件dbo.collection('site').deleteOne(whereStr,function(err,obj){if(err)throwerrconsole.log('文档删除成功')db.close()})})```执行成功后，进入mongo管理工具查看数据已删除：```shell>db.site.find()>```如果要删除多条语句可以使用**deleteMany()**方法以下实例将type为en的所有数据删除:##删除多条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('runoob')varwhereStr={type:'en'}//查询条件dbo.collection('site').deleteMany(whereStr,function(err,obj){if(err)throwerrconsole.log(obj.result.n+'条文档被删除')db.close()})})```obj.result.n删除的条数。###排序排序使用sort()方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。例如：```shell{type:1}//按type字段升序{type:-1}//按type字段降序```按type升序排列:##排序```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('runoob')varmysort={type:1}dbo.collection('site').find().sort(mysort).toArray(function(err,result){if(err)throwerrconsole.log(result)db.close()})})```###查询分页如果要设置指定的返回条数可以使用**limit()**方法，该方法只接受一个参数，指定了返回的条数。##limit()：读取两条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('runoob')dbo.collection('site').find().limit(2).toArray(function(err,result){if(err)throwerrconsole.log(result)db.close()})})```如果要指定跳过的条数，可以使用**skip()**方法。##skip():跳过前面两条数据，读取两条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('runoob')dbo.collection('site').find().skip(2).limit(2).toArray(function(err,result){if(err)throwerrconsole.log(result)db.close()})})```###连接操作mongoDB不是一个关系型数据库，但我们可以使用**$lookup**来实现左连接。例如我们有两个集合数据分别为：集合1：orders```js;[{_id:1,product_id:154,status:1}]```集合2：products```js;[{_id:154,name:'笔记本电脑'},{_id:155,name:'耳机'},{_id:156,name:'台式电脑'},]```##$lookup实现左连接```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://127.0.0.1:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('runoob')dbo.collection('orders').aggregate([{$lookup:{from:'products',//右集合localField:'product_id',//左集合join字段foreignField:'_id',//右集合join字段as:'orderdetails',//新生成字段（类型array）},},]).toArray(function(err,res){if(err)throwerrconsole.log(JSON.stringify(res))db.close()})})```###删除集合我们可以使用**drop()**方法来删除集合：##drop()```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,function(err,db){if(err)throwerrvardbo=db.db('test')//删除test集合dbo.collection('test').drop(function(err,delOK){//执行成功delOK返回true，否则返回falseif(err)throwerrif(delOK)console.log('集合已删除')db.close()})})```---##使用PromisePromise是一个ECMAScript6提供的类，目的是更加优雅地书写复杂的异步任务。如果你还不了解Promise，可以参考[JavaScriptPromise](https://www.runoob.com/js/js-promise.html)。以下实例使用Promise创建集合：##实例```jsconstMongoClient=require('mongodb').MongoClientconsturl='mongodb://localhost/runoob'MongoClient.connect(url).then((conn)=>{console.log('数据库已连接')vardbase=conn.db('runoob')dbase.createCollection('site').then((res)=>{console.log('已创建集合')}).catch((err)=>{console.log('数据库操作错误')}).finally(()=>{conn.close()})}).catch((err)=>{console.log('数据库连接失败')})```###Promise数据操作现在我们在一个程序中实现四个连续操作：增加、查询、更改、删除。##实例```jsconstMongoClient=require('mongodb').MongoClientconsturl='mongodb://localhost/'MongoClient.connect(url).then((conn)=>{console.log('数据库已连接')consttest=conn.db('testdb').collection('test')//增加test.insertOne({site:'runoob.com'}).then((res)=>{//查询returntest.find().toArray().then((arr)=>{console.log(arr)})}).then(()=>{//更改returntest.updateMany({site:'runoob.com'},{$set:{site:'example.com'}},)}).then((res)=>{//查询returntest.find().toArray().then((arr)=>{console.log(arr)})}).then(()=>{//删除returntest.deleteMany({site:'example.com'})}).then((res)=>{//查询returntest.find().toArray().then((arr)=>{console.log(arr)})}).catch((err)=>{console.log('数据操作失败'+err.message)}).finally(()=>{conn.close()})}).catch((err)=>{console.log('数据库连接失败')})```执行结果：```js数据库已连接[{_id:5f1664966833e531d83d3ac6,site:'runoob.com'}][{_id:5f1664966833e531d83d3ac6,site:'example.com'}][]```###用异步函数实现相同的数据操作##实例```jsconstMongoClient=require('mongodb').MongoClientconsturl='mongodb://localhost/'asyncfunctiondataOperate(){varconn=nulltry{conn=awaitMongoClient.connect(url)console.log('数据库已连接')consttest=conn.db('testdb').collection('test')//增加awaittest.insertOne({site:'runoob.com'})//查询vararr=awaittest.find().toArray()console.log(arr)//更改awaittest.updateMany({site:'runoob.com'},{$set:{site:'example.com'}},)//查询arr=awaittest.find().toArray()console.log(arr)//删除awaittest.deleteMany({site:'example.com'})//查询arr=awaittest.find().toArray()console.log(arr)}catch(err){console.log('错误：'+err.message)}finally{if(conn!=null)conn.close()}}dataOperate()```运行结果：```js数据库已连接[{_id:5f169006a2780f0cd4ea640b,site:'runoob.com'}][{_id:5f169006a2780f0cd4ea640b,site:'example.com'}][]```","Back-End\\Database\\mybatis\\annotation-crud.md":"#Mybatis##静态SQL###mapper.xml```javapackagecom.how2java.mapper;importjava.util.List;importorg.apache.ibatis.annotations.Delete;importorg.apache.ibatis.annotations.Insert;importorg.apache.ibatis.annotations.Select;importorg.apache.ibatis.annotations.Update;importcom.how2java.pojo.Category;publicinterfaceCategoryMapper{@Insert(\"insertintocategory_(name)values(#{name})\")publicintadd(Categorycategory);@Delete(\"deletefromcategory_whereid=#{id}\")publicvoiddelete(intid);@Select(\"select*fromcategory_whereid=#{id}\")publicCategoryget(intid);@Update(\"updatecategory_setname=#{name}whereid=#{id}\")publicintupdate(Categorycategory);@Select(\"select*fromcategory_\")publicList<Category>list();}```###mybatis-config.xml```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><!DOCTYPEconfigurationPUBLIC\"-//mybatis.org//DTDConfig3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"><configuration><typeAliases><packagename=\"com.how2java.pojo\"/></typeAliases><environmentsdefault=\"development\"><environmentid=\"development\"><transactionManagertype=\"JDBC\"/><dataSourcetype=\"POOLED\"><propertyname=\"driver\"value=\"com.mysql.jdbc.Driver\"/><propertyname=\"url\"value=\"jdbc:mysql://localhost:3306/dbName?characterEncoding=UTF-8\"/><propertyname=\"username\"value=\"root\"/><propertyname=\"password\"value=\"admin\"/></dataSource></environment></environments><mappers><mapperresource=\"com/how2java/pojo/Category.xml\"/><mapperclass=\"com.how2java.mapper.CategoryMapper\"/></mappers></configuration>```###TestClass3```javapackagecom.how2java;importjava.io.IOException;importjava.io.InputStream;importjava.util.List;importorg.apache.ibatis.io.Resources;importorg.apache.ibatis.session.SqlSession;importorg.apache.ibatis.session.SqlSessionFactory;importorg.apache.ibatis.session.SqlSessionFactoryBuilder;importcom.how2java.mapper.CategoryMapper;importcom.how2java.pojo.Category;publicclassTestMybatis{publicstaticvoidmain(String[]args)throwsIOException{Stringresource=\"mybatis-config.xml\";InputStreaminputStream=Resources.getResourceAsStream(resource);SqlSessionFactorysqlSessionFactory=newSqlSessionFactoryBuilder().build(inputStream);SqlSessionsession=sqlSessionFactory.openSession();CategoryMappermapper=session.getMapper(CategoryMapper.class);//add(mapper);//delete(mapper);//get(mapper);//update(mapper);listAll(mapper);session.commit();session.close();}privatestaticvoidupdate(CategoryMappermapper){Categoryc=mapper.get(8);c.setName(\"修改了的Category名稱\");mapper.update(c);listAll(mapper);}privatestaticvoidget(CategoryMappermapper){Categoryc=mapper.get(8);System.out.println(c.getName());}privatestaticvoiddelete(CategoryMappermapper){mapper.delete(2);listAll(mapper);}privatestaticvoidadd(CategoryMappermapper){Categoryc=newCategory();c.setName(\"新增加的Category\");mapper.add(c);listAll(mapper);}privatestaticvoidlistAll(CategoryMappermapper){List<Category>cs=mapper.list();for(Categoryc:cs){System.out.println(c.getName());}}}```##动态SQL>-mapper使用>>-@UpdateProvider(type=VideoSqlProvider.class,method=\"updateVideo\")更新>-@InsertProvider插入>-@DeleteProvider删除>-@SelectProvider查询>>-method使用>-UPDATE()>-INSERT()>-SELECT()>-SET()>-WHERE()>-VALUE()>-DELETE()>-OR()>-FORM()```javaimportorg.apache.ibatis.jdbc.SQL;/***video构建动态sql语句*/publicclassVideoProvider{/***更新video动态语句*@paramvideo*@return*/publicStringupdateVideo(finalVideovideo){returnnewSQL(){{UPDATE(\"video\");//条件写法.if(video.getTitle()!=null){SET(\"title=#{title}\");}if(video.getSummary()!=null){SET(\"summary=#{summary}\");}if(video.getCoverImg()!=null){SET(\"cover_img=#{coverImg}\");}if(video.getViewNum()!=null){SET(\"view_num=#{viewNum}\");}if(video.getPrice()!=null){SET(\"price=#{price}\");}if(video.getOnline()!=null){SET(\"online=#{online}\");}if(video.getPoint()!=null){SET(\"point=#{point}\");}WHERE(\"id=#{id}\");}}.toString();}}```","Back-End\\Database\\mybatis\\mybatis-Plus.md":"#Mybatis-Plus##查到数据，但是返回空>-数据库定义字段名为`name1_name2`,实体类要定义`name1Name2`,而不是`name1_name2`>-或者写`mapper.xml`文件","Back-End\\Database\\mybatis\\mybatis.md":"#mybatis>[mybatis-spring–](http://mybatis.org/spring/zh/getting-started.html)##Mybatis注解增删改查###要点-有另一种方法来完成语句映射。它们映射的语句可以不用XML来配置，而可以使用Java注解来配置。-**使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java注解不仅力不从心，还会让你本就复杂的SQL语句更加混乱不堪。**-**如果你需要做一些很复杂的操作，最好用XML来映射语句。**-需要在config.xml中注册Java接口```xml<mappers><mapperclass=\"com.mybatis.DAO.PeopleMapper\"/></mappers>```>要用class=###查```javapublicinterfacePeopleMapper{@Select(\"select*frompeople\")List<People>getPeopleList();}```###增可以先开启事务自动提交```javapublicstaticSqlSessiongetSqlSession(){returnsqlSessionFactory.openSession(true);}}```Mapper.java```javapublicinterfacePeopleMapper{@Select(\"select*frompeople\")List<People>getPeopleList();@Insert(\"insertintopeople(id,name,age,address)VALUES(#{id},#{name},#{age},#{address})\")intaddPeople(Peoplepeople);}```test```javapublicclassPeopleDAOtest{@Testpublicvoidprint(){SqlSessionsqlSession=MybatisUtils.getSqlSession();PeopleMapperpeopleMapper=sqlSession.getMapper(PeopleMapper.class);List<People>people=peopleMapper.getPeopleList();for(Peoplep:people){System.out.println(p);}sqlSession.close();}@Testpublicvoidadd(){SqlSessionsqlSession=MybatisUtils.getSqlSession();PeopleMapperpeopleMapper=sqlSession.getMapper(PeopleMapper.class);peopleMapper.addPeople(newPeople(6,\"圣迭戈\",456,\"啥地方\"));print();}}```>因为已经自动提交了，所以不需要sqlSession.commit();###删-**注解@Param**1.只能用于基本数据类型2.传入的参数只能和sql语句中参数一样![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6be7cb5164e48d2b417e8af39fddfa2~tplv-k3u1fbpfcp-watermark.image)1.多个参数![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753abf07c5f04361a1e7de31c2ff8175~tplv-k3u1fbpfcp-watermark.image)-样例Mapper.java```javapublicinterfacePeopleMapper{@Delete(\"deletepeoplefrompeoplewhereid=#{uid}\")intdelPeople(@Param(\"uid\")inti);}```test```javapublicclassPeopleDAOtest{@Testpublicvoiddel(){SqlSessionsqlSession=MybatisUtils.getSqlSession();PeopleMapperpeopleMapper=sqlSession.getMapper(PeopleMapper.class);peopleMapper.delPeople(6);print();}}```###改Mapper.java```javapublicinterfacePeopleMapper{@Update(\"updatemybatis.peoplesetname=#{name},age=#{age},address=#{address}whereid=#{id}\")intupdateP(Peoplepeople);}```test```javapublicclassPeopleDAOtest{@Testpublicvoidupdate(){SqlSessionsqlSession=MybatisUtils.getSqlSession();PeopleMapperpeopleMapper=sqlSession.getMapper(PeopleMapper.class);peopleMapper.updateP(newPeople(5,\"圣迭戈\",456,\"啥地方\"));print();}}```><https://blog.csdn.net/weixin_43168190/article/details/102959304>##DEMO###pom.xml```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><projectxmlns=\"http://maven.apache.org/POM/4.0.0\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd\"><modelVersion>4.0.0</modelVersion><groupId>org.example</groupId><artifactId>MybatisDemo</artifactId><version>1.0-SNAPSHOT</version><name>MybatisDemo</name><!--FIXMEchangeittotheproject'swebsite--><url>http://www.example.com</url><properties><project.build.sourceEncoding>UTF-8</project.build.sourceEncoding><maven.compiler.source>1.7</maven.compiler.source><maven.compiler.target>1.7</maven.compiler.target></properties><dependencies><dependency><groupId>junit</groupId><artifactId>junit</artifactId><version>4.11</version><scope>test</scope></dependency><dependency><groupId>org.mybatis</groupId><artifactId>mybatis</artifactId><version>3.2.8</version></dependency><dependency><groupId>mysql</groupId><artifactId>mysql-connector-java</artifactId><version>8.0.18</version></dependency><dependency><groupId>log4j</groupId><artifactId>log4j</artifactId><version>1.2.17</version></dependency><dependency><groupId>junit</groupId><artifactId>junit</artifactId><version>4.12</version><scope>test</scope></dependency><dependency><groupId>org.projectlombok</groupId><artifactId>lombok</artifactId><version>RELEASE</version><scope>compile</scope></dependency><dependency><groupId>org.junit.jupiter</groupId><artifactId>junit-jupiter</artifactId><version>RELEASE</version><scope>compile</scope></dependency></dependencies><build><pluginManagement><!--lockdownpluginsversionstoavoidusingMavendefaults(maybemovedtoparentpom)--><plugins><!--cleanlifecycle,seehttps://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle--><plugin><artifactId>maven-clean-plugin</artifactId><version>3.1.0</version></plugin><!--defaultlifecycle,jarpackaging:seehttps://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging--><plugin><artifactId>maven-resources-plugin</artifactId><version>3.0.2</version></plugin><plugin><artifactId>maven-compiler-plugin</artifactId><version>3.8.0</version></plugin><plugin><artifactId>maven-surefire-plugin</artifactId><version>2.22.1</version></plugin><plugin><artifactId>maven-jar-plugin</artifactId><version>3.0.2</version></plugin><plugin><artifactId>maven-install-plugin</artifactId><version>2.5.2</version></plugin><plugin><artifactId>maven-deploy-plugin</artifactId><version>2.8.2</version></plugin><!--sitelifecycle,seehttps://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle--><plugin><artifactId>maven-site-plugin</artifactId><version>3.7.1</version></plugin><plugin><artifactId>maven-project-info-reports-plugin</artifactId><version>3.0.0</version></plugin></plugins></pluginManagement></build></project>```###log4j.properties```propertieslog4j.rootLogger=DEBUG,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[service]%d-%c-%-4r[%t]%-5p%c%x-%m%n#log4j.appender.R=org.apache.log4j.DailyRollingFileAppender#log4j.appender.R.File=../logs/service.log#log4j.appender.R.layout=org.apache.log4j.PatternLayout#log4j.appender.R.layout.ConversionPattern=[service]%d-%c-%-4r[%t]%-5p%c%x-%m%n#log4j.logger.com.ibatis=debug#log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug#log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug#log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug#log4j.logger.java.sql.Connection=debuglog4j.logger.java.sql.Statement=debuglog4j.logger.java.sql.PreparedStatement=debuglog4j.logger.java.sql.ResultSet=debug```###SqlMapConfig.xml```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><!DOCTYPEconfigurationPUBLIC\"-//mybatis.org//DTDConfig3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"><!--MyBatis的主配置文件--><configuration><!--配置环境--><environmentsdefault=\"mysql\"><!--配置MySQL环境--><environmentid=\"mysql\"><!--配置事务类型--><transactionManagertype=\"JDBC\"/><!--配置数据源/连接池--><dataSourcetype=\"POOLED\"><!--配置连接数据库的4个基本信息--><propertyname=\"driver\"value=\"com.mysql.cj.jdbc.Driver\"/><propertyname=\"url\"value=\"jdbc:mysql://localhost:3306/node?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\"/><propertyname=\"username\"value=\"root\"/><propertyname=\"password\"value=\"\"/></dataSource></environment></environments><!--指定映射配置文件的位置--><mappers><!--<mapperresource=\"IUserDao.xml\"/>-->//使用配置文件的用法<mapperclass=\"org.example.dao.IUserDao\"/>//使用注解开发的用法</mappers></configuration>```###User```javapackageorg.example.entity;importlombok.Data;importjava.util.Date;@DatapublicclassUser{privateintid;privateStringusername;privateDatebirthday;privateStringsex;privateStringaddress;@OverridepublicStringtoString(){return\"User{\"+\"id=\"+id+\",username='\"+username+'\\''+\",birthday=\"+birthday+\",sex='\"+sex+'\\''+\",address='\"+address+'\\''+'}';}}```###IUserDao.java```javapackageorg.example.dao;importorg.apache.ibatis.annotations.Select;importorg.example.entity.User;importjava.util.List;publicinterfaceIUserDao{List<User>findAll();@Select(\"select*fromeesy_mybatis\")List<User>findAllUser();}```###IUserDao.xml```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><!DOCTYPEmapperPUBLIC\"-//mybatis.org//DTDMapper3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><mappernamespace=\"org.example.dao.IUserDao\"><!--配置查询所有--><selectid=\"findAll\"resultType=\"org.example.entity.User\">select*fromeesy_mybatis</select></mapper>```###MybatisTest.java```javapackageorg.example.test;importorg.apache.ibatis.session.SqlSession;importorg.apache.ibatis.session.SqlSessionFactory;importorg.apache.ibatis.session.SqlSessionFactoryBuilder;importorg.example.dao.IUserDao;importorg.example.entity.User;importorg.junit.jupiter.api.Test;importorg.apache.ibatis.io.Resources;importjava.io.InputStream;importjava.util.List;publicclassMybatisTest{@Test//使用mapper.xml开发publicvoidDEMO()throwsException{InputStreamin=Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactoryBuilderbuilder=newSqlSessionFactoryBuilder();SqlSessionFactoryfactory=builder.build(in);SqlSessionsession=factory.openSession();IUserDaouserDao=session.getMapper(IUserDao.class);List<User>users=userDao.findAll();for(Useruser:users){System.out.println(user);}session.close();in.close();}@Test//使用注解开发publicvoidDEMO2()throwsException{InputStreamin=Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactoryBuilderbuilder=newSqlSessionFactoryBuilder();SqlSessionFactoryfactory=builder.build(in);SqlSessionsession=factory.openSession();IUserDaouserDao=session.getMapper(IUserDao.class);List<User>users=userDao.findAllUser();for(Useruser:users){System.out.println(user);}session.close();in.close();}}```##动态注解SQL```javaimportorg.apache.ibatis.jdbc.SQL;publicclassCategoryDynaSqlProvider{publicStringlist(){returnnewSQL().SELECT(\"*\").FROM(\"category_\").toString();}publicStringget(){returnnewSQL().SELECT(\"*\").FROM(\"category_\").WHERE(\"id=#{id}\").toString();}publicStringadd(){returnnewSQL().INSERT_INTO(\"category_\").VALUES(\"name\",\"#{name}\").toString();}publicStringupdate(){returnnewSQL().UPDATE(\"category_\").SET(\"name=#{name}\").WHERE(\"id=#{id}\").toString();}publicStringdelete(){returnnewSQL().DELETE_FROM(\"category_\").WHERE(\"id=#{id}\").toString();}}``````java@Insert(\"insertintocategory_(name)values(#{name})\")publicintadd(Categorycategory);//修改为了注解@InsertProvider配合CategoryDynaSqlProvider的add方法@InsertProvider(type=CategoryDynaSqlProvider.class,method=\"add\")publicintadd(Categorycategory);``````javapublicinterfaceCategoryMapper{@InsertProvider(type=CategoryDynaSqlProvider.class,method=\"add\")publicintadd(Categorycategory);@DeleteProvider(type=CategoryDynaSqlProvider.class,method=\"delete\")publicvoiddelete(intid);@SelectProvider(type=CategoryDynaSqlProvider.class,method=\"get\")publicCategoryget(intid);@UpdateProvider(type=CategoryDynaSqlProvider.class,method=\"update\")publicintupdate(Categorycategory);@SelectProvider(type=CategoryDynaSqlProvider.class,method=\"list\")publicList<Category>list();}**步骤****7****:****关于SQL类**SQL类是用于进行动态SQL生成的，如下代码是一个相对复杂的SQL类的使用举例，以后需要用到的时候，再来参考。privateStringselectPersonSql(){returnnewSQL(){{SELECT(\"P.ID,P.USERNAME,P.PASSWORD,P.FULL_NAME\");SELECT(\"P.LAST_NAME,P.CREATED_ON,P.UPDATED_ON\");FROM(\"PERSONP\");FROM(\"ACCOUNTA\");INNER_JOIN(\"DEPARTMENTDonD.ID=P.DEPARTMENT_ID\");INNER_JOIN(\"COMPANYConD.COMPANY_ID=C.ID\");WHERE(\"P.ID=A.ID\");WHERE(\"P.FIRST_NAMElike?\");OR();WHERE(\"P.LAST_NAMElike?\");GROUP_BY(\"P.ID\");HAVING(\"P.LAST_NAMElike?\");OR();HAVING(P.FIRST_NAMElike?\");ORDER_BY(\"P.ID\");ORDER_BY(\"P.FULL_NAME\");}}.toString();}```","Back-End\\Database\\mysql\\mysql-basic.md":"#MySQL-basic>[MySQL::DownloadMySQLCommunityServer(ArchivedVersions)](https://downloads.mysql.com/archives/community/)>>[MySQL::MySQLCommunityDownloads](https://dev.mysql.com/downloads/)##推荐文章>[MYSQL创建表的约束条件（可选）-迎风而来-博客园(cnblogs.com)](https://www.cnblogs.com/sui776265233/p/9343690.html)>>[(1条消息)MySQL索引的创建与使用\\_mysql创建索引](https://blog.csdn.net/justry_deng/article/details/81458470)##环境搭建>[免安装版安装](https://blog.csdn.net/qq_39135287/article/details/82117234)>>[官方下载路径](https://downloads.mysql.com/archives/community/)##基础使用```shellmysqld--install#安装mysql服务netstartmysql#启动mysql服务netstopmysql#关闭mysql服务mysql-uroot-p[密码]#登录[-p后面没有空格]```登录成功后```shellALLERUSER'root'@'localhost'IDENTFIEDBY'新密码';#修改密码exit;#退出```##控制台使用mysql```sqlselectuser();#查询用户showdatabases;#显示所有数据库createdatabase[数据库名]#创建数据库dropdatabase[数据库名]#删除数据库createdatabaseifnotexists#[数据库名]#判断数据库时候存在use[数据库名]#使用数据库showtables;#显示所有表#显示数据表的字段showcolumnsfrom[数据表名];describe[数据表名];desc[数据表名];select*from[数据表];#查询数据#其他selectnow();#查询时间selectversion();#查询数据库版本sourceC:\\RUIHUA\\Project\\mysql\\init.sql#执行本地脚本```##基础使用###基本数据类型>整数类型：BIT、BOOL、TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT>>浮点数类型：FLOAT、DOUBLE、DECIMAL>>字符串类型：CHAR、VARCHAR、NVARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB>>日期类型：Date、DateTime、TimeStamp、Time、Year>>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等###数据库>创建:`cratedatabasedatabaseName`>>删除:`dropdatabasedatabaseName`>>使用:`usedatabaseName`###表>删除:`droptabletableName`>>插入数据:`insertintotable_name(field1,field2,...)values(value1,value2,...)`####创建表```sqlCREATETABLEIFNOTEXISTS`user`(`user_id`INTUNSIGNEDAUTO_INCREMENT,`user_title`VARCHAR(100)NOTNULL,`user_author`VARCHAR(40)NOTNULL,`submission_date`DATE,PRIMARYKEY(`user_id`))ENGINE=InnoDBDEFAULTCHARSET=utf8;```>auto_increment:自增的属性,一般用于主键>>notnull:不可为空>>primarykey:关键字用于定义主键,使用多列来定义组件,列间以逗号分隔开>>engine:设置存储引擎>>charset:设置编码####更新>`updatetable_namesetfield1=new_value1,field2=new_value2...[whereclause]`###列####添加列，修改列，删除列```sqlALTERTABLE：添加，修改，删除表的列，约束等表的定义。查看列：desc表名;修改表名：altertablet_bookrenametobbb;添加列：altertable表名addcolumn列名varchar(30);删除列：altertable表名dropcolumn列名;修改列名MySQL：altertablebbbchangennnnnhhint;修改列名SQLServer：execsp_rename't_student.name','nn','column';修改列名Oracle：ltertablebbbrenamecolumnnnnnntohhint;修改列属性：altertablet_bookmodifynamevarchar(22);```####MySQL查看约束，添加约束，删除约束添加列，修改列，删除列```sql查看表的字段信息：desc表名;查看表的所有信息：showcreatetable表名;添加主键约束：altertable表名addconstraint主键（形如：PK_表名）primarykey表名(主键字段);添加外键约束：altertable从表addconstraint外键（形如：FK_从表_主表）foreignkey从表(外键字段)references主表(主键字段);删除主键约束：altertable表名dropprimarykey;删除外键约束：altertable表名dropforeignkey外键（区分大小写）;修改表名：altertablet_bookrenametobbb;添加列：altertable表名addcolumn列名varchar(30);删除列：altertable表名dropcolumn列名;修改列名MySQL：altertablebbbchangennnnnhhint;修改列属性：altertablet_bookmodifynamevarchar(22);```###**select查询**```sql//查询某张表所有数据select*fromtemp;//查询指定列和条件的数据//查询name和age这两列，age等于22的数据selectname,agefromtempwhereage=22;//as对列重命名//as可以省略不写，如果重命名的列名出现特殊字符，如单引号，那就需要用双引号引在外面selectnameas'名称'fromtemp;//给table去别名selectt.nameNamefromtempast;//where条件查询>、>=、<、<=、=、<>都可以出现在where语句中selectfromtwherea>2ora>=3ora<5ora<=6ora=7ora<>0;//and并且//查询名称等于Jack并且年龄大于20的select*fromtempwhereage>20andname='jack';//or或者--满足一个条件即可select*fromtempwherename='jack'orname='jackson';//betweenvandv2--大于等于v且小于等于v2select*fromtempwhereagebetween20and25;//in查询--可以多个条件，类似于or--查询id在括号中出现的数据select*fromtempwhereidin(1,2,3);//like模糊查询--查询name以j开头的select*fromtempwherenamelike'j%';--查询name包含k的select*fromtempwherenamelike'%k%';--escape转义,指定\\为转义字符，上面的就可以查询name中包含“_”的数据--select*fromtempwherenamelike'\\_%'escape'\\';//isnull、isnotnull--查询为null的数据select*fromtempwherenameisnull;--查询不为null的数据select*fromtempwherenameisnotnull;//orderby--排序，升序(desc)、降序(asc)--默认升序select*fromtemporderbyid;select*fromtemporderbyidasc;--多列组合select*fromtemporderbyid,age;//notselect*fromtempwherenot(age>20);select*fromtempwhereidnotin(1,2);//distinct去掉重复数据selectdistinctidfromtemp;//多列将是组合的重复数据selectdistinctid,agefromtemp;//查询常量select5+2;selectconcat('a','bbb');//concat函数，字符串连接//concat和null进行连接，会导致连接后的数据成为nullselectconcat(name,'-eco')fromtemp;//对查询的数据进行运算操作selectage+2,age/2,age-2,age*2fromtempwhereage-2>22;```###分页```sqlselect*fromt_areainfowherelimit10,10;//查询第11-20条//使用子查询```###索引###分区","Back-End\\Database\\mysql\\mysql-expand.md":"#mysql-expand##变量声明与赋值####单变量赋值```sqldeclare@idint(16);set@a='12';set@b=(selectcount(*)fromuser);```####多变量赋值```sqldeclareidint(16);declarenamevarchar(128);selectid,nameinto@id,@namefromuserwhereid=1;select@id:=id,@name:=namefromuserwhereid=1;```##循环的使用###函数中使用```sql--获取根分类中的根分类名称delimiter//dropfunctionifexists'getRootCateName'//CREATEFUNCTIONgetRootCateName(cate_idvarchar(32))RETURNSvarchar(128)DETERMINISTIC--deterministicBEGINselectpid,categoryinto@p_id,@cate_namefromsystem_categorywhereid=cate_id;set@temp_id=@p_id;while@temp_id>0doselectpid,categoryinto@p_id,@cate_namefromsystem_categorywhereid=@temp_id;set@temp_id=@p_id;endwhile;RETURN@cate_name;end//delimiter;--调用selectgetRootCateName(28);```###选择语句使用```sqldelimiter//createfunctiongetScoreName(scoreint(10))RETURNSvarchar(128)DETERMINISTICBEGINifscore>=90thenset@grade='A';elseifscore<90andscore>=80thenset@grade='B';elseifscore<80andscore>=70thenset@grade='C';elseifscore<70andscore>=60thenset@grade='D';elseset@grade='E';endif;RETURN@grade;END//delimiter;--调用selectgetScoreName(91);```###分支语句使用```sqldelimiter//createfunctiongetScoreName2(scoreint(10))RETURNSvarchar(128)DETERMINISTICBEGINSELECTcasewhenscore>=90then'甲'whenscore>=80then'乙'whenscore>=70then'丙'whenscore>=60then'丁'else'差'endasgradeinto@commont_grade;RETURN@commont_grade;END//delimiter;--调用selectgetScoreName2(98);```###存储过程使用```sqlDELIMITER$$DROPPROCEDUREIFEXISTS'delete_session'$$CREATEDEFINER=`root`@`localhost`PROCEDURE`delete_session`(INtopint)BEGINDECLAREdoneINTDEFAULT0;DECLAREtemp_idINT;DECLAREcurCURSORfor(SELECTidfromuser);DECLARECONTINUEHANDLERFORNOTFOUNDSETdone=1;OPENcur;FETCHcurINTOtemp_id;WHILEdone<>1DODELETEFROMuser_sessionWHEREid=temp_id;FETCHcurINTOtemp_id;ENDWHILE;CLOSEcur;END$$DELIMITER;```###存储过程输入输出变量```sqlDELIMITER$$DROPPROCEDUREIFEXISTS`user_banlance`$$CREATEPROCEDUREuser_banlance(IN`in_userId`INT,IN`in_banlance`INT,OUTout_codeINT,OUTout_messageVARCHAR(100))_return:BEGINDECLARE_userIdbigint(20);DECLARE_banlanceint;--余额DECLARE_verisonINTDEFAULT0;DECLARE_errorINTDEFAULT0;DECLARECONTINUEHANDLERFORSQLEXCEPTIONSET_error=1;--异常处理SETout_code=-1;SETout_message='执行失败';#用户账户不存在IFNOTEXISTS(selectidfromuser_banlancewhereid=in_userId)THENSETout_code=1;SETout_message='用户不存在';LEAVE_return;ENDIF;selectverison,banlanceinto_verison,_banlancefromuser_banlancewhereid=in_userId;STARTTRANSACTION;--开启事务乐观锁的使用updateuser_banlancesetbanlance=banlance-in_banlance,verison=verison+1whereid=in_userIdandverison=_verison;SET@ret_update=ROW_COUNT();IF@ret_update=0THENROLLBACK;SETout_code=-4;SETout_message='系统错误';LEAVE_return;ENDIF;IF_error<>0THENROLLBACK;SETout_code=-3;SETout_message='系统错误';LEAVE_return;ELSECOMMIT;SETout_code=1;SETout_message='';ENDIF;END$$DELIMITER;--调用注意输出参数必须是声明的变量，否则会报错set@b=0;set@c='';calluser_banlance(1,10,@b,@c);select@b,@c```###存储过程的使用(查询游标)```sqlDELIMITER$$DROPPROCEDUREIFEXISTS`user_banlance`$$CREATEPROCEDUREuser_banlance(IN`in_userId`INT,IN`in_banlance`INT)BEGIN#遍历数据结束标志DECLAREdoneINTDEFAULTFALSE;DECLARE_idINT;DECLARE_banlanceBIGINT(20);#游标DECLAREcurCURSORFORSELECTid,banlanceFROMuser_banlancewhereid>in_userIdandbanlance>in_banlance;#将结束标志绑定到游标DECLARECONTINUEHANDLERFORNOTFOUNDSETdone=TRUE;--建表tb_tempDROPTABLEIFEXISTStb_temp;CREATETEMPORARYTABLEtb_temp(`id`intUNSIGNEDNOTNULL,`banlance`bigint(20)NOTNULL,PRIMARYKEY(`id`))ENGINE=MYISAMDEFAULTcharset=utf8;--打开游标OPENcur;--开始循环read_loop:LOOP--提取游标里的数据FETCHcurINTO_id,_banlance;IFdoneTHENLEAVEread_loop;ELSEreplaceintotb_temp(id,banlance)values(_id,_banlance);--替换具有唯一索引和主键索引的相同记录ENDIF;ENDLOOP;--关闭游标CLOSEcur;select*fromtb_temp;DROPTABLEIFEXISTStb_temp;END$$DELIMITER;--调用calluser_banlance(2,1500);```###游标循环另一种实现方式```sql--打开游标OPENcur;--开始循环REPEAT--提取游标里的数据FETCHcurINTO_id,_banlance;IFnotdoneTHENinsertintotb_temp(id,banlance)values(_id,_banlance);--替换具有唯一索引和主键索引的相同记录ENDIF;UNTILdoneENDREPEAT;--关闭游标CLOSEcur;```##存储过程与函数###区别>调用方式:>>-存储过程:callprocedure_name(args,args2...);>-函数:selectfunction_name(arges);>>返回值：>>-存储过程：多个值>-函数：只有一个返回值###存储过程与存储函数####存储过程>-存储过程是一组为了完成某项特定功能的sql语句集，其实质上就是一段存储在数据库中的代码，他可以由声明式的sql语句（如CREATE,UPDATE,SELECT等语句）和过程式sql语句（如IF...THEN...ELSE控制结构语句）组成。>-就是数据库SQL语言层面的代码封装与重用。#####存储过程的优缺点**优点:**>1.可增强sql语言的功能和灵活性>存储过程可以用流程控制语言编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。>2.良好的封装性>存储过程被创建后，可以在程序中被多次调用，而不必担心重写编写该存储过程的sql语句。>3.高性能>存储过程执行一次后，其执行规划就驻留在高速缓冲存储器中，以后的操作中只需要从高速缓冲器中调用已编译好的二进制代码执行即可，从而提高了系统性能。**缺点:**>-存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。#####创建存储过程#####DELIMITER定界符>-解决存储过程/函数里面有分号会导致该存储过程/函数提前结束的问题**DELIMITER语法格式：**```sqlDELIMITER?```>`?`是用户定义的结束符，通常这个符号可以是一些特殊的符号。另外应避免使用反斜杠,因为他是转义字符。若希望换回默认的分号作为结束标记，只需再在命令行输入下面的sql语句即可。```sqlDELIMITER;```#####存储过程创建>使用`CREATEPROCEDURE`语句来创建存储过程。```sqlCREATEPROCEDUREp_name([proc_parameter[,...]])routine_body```>语法项“proc_parameter”的语法格式是：```sql[IN|OUT|INOUT]parame_nametype```>p_name:存储过程的名称>>proc_parameter:指定存储过程中的参数列表>>-parame_name:参数名>-type:参数类型>-IN:输入参数，OUT:输出参数,INOUT:输入输出类型>>rountine_body:存储过程的主体部分>>-以`BEGIN`开始,`END`结束>-若只有一条语句可以忽略`BEGIN...END`#####局部变量```sqlDECLAREvar_nametype[DEFAULTvalue]```-\"var_name\"用于指定局部变量的名称；-\"type\"用来声明变量的类型；-\"DEFAULT\"用来指定默认值，如果没有指定则为NULL。>注意：局部变量只能在存储过程体的BEGIN...END语句块中;局部变量必须在存储过程体的开头处声明;局部变量的作用范围仅限于声明它的BEGIN...END语句块，其他语句块中的语句不可以使用它。#####用户变量用户变量一般以@开头。注意：滥用用户变量会导致程序难以理解及管理。#####SET语句>通过SET语句对局部变量赋值，其格式是：```sqlSETvar_name=expr[,var_name2=expr]....```#####SELECT....INTO语句>用SELECT...INTO语句把选定的列的值存储到局部变量中。格式是：```sqlSELECTcol_name[,..]INTOvar_name[,....]table_expr```-\"col_name\"用于指定列名；-\"var_name\"用于指定要赋值的变量名；-\"table_expr\"表示SELECT语句中FROM后面的部分。>注意：SELECT...INTO语句返回的结果集只能有一行数据。#####流程控制语句######if-then-else```sqlDELIMITER&&CREATEPROCEDUREproc2(rint)begindeclarevarint;setvar=parameter+1;ifvar=0theninsertintotvalues(17);endif;ifparameter=0thenupdatetsets1=s1+1;elseupdatetsets1=s1+2;endif;end;&&DELIMITER;```######**case语句:**```sqlDELIMITER&&CREATEPROCEDUREproc3(inparameterint)begindeclarevarint;setvar=parameter+1;casevarwhen0theninsertintotvalues(17);when1theninsertintotvalues(18);elseinsertintotvalues(19);endcase;end;&&DELIMITER;```######**while····endwhile:**```sqlDELIMITER&&CREATEPROCEDUREproc4()begindeclarevarint;setvar=0;whilevar<6doinsertintotvalues(var);setvar=var+1;endwhile;end;&&DELIMITER;```######**repeat····endrepea：**>在执行操作后检查结果，而while则是执行前进行检查。```sqlDELIMITER&&CREATEPROCEDUREproc5()begindeclarevint;setv=0;repeatinsertintotvalues(v);setv=v+1;untilv>=5endrepeat;end;&&DELIMITER;repeat--循环体until循环条件endrepeat;```######**loop·····endloop:**loop循环不需要初始条件，这点和while循环相似，同时和repeat循环一样不需要结束条件,leave语句的意义是离开循环。```sqlDELIMITER&&CREATEPROCEDUREproc6()begindeclarevint;setv=0;LOOP_LABLE:loopinsertintotvalues(v);setv=v+1;ifv>=5thenleaveLOOP_LABLE;--离开循环endif;endloop;end;&&DELIMITER;```######**ITERATE迭代：**```sqlDELIMITER&&CREATEPROCEDUREproc10()begindeclarevint;setv=0;LOOP_LABLE:loopifv=3thensetv=v+1;ITERATELOOP_LABLE;endif;insertintotvalues(v);setv=v+1;ifv>=5thenleaveLOOP_LABLE;endif;endloop;end;&&DELIMITER;```######游标>可以用来存储select语句查询到的结果集，这个结果集可以包含多行数据，从而使我们可以使用迭代的方法从游标中依次取出每行数据。>MySQL游标的特点：>>1.只读：无法通过光标更新基础表中的数据。>2.不可滚动：只能按照select语句确定的顺序获取行。不能以相反的顺序获取行。此外，不能跳过行或跳转到结果集中的特定行。>3.敏感：有两种游标：敏感游标和不敏感游标。>1.敏感游标指向实际数据，不敏感游标使用数据的临时副本。>2.敏感游标比一个不敏感的游标执行得更快，因为它不需要临时拷贝数据。MySQL游标是敏感的。1.声明游标游标声明必须在变量声明之后。如果在变量声明之前声明游标，MySQL将会发出一个错误。游标必须始终与select语句相关联。```sqldeclarecursor_namecursorforselect_statement;```2.打开游标使用open语句打开游标，只有先打开游标才能读取数据。```sqlopencursor_name```3.读取游标使用fetch语句来检索游标指向的一行数据，并将游标移动到结果集中的下一行。```sqlfetchcursor_nameintovar_name;```4.关闭游标使用close语句关闭游标。```sqlclosecursor_name;```当游标不再使用时，应该关闭它。当使用MySQL游标时，还必须声明一个`notfound`处理程序来处理当游标找不到任何行时的情况。因为每次调用fetch语句时，游标会尝试依次读取结果集中的每一行数据。当游标到达结果集的末尾时，它将无法获得数据，并且会产生一个条件。处理程序用于处理这种情况。```sqldeclarecontinuehandlerfornotfoundsettype=1;```type是一个变量，示游标到达结果集的结尾。```sqldelimiter?createPROCEDUREphoneDeal()BEGINDECLAREidvarchar(64);--idDECLAREphone1varchar(16);--phoneDECLAREpassword1varchar(32);--密码DECLAREname1varchar(64);--id--遍历数据结束标志DECLAREdoneINTDEFAULTFALSE;--游标DECLAREcur_accountCURSORFORselectphone,password,namefromaccount_temp;--将结束标志绑定到游标DECLARECONTINUEHANDLERFORNOTFOUNDSETdone=TRUE;--打开游标OPENcur_account;--遍历read_loop:LOOP--取值取多个字段FETCHNEXTfromcur_accountINTOphone1,password1,name1;IFdoneTHENLEAVEread_loop;ENDIF;--你自己想做的操作insertintoaccount(id,phone,password,name)value(UUID(),phone1,password1,CONCAT(name1,'的家长'));ENDLOOP;--关闭游标CLOSEcur_account;END?```#####调用存储过程使用call语句调用存储过程```sqlcallsp_name[(传参)];```#####删除存储过程使用drop语句删除存储过程```sqlDROPPROCEDUREsp_name```####存储函数>-存储函数和存储过程一样，都是sql和语句组成的代码块。->-存储函数不能有输入参数，并且可以直接调用，不需要call语句，且必须有一条包含RETURN语句。#####创建存储函数使用CREATEFUNCTION语句创建：```sqlCREATEFUNCTIONfun_name(par_nametype[,...])RETURNStype[characteristics]fun_body```-fun_name为函数名，并且名字唯一，不能与存储过程重名。-par_name是指定的参数，type为参数类型；-RETURNS字句用来声明返回值和返回值类型。fun_body是函数体，所有存储过程中的sql在存储函数中同样可以使用。但是存储函数体中必须包含一个RETURN语句。-characteristics指定存储过程的特性，有以下取值：-LANGUAGESQL:说明routine_body部分是由SQL语句组成的，当前系统支持的语言为SQL，SQL是LANGUAGE特性的唯一值。-[NOT]DETERMINISTIC:指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的，每次执行存储过程时，相同的输入会得到相同的输出，NOTDETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出，如果没有指定任意一个值，默认为NOTDETERMINISTIC。-[CONTAINSSQL|NOSQL|READSSQLDATA|MODIFIESSQLDATA]：指明子程序使用SQL语句的限制。CONTAINSSQL表明子程序包含SQL语句，但不包含读写数据语句；NOSQL表明子程序不包含SQL语句；READSSQLDATA说明子程序包含读数据的语句；MODIFIESSQLDATA表名子程序包含写数据的语句。默认情况下，系统会指定为CONTAINSSQL。-SQLSECURITY[DEFINER|INVOKER]：指明谁有权限来执行。DEFINER表示只有定义着才能执行。INVOKER表示用友权限的调用者可以执行。默认情况下，系统指定为DEFINER。-COMMENT'string'：注释信息，用来描述存储过程或函数。```sqldelimiter?createfunctiongetAnimalName(animalIdint)RETURNSVARCHAR(50)DETERMINISTICbegindeclarenameVARCHAR(50);setname=(selectnamefromanimalwhereid=animalId);return(name);end?delimiter;--调用selectgetAnimalName(4)```###**函数**>[官网地址](https://dev.mysql.com/doc/refman/8.0/en/functions.html[)>>mysql中的函数可分为两类：系统函数、用户自定义函数。>>函数体里面不用直接`select`|函数||功能||-----------------------|-----------------------|----------------------||SUBSTRING|substring|截取字符串||CHAR_LENGTH|char_length|获取字符串长度||DATE_FORMAT|date_format|格式化日期时间||CONCAT|concat|字符串连接||CONCAT_GROUP...GOURPBY|concat_group...gourpby|将分组的各个字符串连接||SUBSTRING_INDEX|substring_index|字符串截取||ROUND|round|数值保留几位小数|####普通函数>返回值是一个标量创建函数：```sql//msyql中的函数一定有返回值//创建函数的语法，注意:参数和返回值一定要写长度，避免使用到关键字createfunction函数名（[形参列表]）returns数据类型begin--函数体--返回值end//写一个实例,通过子订单child_order_no的订单号获取其最高父订单的订单金额sale_pricecreatefunctioncalcPrice(child_order_novarchar(30))returnsdecimal(12,2)begin//声明变量，注意：一定要写长度declaresale_pricedecimaldefault0.00;declaref_order_novarchar(30)defaultorder_no;WHILEf_order_noisnotnullDOsetorder_no=f_order_no;SETf_order_no=(SELECTo.PARENT_ORDER_NOFROMorderoWHEREo.ORDER_NO=f_order_no);ENDWHILE;SELECTf.SALE_PRICEASSALE_PRICEFROMorderfWHEREf.ORDER_NO=order_nointosale_price;returnsale_price;end//使用这个函数selectcalcPrice(1000011);```查看自定义函数：```//查看自定义的所有函数showfunctionstatus//可以根据名称查看所有自定义的函数，支持模糊查询showfunctionstatuslike'名字';showfunctionstatuslike'%me';//查看函数的创建语句showcreatefunction'函数名字';showcreatefunctiongetName;```使用函数：```sql//使用select关键字查看selectgetNames();```删除函数：```sql//删除对应函数dropfunction'函数名'；dropfunctiongetNames;```有的时候创建函数和使用函数时，会被告诉没有权限，这时需要给用户添加上权限，如下：|createroutine|创建函数||--------------|--------------||alterroutine|修改和删除函数||execute|使用函数|上边只是对mysql中函数的使用做了简单的介绍，想要熟练使用还需要在实战中多使用。函数类似于存储过程，只是调用方式不同```sql//创建函数createfunctionaddAge(ageint)returnsintreturnage+5;//使用函数：selectaddAge(age)fromtemp;//删除函数dropfunctionifexistsaddAge;dropfunctionaddAge;//显示创建语法showcreatefunctionaddAge;```####表格值函数>内联表格函数>>多句表格值函数-**A、**内联表格值函数：返回一个表格语法：```sqlcreatefunction函数名（参数）returnstableasreturn(一条SQL语句)```例子：1.创建函数：```sqlCREATEFUNCTIONtabcmess(@titleVARCHAR(10))RETURNSTABLEASreturn(selecttitle,desfromproductwheretitlelike'%'+@title+'%')```2.执行：```sqlSELECT*FROMtabcmess('aaa')```-**B.多句表格值函数**语法：```sqlcreatefunction函数名（参数）returns表格变量名table(表格变量定义)asbegin--SQL语句end```例子：```sqlCREATEfunctiontabcmessalot(@titlevarchar(10))Returns@ctabletable(titlevarchar(10)null,desvarchar(100)null)AsBeginInsert@ctableSelecttitle,desfromproductWHEREtitleLIKE'%'+@title+'%'returnEnd--执行SELECT*FROMtabcmessalot('aaa')```##**触发器**触发器分为insert、update、delete三种触发器事件类型，还有after、before触发时间```sql//创建触发器createtriggertrg_temp_insbeforeinsertontempforeachrowbegininsertintotemp_logvalues(NEW.id,NEW.name);end//删除触发器droptriggertrg_temp_ins```##DEMO###递归查询>父子查询:根据父id查询所有的子节点数据>>子父查询:根据子id查询上面所有父节点数据####**创建表，并添加测试数据**```sqlDROPTABLEIFEXISTS`vrv_org_tab`;CREATETABLE`vrv_org_tab`(`id`bigint(8)NOTNULLAUTO_INCREMENT,`org_name`varchar(50)NOTNULL,`org_level`int(4)NOTNULLDEFAULT‘0’,`org_parent_id`bigint(8)NOTNULLDEFAULT‘0’,PRIMARYKEY(`id`),UNIQUEKEY`unique_org_name`(`org_name`))ENGINE=InnoDBAUTO_INCREMENT=18DEFAULTCHARSET=utf8;``````sqlINSERTINTO`vrv_org_tab`VALUES(‘1’,‘北信源’,‘1’,‘0’);INSERTINTO`vrv_org_tab`VALUES(‘2’,‘北京’,‘2’,‘1’);INSERTINTO`vrv_org_tab`VALUES(‘3’,‘南京’,‘2’,‘1’);INSERTINTO`vrv_org_tab`VALUES(‘4’,‘武汉’,‘2’,‘1’);INSERTINTO`vrv_org_tab`VALUES(‘5’,‘上海’,‘2’,‘1’);INSERTINTO`vrv_org_tab`VALUES(‘6’,‘北京研发中心’,‘3’,‘2’);INSERTINTO`vrv_org_tab`VALUES(‘7’,‘南京研发中心’,‘3’,‘3’);INSERTINTO`vrv_org_tab`VALUES(‘8’,‘武汉研发中心’,‘3’,‘4’);INSERTINTO`vrv_org_tab`VALUES(‘9’,‘上海研发中心’,‘3’,‘5’);INSERTINTO`vrv_org_tab`VALUES(‘10’,‘北京EMM项目组’,‘4’,‘6’);INSERTINTO`vrv_org_tab`VALUES(‘11’,‘北京linkdd项目组’,‘4’,‘6’);INSERTINTO`vrv_org_tab`VALUES(‘12’,‘南京EMM项目组’,‘4’,‘7’);INSERTINTO`vrv_org_tab`VALUES(‘13’,‘南京linkdd项目组’,‘4’,‘7’);INSERTINTO`vrv_org_tab`VALUES(‘14’,‘武汉EMM项目组’,‘4’,‘8’);INSERTINTO`vrv_org_tab`VALUES(‘15’,‘武汉linkdd项目组’,‘4’,‘8’);INSERTINTO`vrv_org_tab`VALUES(‘16’,‘上海EMM项目组’,‘4’,‘9’);INSERTINTO`vrv_org_tab`VALUES(‘17’,‘上海linkdd项目组’,‘4’,‘9’);```####**根据父id递归查询所有子节点**>cast(variableasvariable_type):将变量转换为指定的类型>>concat():连接多个数据>>group_concat():连接多个数据(消除重复值)>>find_in_set(str,strList):查询字段strList中包含str的结果,返回null或记录>>-str:要查询的字符串>-strList:支付数组```sqlcreatefunctiongetChildrenOrg(orgidINT)returnsvarchar(4000)BEGINDECLAREoTempVARCHAR(4000);DECLAREoTempChildVARCHAR(4000);SEToTemp='';SEToTempChild=CAST(orgidASCHAR);WHILEoTempChildISNOTNULLDOSEToTemp=CONCAT(oTemp,',',oTempChild);SELECTGROUP_CONCAT(id)INTOoTempChildFROMvrv_org_tabWHEREFIND_IN_SET(org_parent_id,oTempChild)>0;ENDWHILE;RETURNoTemp;END;--查询组织机构为1的下面的所有的组织结构select*fromvrv_org_tabwherefind_in_set(id,getChildrenOrg(1));```####**根据子id递归查询所有父节点**```sqlSELECTid,org_name,org_level,org_parent_idFROM(SELECT@rAS_id,(SELECT@r:=org_parent_idFROMvrv_org_tabWHEREid=_id)ASparent_id,@l:=@l+1ASlvlFROM(SELECT@r:=10000,@l:=0)vars,vrv_org_tabhWHERE@r<>0)T1JOINvrv_org_tabT2ONT1._id=T2.idORDERBYid;```注意：大家看到那个10000了吗，就是我们的子节点id。注意：只支持单个查询，意思是不可以根据两个或者两个以上的子节点同时查询出所有父节点。我们可以看到，上面参数都是单个值进行递归查询的。西面提供一个函数支持多个查询####**根据组织机构名称模糊查询所有父节点**>distinct:删除重复行>>substring(string,position):截取string指定长度的字符串>>substring_index(str[被截取字段],delim[关键字],count[关键字出现的次数]):按关键字截取字符串>>length(str):返回字串的长度```sqlCREATEFUNCTIONgetParentOrgByOrgName(orgNameVARCHAR(20))RETURNSVARCHAR(4000)BEGINDECLAREsPidVARCHAR(1000);DECLAREsPidTempVARCHAR(1000);DECLAREpidVARCHAR(1000);DECLAREcountINTDEFAULT0;DECLAREallpidVARCHAR(4000);SETsPidTemp='';SELECTGROUP_CONCAT(DISTINCT(CAST(idASCHAR)))INTOsPidFROMvrv_org_tabWHEREorg_nameLIKECONCAT('%',orgName,'%');SETallpid='';WHILEcount=0DOIFsPidISNULLTHENSETallpid='-1';SETcount=1;ELSESETpid=SUBSTRING_INDEX(sPid,',',1);SETsPidTemp=CONCAT(sPidTemp,',',pid);IFLENGTH(pid)=LENGTH(sPid)THENSETcount=1;SETsPid=SUBSTRING(sPidFROMLENGTH(SUBSTRING_INDEX(sPid,',',1))FORLENGTH(sPid)+1);ELSESETsPid=SUBSTRING(sPidFROMLENGTH(SUBSTRING_INDEX(sPid,',',1))+2FORLENGTH(sPid)+1);ENDIF;SELECTGROUP_CONCAT(CAST(idASCHAR))INTOsPidTempFROM(SELECT@rAS_id,(SELECT@r:=org_parent_idFROMvrv_org_tabWHEREid=_id)ASparent_id,@l:=@l+1ASlvlFROM(SELECT@r:=pid,@l:=0)vars,vrv_org_tabhWHERE@r<>0)T1JOINvrv_org_tabT2ONT1._id=T2.id;SETallpid=CONCAT_WS(',',pid,sPidTemp,allpid);ENDIF;ENDWHILE;RETURNallpid;END```","Back-End\\Database\\mysql\\mysql-node.md":"#Node.js连接MySQL><https://github.com/mysqljs/mysql>##安装驱动```shellcnpminstallmysql```##连接数据库在以下实例中根据你的实际配置修改数据库用户名、及密码及数据库名：```jsvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',database:'test',})connection.connect()connection.query('SELECT1+1ASsolution',function(error,results,fields){if(error)throwerrorconsole.log('Thesolutionis:',results[0].solution)})```执行以下命令输出结果为：```shell$nodetest.jsThesolutionis:2```###数据库连接参数说明|参数|描述||:-----------------|:---------------------------------------------------------------------------------------------------------------------||host|主机地址（默认：localhost）||user|用户名||password|密码||port|端口号（默认：3306）||database|数据库名||charset|连接字符集（默认：'UTF8_GENERAL_CI'，注意字符集的字母都要大写）||localAddress|此IP用于TCP连接（可选）||socketPath|连接到unix域路径，当使用host和port时会被忽略||timezone|时区（默认：'local'）||connectTimeout|连接超时（默认：不限制；单位：毫秒）||stringifyObjects|是否序列化对象||typeCast|是否将列值转化为本地JavaScript类型值（默认：true）||queryFormat|自定义query语句格式化方法||supportBigNumbers|数据库支持bigint或decimal类型列时，需要设此option为true（默认：false）||bigNumberStrings|supportBigNumbers和bigNumberStrings启用强制bigint或decimal列以JavaScript字符串类型返回（默认：false）||dateStrings|强制timestamp,datetime,data类型以字符串类型返回，而不是JavaScriptDate类型（默认：false）||debug|开启调试（默认：false）||multipleStatements|是否许一个query中有多个MySQL语句（默认：false）||flags|用于修改连接标志||ssl|使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑AmazonRDS的配置文件|---##数据库操作(CURD)```jsletsql='';//相当于在sql中执行的语句[可以写insert,delete,select,update]letParams=[];//当sql有?,Params中的参数和sql一一对应connection.query(sql,[Params],function(err,result){}```###查询数据```jsvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',port:'3306',database:'test',})connection.connect()varsql='SELECT*FROMwebsites'//查connection.query(sql,function(err,result){if(err){console.log('[SELECTERROR]-',err.message)return}console.log('--------------------------SELECT----------------------------')console.log(result)console.log('------------------------------------------------------------\\n\\n',)})connection.end()```执行以下命令输出就结果为：```shell$nodetest.js--------------------------SELECT----------------------------[RowDataPacket{id:1,name:'Google',url:'https://www.google.cm/',alexa:1,country:'USA'},RowDataPacket{id:2,name:'淘宝',url:'https://www.taobao.com/',alexa:13,country:'CN'},RowDataPacket{id:3,name:'菜鸟教程',url:'http://www.runoob.com/',alexa:4689,country:'CN'},RowDataPacket{id:4,name:'微博',url:'http://weibo.com/',alexa:20,country:'CN'},RowDataPacket{id:5,name:'Facebook',url:'https://www.facebook.com/',alexa:3,country:'USA'}]------------------------------------------------------------```###插入数据```jsvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',port:'3306',database:'test',})connection.connect()varaddSql='INSERTINTOwebsites(Id,name,url,alexa,country)VALUES(0,?,?,?,?)'varaddSqlParams=['菜鸟工具','https://c.runoob.com','23453','CN']//增connection.query(addSql,addSqlParams,function(err,result){if(err){console.log('[INSERTERROR]-',err.message)return}console.log('--------------------------INSERT----------------------------')//console.log('INSERTID:',result.insertId);console.log('INSERTID:',result)console.log('-----------------------------------------------------------------\\n\\n',)})connection.end()```执行以下命令输出就结果为：```shell$nodetest.js--------------------------INSERT----------------------------INSERTID:OkPacket{fieldCount:0,affectedRows:1,insertId:6,serverStatus:2,warningCount:0,message:'',protocol41:true,changedRows:0}-----------------------------------------------------------------```执行成功后，查看数据表，即可以看到添加的数据：![img](https://www.runoob.com/wp-content/uploads/2017/03/1E2D27C5-45F3-4E57-90D3-4AE35AEB17F7.jpg)###更新数据```jsvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',port:'3306',database:'test',})connection.connect()varmodSql='UPDATEwebsitesSETname=?,url=?WHEREId=?'varmodSqlParams=['菜鸟移动站','https://m.runoob.com',6]//改connection.query(modSql,modSqlParams,function(err,result){if(err){console.log('[UPDATEERROR]-',err.message)return}console.log('--------------------------UPDATE----------------------------')console.log('UPDATEaffectedRows',result.affectedRows)console.log('-----------------------------------------------------------------\\n\\n',)})connection.end()```执行以下命令输出就结果为：```--------------------------UPDATE----------------------------UPDATEaffectedRows1-----------------------------------------------------------------```执行成功后，查看数据表，即可以看到更新的数据：![img](https://www.runoob.com/wp-content/uploads/2017/03/A5C8911B-E07B-48DD-9C3E-28F1E73A1A30.jpg)###删除数据```jsvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',port:'3306',database:'test',})connection.connect()vardelSql='DELETEFROMwebsiteswhereid=6'//删connection.query(delSql,function(err,result){if(err){console.log('[DELETEERROR]-',err.message)return}console.log('--------------------------DELETE----------------------------')console.log('DELETEaffectedRows',result.affectedRows)console.log('-----------------------------------------------------------------\\n\\n',)})connection.end()```执行以下命令输出就结果为：```--------------------------DELETE----------------------------DELETEaffectedRows1-----------------------------------------------------------------```执行成功后，查看数据表，即可以看到id=6的数据已被删除：![img](https://www.runoob.com/wp-content/uploads/2017/03/27BEB36A-0DCE-4C75-961F-93D55CBECC54.jpg)##websites.sql```sql/*NavicatMySQLDataTransferSourceServer:127.0.0.1SourceServerVersion:50621SourceHost:localhostSourceDatabase:RUNOOBTargetServerVersion:50621FileEncoding:utf-8Date:05/18/201611:44:07AM*/SETNAMESutf8;SETFOREIGN_KEY_CHECKS=0;--------------------------------Tablestructurefor`websites`------------------------------DROPTABLEIFEXISTS`websites`;CREATETABLE`websites`(`id`int(11)NOTNULLAUTO_INCREMENT,`name`char(20)NOTNULLDEFAULT''COMMENT'站点名称',`url`varchar(255)NOTNULLDEFAULT'',`alexa`int(11)NOTNULLDEFAULT'0'COMMENT'Alexa排名',`country`char(10)NOTNULLDEFAULT''COMMENT'国家',PRIMARYKEY(`id`))ENGINE=InnoDBAUTO_INCREMENT=6DEFAULTCHARSET=utf8;--------------------------------Recordsof`websites`------------------------------BEGIN;INSERTINTO`websites`VALUES('1','Google','https://www.google.cm/','1','USA'),('2','淘宝','https://www.taobao.com/','13','CN'),('3','菜鸟教程','http://www.runoob.com/','4689','CN'),('4','微博','http://weibo.com/','20','CN'),('5','Facebook','https://www.facebook.com/','3','USA');COMMIT;SETFOREIGN_KEY_CHECKS=1;```","Back-End\\Database\\mysql\\navicat.md":"#Navicat>数据库可视化工具>>[NavicatPremiumv15.0.25中文最新破解版（附：激活工具）–DEFCON笔记](https://defcon.cn/214.html)","Back-End\\Database\\mysql\\question.md":"#question##MYSQLERROR2003>原因:使用电脑管家关掉mysql>>解决方法:重启mysql```shell//打开命令窗口(管理员)$mysqld--install$netstartmysql$mysql-uroot-p[密码]```","Back-End\\Database\\mysql\\规范.md":"#数据库命名规范采用小写字母、数字（通常不需要）和下划线组成。禁止使用’-’，命名简洁、含义明确。2.####表命名-根据业务类型不同，采用不同的前缀，小写字母、下划线组成-长度控制在30个字符以内推荐的命名规则|类型|前缀|说明||--------------------|----------|--------||业务表|tb\\_|||关系表|tr\\_|||历史表|th\\_|||统计表|ts\\_|||日志表|tl_xx_log|||系统表、字典表、码表|sys\\_|||临时表|tmp\\_|禁止使用||备份表|bak_xx_ymd|||视图|view\\_|避免使用|1.####引擎使用默认Innodb引擎（5.5以后默认）支持事务、支持行级锁、更好的恢复性、高并发下性能更好。2.####字符集-数据库和表的字符集统一,尽量使用UTF8（根据业务需求）-兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效-UTF8和UTF8MB4字段进行关联，会导致索引失效-除非特殊情况，禁止建表指定字符集（采用库默认字符集），降低出现字符集不统一导致性能问题的风险。-无特殊要求，禁止指定表COLLATE-----COLLATE主要的作用是排序的规则以及检索的规则，utf8字符集默认的是utf8_general_ci，utf8mb4字符集默认的是utf8mb4_general_ci，结尾的ci意思是不区分大小写。COLLATE会影响到ORDERBY语句的顺序，会影响到WHERE条件中大于小于号筛选出来的结果，会影响**DISTINCT**、**GROUPBY**、**HAVING**语句的查询结果。比如：select\\*fromtestwherenamelike'A%',在utf8_bin字符集下，是无法检索出‘abc’字段的，并且排序的情况下Abc和abc所在的顺序是不一致的。-慎重选择row_format（行记录格式）Barracuda:新的文件格式。它支持InnoDB的所有行格式，包括新的行格式：**COMPRESSED**和**DYNAMIC**在msyql5.7.9及以后版本，默认行格式由innodb_default_row_format变量决定，它的默认值是**DYNAMIC**db默认的innodb_file_format为Barracuda，默认的innodb_default_row_format为dynamic；其中COMPRESSED压缩比经测试最大也就1/2，但读取和写入会有额外cpu开销，并且申请内存是按照解压后的原大小申请，在高并发情况下容易导致性能问题。Dynamic行格式，列存储是否放到off-page页，主要取决于行大小，他会把行中最长的一列放到off-page，直到数据页能存放下两行。TEXT或BLOB列<=40bytes时总是存在于数据页。这种方式可以避免compact那样把太多的大列值放到B-treeNode（数据页中只存放20个字节的指针，实际的数据存放在OffPage中，之前的Compact和Redundant两种格式会存放768个字前缀字节）。Compressed物理结构上与Dynamic类似，Compressed行记录格式的另一个功能就是存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度数据能够进行有效的存储（减少40%，但对CPU要求更高）。3.####字段设计-所有表和字段都需要添加注释，使用comment从句添加表和列的备注从一开始就进行数据字典的维护-尽量控制单表数据量的大小，建议控制在500万以内500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题，可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小-谨慎使用MySQL分区表分区表在物理上表现为多个文件，在逻辑上表现为一个表。谨慎选择分区键，跨分区查询效率可能更低，另外，对于表结构维护，分区表的维护造成的开销更集中，建议采用物理分表的方式管理大数据-建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据，尽量做到冷热数据分离，减小表的宽度-MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节。为减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO），更有效的利用缓存，避免读入无用的冷数据，经常一起使用的列放到一个表中（避免更多的关联操作）。对于非常用字段，建议采用扩展表的方式进行分表。注意：每一行数据的65535字节中，utf8字符集下，varchar每一个长度占用3个字节，utf8mb4字符集下，每一个长度占用4个字节-尽量不在表中建立预留字段预留字段的命名很难做到见名识义，预留字段无法确认存储的数据类型，所以无法选择合适的类型。对预留字段类型的修改，会对表进行锁-禁止使用外键约束外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈。建议在业务端实现。4.####数据库字段设计规范---**愿君学长松慎勿作桃李**🏆🏆🏆🏆-关于数据长度够用前提下，越短越好，这样能够消耗更少的存储空间；因排序申请的内存大小和字段长度有关，需要进行排序时，长度小的字段消耗更少的内存空间；优先选择符合存储需要的最小的数据类型-禁止使用TEXT/BLOB类型，禁止在数据库中存储图片，文件等大的二进制数据通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息-避免使用ENUM(枚举)类型修改ENUM值需要使用ALTER语句;ENUM类型的ORDERBY操作效率低，需要额外操作；禁止使用数值作为ENUM的枚举值-尽可能把所有列定义为NOTNULL索引NULL列需要额外的空间来保存，所以要占用更多的空间进行比较和计算时要对NULL值做特别的处理NULL只能采用ISNULL或者ISNOTNULL，而在=/!=/in/notin时很容易造成查询结果与设计逻辑不符-使用TIMESTAMP（4个字节）或DATETIME类型（5个字节）存储时间网上很多博客都说DATETIME是8个字节，其实在5.6.4版本一上就减少到5个字节[mysql源码github地址](https://github.com/mysql/mysql-server)```javalonglongTIME_to_longlong_datetime_packed(constMYSQL_TIME&my_time){longlongymd=((my_time.year*13+my_time.month)<<5)|my_time.day;longlonghms=(my_time.hour<<12)|(my_time.minute<<6)|my_time.second;longlongtmp=my_packed_time_make(((ymd<<17)|hms),my_time.second_part);assert(!check_datetime_range(my_time));/*Makesurenooverflow*/returnmy_time.neg?-tmp:tmp;}根据上述算法，计算极限时间9999-12-3123:59:59时间各部分依次是year-month-dayhour:minute:second1.计算longlongymdyear*13+month=9999*13+12=129999将129999左移5位，再与31进行或运算‬000000000011111101111001111[00000]---129999左移5位（年*13+月）000000000000000000000000‭00011111‬---31（日）=‬00000000001111110111100111111111---得出longlongymd低位，极限有22位2.计算longlonghms将hour左移12位，与minute左移6位，再与second进行或运算00010111[000000000000]---23左移12位（时）111011‬[000000]---59左移6位（分）111011---59（秒）=00010111111011111011---得出longlonghms的低位，极限有17位3.计算longlongtmpymd右移17位，与hms进行或运算，这样刚好存到39位。（至此，再加上1位标识位，也就刚好40位，为5字节了）再使用my_packed_time_make(）函数，将ymd与小数秒部分连起来。```TIMESTAMP存储的时间范围：1970-01-0100:00:01~2038-01-19-03:14:07。TIMESTAMP占用4字节和INT相同，但比INT可读性高超出TIMESTAMP取值范围的使用DATETIME类型存储。-同财务相关的金额类数据{设计使用小数}必须使用decimal类型Decimal类型为精准浮点数，在计算时不会丢失精度。-同一意义的字段定义必须相同-同一意义的字段定义包括字段类型和长度范围必须相同-增加字段时禁止指定after-VARCHAR(N)，N尽可能小如果N<256时会使用一个字节来存储长度，如果N>=256则使用两个字节来存储长度。-数值型字段，default值建议选用05.####索引设计规范---**共矜然诺心各负纵横志**❤❤❤❤-创建表一定要有主键（PRIMARYKEY），推荐使用雪花或梨花。-不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。-限制每张表上的索引数量索引并不是越多越好！索引可以提高效率同样可以降低效率。索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会**增加mysql优化器生成执行计划的时间**，同样会降低查询性能。-区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；-尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；-使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。-避免建立冗余索引和重复索引---因为这样会增加查询优化器生成执行计划的时间。重复索引示例：primarykey(id)、index(id)、uniqueindex(id)冗余索引示例：index(a,b,c)、index(a,b)、index(a)-优先考虑覆盖索引对于频繁的查询优先考虑使用覆盖索引。覆盖索引就是包含了所有查询字段(where,select,orderyby,groupby包含的字段)的索引覆盖索引的好处：1.可以把随机IO变成顺序IO加快查询效率；2.能够避免回表查询，提升查询效率-一定要在表与表之间的关联键上建立索引6.####sql开发规划---**月缺不改光剑折不改刚**❤️❤️❤️❤️-建议使用预编译语句进行数据库操作预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题；只传参数，比传递SQL语句更高效；相同语句可以一次解析，多次使用，提高处理效率。在实际生产环境中，如MyBatis等ORM框架大量使用了预编译语句，最终底层调用都会走到MySQL驱动里，从驱动中了解相关实现细节有助于更好地理解预编译语句就像我们熟悉的#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入MySQL驱动里对于server预编译的情况维护了两个**基于LinkedHashMap使用LRU策略的cache**，分别是serverSideStatementCheckCache用于缓存sql语句是否可以由服务端来缓存以及serverSideStatementCache用于缓存服务端预编译sql语句，这两个缓存的大小由**prepStmtCacheSize**参数控制。-避免数据类型的隐式转换隐式转换会导致索引失效。如：selectname,phonefromcustomerwhereid='111';-充分利用表上已经存在的索引-避免使用双%号的查询条件如alike'%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）。-一个SQL只能利用到复合索引中的一列进行范围查询如：有a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。-WHERE从句中禁止对列进行函数转换和计算不推荐：wheredate(create_time)=20190101推荐：wherecreate_time>=20190101andcreate_time<20190102-在明显不会有重复值时使用**UNIONALL**而不是UNIONUNION会把两个结果集的所有数据放到临时表中后再进行去重和排序操作UNIONALL不会再对结果集进行去重和排序操作-拆分复杂的大SQL为多个小SQL-SQL性能优化的目标:至少要达到range级别，要求是ref级别，如果可以是consts最好。-不要使用count(列名)或count(常量)来替代count(_)，count(_)就是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。","Back-End\\Database\\mysql.md":"#mysql##mysql启动失败1.删除data文件夹2.修改my.ini```shbasedir=\"C:\\RUIHUA\\env\\mysql\\5.7.31.2\"#设置mysql的安装目录datadir=\"C:\\RUIHUA\\env\\mysql\\5.7.31.2\\data\"#设置mysql数据库的数据的存放目录，必须是data，或者是//xxx/data```3.管理员身份模式进入mysql下的bin目录4.移除已注册服务`mysqldremove`5.初始化`mysqld--initialize--console`-root@localhost:[这里是密码]6.注册服务:`mysqld-install`7.启动服务:`netstartmysql`8.启动:`mysql-uroot-p`1.修改密码MySQL8.0.4以前，执行```SETPASSWORD=PASSWORD('[修改的密码]');mysql8.0.4以后ALTER``USER``'root'``@``'localhost'``IDENTIFIED``WITH``mysql_native_password``BY``'修改的密码'``;```目前密码:`ruihuag`","Back-End\\GoLang\\index.md":"#Go","Back-End\\Java\\java-basis.md":"#java>[文档](http://c.biancheng.net/view/6262.html)>>cmd界面运行java文件>>1.创建.java文件>2.cmd界面到该文件路径下,运行`javac文件名.java`>3.运行成功会生成一个.class文件>4.再运行`java文件名`就可以看到结果##基础###标识符>-标识符由数字（0\\~9）和字母（A~Z和a~z）、美元符号（$）、下划线（\\_）以及Unicode字符集中符号大于0xC0的所有符号组合构成（各符号之间没有空格）。>-标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线。###关键字>1.数据类型：boolean、int、long、short、byte、float、double、char、class、interface。>2.流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。>3.修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。>4.动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。>5.保留字：true、false、null、goto、const。###注释```java单行注释//注释多行注释/*注释*/文档注释/***文档注释*/```###基本数据类型>null：基本数据类型直接量只有一个值（null),可以给任何数据类型赋值|名称|包装类|字节数|栗子|直接量||-------|---------|-------|-----------|-------------------------||byte|Byte|1|1|012(八进制)、0x12(16进制)||short|Short|2|2|||int|Interger|4|123|||long|Long|8|123|||float|Float|4|3.14f|5.34F、3.14E5f||double|Double|8|1.1|5.34、3.14E5||char|Character|2|\"关\"|‘a’，‘\\n’和‘\\u0061’||String|/|/|\"华\"|||boolean|Boolean|一般是4|true\\|flase||###包装类和基本数据类型>包装类:能够直接将简单类型的变量表示为一个类，在执行变量类型的相互转换时，我们会大量使用这些包装类####包装类的用途>1.集合中不可以存放基本数据类型,故常用包装类>2.包含了每种基本类型的相关属性,如最大值,最小值,所占位符数>3.作为基本数据类型对应的类类型,提供了一系列的对象操作,如类型转换,进制转换等####基本类型与包装类型的区别>1、在Java中，一切皆对象，但八大基本类型却不是对象。>>2、声明方式的不同，基本类型无需通过new关键字来创建，而封装类型需new关键字。>3、存储方式及位置的不同，基本类型是直接存储变量的值保存在堆栈中能高效的存取，封装类型需要通过引用指向实例，具体的实例保存在堆中。>4、初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；>5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。>6、什么时候该用包装类，什么时候用基本类型，看基本的业务来定：这个字段允许null值，就需要使用包装类型，如果不允许null值，使用基本类型就可以了，用到比如泛型和反射调用函数，就需要用包装类！>>7、Ingeter是int的包装类,初始值null,int初始值为0###引用数据类型>-类class>-接口interface>-数组[]####数组常用定义方法```java//一维数组int[]str;intstr=newint[]{1,2,3,4};intstr={1,2,3,4,5};int[]str=newString[5];//二维数组int[][]str=newint[][]{{1,2,3,4},{1,2,3,4}}int[][]str=newint[2][3];int[][]str=newint[2][];```###类型转换####隐式转换(自动类型转换)-数值型数据的转换：byte→short→int→long→float→double。-字符型转换为整型：char→int。####显示转换(强制类型转换)>当转换的两种类型不兼容,或目标类型的取值范围小于源数据类型时,自动转换键无法进行,这时需要进行强制类型转换```java(type)variableName```###java运算符####一元运算符|运算符|名称|说明|例子||--------|--------|----------------------------|----------||-|取反符号|取反运算|b=-a||++|自加一|先取值再加一，或先加一再取值|a++或++a||--|自减一|先取值再减一，或先减一再取值|a--或--a|>++/--:在前要先进行自加(减)####二元运算符|运算符|名称|说明|例子||--------|-----|--------------------------------------------------------|------||+|加|求a加b的和，还可用于String类型，进行字符串连接操作|a+b||-|减|求a减b的差|a-b||\\*|乘|求a乘以b的积|a\\*b||/|除|求a除以b的商|a/b||%|取余|求a除以b的余数|a%b|####算术赋值运算符|运算符|名称|例子||--------|--------|----------------||+=|加赋值|a+=b、a+=b+3||-=|减赋值|a-=b||\\*=|乘赋值|a\\*=b||/=|除赋值|a/=b||%=|取余赋值|a%=b|####逻辑运算符|运算符|用法|含义|说明|实例|结果||:-----|:-----|:-----|:-------------------------------------------------|:---------|:----||&&|a&&b|短路与|ab全为true时，计算结果为true，否则为false。|2>1&&3<4|true||\\|\\||a\\|\\|b|短路或|ab全为false时，计算结果为false，否则为true。|2<1\\|\\|3>4|false||!|!a|逻辑非|a为true时，值为false，a为false时，值为true|!(2>4)|true||\\||a\\|b|逻辑或|ab全为false时，计算结果为false，否则为true|1>2\\|3>5|false||&|a&b|逻辑与|ab全为true时，计算结果为true，否则为false|1<2&3<5|true|####关系运算符|运算符|含义|说明|实例|结果||------|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|--------------------||>|大于|只支持左右两边操作数是数值类型。如果前面变量的值大于后面变量的值，则返回true。|2>3|false||>=|大于或等于|只支持左右两边操作数是数值类型。如果前面变量的值大于等于后面变量的值，则返回true。|4>=2|true||<|小于|只支持左右两边操作数是数值类型。如果前面变量的值小于后面变量的值，则返回true。|2<3|true||<=|小于或等于|只支持左右两边操作数是数值类型。如果前面变量的值小于等于后面变量的值，则返回true。|4<=2|false||==|相等|如果进行比较的两个操作数都是数值类型，无论它们的数据类型是否相同，只要它们的值相等，也都将返回true。如果两个操作数都是引用类型，只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回true。[Java](http://c.biancheng.net/java/)也支持两个boolean类型的值进行比较。|4==497=='a'5.0==5true==false|truetruetruefalse||!=|不相等|如果进行比较的两个操作数都是数值类型，**无论它们的数据类型是否相同**，只要它们的**值不相等**，也都将返回true。<br>如果两个操作数都是引用类型，只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回true。|4!=2|true|####位运算符|运算符|含义|实例|结果||------|-----------------------|------|----||&|按位进行与运算（AND）|4&5|4||\\||按位进行或运算（OR）|4\\|5|5||^|按位进行异或运算（XOR）|4^5|1||~|按位进行取反运算（NOT）|~4|-5|####三目运算符>`result=<expression>?<statement1>:<statement3>;`####运算符优先级|优先级|运算符|结合性||------|-------------------------------------------------|--------||1|()、[]、{}|从左向右||2|!、+、-、~、++、--|从右向左||3|\\*、/、%|从左向右||4|+、-|从左向右||5|«、»、>>>|从左向右||6|<、<=、>、>=、instanceof|从左向右||7|==、!=|从左向右||8|&|从左向右||9|^|从左向右||10|\\||从左向右||11|&&|从左向右||12|\\|\\||从左向右||13|?:|从右向左||14|=、+=、-=、\\*=、/=、&=、\\|=、^=、~=、«=、»=、>>>=|从右向左|###流程控制语句>ifelse>>switchcase>>while>>do…while>>for>>foreach>>```java>for(类型变量名:集合){>语句块;>}>```>>break>>continue###字符串处理>不可变的好处>>-String的hash值经常被使用,例如String用做HashMap的key,不可以变的特性可以使得hash值也不可以变,因此只需要进行一次计算>-StringPool的需要>-如果一个String对象已经被创建过了,那么就会从StringPool中去的应用,只有String是不可以变的,才可能使用StringPool####直接定义字符串```javaStringstr=\"hello\";```####使用String类定义```java//String()newString();//空字符序列//String(Stringoriginal)Stringstr1=newString(\"HelloJava\");//新建字符串序列Stringstr2=newString(str1);//这可以说是str1的一个副本//String(char[]value)chara[]={'H','e','l','l','0'};StringsChar=newString(a);a[1]='s';//不会影响sChar的值//String(char[]value,intoffset,intcount)chara[]={'H','e','l','l','o'};StringsChar=newString(a,1,4);//elloa[1]='s';//不会影响sChar的值```####String转换为int>-Integer.parseInt(str)>-Integer.valueOf(str).intValue()####int转换为String>-Strings=String.valueOf(i);>-Strings=Integer.toString(i);>-Strings=\"\"+i;####String,StringBuffer和StringBuilder类区别>-可变性>-String不可变>-StringBuffer和StringBuilder可变>-线程安全>-String不可变,so线程安全>-StringBuilder不是线程安全的>-StringBuffer是线程安全,内部使用synchronized进行同步![](https://images.gitee.com/uploads/images/2020/1102/010927_dfdaec78_7984151.png)###数字和日期处理###内置安装包###数组处理###类和对象###继承和多态###异常处理###集合、泛型和枚举###反射机制###输入输出流###注解##队列>队列:先进先出(FirstINFirstOut,FIFO)>>常用方法:>>-去队(enqueque)>-出队(dequeue)>>入口端口叫队尾(rear)>>出口端口叫队首(front)>>常见使用场景>>-存储多线程中等待排队执行的任务>-存储多线程公平说中等待执行任务的线程>-常见消息中间件的任务队列等###自定义队列```javapublicclassMyQueue<E>{privateObject[]queue;//存储容器privateinthead;//头部指针privateinttail;//尾部指针privateintsize;//队列实际存储长度privateintmaxSize;//最大容量publicMyQueue(){//无参构造函数，设置默认参数this.maxSize=10;this.head=0;this.tail=-1;this.size=0;this.queue=newObject[this.maxSize];}publicMyQueue(intinitSize){//有参构造函数，设置参数this.maxSize=initSize;this.head=0;this.tail=-1;this.size=0;this.queue=newObject[this.maxSize];}/***查询队头元素*/publicEpeek()throwsException{if(size==0){thrownewException(\"队列中暂无数据\");}return(E)this.queue[this.head];}/***入列*/publicbooleanoffer(Ee)throwsException{if(tail>=(maxSize-1)){thrownewException(\"添加失败，队列已满\");}this.queue[++tail]=e;size++;returntrue;}/***出列*/publicEpoll()throwsException{if(size==0){thrownewException(\"删除失败，队列为空\");}size--;return(E)this.queue[head++];}/***代码测试*/publicstaticvoidmain(String[]args)throwsException{MyQueuequeue=newMyQueue();queue.offer(\"Hello\");queue.offer(\"Java\");System.out.println(queue.peek());queue.poll();System.out.println(queue.poll());}}//运行结果HelloJava```自定义队列-链表![](https://images.gitee.com/uploads/images/2020/1023/212153_7c979d68_7984151.png)```javapublicclassQueueByLinked{/***声明链表节点*/staticclassNode<E>{Eitem;//当前的值Node<E>next;//下一个节点Node(Ee){this.item=e;}}privateNodefirstNode;//队头元素privateNodelastNode;//队尾元素privateintsize;//队列实际存储数量privateintmaxSize;//队列最大容量publicQueueByLinked(intmaxSize){if(maxSize<=0)thrownewRuntimeException(\"队列最大容量不能为空\");//默认初始化函数firstNode=lastNode=newNode(null);this.size=0;this.maxSize=maxSize;}/***判断队列是否为空*/publicbooleanisEmpty(){returnsize==0;}/***入列*/publicvoidoffer(Objecte){//最大值效验if(maxSize<=size)thrownewRuntimeException(\"队列已满\");Nodenode=newNode(e);lastNode=lastNode.next=node;//设置最后一个节点和倒数第二个节点的nextsize++;//队列数量+1}/***出列*/publicNodepoll(){if(isEmpty())thrownewRuntimeException(\"队列为空\");size--;//队列数量-1returnfirstNode=firstNode.next;//设置并返回队头元素（第一个节点是null，当前元素则为Node.next）}/***查询队头元素*/publicNodepeek(){if(isEmpty())thrownewRuntimeException(\"队列为空\");returnfirstNode.next;//返回队头元素（第一个节点是null，当前元素则为Node.next）}/***代码测试*/publicstaticvoidmain(String[]args){QueueByLinkedqueue=newQueueByLinked(10);queue.offer(\"Hello\");queue.offer(\"JDK\");queue.offer(\"Java\");System.out.println(queue.poll().item);System.out.println(queue.poll().item);System.out.println(queue.poll().item);}}//执行结果HelloJDKJava```使用List实现自定义队列>不建议使用```javaimportjava.util.ArrayList;importjava.util.List;/***自定义队列（List方式）*/publicclassQueueByList<E>{privateListvalue;//队列存储容器publicQueueByList(){//初始化value=newArrayList();}/***判断队列是否为空*/publicbooleanisEmpty(){returnvalue.size()==0;}/***入列*/publicvoidoffer(Objecte){value.add(e);}/***出列*/publicEpoll(){if(isEmpty())thrownewRuntimeException(\"队列为空\");Eitem=(E)value.get(0);value.remove(0);returnitem;}/***查询队头元素*/publicEpeek(){if(isEmpty())thrownewRuntimeException(\"队列为空\");return(E)value.get(0);}/***代码测试*/publicstaticvoidmain(String[]args){QueueByListqueue=newQueueByList();queue.offer(\"Hello\");queue.offer(\"JDK\");queue.offer(\"Java\");System.out.println(queue.poll());System.out.println(queue.poll());System.out.println(queue.poll());}}//执行结果HelloJDKJava```<imgsrc=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54994efac0d43de9c8a93f0b8ef9f5a~tplv-k3u1fbpfcp-zoom-1.image\"alt=\"image.png\"style=\"zoom:50%;\"/>###阻塞队列和非阻塞队列阻塞队列（BlockingQueue）提供了可阻塞的`put`和`take`方法，它们与可定时的`offer`和`poll`是等价的。如果队列满了`put`方法会被阻塞等到有空间可用再将元素插入；如果队列是空的，那么`take`方法也会阻塞，直到有元素可用。当队列永远不会被充满时，`put`方法和`take`方法就永远不会阻塞。![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdec5b9180a446a7b2277cef0944d30d~tplv-k3u1fbpfcp-zoom-1.image)我们可以从队列的名称中知道此队列是否为阻塞队列，阻塞队列中包含`BlockingQueue`关键字，比如以下这些：-ArrayBlockingQueue-LinkedBlockingQueue-PriorityBlockingQueue-.......####阻塞队列功能演示接下来我们来演示一下当阻塞队列的容量满了之后会怎样，示例代码如下：```javaimportjava.util.Date;importjava.util.concurrent.ArrayBlockingQueue;publicclassBlockingTest{publicstaticvoidmain(String[]args)throwsInterruptedException{//创建一个长度为5的阻塞队列ArrayBlockingQueueq1=newArrayBlockingQueue(5);//新创建一个线程执行入列newThread(()->{//循环10次for(inti=0;i<10;i++){try{q1.put(i);}catch(InterruptedExceptione){e.printStackTrace();}System.out.println(newDate()+\"|ArrayBlockingQueueSize:\"+q1.size());}System.out.println(newDate()+\"|ForEnd.\");}).start();//新创建一个线程执行出列newThread(()->{for(inti=0;i<5;i++){try{//休眠1SThread.sleep(1000);}catch(InterruptedExceptione){e.printStackTrace();}if(!q1.isEmpty()){try{q1.take();//出列}catch(InterruptedExceptione){e.printStackTrace();}}}}).start();}}```以上代码的执行结果如下：>MonOct1920:16:12CST2020|ArrayBlockingQueueSize:1>>MonOct1920:16:12CST2020|ArrayBlockingQueueSize:2>>MonOct1920:16:12CST2020|ArrayBlockingQueueSize:3>>MonOct1920:16:12CST2020|ArrayBlockingQueueSize:4>>MonOct1920:16:12CST2020|ArrayBlockingQueueSize:5>>MonOct1920:16:13CST2020|ArrayBlockingQueueSize:5>>MonOct1920:16:14CST2020|ArrayBlockingQueueSize:5>>MonOct1920:16:15CST2020|ArrayBlockingQueueSize:5>>MonOct1920:16:16CST2020|ArrayBlockingQueueSize:5>>MonOct1920:16:17CST2020|ArrayBlockingQueueSize:5>>MonOct1920:16:17CST2020|ForEnd.从上述结果可以看出，当`ArrayBlockingQueue`队列满了之后就会进入阻塞，当过了1秒有元素从队列中移除之后，才会将新的元素入列。####非阻塞队列非阻塞队列也就是普通队列，它的名字中不会包含`BlockingQueue`关键字，并且它不会包含`put`和`take`方法，当队列满之后如果还有新元素入列会直接返回错误，并不会阻塞的等待着添加元素，如下图所示：![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20117a9dd30247e8806d56cd60f17307~tplv-k3u1fbpfcp-zoom-1.image)非阻塞队列的典型代表是`ConcurrentLinkedQueue`和`PriorityQueue`。###有界队列和无界队列**有界队列**：是指有固定大小的队列，比如设定了固定大小的`ArrayBlockingQueue`，又或者大小为0的`SynchronousQueue`。![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d413d77bccd42db8e130cca8b31114d~tplv-k3u1fbpfcp-zoom-1.image)**无界队列**：指的是没有设置固定大小的队列，但其实如果没有设置固定大小也是有默认值的，只不过默认值是Integer.MAX_VALUE，当然实际的使用中不会有这么大的容量（超过Integer.MAX_VALUE），所以从使用者的角度来看相当于“无界”的。![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc957d5edd54885909031dc2c72bc22~tplv-k3u1fbpfcp-zoom-1.image)###按功能分类接下来就是本文的重点了，我们以功能来划分一下队列，它可以被分为：普通队列、优先队列、双端队列、延迟队列、其他队列等，接下来我们分别来看。####1.普通队列普通队列（Queue）是指实现了先进先出的基本队列，例如`ArrayBlockingQueue`和`LinkedBlockingQueue`，其中`ArrayBlockingQueue`是用数组实现的普通队列，如下图所示：![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f5c609371584b6bbc38ad704b98fadd~tplv-k3u1fbpfcp-zoom-1.image)而`LinkedBlockingQueue`是使用链表实现的普通队列，如下图所示：![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bd0d697eaf741858afe1f2f358c71d4~tplv-k3u1fbpfcp-zoom-1.image)#####常用方法普通队列中的常用方法有以下这些：-offer()：添加元素，如果队列已满直接返回false，队列未满则直接插入并返回true；-poll()：删除并返回队头元素，当队列为空返回null；-add()：添加元素，此方法是对offer方法的简单封装，如果队列已满，抛出IllegalStateException异常；-remove()：直接删除队头元素；-put()：添加元素，如果队列已经满，则会阻塞等待插入；-take()：删除并返回队头元素，当队列为空，则会阻塞等待；-peek()：查询队头元素，但不会进行删除；-element()：对peek方法进行简单封装，如果队头元素存在则取出并不删除，如果不存在抛出NoSuchElementException异常。注意：**一般情况下offer()和poll()方法配合使用，put()和take()阻塞方法配合使用，add()和remove()方法会配合使用，程序中常用的是offer()和poll()方法，因此这两个方法比较友好，不会报错**。接下来我们以`LinkedBlockingQueue`为例，演示一下普通队列的使用：```javaimportjava.util.concurrent.LinkedBlockingQueue;staticclassLinkedBlockingQueueTest{publicstaticvoidmain(String[]args){LinkedBlockingQueuequeue=newLinkedBlockingQueue();queue.offer(\"Hello\");queue.offer(\"Java\");queue.offer(\"中文社群\");while(!queue.isEmpty()){System.out.println(queue.poll());}}}```以上代码的执行结果如下：>Hello>>Java>>中文社群####2.双端队列双端队列（Deque）是指队列的头部和尾部都可以同时入队和出队的数据结构，如下图所示：![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)接下来我们来演示一下双端队列`LinkedBlockingDeque`的使用：```javaimportjava.util.concurrent.LinkedBlockingDeque;/***双端队列示例*/staticclassLinkedBlockingDequeTest{publicstaticvoidmain(String[]args){//创建一个双端队列LinkedBlockingDequedeque=newLinkedBlockingDeque();deque.offer(\"offer\");//插入首个元素deque.offerFirst(\"offerFirst\");//队头插入元素deque.offerLast(\"offerLast\");//队尾插入元素while(!deque.isEmpty()){//从头遍历打印System.out.println(deque.poll());}}}```以上代码的执行结果如下：>offerFirst>>offer>>offerLast####3.优先队列优先队列（PriorityQueue）是一种特殊的队列，它并不是先进先出的，而是优先级高的元素先出队。优先队列是根据二叉堆实现的，二叉堆的数据结构如下图所示：![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)**二叉堆分为两种类型：一种是最大堆一种是最小堆。**以上展示的是最大堆，**在最大堆中，任意一个父节点的值都大于等于它左右子节点的值。**>因为优先队列是基于二叉堆实现的，因此它可以将优先级最好的元素先出队。接下来我们来演示一下优先队列的使用：```javaimportjava.util.PriorityQueue;publicclassPriorityQueueTest{//自定义的实体类staticclassViper{privateintid;//idprivateStringname;//名称privateintlevel;//等级publicViper(intid,Stringname,intlevel){this.id=id;this.name=name;this.level=level;}publicintgetId(){returnid;}publicvoidsetId(intid){this.id=id;}publicStringgetName(){returnname;}publicvoidsetName(Stringname){this.name=name;}publicintgetLevel(){returnlevel;}publicvoidsetLevel(intlevel){this.level=level;}}publicstaticvoidmain(String[]args){PriorityQueuequeue=newPriorityQueue(10,newComparator<Viper>(){@Overridepublicintcompare(Viperv1,Viperv2){//设置优先级规则（倒序，等级越高权限越大）returnv2.getLevel()-v1.getLevel();}});//构建实体类Viperv1=newViper(1,\"Java\",1);Viperv2=newViper(2,\"MySQL\",5);Viperv3=newViper(3,\"Redis\",3);//入列queue.offer(v1);queue.offer(v2);queue.offer(v3);while(!queue.isEmpty()){//遍历名称Viperitem=(Viper)queue.poll();System.out.println(\"Name：\"+item.getName()+\"Level：\"+item.getLevel());}}}```以上代码的执行结果如下：>Name：MySQLLevel：5>>Name：RedisLevel：3>>Name：JavaLevel：1从上述结果可以看出，**优先队列的出队是不考虑入队顺序的，它始终遵循的是优先级高的元素先出队**。####4.延迟队列延迟队列（DelayQueue）是基于优先队列`PriorityQueue`实现的，它可以看作是一种以时间为度量单位的优先的队列，当入队的元素到达指定的延迟时间之后方可出队。![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)我们来演示一下延迟队列的使用：```javaimportlombok.Getter;importlombok.Setter;importjava.text.DateFormat;importjava.util.Date;importjava.util.concurrent.DelayQueue;importjava.util.concurrent.Delayed;importjava.util.concurrent.TimeUnit;publicclassCustomDelayQueue{//延迟消息队列privatestaticDelayQueuedelayQueue=newDelayQueue();publicstaticvoidmain(String[]args)throwsInterruptedException{producer();//调用生产者consumer();//调用消费者}//生产者publicstaticvoidproducer(){//添加消息delayQueue.put(newMyDelay(1000,\"消息1\"));delayQueue.put(newMyDelay(3000,\"消息2\"));}//消费者publicstaticvoidconsumer()throwsInterruptedException{System.out.println(\"开始执行时间：\"+DateFormat.getDateTimeInstance().format(newDate()));while(!delayQueue.isEmpty()){System.out.println(delayQueue.take());}System.out.println(\"结束执行时间：\"+DateFormat.getDateTimeInstance().format(newDate()));}staticclassMyDelayimplementsDelayed{//延迟截止时间（单位：毫秒）longdelayTime=System.currentTimeMillis();//借助lombok实现@Getter@SetterprivateStringmsg;/***初始化*@paramdelayTime设置延迟执行时间*@parammsg执行的消息*/publicMyDelay(longdelayTime,Stringmsg){this.delayTime=(this.delayTime+delayTime);this.msg=msg;}//获取剩余时间@OverridepubliclonggetDelay(TimeUnitunit){returnunit.convert(delayTime-System.currentTimeMillis(),TimeUnit.MILLISECONDS);}//队列里元素的排序依据@OverridepublicintcompareTo(Delayedo){if(this.getDelay(TimeUnit.MILLISECONDS)>o.getDelay(TimeUnit.MILLISECONDS)){return1;}elseif(this.getDelay(TimeUnit.MILLISECONDS)<o.getDelay(TimeUnit.MILLISECONDS)){return-1;}else{return0;}}@OverridepublicStringtoString(){returnthis.msg;}}}```以上代码的执行结果如下：>开始执行时间：2020-10-2020:17:28>>消息1>>消息2>>结束执行时间：2020-10-2020:17:31从上述结束执行时间和开始执行时间可以看出，消息1和消息2都正常实现了延迟执行的功能。####5.其他队列在Java的队列中有一个比较特殊的队列`SynchronousQueue`，它的特别之处在于它内部没有容器，每次进行`put()`数据后（添加数据），必须等待另一个线程拿走数据后才可以再次添加数据，它的使用示例如下：```javaimportjava.util.concurrent.SynchronousQueue;publicclassSynchronousQueueTest{publicstaticvoidmain(String[]args){SynchronousQueuequeue=newSynchronousQueue();//入队newThread(()->{for(inti=0;i<3;i++){try{System.out.println(newDate()+\"，元素入队\");queue.put(\"Data\"+i);}catch(InterruptedExceptione){e.printStackTrace();}}}).start();//出队newThread(()->{while(true){try{Thread.sleep(1000);System.out.println(newDate()+\"，元素出队：\"+queue.take());}catch(InterruptedExceptione){e.printStackTrace();}}}).start();}}```以上代码的执行结果如下：>MonOct1921:00:21CST2020，元素入队>>MonOct1921:00:22CST2020，元素出队：Data0>>MonOct1921:00:22CST2020，元素入队>>MonOct1921:00:23CST2020，元素出队：Data1>>MonOct1921:00:23CST2020，元素入队>>MonOct1921:00:24CST2020，元素出队：Data2从上述结果可以看出，当有一个元素入队之后，只有等到另一个线程将元素出队之后，新的元素才能再次入队。###总结本文讲了Java中的5种队列：普通队列、双端队列、优先队列、延迟队列、其他队列。其中普通队列的典型代表为`ArrayBlockingQueue`和`LinkedBlockingQueue`，双端队列的代表为`LinkedBlockingDeque`，优先队列的代表为`PriorityQueue`，延迟队列的代表为`DelayQueue`，最后还讲了内部没有容器的其他队列`SynchronousQueue`。>文末福利：搜索公众号「Java中文社群」发送“面试”，领取最新的面试资料。","Back-End\\Java\\java-Collection.md":"#集合##集合与数组>**数组**>>-特点>-可以存储基本数据类型>-数组的长度固定>-不适合在对象数量未知的情况下使用>**集合**>>-特点>-只能存储对象，对象类型可以不一样>-长度可变，可在多数情况下使用。##集合中接口和类的关系###**Collection**>-集合类的根接口，Java中没有提供这个接口的直接的实现类。>-但是却让其被继承产生了两个接口，就是Set和List。>-Set中不能包含重复的元素。>-List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。###**Map**>-Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。>-Map包含了key-value对。>-Map**不能包含重复的key**，但是可以包含相同的value。###**Iterator**>-遍历集合中元素的接口，主要包含以下三种方法：1.**hasNext()**是否还有下一个元素。2.**next()**返回下一个元素。3.**remove()**删除当前元素。###层次图图一这个比较简单![这里写图片描述](http://img.blog.csdn.net/20170905084526091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl2ZW9yX0RpZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)图二完整![这里写图片描述](http://img.blog.csdn.net/20170905084554470?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl2ZW9yX0RpZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)###list,set,map对比|接口|子接口|是否有序|是否允许元素重复||----------|-----------|------------------|---------------------------------------------------------||Collection||否|||List|ArrayList|否|是|||LinkedList|否|是|||Vector|否|是||Set|AbstractSet|否|否|||HashSet|否|否|||TreeSet|是（用二叉排序树）|否||Map|AbstractMap|否|使用key-value来映射和存储数据，key必须唯一，value可以重复|||HashMap||否|||TreeMap|是（用二叉排序树）|使用key-value来映射和存储数据，key必须唯一，value可以重复|##list（有序、可重复）>-List里存放的对象是有序的，同时也是可以重复的>-List关注的是索引，拥有一系列和索引相关的方法，查询速度快。>-因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有**插入删除数据速度慢**。###ArrayList>-ArrayList是基于数组的，在初始化ArrayList时，会构建空数组（Object[]elementData={}）。>-ArrayList是一个无序的，它是按照添加的先后顺序排列>-提供了sort方法，如果需要对ArrayList进行排序，只需要调用这个方法，提供Comparator比较器即可####add操作1）如果是第一次添加元素，数组的长度被扩容到默认的capacity，也就是10.2)当发觉同时添加一个或者是多个元素，数组长度不够时，就扩容，这里有两种情况：只添加一个元素，例如：原来数组的capacity为10，size已经为10，不能再添加了。需要扩容，新的capacity=oldcapacity+oldcapacity>>1=10+10/2=15.即新的容量为15。当同时添加多个元素时，原来数组的capacity为10，size为10，当同时添加6个元素时。它需要的mincapacity为16，而按照capacity=oldcapacity+oldcapacity>>1=10+10/2=15。newcapacity小于mincapacity，则取mincapacity。对于添加，如果不指定下标，就直接添加到数组后面，不涉及元素的移动，如果要添加到某个特定的位置，那需要将这个位置开始的元素往后挪一个位置，然后再对这个位置设置。####Remove操作Remove提供两种，按照下标和value。1）**remove(intindex)**：首先需要检查Index是否在合理的范围内。其次再调用System.arraycopy将index之后的元素向前移动。2）**remove(Objecto)**：首先遍历数组，获取第一个相同的元素，获取该元素的下标。其次再调用System.arraycopy将index之后的元素向前移动。####Get操作这个比较简单，直接对数组进行操作即可。###LinkedListLinkedList是基于链表的，它是一个双向链表，每个节点维护了一个prev和next指针。同时对于这个链表，维护了first和last指针，first指向第一个元素，last指向最后一个元素。LinkedList是一个无序的链表，按照插入的先后顺序排序，不提供sort方法对内部元素排序。####Add元素LinkedList提供了几个添加元素的方法：addFirst、addLast、addAll、add等，时间复杂度为O(1)。####Remove元素LinkedList提供了几个移除元素的方法：removeFirst、removeLast、removeFirstOccurrence、remove等，时间复杂度为O(1)。####Get元素根据给定的下标index，判断它first节点、last直接距离，如果index<size（数组元素个数)/2,就从first开始。如果大于，就从last开始。这个和我们平常思维不太一样，也许按照我们的习惯，从first开始。这也算是一点小心的优化吧。###遍历在类集中提供了以下四种的常见输出方式：1）Iterator：迭代输出，是使用最多的输出方式。2）ListIterator：是Iterator的子接口，专门用于输出List中的内容。3）foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。4）for循环代码示例如下：**for的形式：**for（inti=0;i<arr.size();i++）{...}**foreach的形式：**for（inti：arr）{...}**iterator的形式：**Iteratorit=arr.iterator();while(it.hasNext()){objecto=it.next();...}##Set（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。###HashSetHashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，而HashMap的value始终都是PRESENT。HashSet不允许重复（HashMap的key不允许重复，如果出现重复就覆盖），允许null值，非线程安全。####构造方法**HashSet()**构造一个新的空set，其底层HashMap实例的默认初始容量是16，加载因子是0.75。**HashSet(Collection<?extendsE>c)**构造一个包含指定collection中的元素的新set。**HashSet(intinitialCapacity)**构造一个新的空set，其底层HashMap实例具有指定的初始容量和默认的加载因子（0.75）。**HashSet(intinitialCapacity,floatloadFactor)**构造一个新的空set，其底层HashMap实例具有指定的初始容量和指定的加载因子。####方法**booleanadd(Ee)\\*\\*如果此set中尚未包含指定元素，则添加指定元素。\\*\\*voidclear()\\*\\*从此set中移除所有元素。\\*\\*Objectclone()\\*\\*返回此HashSet实例的浅表副本：并没有复制这些元素本身。\\*\\*booleancontains(Objecto)\\*\\*如果此set包含指定元素，则返回true。\\*\\*booleanisEmpty()**如果此set不包含任何元素，则返回true。**Iteratoriterator()**返回对此set中元素进行迭代的迭代器。**booleanremove(Objecto)**如果指定元素存在于此set中，则将其移除。**intsize()**返回此set中的元素的数量（set的容量）。###TreeSet基于TreeMap的NavigableSet实现。使用元素的自然顺序对元素进行排序，或者根据创建set时提供的Comparator进行排序，具体取决于使用的构造方法。**构造方法和方法比较类似就不说了**###遍历（和list相似）对set的遍历1.迭代遍历：```Set<String>set=newHashSet<String>();Iterator<String>it=set.iterator();while(it.hasNext()){Stringstr=it.next();System.out.println(str);}```2.for(foreach)循环遍历：```for(Stringstr:set){System.out.println(str);}```##Map（键值对、键唯一、值不唯一）Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。###HashMap数组方式存储key/value，**线程非安全**，**允许null作为key和value**，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，key的hash值是先计算key的hashcode值，然后再进行计算，每次容量扩容会重新计算所以key的hash值，会消耗资源，要求key必须重写equals和hashcode方法默认初始容量16，加载因子0.75，扩容为旧容量乘2，查找元素快，如果key一样则比较value，如果value不一样，则按照链表结构存储value，就是一个key后面有多个value；####方法**1、添加：****Vput(Kkey,Vvalue)**（可以相同的key值，但是添加的value值会覆盖前面的，返回值是前一个，如果没有就返回null）**putAll(Mapm)**从指定映射中将所有映射关系复制到此映射中（可选操作）。**2、删除****remove()**删除关联对象，指定key对象**clear()**清空集合对象**3、获取****valueget(key)**可以用于判断键是否存在的情况。当指定的键不存在的时候，返回的是null。**４、判断：****booleanisEmpty()**长度为0返回true否则false**booleancontainsKey(Objectkey)**判断集合中是否包含指定的key**booleancontainsValue(Objectvalue)**判断集合中是否包含指定的value4、长度：**Intsize（）**map的主要的方法就这几个###HashtableHashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。###LinkedHashMapLinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。###TreeMap基于红黑二叉树的NavigableMap的实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出###遍历**第一种：KeySet()**将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。keySet():迭代后只能通过get()取key。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。```Mapmap=newHashMap();map.put(\"key1\",\"lisi1\");map.put(\"key2\",\"lisi2\");map.put(\"key3\",\"lisi3\");map.put(\"key4\",\"lisi4\");//先获取map集合的所有键的set集合，keyset（）Iteratorit=map.keySet().iterator();//获取迭代器while(it.hasNext()){Objectkey=it.next();System.out.println(map.get(key));}```**第二种：values()**获取所有的值.Collectionvalues()**不能获取到key对象**```Collection<String>vs=map.values();Iterator<String>it=vs.iterator();while(it.hasNext()){Stringvalue=it.next();System.out.println(\"value=\"+value);}```**第三种：entrySet（）**Set<Map.Entry<K,V>>entrySet()//返回此映射中包含的映射关系的Set视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。典型用法如下：```//返回的Map.Entry对象的Set集合Map.Entry包含了key和value对象Set<Map.Entry<Integer,String>>es=map.entrySet();Iterator<Map.Entry<Integer,String>>it=es.iterator();while(it.hasNext()){//返回的是封装了key和value对象的Map.Entry对象Map.Entry<Integer,String>en=it.next();//获取Map.Entry对象中封装的key和value对象Integerkey=en.getKey();Stringvalue=en.getValue();System.out.println(\"key=\"+key+\"value=\"+value);}```推荐使用第三种方式，即entrySet()方法，效率较高。对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。##总结###Vector和ArrayList1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。ArrayList和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。###arraylist和linkedlist1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList.因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。###HashMap与TreeMap1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。2、在Map中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和equals()的实现。两个map中的元素一样，但顺序不一样，导致hashCode()不一样。同样做测试：在HashMap中，同样的值的map,顺序不同，equals时，false;而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。###HashTable与HashMap1、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。2、HashMap允许存在一个为null的key，多个为null的value。3、hashtable的key和value都不允许为null。","Back-End\\Java\\java-expand.md":"#java-expand##JVM虚拟内存分布>借鉴<https://www.cnblogs.com/syp172654682/p/8082625.html><imgsrc=\"https://images.gitee.com/uploads/images/2020/1101/171425_ce5ca706_7984151.png\"style=\"zoom:50%;align:center;\"/>>-**程序计数器**是jvm执行程序的流水线，存放一些跳转指令。>-**本地方法栈**是jvm调用操作系统方法所使用的栈。>-**虚拟机栈**是jvm执行java代码所使用的栈。>-**方法区**存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。>-**虚拟机堆**是jvm执行java代码所使用的堆。###常量池>分为:**静态常量池**和**运行时常量池**>>可以通过jvm参数`-XX:PermSize、-XX:MaxPermSize来设置方法区大小`,从而间接显示常量池的大小####静态常量池>-`*.class`文件中的常量池>-`*.class`文件中的常量池不仅仅包含字符串(数字)字面量,还包含类,方法的信息,常用class文件绝大部分空间,改常量池主要涌入存放两大类常量:`字面量(Literal)`和`符号引用量(SymbolicReferences)`>-字面量:相当于Java语言层面的概念,入文本字符串,声明为final的常量值等>-符号引用量:属于编译原理方面的概念,包含了如下三种类型的常量:>-类和接口的全限定名>-字段名称和描述符>-方法名称和描述符####运行常量池>-这是JVM虚拟机在完成类装载操作后,将class文件中的常量池载入到内存中,并保存到方法区中,我们常说的常量池,就是指方法去中的运行时常量池>-运行时常量池相对于CLass文件常量池的另外一个重要特征是**具备动态性**，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String类的intern()**方法。>-String的`intern()`方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池#####常量池的好处>-避免频繁的创建和销毁对象而影响系统性能,其实现了对象的共享>-节约内存空间:常量池中所有相同的字符串长阿林被合并,只占用一个空间>-节约运行时间:比较字符串是,==比equals()快,对于两个引用变量,只用==判断引用是否相等,也就是判断实际值是否相等```javaStrings1=\"hello\";Strings2=\"hello\";Strings3=\"hel\"+\"lo\";Strings4=\"hel\"+newString(\"lo\");Strings5=newString(\"hello\");Strings6=s5.intern();Strings7=\"H\";Strings8=\"ello\";Strings9=s7+s8;System.out.println(s1==s2);//true/**s1和s2在赋值的时候,均使用字符串字面量,在编译期间,这种字面量会直接放入class文件的常量池中,而实现复用载入运行时常量池后,s1,s2指向同一个内存地址,所以相等*/System.out.println(s1==s3);//true/*s3虽然是动态拼接出来的字符串,但是所有参与拼接的部分都是已知的字面量,在编译期间,这种拼接会被优化,编译器直接帮你拼接好只有使用引号包括的文本的方式创建的String对象之间使用\"+\"连接产生新的对象才会被加入字符串池中*/System.out.println(s1==s4);//false/*s4有一部分不是已知字面量,编译器不会优化,必须等到运行时才可以确定结果,给字符串不变定理,不确定s4被分配到哪里,所以地址不相同对于所有包含new方式新建对象(包括null)的\"+\"连接表达式,他所产生的新对象都不会被加入字符串池中*/System.out.println(s1==s9);//false/**s7,s8作为两个变量,都是不可以预料的,都是不可以预料的,在编译期被确认,所以不做优化,只能等到运行时,在堆中创建*/System.out.println(s4==s5);//false//两个都在堆中,地址不相同System.out.println(s1==s6);//true//intern()会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，//因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；故地址相同```特例1```javapublicstaticfinalStringA=\"ab\";//常量ApublicstaticfinalStringB=\"cd\";//常量Bpublicstaticvoidmain(String[]args){Strings=A+B;//将两个常量用+连接对s进行初始化Stringt=\"abcd\";System.out.println(s==t);//true}//A和B都是常量,值是固定的,因此s的值也是固定的,他在编译时就已确认,也就是Strings=A+B;等同于Strings=\"ab\"+\"cd\";```特例2```javapublicstaticfinalStringA;//常量ApublicstaticfinalStringB;//常量Bstatic{A=\"ab\";B=\"cd\";}publicstaticvoidmain(String[]args){//将两个常量用+连接对s进行初始化Strings=A+B;Stringt=\"abcd\";System.out.println(s==t);//false}```>A和B虽然被定义为常量,但是它们都没有被马上复制,在运算上s的值之前,它们合适被赋值,以及被赋予什么样的值,都是变数,因此A和B在被赋值之前,性质类型于与变量,那么s就不能在编译期被确认,只能在运行时被创建####缓存池>-newInteger(123)每次都会新建一个对象；>-Integer.valueOf(123)会使用缓存池中的对象，多次调用会取得同一个对象的引用。>-integer缓存池大小默认为-128~127```javaIntegerx=newInteger(123);Integery=newInteger(123);System.out.println(x==y);//falseIntegerz=Integer.valueOf(123);Integerk=Integer.valueOf(123);System.out.println(z==k);//true```##包装类和基本类型```javainti=128;Integeri2=128;Integeri3=newInteger(128);System.out.println(i==i2);//Integer会自动拆箱为int，所以为trueSystem.out.println(i==i3);//true，理由同上Integeri4=127;//编译时被翻译成：Integeri4=Integer.valueOf(127);Integeri5=127;System.out.println(i4==i5);Integeri6=128;Integeri7=128;System.out.println(i6==i7);Integeri8=newInteger(127);System.out.println(i5==i8);//falseIntegeri9=newInteger(128);Integeri10=newInteger(123);System.out.println(i9==i10);//falseinti11=11;inti12=11;System.out.println(i11==i12);//true```>i4和i5为true的原因:>>--128~127之间的数,会进行缓存,>-Intergeri4=127时,会将127进行缓存>-Intergeri5=127时,会直接在缓存中去,就不会再new一个对象>-所以i4和i5是true,i6和i7为false>>总结:>>-两个都是new出来的,都是false,地址不同>-int和Interger(无论new否)比,都是true,因为Interger自动猜想为int再去比","Back-End\\Java\\java8\\lambda.md":"#Lambda>-`Lambda`表达式，也可称为`闭包`，是一个`匿名函数`。>-可以把Lambda表达式理解为是`一段可传递的代码`（像数据一样传递）。即Lambda允许把`函数`作为一个方法的`实参参数`（函数当作参数传递到方法中）。>-`Java8`的其中一个很重要的新特性。```javapublicclassLambdaDemo{publicstaticvoidmain(String[]args){List<String>list=Arrays.asList(\"A\",\"B\",\"C\");//x->System.out.println(x)，就是一个匿名函数,即Lambda表达式，作为实参传给dealList方法dealList(list,x->System.out.println(x));}publicstaticvoiddealList(List<String>list,Consumer<String>consumer){//遍历list中的每一个元素，传给consumer对象的accept函数，进行调用for(Stringx:list){consumer.accept(x);}}}```>-Lambda表达式是对某些接口的简单实现，但不是所有接口都可以使用Lambda表达式来实现的，Lambda规定能被Lambda表达式实现的接口中，它`只能只有一个需要被实现的方法（函数）`，但`不要求接口中只能只有一个方法。`>-因为Java8中有另外一个新特性，即`default`关键字修饰的接口方法有默认实现，这个默认的方法是可以不需要子类实现的，可使用`@FunctionalInterface`注解来强制使接口只能有一个需要被实现的方法。```java//此注解表明此接口为函数接口，即只能有一个抽象方法@FunctionalInterfacepublicinterfaceHuman{//抽象方法，需要被实现voideat(Stringname);//default修饰的默认方法，不需要被子类实现defaultvoidrun(){System.out.println(\"Icanrun...\");}}publicstaticvoidmain(String[]args){Humanhuman=x->System.out.println(x+\"iseat\");human.eat(\"Mr.nobody\");human.run();}//输出结果Mr.nobodyiseatIcanrun...```##案例一```java//接口publicinterfaceHuman{//抽象方法，需要被实现voidspeak();}```###通过类来实现接口>并且实现里面的抽象方法```java//实现类，并且实现抽象方法publicclassManimplementsHuman{@Overridepublicvoidspeak(){System.out.println(\"Iamman!\");}}publicclassMain{publicstaticvoidmain(String[]args){//方式一直接编写实现类Humanhuman=newMan();human.speak();}}```###匿名内部类```javapublicclassMain{publicstaticvoidmain(String[]args){//方式一直接编写实现类Humanhuman=newMan();human.speak();//方式二匿名内部类Humanhuman1=newHuman(){@Overridepublicvoidspeak(){System.out.println(\"Iamwoman!\");}};human1.speak();}}```>但方式二中，有用的就只有`System.out.println(\"Iamwoman!\");`这一行，所以有了Lambda表达式，可以这样写，如方式三：```javapublicclassMain{publicstaticvoidmain(String[]args){//方式一直接编写实现类Humanhuman=newMan();human.speak();//方式二匿名内部类Humanhuman1=newHuman(){@Overridepublicvoidspeak(){System.out.println(\"Iamwoman!\");}};human1.speak();//方式三Lambda表达式Humanhuman2=()->System.out.println(\"Iamwoman!\");human2.speak();}}```##案例二>再假如我们要对一个Student类的数组按指定条件进行过滤，如下：```javapublicclassStudent{privateStringname;privateintage;privatedoublescore;}publicclassMain{publicstaticvoidmain(String[]args){List<Student>students=Arrays.asList(newStudent(\"张三\",18,89.5),newStudent(\"李四\",20,60),newStudent(\"王五\",19,100),newStudent(\"赵六\",22,89));//过滤出年龄大于等于20的学生List<Student>stus1=filterStudentByAge(students);System.out.println(stus1);//过滤出成绩大于80的学生List<Student>stus2=filterStudentByScore(students);System.out.println(stus2);}//过滤出年龄大于等于20的学生privatestaticList<Student>filterStudentByAge(List<Student>students){List<Student>stus=newArrayList<>();for(Studentstu:students){if(stu.getAge()>=20){stus.add(stu);}}returnstus;}//过滤出成绩大于80的学生privatestaticList<Student>filterStudentByScore(List<Student>students){List<Student>stus=newArrayList<>();for(Studentstu:students){if(stu.getScore()>80){stus.add(stu);}}returnstus;}}```>按上面的方式，如果要按另外一个条件过滤呢，又要写一个方法。那可以用策略模式处理，编写一个抽象策略接口，然后编写多个不同策略类实现它。```java//策略接口publicinterfaceMyPredicate<T>{booleantest(Tt);}//过滤出年龄大于等于20的学生publicclassfilterStudentByAgeimplementsMyPredicate<Student>{@Overridepublicbooleantest(Studentt){returnt.getAge()>=20;}}//过滤出成绩大于80的学生publicclassfilterStudentByScoreimplementsMyPredicate<Student>{@Overridepublicbooleantest(Studentt){returnt.getScore()>80;}}publicclassMain{publicstaticvoidmain(String[]args){List<Student>students=Arrays.asList(newStudent(\"张三\",18,89.5),newStudent(\"李四\",20,60),newStudent(\"王五\",19,100),newStudent(\"赵六\",22,89));//过滤出年龄大于等于20的学生List<Student>stus1=filterStudent(students,newFilterStudentByAge());System.out.println(stus1);//过滤出成绩大于80的学生List<Student>stus2=filterStudent(students,newFilterStudentByScore());System.out.println(stus2);}//按myPredicate策略过滤出满足条件的学生privatestaticList<Student>filterStudent(List<Student>students,MyPredicate<Student>myPredicate){List<Student>stus=newArrayList<>();for(Studentstu:students){if(myPredicate.test(stu)){stus.add(stu);}}returnstus;}}```>但是以上方式，每增加一个过滤条件，就要编写一个策略类，太麻烦。所以我们就用匿名内部类方式。```java//匿名内部类形式过滤出年龄大于等于18的学生List<Student>stus3=filterStudent(students,newMyPredicate<Student>(){@Overridepublicbooleantest(Studentt){returnt.getAge()>18;}});System.out.println(stus3);```>但我们会觉得匿名内部类还是太麻烦，无用代码太多，有用的代码其实就只有`returnt.getAge()>18;`，于是Lambda表达式发挥的作用就来了：```java//Lambda形式过滤出年龄大于等于18的学生List<Student>stus4=filterStudent(students,t->t.getAge()>18);System.out.println(stus4);```>这时还是有人会问，那我们定义的`接口MyPredicate`和`方法filterStudent()`，好像没什么作用呀。然而官方已经想到这一点，它内置了一些通用接口，我们可以使用它。例如断言的接口`Predicate`，那我们就用如下方式，完全不用写`接口MyPredicate`和`方法filterStudent()`，如下：```java//按myPredicate策略过滤出满足条件的学生privatestaticList<Student>filterStudent(List<Student>students,Predicate<Student>predicate){List<Student>stus=newArrayList<>();for(Studentstu:students){if(predicate.test(stu)){stus.add(stu);}}returnstus;}```>当然，如果你会使用Stream（可以看我另外一篇文章），只需要写下面的代码，如下：```javapublicclassMain{publicstaticvoidmain(String[]args){List<Student>students=Arrays.asList(newStudent(\"张三\",18,89.5),newStudent(\"李四\",20,60),newStudent(\"王五\",19,100),newStudent(\"赵六\",22,89));//过滤出年龄大于等于20的学生students.stream().filter(t->t.getAge()>=20).forEach(System.out::println);System.out.println(\"-------------------------------------\");//过滤出成绩大于80的学生students.stream().filter(t->t.getScore()>80).forEach(System.out::println);}}```##Lambda语法>语法：()->{}()：Lambda的形参列表，也就是接口里面那个抽象方法的形参列表。->：Lambda的操作符，可以理解为参数和Lambda体的分隔符。{}：实现了接口中的抽象方法的方法体。>我们还是以一个简单的例子，由浅到深学习Lambda语法。按照语法，我们可以写出如下Lambda表达式，`(Stringname,intage)`是参数列表，`->`是分隔符，`{}`中的代码是方法体。```java//函数接口@FunctionalInterfacepublicinterfaceHuman{//抽象方法，需要被实现Stringspeak(Stringname,intage);}publicclassLambdaDemo{publicstaticvoidmain(String[]args){Humanhuman=(Stringname,intage)->{System.out.println(\"Mynameis\"+name+\",Iam\"+age+\"yearsold.\");returnname;};human.speak(\"Mr.nobody\",18);}}```>当然，`()`括号内的`参数类型还能省略`（推荐）。```javapublicclassLambdaDemo{publicstaticvoidmain(String[]args){Humanhuman=(name,age)->{System.out.println(\"Mynameis\"+name+\",Iam\"+age+\"yearsold.\");returnname;};human.speak(\"Mr.nobody\",18);}}```>如果是`只有一个参数，()也能省略`。```java@FunctionalInterfacepublicinterfaceHuman{//抽象方法，需要被实现Stringspeak(Stringname);}publicclassLambdaDemo{publicstaticvoidmain(String[]args){Humanhuman=name->{System.out.println(\"Mynameis\"+name+\".\");returnname;};human.speak(\"Mr.nobody\");}}```>如果，方法体`{}`中，只有一行语句，{}也能省略（推荐）。```java@FunctionalInterfacepublicinterfaceHuman{//抽象方法，需要被实现voidspeak(Stringname,intage);}publicclassLambdaDemo{publicstaticvoidmain(String[]args){Humanhuman=(name,age)->System.out.println(\"Mynameis\"+name+\",Iam\"+age+\"yearsold.\");human.speak(\"Mr.nobody\",18);}}```>如果`方法体需要返回值`，而且`只有一行语句`，那`{}`大括号和`return`关键字都可以省略（推荐）。```java@FunctionalInterfacepublicinterfaceHuman{//抽象方法，需要被实现Stringspeak(Stringname,intage);}publicclassLambdaDemo{publicstaticvoidmain(String[]args){Humanhuman=(name,age)->\"Mynameis\"+name+\",Iam\"+age+\"yearsold.\";human.speak(\"Mr.nobody\",18);}}```","Back-End\\Java\\VO_DTO_Entity.md":"#VO_DTO_Entity>1、entity里的每一个字段，与数据库相对应，>>2、vo里的每一个字段，是和你前台html页面相对应，>>3、dto这是用来转换从entity到vo，或者从vo到entity的中间的东西。举个例子：你的html页面上有三个字段，name，pass，age你的数据库表里，有两个字段，name，pass，注意没有age。而你的vo里，就应该有下面三个成员变量，因为对应html页面上三个字段。```javaprivatestringname；privatestringpass;privatestringage;```这个时候，你的entity里，就应该有两个成员变量，因为对应数据库表中的2个字段。```javaprivatestringname；privatestringpass;```到了这里，好了，业务经理让你做这样一个业务“年龄大于20的才能存入数据库，这个时候，你就要用到dto了，1）你要先从页面上拿到vo，然后判断vo中的age是不是大于20。2）如果大于20，就把vo中的name和pass拿出来，放到dto中。3）然后在把dto中的name和pass原封不动的给entity，然后根据entity的值，在传入数据库。这就是他们三个的区别。PS：dto和entity里面的字段应该是一样的，dto只是entity到vo，或者vo到entity的中间过程，如果没有这个过程，你仍然可以做到增删改查，这是根据具体公司规范来的。","Back-End\\Java\\线程.md":"#线程##多线程>一个程序执行多个任务,通常一个任务称为一个线程###Thread```javapackagecom.java.test;publicclassThreadTest{publicstaticvoidmain(String[]args){TreadTest1thread1=newTreadTest1();TreadTest2thread2=newTreadTest2();thread1.start();thread2.start();}}classTreadTest1extendsThread{@Overridepublicvoidrun(){for(inti=0;i<1000;++i){System.out.println(\"Test1\"+i);}}}classTreadTest2extendsThread{@Overridepublicvoidrun(){for(inti=0;i<1000;++i){System.out.println(\"Test2\"+i);}}}```###Runnable```javapackagecom.java.test;publicclassThreadTest{publicstaticvoidmain(String[]args){//线程的另一种实现方法，也可以使用匿名的内部类Threadthreadtest1=newThread((newThreadTest1()));threadtest1.start();Threadthreadtest2=newThread((newThreadTest2()));threadtest2.start();}}classThreadTest1implementsRunnable{@Overridepublicvoidrun(){for(inti=0;i<100;++i){System.out.println(\"Hello:\"+i);}}}classThreadTest2implementsRunnable{@Overridepublicvoidrun(){for(inti=0;i<100;++i){System.out.println(\"Welcome:\"+i);}}}```##线程同步>Threadsynchronization>>对所有线程对于同一个资源的访问上的时序性栗子:>会出现账号的金额数目发生改变,本来这程序本来来说应该是不会发生改变的,但是你运行后会发现数字一直在变大或变小```javapublicclassDemo1{publicstaticvoidmain(String[]args){Bankbank=newBank();//创建10个线程，不停的将一个账号资金转移到另一个账号上for(inti=0;i<100;i++){newThread(()->{while(true){intaccount1=((Double)Math.floor(Math.random()*10)).intValue();intaccount2=((Double)Math.floor(Math.random()*10)).intValue();intnum=((Long)Math.round(Math.random()*100)).intValue();bank.transfer(account1,account2,num);try{Thread.sleep(((Double)(Math.random()*10)).intValue());}catch(Exceptione){}}}).start();}}}classBank{/***10个资金账户*/publicint[]accounts=newint[10];publicBank(){Arrays.fill(accounts,1000);}publicvoidtransfer(intfrom,intto,intnum){accounts[from]-=num;accounts[to]+=num;//计算和intsum=0;for(intj=0;j<10;j++){sum+=accounts[j];}System.out.println(sum);}}```修复方法>-synchronized关键字自动提供了一个锁以及相关的条件>-牺牲时间来解决访问冲突>-ReentrantLock>-ThreadLocal>-牺牲存储空间>-只有在线程内才可以获取到对应的值```java//方法一:在main函数synchronized(bank){bank.transfer(account1,account2,num);}//方法二:publicsynchronizedvoidtransfer(intfrom,intto,intnum){...}//方法三:privateReentrantLocklock=newReentrantLock();publicsynchronizedvoidtransfer(intfrom,intto,intnum){lock.lock();//上锁try{//要保护的代码块}finally{lock.unlock();//释放锁}}```","Back-End\\Spring\\maven.md":"#maven>[下载-Maven–DownloadApacheMaven](http://maven.apache.org/download.cgi)##maven目录####1）bin该目录包含了mvn运行的脚本，这些脚本用来配置Java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。其中mvn是基于UNIX平台的shell脚本，mvn.bat是基于Windows平台的bat脚本。在命令行输入任何一条mvn命令时，实际上就是在调用这些脚本。该目录还包含了mvnDebug和mvnDebug.bat两个文件，同样，前者是UNIX平台的shell脚本，后者是Windows平台的bat脚本。那么mvn和mvnDebug有什么区别和关系呢？打开文件我们就可以看到，两者基本是一样的，只是mvnDebug多了一条MAVEN_DEBUG_OPTS配置，其作用就是在运行Maven时开启debug，以便调试Maven本身。此外，该目录还包含m2.conf文件，这是classworlds的配置文件，后面会介绍classworlds。####2）boot该目录只包含一个文件，以maven3.3.9为例，该文件为plexus-classworlds-2.5.2.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架加载自己的类库。更多关于classworlds的信息请参考<http://classworlds.codehaus.org/>。对于一般的Maven用户来说，不必关心该文件。####3）conf>重点**setting.xml**该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为。一般情况下，我们更偏向于复制该文件至～/.m2/目录下（～表示用户目录），然后修改该文件，在用户范围定制Maven的行为。后面将会多次提到**settings.xml**，并逐步分析其中的各个元素。####4）lib该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、maven-model-3.0.jar之类的文件。此外，这里还包含一些Maven用到的第三方依赖，如common-cli-1.2.jar、commons-lang-2.6.jar等。对于Maven2来说，该目录只包含一个如maven-2.2.1-uber.jar的文件，原本各为独立JAR文件的Maven模块和第三方类库都被拆解后重新合并到了这个JAR文件中。可以说，lib目录就是真正的Maven。关于该文件，还有一点值得一提的是，用户可以在这个目录中找到Maven内置的超级POM，这一点教程后面会详细解释。####5）LICENSE.txt记录了Maven使用的软件许可证ApacheLicenseVersion2.0。####6）NOTICE.txt记录了Maven包含的第三方软件。####7）README.txt包含了Maven的简要介绍，包括安装需求及如何安装的简要指令等。##常用指令|指令|描述||------------------------|-------------||`mvn-v`|查看maven版本||`mvnarchetype:generate`|创建一个项目|##编译和测试>先切换到工程目录下|指令|描述||-------------|-----------------------------------------------------------------------------||`mvnclean`|清楚以前编译安装过的历史结果||`mvncompile`|编译源代码||`mvntest`|运行测试案例进行测试||`mvninstall`|将当前代码打层jar包,安装maven的本地管理目录下,其他maven工程指定坐标可以使用|>-`mvnsite`:生成站点信息>-`mvnjavadoc:javadoc`:生成APIDoc文档##其他指令>mvnarchetype:create//创建Maven项目>mvncompile//编译源代码>mvntest-compile//编译测试代码>mvntest//运行应用程序中的单元测试>mvnsite//生成项目相关信息的网站>mvnpackage//依据项目生成jar文件>mvninstall//在本地Repository中安装jar>mvn-Dmaven.test.skip=true//忽略测试文档编译>mvnclean//清除目标目录中的生成结果>mvncleancompile//将.java类编译为.class文件>mvncleanpackage//进行打包>mvncleantest//执行单元测试>mvncleandeploy//部署到版本仓库>mvncleaninstall//使其他项目使用这个jar,会安装到maven本地仓库中>mvnarchetype:generate//创建项目架构>mvndependency:list//查看已解析依赖>mvndependency:tree//看到依赖树>mvndependency:analyze//查看依赖的工具>mvnhelp:system//从中央仓库下载文件至本地仓库>mvnhelp:active-profiles//查看当前激活的profiles>mvnhelp:all-profiles//查看所有profiles>mvnhelp:effective-pom//查看完整的pom信息##Archetype插件####1）maven-archetype-quickstartmaven-archetype-quickstart应该是最常用的Archetype。在用户输入命令行“mvnarchetype:generate”时，如果没有指定使用哪个Archetype，默认就是使用quickstart。使用maven-archetype-quickstart生成的项目比较简单。-pom.xml，包含有JUnit的依赖声明。-src/main/java，主代码目录以及一个名为App的[Java](http://c.biancheng.net/java/)类。-src/main/test，测试代码目录以及一个名为AppTest的JUnit测试用例类。如果需要创建一个全新的Maven项目，可以使用该Archetype生成项目架构，再在该架构的基础上进行对应地修改，比如添加依赖、添加resources目录等，从而省去手动创建pom以及目录结构的麻烦。####2）maven-archetype-webappmaven-archetype-webapp是一个创建MavenWar项目的Archetype。它能创建一个Web应用的基本目录结构和必需的web.xml。使用maven-archetype-webapp生成如下内容。-pom.xmlpackaging的值为war，带有JUnit的依赖声明。-src/main/webapp目录。-src/main/webapp/index.jsp文件。-src/main/webapp/WEB-INF/web.xml文件。","Back-End\\Spring\\question\\ssm跨域.md":"#ssm跨域创建一个类实现javax.servlet.Filter接口```javapublicclassMyCORSFilterimplementsFilter{@Overridepublicvoiddestroy(){}@OverridepublicvoiddoFilter(ServletRequestreq,ServletResponseres,FilterChainchain)throwsIOException,ServletException{HttpServletResponseresponse=(HttpServletResponse)res;response.setHeader(\"Access-Control-Allow-Origin\",\"*\");response.setHeader(\"Access-Control-Allow-Methods\",\"POST,GET,OPTIONS,DELETE\");response.setHeader(\"Access-Control-Max-Age\",\"3600\");response.setHeader(\"Access-Control-Allow-Headers\",\"x-requested-with\");chain.doFilter(req,res);}@Overridepublicvoidinit(FilterConfigarg0)throwsServletException{}}```修改web.xml文件添加Filter的配置```xml<filter><filter-name>cors</filter-name><filter-class>com.ma.filter.MyCORSFilter</filter-class></filter><filter-mapping><filter-name>cors</filter-name><url-pattern>/*</url-pattern></filter-mapping>```","Back-End\\Spring\\question\\tomcat.md":"#Tomcat##**在请求目标中找到无效字符。有效字符在RFC7230和RFC3986中定义**>环境：tomcat9>>在tomcat配置中conf/server.xml```xml<Connectorport=\"8080\"protocol=\"HTTP/1.1\"connectionTimeout=\"20000\"redirectPort=\"8443\"//添加的relaxedPathChars=\"|{}[],%\"relaxedQueryChars=\"|{}[],%\"/>```","Back-End\\Spring\\Shiro.md":"#Shiro##简介>-说明:>-在Web系统中涉及到权限问题,例如不同角色的人登录系统,他操作的功能,按钮,菜单是各不相同>-权限校验>-用户认证-用户身份识别,即登录>-用户授权-访问控制>-密码加密-加密敏感数据房子被偷窥>-会话管理-与用户相关的时间敏感的状态信息>-Shiro>-适用环境:javaSE,JavaEE>-认证,授权,加密,会话管理,与Web继承,缓存等>-官网<http://shiro.apache.org/>","Back-End\\Spring\\Spring-Boot-annotations.md":"#SpringBoot注解##注解(annotations)列表>**@SpringBootApplication**：>>-包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。>-其中@ComponentScan让springBoot扫描到Configuration类并把它加入到程序上下文。|注解|描述||----------------------------|----------------------------------------------------------------------------------------------------------------||@Configuration|等同于spring的XML配置文件；使用[Java][]代码可以检查类型安全。||@EnableAutoConfiguration|自动配置||@ComponentScan|组件扫描||@Component|可配合CommandLineRunner使用,在程序启动后执行一些任务||@RestController|是@Controller和@ResponseBody的合集,表示这个是控制器,并且是将函数的返回值,接填入HTTP响应体中,REST风格控制器||@Autowried|自动导入||@PathVariable|获取参数||@JsonBackReference|解决嵌套外链问题||@RepositoryRestResoucepublic|配合spring-boot-start-data-rest使用|##注解(annotations)详解@SpringBootApplication：-申明让springboot自动给程序进行必要的配置，这个配置等同于：@Configuration，@EnableAutoConfiguration和@ComponentScan三个配置。```javapackagecom.example.myproject;importorg.springframework.boot.SpringApplication;importorg.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication//sameas@Configuration@EnableAutoConfiguration@ComponentScanpublicclassApplication{publicstaticvoidmain(String[]args){SpringApplication.run(Application.class,args);}}```@ResponseBody：​表示该方法的返回结果直接写入HTTPresponsebody中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTPresponsebody中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：```java@RequestMapping(“/test”)@ResponseBodypublicStringtest(){return”ok”;}```@Controller：​用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：```java@Controller@RequestMapping(“/demoInfo”)publicclassDemoController{@AutowiredprivateDemoInfoServicedemoInfoService;@RequestMapping(\"/hello\")publicStringhello(Map<String,Object>map){System.out.println(\"DemoController.hello()\");map.put(\"hello\",\"fromTemplateController.helloHtml\");//会使用hello.html或者hello.ftl模板进行渲染显示.return\"/hello\";}}```@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：```javapackagecom.kfit.demo.web;importorg.springframework.web.bind.annotation.RequestMapping;importorg.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(“/demoInfo2”)publicclassDemoController2{@RequestMapping(\"/test\")publicStringtest(){return\"ok\";}}```@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。@EnableAutoConfiguration：SpringBoot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库][Link1]连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，SpringBoot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。@Import：用来导入其他配置类。@ImportResource：用来加载xml配置文件。@Autowired：自动导入依赖的bean@Service：一般用于修饰service层的组件@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。@Bean：用@Bean标注方法等价于XML中配置的bean。@Value：注入Springbootapplication.properties配置的属性的值。示例代码：```@Value(value=“#{message}”)privateStringmessage;```@Inject：等价于默认的@Autowired，只是没有required属性；@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：```@Autowired@Qualifier(value=“demoInfoService”)privateDemoInfoServicedemoInfoService;```@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。##JPA注解@Entity：​@Table(name=\"\")：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。@Column：如果字段名与列名相同，则可以省略。@Id：表示该属性为主键。@GeneratedValue(strategy=GenerationType.SEQUENCE,generator=“repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。@SequenceGeneretor(name=“repair_seq”,sequenceName=“seq_repair”,allocationSize=1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式@JsonIgnore：作用是json序列化时将[Java][Java1]bean中的一些属性忽略掉,序列化和反序列化都受影响。@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。@OneToOne、@OneToMany、@ManyToOne：对应[hibernate][spring]配置文件中的一对一，一对多，多对一。##springMVC相关注解@RequestMapping：-@RequestMapping(“/path”)表示该控制器处理所有“/path”的URL请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。>-用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：>-params:指定request中必须包含某些参数值是，才让该方法处理。>-headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。>-value:指定请求的实际地址，指定的地址可以是URITemplate模式>-method:指定请求的method类型，GET、POST、PUT、DELETE等>-consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;>-produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回@RequestParam：用在方法的参数前面。@RequestParamStringa=request.getParameter(“a”)。@PathVariable:路径变量。如```java@RequestMapping(“user/get/mac/{macAddress}”)publicStringgetByMacAddress(@PathVariableStringmacAddress){//dosomething;}```参数与大括号里的名字一样要相同。##全局异常处理@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。","Back-End\\Spring\\SpringJDBC.md":"#SpringJDBC>主要包括四个包:>>-core:包含JDBC的核心功能,包括JdbcTemplate等类>-dataSource:访问数据源的实用工具类,他有多种数据源的实现,可以在JavaEE容器外部测试jdbc代码>-object:以访问对象方式访问数据库,他允许执行查询并将返回结果作为业务对象,可以在数据表的列表业务对象的属性之间映射查询结果>-support:包含core和object包的支持类,例如:提供异常转换功能的SQLException类```javaimportlombok.Data;@DatapublicclassUser{privateintID;privateStringname;privateStringage;}``````javaimportjava.util.List;publicinterfaceUserDao{publicintupdate(Stringsql,Object[]param);publicList<User>query(Stringsql,Object[]param);}``````js@Repository(\"userDao\")publicclassUserDaoImplimplementsUserDao{@AutowiredprivateJdbcTemplatejdbcTemplate;publicintupdate(Stringsql,Object[]param){returnjdbcTemplate.update(sql,param);}publicList<User>query(Stringsql,Object[]param){RowMapper<User>rowMapper=newBeanPropertyRowMapper<>(User.class);returnjdbcTemplate.query(sql,rowMapper,param);}}``````xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:context=\"http://www.springframework.org/schema/context\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd\"><context:component-scanbase-package=\"com.tutorialspoint.dao.jdbcDemo\"/><!--配置数据源--><beanid=\"dataSource\"class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"><!--数据库驱动--><propertyname=\"driverClassName\"value=\"com.mysql.cj.jdbc.Driver\"></property><!--连接数据库URL--><propertyname=\"url\"value=\"jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true\"/><!--连接数据库和密码--><propertyname=\"username\"value=\"root\"/><propertyname=\"password\"value=\"\"/></bean><!--配置jdbc模版--><beanid=\"jdbcTemplate\"class=\"org.springframework.jdbc.core.JdbcTemplate\"><!--默认必须使用的数据源--><propertyname=\"dataSource\"ref=\"dataSource\"/></bean></beans>``````java@TestpublicvoidDEMO(){ApplicationContextapplicationContext=newClassPathXmlApplicationContext(\"jdbc.xml\");UserDaouserDao=(UserDao)applicationContext.getBean(\"userDao\");Object[]para={\"张三\",21};Stringsql=\"insertintouservalues(null,?,?)\";userDao.update(sql,para);Stringsql1=\"select*fromuser\";List<User>users=userDao.query(sql1,null);for(Useruser:users){System.out.println(user);}}```","Back-End\\Spring\\Spring相关.md":"#Spring相关>-[GettingStarted|BuildingaRESTfulWebService(spring.io)](https://spring.io/guides/gs/rest-service/)>-[Spring|SpringQuickstartGuide](https://spring.io/quickstart)>-[Spring环境配置\\_w3cschool](https://www.w3cschool.cn/wkspring/f6pk1ic8.html)","Back-End\\Spring\\ssm\\log4j.md":"#log4j>log4j包含三个组件>>-Logger(记录器):日志类别>-Appender(输出目的地):日志要输出的地方>-Layout(日志布局):日志以何种形式输出##java项目配置log4j配置步骤pom.xml```xml<!--添加log4j相关jar包--><dependency><groupId>log4j</groupId><artifactId>log4j</artifactId><version>1.2.16</version></dependency>```resources/log4j.properties```properties#日志配置log4j.rootLogger=DEBUG,stdout,file#控制台输出log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.Threshold=DEBUGlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%-d{yyyy-MM-ddHH:mm:ss}[%p]%m%n#所有文件输出log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=D:/logs/log.loglog4j.appender.file.Encoding=UTF-8log4j.appender.file.name=fileLogDemolog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%-d{yyyy-MM-ddHH:mm:ss}[%c{Num}][%l][%t:%r]-[%p]%m%nlog4j.appender.file.append=true```测试类```javaimportorg.apache.log4j.Logger;publicclasslog4jTest{//获取日志记录器Logger，名字为本类类名privatestaticLoggerlogger=Logger.getLogger(log4jTest.class);publicstaticvoidmain(String[]args){for(inti=0;i<3;i++){//记录debug级别的信息logger.debug(\"log4j日志输出：Thisisdebugmessage.\");//记录info级别的信息logger.info(\"log4j日志输出：Thisisinfomessage.\");//记录error级别的信息logger.error(\"log4j日志输出：Thisiserrormessage.\");}}}```##配置Logger记录器```javalog4j.rootLogger=[level],appenderName,appenderName,…```level表示日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者你定义的级别。Log4j建议使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，你可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。appenderName就是指日志输出的目的。你可以灵活地定义日志输出，也可以同时指定多个输出目的地。Log4j配置文件实现了输出到控制台、文件、回滚文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。##配置Appender输出目的地输出目的地类型：```propertiesorg.apache.log4j.ConsoleAppender（控制台），org.apache.log4j.FileAppender（文件），org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）```##配置layout日志布局```propertiesorg.apache.log4j.HTMLLayout（HTML表格形式）org.apache.log4j.SimpleLayout（简单格式的日志，只包括日志信息的级别和指定的信息字符串，如:DEBUG-Hello）org.apache.log4j.TTCCLayout（日志的格式包括日志产生的时间、线程、类别等等信息）org.apache.log4j.PatternLayout（灵活地自定义日志格式）```","Back-End\\Spring\\ssm\\spring.md":"#Spring##前言>-Spring是一个开源框架>-Spring为简化企业级应用开发而生.使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能>-Spring是JavaSE/EE的一站式框架##优点-方便解耦,简化开发-Spring就是一个大工厂,可以将所有对象创建和依赖关系维护,交给Spring管理-AOP变成的支持-Spring提供蜜蜡线切面编程,可以方便的实现对程序进行权限拦截、运行监控等功能-声明式事务的支持-只需要通过配置就可以完成对事务的管理,而无需手动编程-方便程序的测试-Spring对Junit4支持,可以通过注解方便的测试Spring程序-方便继承各种优秀框架-Spring不排斥各种优秀的开源框架,其内部提供对各种优秀的框架(Struts、Hibernate、MyBatis等）的直接支持-降低JavaEEAPI的使用难度-Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低##模块<imgsrc=\"https://images.gitee.com/uploads/images/2020/0711/133424_2ed6aec0_6545143.png\"style=\"zoom:25%;\"/>##SpringIOC的底层原理##导入Spring核心开发包到创建工程>commons-logging-xxx.jar>>spring-beans-x.x.x.RELEASE.jar>>spring-context-x.x.x.RELEASE.jar>>spring-core-x.x.x.RELEASE.jar>>spring-expression-x.x.x.RELEASE.jarpom.xml```xml<dependency><groupId>log4j</groupId><artifactId>log4j</artifactId><version>1.2.17</version></dependency><dependency><groupId>org.springframework</groupId><artifactId>spring-core</artifactId><version>4.2.4.RELEASE</version></dependency><dependency><groupId>org.springframework</groupId><artifactId>spring-context</artifactId><version>4.2.4.RELEASE</version></dependency><dependency><groupId>org.springframework</groupId><artifactId>spring-beans</artifactId><version>4.2.4.RELEASE</version></dependency><dependency><groupId>org.springframework</groupId><artifactId>spring-expression</artifactId><version>4.2.4.RELEASE</version></dependency>```##概念>SpringIOC>>-IOCInverseofControl反转控制的概念,就是将原本在程序中手动创建UserService对象的控制权,交由Spring框架管理>-就是将创建UserService对象控制权反转到Spring框架>-DIDependencyInjection**依赖注入**的概念,就是在创建这个对象的过程中,将这个对象所依赖的属性注入进去###Bean使用注解开发>id和name的作用区别:name可以使用特殊字符使用前需要添加的配置添加前```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd\">//配置bean<beanid=\"idName\"class=\"位置\"></bean></beans>```添加后```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:context=\"http://www.springframework.org/schema/context\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd\"><!--开启注释--><context:annotation-config/><!--注释的位置--><context:component-scanbase-package=\"com.tutorialspoint.beans\"/></beans>``````java//这里的Beans.xml也可以写成相对路径ApplicationContextcontext=newClassPathXmlApplicationContext(\"Beans.xml\");HelloSpringhelloSpring=(HelloSpring)context.getBean(\"helloSpring\");//通过获取bean的实例来初始化,该方法获取bean不需要设置bean的id//HelloSpringhelloSpring=(HelloSpring)context.getBean(HelloSpring.class);helloSpring.setName(\"Springadd\");System.out.println(helloSpring);```####注释和标签的对比|bean.xml|注解|描述||-----------------------------|--------------------------------|----------||id=\"idName\"|@Component(\"idName\")|beanID||lazy-init=\"true\"|@Lazy|延迟加载||scope=\"singleton\"|@Scope(\"singleton\")|||init-method=\"functionName\"|@PostConstruct//放在function前|bean创建时||destroy-method=\"functionName\"|@PreDestroy//放在function前|bean销毁时|####Bean的初始化和销毁前后调用方法1.interface-`implementsInitializingBean,DisposableBean`-然后实现里面的两个方法2.注解-在Bean中里面的方法前分别添加`@PostConstruct`和`@PreDestory`3.xml-先在bean添加方法-再在xml中,bean中init-method和destory-method注册补充Scope的五种取值-singleton:单例模式,在整个SpringIOC容器中只会创建一个实例.默认即为单例模式-prototype:原型模式,每次通过`getBean`方法获取实例,都会创建一个新的实例-request:在同一次`http`请求内,只会产生一个实例(Web应用)-session:在同一词`http`请求内,只会产生一个实例(Web应用)-globalsession:映射到porlet的global范围的session,如果是普通web项目施使用,会当做普通的session(在基于porlet的web应用程序)```java/***Spring的方式实现*/@Testpublicvoiddemo2(){//创建Spring的公厂ApplicationContextapplicationContext=newClassPathXmlApplicationContext(\"applicationContext.xml\");//通过工厂获得类UserServiceuserService=(UserService)applicationContext.getBean(\"userService\");userService.sayHello();}@Test/***读取磁盘系统中的配置文件*/publicvoiddemo3(){//创建Spring的工厂类//读取c盘的配置文件ApplicationContextapplicationContext=newFileSystemXmlApplicationContext(\"c:\\\\applicationContext.xml\");UserServiceuserService=(UserService)applicationContext.getBean(\"userService\");userService.sayHello();}@Test/***传统方式的工厂类:BeanFactory*/publicvoiddemo4(){BeanFactorybeanFactory=newXmlBeanFactory(newClassPathResource(\"applicationContext.xml\"));UserServiceuserService=(UserService)beanFactory.getBean(\"userService\");userService.sayHello();}@Test/***传统方式的工厂类:BeanFactory*/publicvoiddemo5(){BeanFactorybeanFactory=newXmlBeanFactory(newFileSystemResource(\"C:\\\\applicationContext.xml\"));UserServiceuserService=(UserService)beanFactory.getBean(\"userService\");userService.sayHello();}```##Bean###三种实例化Bean的方式####类构造器实例化(默认无参数)applicationContext.xml```xml<!--第一种:无参构造器的方式--><beanid=\"bean1\"class=\"com.ioc.demo2.Bean1\"></bean>```javaclass```javapublicvoiddemo1(){//创建工厂ApplicationContextapplicationContext=newClassPathXmlApplicationContext(\"applicationContext.xml\");//通过工厂类获得类的实例Bean1bean1=(Bean1)applicationContext.getBean(\"bean1\");}```####静态工厂方法实例化(简单工厂模式)applicationContext.xml```xml<!--第二种:静态工厂的方式--><beanid=\"bean2\"class=\"com.ioc.demo2.Bean2Factory\"factory-method=\"createBean2\"></bean>```javaclass```javapublicvoiddemo1(){//创建工厂ApplicationContextapplicationContext=newClassPathXmlApplicationContext(\"applicationContext.xml\");//通过工厂类获得类的实例Bean1bean1=(Bean1)applicationContext.getBean(\"bean1\");}```DEMOPetFactory.java```javapublicclassPetFactory{publicIpetgetPet(Stringtype){if(\"dog\".equals(type)){returnnewDog();}elseif(\"parrot\".equals(type)){returnnewParrot();}else{thrownewIllegalArgumentException(\"pettypeisillegal!\");}}}```factoryBean.xml```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd\"><beanid=\"petFactory\"class=\"com.tutorialspoint.impl.PetFactory\"></bean><beanid=\"dog\"factory-bean=\"petFactory\"factory-method=\"getPet\"><constructor-argvalue=\"dog\"></constructor-arg></bean><beanid=\"parrot\"factory-bean=\"petFactory\"factory-method=\"getPet\"><constructor-argvalue=\"parrot\"></constructor-arg></bean></beans>```Test文件```java@TestpublicvoidFactoryTest1(){Resourceresource=newClassPathResource(\"factoryBeans.xml\");BeanFactoryfactory=newDefaultListableBeanFactory();BeanDefinitionReaderbeanDefinitionReader=newXmlBeanDefinitionReader((BeanDefinitionRegistry)factory);beanDefinitionReader.loadBeanDefinitions(resource);Dogdog=(Dog)factory.getBean(\"dog\");Parrotparrot=(Parrot)factory.getBean(\"parrot\");dog.move();parrot.move();}log:Dogcanrun!Parrotcanfly!```####使用实例工厂方法实例化(工厂方法模式)```xml<!--第三种:实例工厂的方式--><beanid=\"bean3Factory\"class=\"com.ioc.demo2.Bean3Factory\"></bean><beanid=\"bean3\"factory-bean=\"bean3Factory\"factory-method=\"createBean3\"/>```javaclass```javapublicvoiddemo1(){//创建工厂ApplicationContextapplicationContext=newClassPathXmlApplicationContext(\"applicationContext.xml\");//通过工厂类获得类的实例Bean1bean1=(Bean1)applicationContext.getBean(\"bean1\");}```DEMOPetFactory.java```javapublicclassPetFactory{publicstaticIpetgetPet(Stringtype){if(\"dog\".equals(type)){returnnewDog();}elseif(\"parrot\".equals(type)){returnnewParrot();}else{thrownewIllegalArgumentException(\"pettypeisillegal!\");}}}```factoryBean.xml```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd\"><beanid=\"dog\"class=\"com.tutorialspoint.impl.StaticPetFactory\"factory-method=\"getPet\"><constructor-argvalue=\"dog\"></constructor-arg></bean><beanid=\"parrot\"class=\"com.tutorialspoint.impl.StaticPetFactory\"factory-method=\"getPet\"><constructor-argvalue=\"parrot\"></constructor-arg></bean></beans>```Test文件```java@TestpublicvoidFactoryTest1(){Resourceresource=newClassPathResource(\"factoryBeans.xml\");BeanFactoryfactory=newDefaultListableBeanFactory();BeanDefinitionReaderbeanDefinitionReader=newXmlBeanDefinitionReader((BeanDefinitionRegistry)factory);beanDefinitionReader.loadBeanDefinitions(resource);Dogdog=(Dog)factory.getBean(\"dog\");Parrotparrot=(Parrot)factory.getBean(\"parrot\");dog.move();parrot.move();}log:Dogcanrun!Parrotcanfly!```####小结#####调用实例工厂方法和调用静态工厂方法创建Bean的异同区别如下：-配置实例工厂方法创建Bean,必须将实例工厂配置成Bean实例；而配置静态工厂方法创建Bean,则无需配置工厂Bean;-配置实例工厂方法创建Bean,必须使用`factory-bvean`属性确定工厂Bean;而配置静态工厂方法创建Bean,则使用`class`属性确定静态工厂类。相同之处如下：-都需要使用`factory-method`指定生产Bean实例的工厂方法；-工厂方法如果需要参数，都使用`<constructor-arg.../>`元素指定参数值；-普通的设值注入，都使用`<property.../>`元素确定参数值。###Bean的作用域<imgsrc=\"https://images.gitee.com/uploads/images/2020/0802/144827_2c930c4b_6545143.png\"style=\"zoom:50%;\"/>###Bean的生命周期-第一步:MAN被实例化了...,instantiatebean对象实例化-第二步:设置属性...,populateproperties封装属性-第三步,设置Bean的名称man,如果Bean实现了BeanNameAware执行setBeanName-第四步,了解工厂的信息,如果Bean实现BeanFactoryAware或者ApplicationContextAware设置工厂-第五步,初始化前方法,如果存在BeanPostProcessor(后处理Bean),执行postProcessBeforeInitialization-第六步,属性设置后,如果Bean实现了InitializingBean执行afterPropertiesSet-第七步:MAN被初始化了....,调用`<beaninit-mothod=\"init\">`-第八步,初始化后的方法,如果存在类实现BeanPostProcessor(处理Bean),执行postProcessAfterInitialization-第九步:执行业务方法,执行业务处理-第十步:执行Spring的销毁方法,如果Bean实现DisposableBean执行destory-第十一步:MAN被销毁了....,掉用`<beandestroy-method=\"customerDestroy\">`执行销毁方法customerDestroy>最重要的是第五步和第八步:可以增强类的方法>Spring>>```xml><beanid=\"man\"class=\"com.ioc.demo3.Man\"init-method=\"setup\"destroy-method=\"manDestory\">>```>>-初始化bean会触发init-method=\"functionName\">-bean销毁时触发destory-method=\"destoryFunctionName\"补充:前面工厂内使用的classIpet.java```javapublicinterfaceIpet{publicvoidmove();}```Dog.java```javapublicclassDogimplementsIpet{@Overridepublicvoidmove(){System.out.println(\"Dogcanrun!\");}}```Parrot.java```javapublicclassParrotimplementsIpet{@Overridepublicvoidmove(){System.out.println(\"Parrotcanfly!\");}}```##SpringAOP>-Spring框架的一个关键组件是**面向切面的编程**(AOP[AspectOrientedProgramming])框架,可以说是OOP（ObjectOrientedProgramming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。>-不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（crosscutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。>-AOP技术恰恰相反，它利用一种称为\"横切\"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为\"Aspect\"，即切面。所谓\"切面\"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。>-面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。>-跨一个应用程序的多个点的功能被称为**横切关注点**，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。>-在OOP中，关键单元模块度是类，而在AOP中单元模块度是方面。依赖注入帮助你对应用程序对象相互解耦和AOP可以帮助你从它们所影响的对象中对横切关注点解耦。AOP是像编程语言的触发物，如Perl，.NET，Java或者其他。>-SpringAOP模块提供拦截器来拦截一个应用程序，例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。>-使用\"横切\"技术，AOP把软件系统分为两个部分：**核心关注点**和**横切关注点**。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。>-AOP分为两种类型:>-静态AOP:在编译期进行加入,就是对切面进行的任何修改,都要进行重新编译程序>-动态AOP:在代码执行过程中进行加入,他的切面代码不是编译进class文件分钟,SpringAOP就是动态AOP###AOP术语|项|描述||-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||横切关注点|对那些方法进行拦截,拦截后如何处理,这些关注点成为横切关注点||Aspect(切面)|类就是对物体特征的抽象，切面就是对横切关注点的抽象，一个模块具有一组提供横切需求的APIs。例如，一个日志模块为了记录日志将被AOP方面调用。应用程序可以拥有任意数量的方面，这取决于需求。||Joinpoint(连接点)|在你的应用程序中它代表一个点，你可以在插件AOP方面。你也能说，它是在实际的应用程序中，其中一个操作将使用SpringAOP框架。||Advice(通知)|这是实际行动之前或之后执行的方法。这是在程序执行期间通过SpringAOP框架实际被调用的代码。||Pointcut(切入点)|对连接点进行拦截的定义，这是一组一个或多个连接点，通知应该被执行。你可以使用表达式或模式指定切入点正如我们将在AOP的例子中看到的。||Introduction()|在不修改代码的前提下，引入可以在运行期，为类动态地添加一些方法或字段，引用允许你添加新方法或属性到现有的类中。||Targetobject(目标对象)|被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。||Weaving(织入)|Weaving把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。|###**Spring对AOP的支持****Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理**。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：1、**默认使用Java动态代理来创建AOP代理**，这样就可以为任何接口实例创建代理了2、**当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理**，也可强制使用CGLIBAOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：1、定义普通业务组件2、定义切入点，一个切入点可能横切多个业务组件3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：**代理对象的方法=增强处理+被代理对象**的方法。下面给出一个SpringAOP的.xml文件模板，名字叫做aop.xml，之后的内容都在aop.xml上进行扩展：```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xmlns:tx=\"http://www.springframework.org/schema/tx\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.2.xsd\"><!--beandefinition&AOPspecificconfiguration--></beans>```####**基于Spring的AOP简单实现**注意一下，在讲解之前，说明一点：使用SpringAOP，要成功运行起代码，只用Spring提供给开发者的jar包是不够的，请额外上网下载两个jar包：1、aopalliance.jar2、aspectjweaver.jar开始讲解用SpringAOP的XML实现方式，先定义一个接口：```javapublicinterfaceHelloWorld{voidprintHelloWorld();voiddoPrint();}```定义两个接口实现类：```javapublicclassHelloWorldImpl1implementsHelloWorld{publicvoidprintHelloWorld(){System.out.println(\"EnterHelloWorldImpl1.printHelloWorld()\");}publicvoiddoPrint(){System.out.println(\"EnterHelloWorldImpl1.doPrint()\");return;}}``````javapublicclassHelloWorldImpl2implementsHelloWorld{publicvoidprintHelloWorld(){System.out.println(\"EnterHelloWorldImpl2.printHelloWorld()\");}publicvoiddoPrint(){System.out.println(\"EnterHelloWorldImpl2.doPrint()\");return;}}```横切关注点，这里是打印时间：```javapublicclassTimeHandler{publicvoidprintTime(){System.out.println(\"CurrentTime=\"+System.currentTimeMillis());}}```有这三个类就可以实现一个简单的SpringAOP了，看一下aop.xml的配置：```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xmlns:tx=\"http://www.springframework.org/schema/tx\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.2.xsd\"><beanid=\"helloWorldImpl1\"class=\"com.xrq.aop.HelloWorldImpl1\"/><beanid=\"helloWorldImpl2\"class=\"com.xrq.aop.HelloWorldImpl2\"/><beanid=\"timeHandler\"class=\"com.xrq.aop.TimeHandler\"/><aop:config><aop:aspectid=\"time\"ref=\"timeHandler\"><aop:pointcutid=\"addAllMethod\"expression=\"execution(*com.xrq.aop.HelloWorld.*(..))\"/><aop:beforemethod=\"printTime\"pointcut-ref=\"addAllMethod\"/><aop:aftermethod=\"printTime\"pointcut-ref=\"addAllMethod\"/></aop:aspect></aop:config></beans>```写一个main函数调用一下：```javapublicstaticvoidmain(String[]args){ApplicationContextctx=newClassPathXmlApplicationContext(\"aop.xml\");HelloWorldhw1=(HelloWorld)ctx.getBean(\"helloWorldImpl1\");HelloWorldhw2=(HelloWorld)ctx.getBean(\"helloWorldImpl2\");hw1.printHelloWorld();System.out.println();hw1.doPrint();System.out.println();hw2.printHelloWorld();System.out.println();hw2.doPrint();}```运行结果为：```shellCurrentTime=1446129611993EnterHelloWorldImpl1.printHelloWorld()CurrentTime=1446129611993CurrentTime=1446129611994EnterHelloWorldImpl1.doPrint()CurrentTime=1446129611994CurrentTime=1446129611994EnterHelloWorldImpl2.printHelloWorld()CurrentTime=1446129611994CurrentTime=1446129611994EnterHelloWorldImpl2.doPrint()CurrentTime=1446129611994```看到给HelloWorld接口的两个实现类的所有方法都加上了代理，代理内容就是打印时间####**\\*\\*基于Spring的AOP使用其他细节\\*\\***1、增加一个横切关注点，打印日志，Java类为：```javapublicclassLogHandler{publicvoidLogBefore(){System.out.println(\"Logbeforemethod\");}publicvoidLogAfter(){System.out.println(\"Logaftermethod\");}}```aop.xml配置为：```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xmlns:tx=\"http://www.springframework.org/schema/tx\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.2.xsd\"><beanid=\"helloWorldImpl1\"class=\"com.xrq.aop.HelloWorldImpl1\"/><beanid=\"helloWorldImpl2\"class=\"com.xrq.aop.HelloWorldImpl2\"/><beanid=\"timeHandler\"class=\"com.xrq.aop.TimeHandler\"/><beanid=\"logHandler\"class=\"com.xrq.aop.LogHandler\"/><aop:config><aop:aspectid=\"time\"ref=\"timeHandler\"order=\"1\"><aop:pointcutid=\"addTime\"expression=\"execution(*com.xrq.aop.HelloWorld.*(..))\"/><aop:beforemethod=\"printTime\"pointcut-ref=\"addTime\"/><aop:aftermethod=\"printTime\"pointcut-ref=\"addTime\"/></aop:aspect><aop:aspectid=\"log\"ref=\"logHandler\"order=\"2\"><aop:pointcutid=\"printLog\"expression=\"execution(*com.xrq.aop.HelloWorld.*(..))\"/><aop:beforemethod=\"LogBefore\"pointcut-ref=\"printLog\"/><aop:aftermethod=\"LogAfter\"pointcut-ref=\"printLog\"/></aop:aspect></aop:config></beans>```测试类不变，打印结果为：```shellCurrentTime=1446130273734LogbeforemethodEnterHelloWorldImpl1.printHelloWorld()LogaftermethodCurrentTime=1446130273735CurrentTime=1446130273736LogbeforemethodEnterHelloWorldImpl1.doPrint()LogaftermethodCurrentTime=1446130273736CurrentTime=1446130273736LogbeforemethodEnterHelloWorldImpl2.printHelloWorld()LogaftermethodCurrentTime=1446130273736CurrentTime=1446130273737LogbeforemethodEnterHelloWorldImpl2.doPrint()LogaftermethodCurrentTime=1446130273737```要想让logHandler在timeHandler前使用有两个办法：（1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序（2）把logHandler定义在timeHandler前面，Spring默认以aspect的定义顺序作为织入顺序2、我只想织入接口中的某些方法修改一下pointcut的expression就好了：```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xmlns:tx=\"http://www.springframework.org/schema/tx\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.2.xsd\"><beanid=\"helloWorldImpl1\"class=\"com.xrq.aop.HelloWorldImpl1\"/><beanid=\"helloWorldImpl2\"class=\"com.xrq.aop.HelloWorldImpl2\"/><beanid=\"timeHandler\"class=\"com.xrq.aop.TimeHandler\"/><beanid=\"logHandler\"class=\"com.xrq.aop.LogHandler\"/><aop:config><aop:aspectid=\"time\"ref=\"timeHandler\"order=\"1\"><aop:pointcutid=\"addTime\"expression=\"execution(*com.xrq.aop.HelloWorld.print*(..))\"/><aop:beforemethod=\"printTime\"pointcut-ref=\"addTime\"/><aop:aftermethod=\"printTime\"pointcut-ref=\"addTime\"/></aop:aspect><aop:aspectid=\"log\"ref=\"logHandler\"order=\"2\"><aop:pointcutid=\"printLog\"expression=\"execution(*com.xrq.aop.HelloWorld.do*(..))\"/><aop:beforemethod=\"LogBefore\"pointcut-ref=\"printLog\"/><aop:aftermethod=\"LogAfter\"pointcut-ref=\"printLog\"/></aop:aspect></aop:config></beans>```表示timeHandler只会织入HelloWorld接口print开头的方法，logHandler只会织入HelloWorld接口do开头的方法测试aop其他几个标签LogHandler.java```javapackagecom.tutorialspoint.beans.SpringAOP.DynamicAOPPackage;importorg.aspectj.lang.ProceedingJoinPoint;publicclassLogHandler{publicvoidLogBefore(){System.out.println(\"Logbeforemethod\");}publicvoidLogAfter(){System.out.println(\"Logaftermethod\");}//环绕通知需要通过ProceedingJoinPoint类型的参数指定增强执行的时机publicvoidround(ProceedingJoinPointjoinPoint)throwsThrowable{System.out.println(\"方法执行前\");//执行增强的方法joinPoint.proceed();System.out.println(\"方法执行后\");}publicvoidreturning(){System.out.println(\"after-returning\");}publicvoidthrowing(){System.out.println(\"after-throwing\");}}``````xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xmlns:tx=\"http://www.springframework.org/schema/tx\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.2.xsd\"><beanid=\"helloWorldImpl1\"class=\"com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.HelloWorldImpl1\"/><beanid=\"helloWorldImpl2\"class=\"com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.HelloWorldImpl2\"/><beanid=\"timeHandler\"class=\"com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.TimeHandler\"/><beanid=\"logHandler\"class=\"com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.LogHandler\"/><aop:config><aop:aspectid=\"time\"ref=\"timeHandler\"order=\"1\"><aop:pointcutid=\"addAllMethod\"expression=\"execution(*com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.Hello.*(..))\"/><aop:beforemethod=\"printTime\"pointcut-ref=\"addAllMethod\"/><aop:aftermethod=\"printTime\"pointcut-ref=\"addAllMethod\"/></aop:aspect><aop:aspectid=\"log\"ref=\"logHandler\"order=\"2\"><aop:pointcutid=\"pringLog\"expression=\"execution(*com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.Hello.*(..))\"/><aop:beforemethod=\"LogBefore\"pointcut-ref=\"pringLog\"/><aop:aftermethod=\"LogAfter\"pointcut-ref=\"pringLog\"/><aop:aroundmethod=\"round\"pointcut-ref=\"pringLog\"/><aop:after-returningmethod=\"returning\"pointcut-ref=\"pringLog\"/><aop:after-throwingmethod=\"throwing\"pointcut-ref=\"pringLog\"/></aop:aspect></aop:config></beans>```执行```shellCurrentTime=1610941059733Logbeforemethod方法执行前EnterHelloWorldImpl1.printHelloWorld()after-returning方法执行后LogaftermethodCurrentTime=1610941059736...```补充:1.`execution`函数:在通知中定义切入点,通过`execution`函数,可以定义切入点的方法切入2.切入点:就是增强切入点的方法3.常用的表达式:1.`excution(<访问类型>?<返回类型><方法名>(<参数>)<异常>)`2.`excution(*com.test.bean.Book.wirteBook(..))`:表示类Book里面的writeBook的方法3.`execution(*com.test.bean.Book.*(..))`:表示Book下的所有方法4.`execution(**.*(..))`:表示所有5.`execution(public*.*(..))`:所有public的方法6.`execution(*com.test.bean.*(..))`:匹配指定路径下所有类的方法(不包含子包)7.`execution(*com.test.bean..*(..))`:匹配指定路径下所有类的方法（包含包，子包的所有类）8.`execution(*com.test.bean.Book.*(..))`:匹配指定类的所有方法9.`execution(*com*(..))`:匹配特定开头的方法4.配置增强类型1.`aop:before`:前置通知,指定增强的方法在切入点之前执行2.`aop:after`:后置通知,指定增强方法在切入点之后执行3.`aop:after-returning`:最终通知,无论增强方法之后异常都会执行4.`aop:after-throwing`:异常抛出通知,指定增强的方法在出现异常时执行5.`aop:around`:环绕通知,增强方法在切入点方法之前和之后都执行3、强制使用CGLIB生成代理前面说过Spring使用动态代理或是CGLIB生成代理是有规则的，高版本的Spring会自动选择是使用动态代理还是CGLIB生成代理内容，当然我们也可以强制使用CGLIB生成代理，那就是<aop:config>里面有一个\"proxy-target-class\"属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用。###注解式开发XML文件```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xmlns:tx=\"http://www.springframework.org/schema/tx\"xmlns:context=\"http://www.springframework.org/schema/context\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.2.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd\">//组件扫描<context:component-scanbase-package=\"com.tutorialspoint.beans.SpringAOP.AOPAnnontation2\"/>//aop自动扫描<aop:aspectj-autoproxy/></beans>```接口```javapublicinterfaceITargetInterface{publicvoidsave();}```实现类```javapackagecom.tutorialspoint.beans.SpringAOP.AOPAnnontation2;importorg.springframework.stereotype.Component;@Component(\"target\")publicclassTargetimplementsITargetInterface{@Overridepublicvoidsave(){System.out.println(\"saverunning...\");}}```创建切面类```javapackagecom.tutorialspoint.beans.SpringAOP.AOPAnnontation2;importorg.aspectj.lang.ProceedingJoinPoint;importorg.aspectj.lang.annotation.*;importorg.springframework.stereotype.Component;@Component(\"myAspect\")@AspectpublicclassMyAspect{//@Before(\"execution(*com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")//publicvoidbefore(){//System.out.println(\"before\");//}////@AfterReturning(\"execution(*com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")//publicvoidafterReturning(){//System.out.println(\"afterReturning\");//}////@Around(\"execution(*com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")//publicObjectaround(ProceedingJoinPointpjp)throwsThrowable{//System.out.println(\"aroundbefore\");//Objectproceed=pjp.proceed();//System.out.println(\"aroundafter\");//returnproceed;//}////@AfterThrowing(\"execution(*com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")//publicvoidafterThrowing(){//System.out.println(\"throwing\");//}////@After(\"execution(*com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")//publicvoidafter(){//System.out.println(\"returning\");//}@Before(\"pointcut()\")publicvoidbefore(){System.out.println(\"before\");}@AfterReturning(\"pointcut()\")publicvoidafterReturning(){System.out.println(\"afterReturning\");}@Around(\"pointcut()\")publicObjectaround(ProceedingJoinPointpjp)throwsThrowable{System.out.println(\"aroundbefore\");Objectproceed=pjp.proceed();System.out.println(\"aroundafter\");returnproceed;}@AfterThrowing(\"pointcut()\")publicvoidafterThrowing(){System.out.println(\"throwing\");}@After(\"pointcut()\")publicvoidafter(){System.out.println(\"returning\");}@Pointcut(\"execution(*com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")publicvoidpointcut(){}}```>@Pointcut注解定义切点表达式,然后可以在增强注解中使用测试类```javapackagecom.tutorialspoint.beans.SpringAOP.AOPAnnontation2;importorg.junit.Test;importorg.junit.runner.RunWith;importorg.springframework.beans.factory.annotation.Autowired;importorg.springframework.test.context.ContextConfiguration;importorg.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:aop-anno.xml\")publicclassAnnoTest{@AutowiredprivateITargetInterfaceiTargetInterface;@Testpublicvoidtest1(){iTargetInterface.save();}}```##Spring基于注解的配置###@Required>注释应用于bean属性的setter方法，它表明受影响的bean属性在配置时必须放在XML配置文件中，否则容器就会抛出一个BeanInitializationException异常###@Autowired>自动装配@Autowired注释应用于构造函数```javapublicclassMovieRecommender{privatefinalCustomerPreferenceDaocustomerPreferenceDao;@AutowiredpublicMovieRecommender(CustomerPreferenceDaocustomerPreferenceDao){this.customerPreferenceDao=customerPreferenceDao;}//...}```@Autowired注释应用于setter方法```javapublicclassSimpleMovieLister{privateMovieFindermovieFinder;@AutowiredpublicvoidsetMovieFinder(MovieFindermovieFinder){this.movieFinder=movieFinder;}//...}```将@Autowired注释应用于具有任意名称和多个参数的方法```javapublicclassMovieRecommender{privateMovieCatalogmovieCatalog;privateCustomerPreferenceDaocustomerPreferenceDao;@Autowiredpublicvoidprepare(MovieCatalogmovieCatalog,CustomerPreferenceDaocustomerPreferenceDao){this.movieCatalog=movieCatalog;this.customerPreferenceDao=customerPreferenceDao;}//...}```@Autowired注释应用于字段，或者将其与构造函数混合，如以下示例所示```javapublicclassMovieRecommender{privatefinalCustomerPreferenceDaocustomerPreferenceDao;@AutowiredprivateMovieCatalogmovieCatalog;@AutowiredpublicMovieRecommender(CustomerPreferenceDaocustomerPreferenceDao){this.customerPreferenceDao=customerPreferenceDao;}//...}```直接应用于字段是我们使用的最多的一种方式，但是使用构造方法注入从代码层面却是更加好的。除此之外，还有以下不太常见的几种方式将@Autowired注释添加到需要该类型数组的字段或方法，则Spring会从ApplicationContext中搜寻符合指定类型的所有bean，如以下示例所示：```javapublicclassMovieRecommender{@AutowiredprivateMovieCatalog[]movieCatalogs;//...}```数组可以，我们可以马上举一反三，那容器也可以吗，答案是肯定的，下面是set以及map的例子：```javapublicclassMovieRecommender{privateSet<MovieCatalog>movieCatalogs;@AutowiredpublicvoidsetMovieCatalogs(Set<MovieCatalog>movieCatalogs){this.movieCatalogs=movieCatalogs;}//...}publicclassMovieRecommender{privateMap<String,MovieCatalog>movieCatalogs;@AutowiredpublicvoidsetMovieCatalogs(Map<String,MovieCatalog>movieCatalogs){this.movieCatalogs=movieCatalogs;}//...}```以上就是@Autowired注释的主要使用方式，经常使用Spring的话应该对其中常用的几种不会感到陌生。###**@Qualifier**>可能会有这样一种情况，当你创建多个具有相同类型的bean时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用**@Qualifier**注释和**@Autowired**注释通过指定哪一个真正的bean将会被装配来消除混乱```javapublicclassProfile{@Autowired@Qualifier(\"student1\")//对应xml中beanid为student1privateStudentstudent;publicProfile(){System.out.println(\"InsideProfileconstructor\");}publicvoidprintAge(){System.out.println(\"Age:\"+student.getAge());}publicvoidprintName(){System.out.println(\"Name:\"+student.getname());}}``````java<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:context=\"http://www.springframework.org/schema/context\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd\"><context:annotation-config></context:annotation-config><beanid=\"student\"class=\"com.tutorialspoint.beans.Annontation.Student\"><propertyname=\"name\"value=\"grh\"/><propertyname=\"age\"value=\"11\"/></bean><beanid=\"student1\"class=\"com.tutorialspoint.beans.Annontation.Student\"><propertyname=\"name\"value=\"grh2\"/><propertyname=\"age\"value=\"22\"/></bean><beanid=\"profile\"class=\"com.tutorialspoint.beans.Annontation.Profile\"></bean></beans>``````shellInsideProfileconstructorName:grh2Age:22```###@PostConstruct和@PreDestroy>这两个分别对应``init-method`和`destroy-method`>>即bean的安装和卸载###@Resource>使用一个'name'属性,該属性以一个bean名称的形式被注入,遵循by-name中自动连接语句```javapackagecom.tutorialspoint;importjavax.annotation.Resource;publicclassTextEditor{privateSpellCheckerspellChecker;@Resource(name=\"spellChecker\")publicvoidsetSpellChecker(SpellCheckerspellChecker){this.spellChecker=spellChecker;}publicSpellCheckergetSpellChecker(){returnspellChecker;}publicvoidspellCheck(){spellChecker.checkSpelling();}}```###@Configuration和@Bean注解>**@Configuration**的注解类表示这个类可以使用SpringIoC容器作为bean定义的来源。>>**@Bean**注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。```javapublicclassHelloWorld{privateStringmessage;publicvoidsetMessage(Stringmessage){this.message=message;}publicvoidgetMessage(){System.out.println(\"Yourmessage:\"+message);}}``````javapackagecom.tutorialspoint.beans.Annontation;importorg.springframework.context.annotation.Bean;importorg.springframework.context.annotation.Configuration;@ConfigurationpublicclassHelloWorldConfig{@BeanpublicHelloWorldhelloWorld(){returnnewHelloWorld();}}``````xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:context=\"http://www.springframework.org/schema/context\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd\"><context:annotation-config></context:annotation-config><context:component-scanbase-package=\"com.tutorialspoint.beans.Annontation\"/></beans>```Test```javaApplicationContextcontext=newClassPathXmlApplicationContext(\"Annontation.xml\");HelloWorldhelloWorld=context.getBean(HelloWorld.class);helloWorld.setMessage(\"HelloWorld!\");helloWorld.getMessage();```###@import>允许从另一个配置类中加载@Bean定义```java@ConfigurationpublicclassConfigA{@BeanpublicAa(){returnnewA();}}```你可以在另一个Bean声明中导入上述Bean声明，如下所示：```java@Configuration@Import(ConfigA.class)publicclassConfigB{@BeanpublicBb(){returnnewB();}}```现在，当实例化上下文时，不需要同时指定ConfigA.class和ConfigB.class，只有ConfigB类需要提供，如下所示：```javapublicstaticvoidmain(String[]args){ApplicationContextctx=newAnnotationConfigApplicationContext(ConfigB.class);//nowbothbeansAandBwillbeavailable...Aa=ctx.getBean(A.class);Bb=ctx.getBean(B.class);}```>注意这里的`ApplicationContextctx=newAnnotationConfigApplicationContext(ConfigB.class);`###生命周期回调@Bean(initMethod=\"\",destroyMethod=\"\")>@Bean注解支持指定任意的初始化和销毁的回调方法，就像在bean元素中Spring的XML的初始化方法和销毁方法的属性：```javapublicclassFoo{publicvoidinit(){//initializationlogic}publicvoidcleanup(){//destructionlogic}}@ConfigurationpublicclassAppConfig{@Bean(initMethod=\"init\",destroyMethod=\"cleanup\")publicFoofoo(){returnnewFoo();}}```指定Bean的范围：默认范围是单实例，但是你可以重写带有@Scope注解的该方法，如下所示：```java@ConfigurationpublicclassAppConfig{@Bean@Scope(\"prototype\")publicFoofoo(){returnnewFoo();}}```###@Primary>对于同一个接口,可能有几种不同的实现类,而默认只会采取其中一种情况下@Primary的作用就出来了>>自动装配时当出现多个Bean候选者时,被注解为@Primary将作为首选者,否则将会抛出异常##事件处理>-Spring核心是ApplicationContext,负责调用beans的生命周期>-Spring的时间处理是单线程的,所有如果一个时间被发布,直至并且除非所有的接收者得到的该消息,该进程被阻塞并且流程将不会继续|事件名|Spring内置事件&描述||-------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||**ContextRefreshedEvent**|ApplicationContext被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext接口中使用refresh()方法来发生。||**ContextStartedEvent**|当使用ConfigurableApplicationContext接口中的start()方法启动ApplicationContext时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。||**ContextStoppedEvent**|当使用ConfigurableApplicationContext接口中的stop()方法停止ApplicationContext时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。||**ContextClosedEvent**|当使用ConfigurableApplicationContext接口中的close()方法关闭ApplicationContext时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。||**RequestHandledEvent**|这是一个web-specific事件，告诉所有beanHTTP请求已经被服务。|####监听上下文事件```javapackagecom.tutorialspoint;publicclassHelloWorld{privateStringmessage;publicvoidsetMessage(Stringmessage){this.message=message;}publicvoidgetMessage(){System.out.println(\"YourMessage:\"+message);}}```下面是**CStartEventHandler.java**文件的内容：```javapackagecom.tutorialspoint;importorg.springframework.context.ApplicationListener;importorg.springframework.context.event.ContextStartedEvent;publicclassCStartEventHandlerimplementsApplicationListener<ContextStartedEvent>{publicvoidonApplicationEvent(ContextStartedEventevent){System.out.println(\"ContextStartedEventReceived\");}}```下面是**CStopEventHandler.java**文件的内容：```javapackagecom.tutorialspoint;importorg.springframework.context.ApplicationListener;importorg.springframework.context.event.ContextStoppedEvent;publicclassCStopEventHandlerimplementsApplicationListener<ContextStoppedEvent>{publicvoidonApplicationEvent(ContextStoppedEventevent){System.out.println(\"ContextStoppedEventReceived\");}}```下面是**MainApp.java**文件的内容：```javapackagecom.tutorialspoint;importorg.springframework.context.ConfigurableApplicationContext;importorg.springframework.context.support.ClassPathXmlApplicationContext;publicclassMainApp{publicstaticvoidmain(String[]args){ConfigurableApplicationContextcontext=newClassPathXmlApplicationContext(\"Beans.xml\");//Letusraiseastartevent.context.start();HelloWorldobj=(HelloWorld)context.getBean(\"helloWorld\");obj.getMessage();//Letusraiseastopevent.context.stop();}}```下面是配置文件**Beans.xml**文件：```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"><beanid=\"helloWorld\"class=\"com.tutorialspoint.HelloWorld\"><propertyname=\"message\"value=\"HelloWorld!\"/></bean><beanid=\"cStartEventHandler\"class=\"com.tutorialspoint.CStartEventHandler\"/><beanid=\"cStopEventHandler\"class=\"com.tutorialspoint.CStopEventHandler\"/></beans>```一旦你完成了创建源和bean的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下消息：```shellContextStartedEventReceivedYourMessage:HelloWorld!ContextStoppedEventReceived```##自定义事件>编写和发布自定义事件**CustomEvent.java**```javapackagecom.tutorialspoint;importorg.springframework.context.ApplicationEvent;publicclassCustomEventextendsApplicationEvent{publicCustomEvent(Objectsource){super(source);}publicStringtoString(){return\"MyCustomEvent\";}}```下面是**CustomEventPublisher.java**文件的内容：```javapackagecom.tutorialspoint;importorg.springframework.context.ApplicationEventPublisher;importorg.springframework.context.ApplicationEventPublisherAware;publicclassCustomEventPublisherimplementsApplicationEventPublisherAware{privateApplicationEventPublisherpublisher;publicvoidsetApplicationEventPublisher(ApplicationEventPublisherpublisher){this.publisher=publisher;}publicvoidpublish(){CustomEventce=newCustomEvent(this);publisher.publishEvent(ce);}}```下面是**CustomEventHandler.java**文件的内容：```javapackagecom.tutorialspoint;importorg.springframework.context.ApplicationListener;publicclassCustomEventHandlerimplementsApplicationListener<CustomEvent>{publicvoidonApplicationEvent(CustomEventevent){System.out.println(event.toString());}}```下面是**MainApp.java**文件的内容：```javapackagecom.tutorialspoint;importorg.springframework.context.ConfigurableApplicationContext;importorg.springframework.context.support.ClassPathXmlApplicationContext;publicclassMainApp{publicstaticvoidmain(String[]args){ConfigurableApplicationContextcontext=newClassPathXmlApplicationContext(\"Beans.xml\");CustomEventPublishercvp=(CustomEventPublisher)context.getBean(\"customEventPublisher\");cvp.publish();cvp.publish();}}```下面是配置文件**Beans.xml**：```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><beansxmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"><beanid=\"customEventHandler\"class=\"com.tutorialspoint.CustomEventHandler\"/><beanid=\"customEventPublisher\"class=\"com.tutorialspoint.CustomEventPublisher\"/></beans>```一旦你完成了创建源和bean的配置文件后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：```shellMyCustomEventMyCustomEvent```","Back-End\\Spring\\ssm\\SpringMVC.md":"#SpringMVC>-[Spring官网](https://spring.io/)>-[SpringMVC](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html)>-Spring体系的轻量级webmvc框架>-核心Controller控制器,用于处理请求,产生响应>-基于SpringIOC容器运行,所有对象被IOC管理>-MVC>-M:模型封装应用数据,通常他们由pojo组成>-V:呈现数据模型,并且通常由它生成客户端的浏览器可以解释的HTML输出>-C:控制器主要用于处理用户请求,并且构建合适的模型并将其传递到视图呈现版本变化>Spring5.x最低要求JDK8余J2EE7(Servlet3.1/Tomcat8.5+)>>支持响应式编程##DispatchServlet>-SpringWeb的mvc模型是围绕dispatcherServlet设计的,dispatcherServlet用来处理所有http请求和响应>-SpringMVCDispatcherServlet请求的工作流程>-收到一个http请求后,dispatcherServlet根据HanderMapping来选择适当的控制器>-控制器接收请求,并基于使用的get或post方法来调用service方法,service方法将设置基于业务逻辑的模型数据,并返回视图名称到dispatcherServlet中>-dispatcherServlet会用viewResolver获取帮助,为请求检取定义视图>-一旦确定思路,dispatcherServlet将把模型数据传输给视图,最后呈现在浏览器中##入门###环境搭建####Maven依赖spring-webmvc```xml<?xmlversion=\"1.0\"encoding=\"UTF-8\"?><projectxmlns=\"http://maven.apache.org/POM/4.0.0\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd\"><modelVersion>4.0.0</modelVersion><groupId>org.example</groupId><artifactId>SpringMVC_DEMO1</artifactId><version>1.0-SNAPSHOT</version><!--添加阿里云的镜像路径,方便下载依赖--><repositories><repository><id>aliyun</id><name>aliyun</name><url>https://maven.aliyun.com/repository/public</url></repository></repositories><dependencies><dependency><groupId>org.springframework</groupId><artifactId>spring-webmvc</artifactId><version>5.1.9.RELEASE</version></dependency></dependencies></project>```####web.xml配置DispatcherServlet####配置applicationContext的mvc标记####开发Controller控制器##数据绑定##Restful开发风格##拦截器","Back-End\\Spring\\ssm\\ssm.md":"#SSM##ssmcontroller绑定参数根据url读取参数>->-通过URL路径传递参数并接收```java@RequestMapping(value=\"/path/{key}/{value}\",method=RequestMethod.POST)@ResponseBodypublicStringrequestPath(@PathVariableStringkey,@PathVariableStringvalue){return\"Getrequestissuccessful.Pathparam:key-\"+key+\";value-\"+value;}```","CSS\\at-rules\\charset.md":"#@charset>指定样式表使用的字符集>>样式表中第一行,前面不可有任何字符```css@charset\"UTF-8\";@charset\"utf-8\";/*大小写不敏感*//*设置css的编码格式为UnicodeUTF-8*/@charset'iso-8859-15';/*无效的,使用了错误的引号*/@charset'UTF-8';/*无效的,使用了错误的引号*/@charset\"UTF-8\";/*无效的,多于一个空格*/@charset\"UTF-8\";/*无效的,在at-rule之前多了一个空格*/@charsetUTF-8;/*Invalid,without'or\",thecharsetisnotaCSS<string>*/```","CSS\\at-rules\\color-profile.md":"#@color-profile>定义并命名了一个颜色配置文件，以后可以在`color()`函数中使用该颜色配置文件来指定颜色。##src指定从中检索颜色配置文件信息的URL。##`redering-intent`渲染意图>如果颜色配置文件包含多个渲染意图，则此描述符允许选择一个作为用于定义如何将颜色映射到比此配置文件定义的色域更小的色域的描述符。>>如果使用，它必须是以下关键字之一：>>-相对比色法(**relative-colorimetric**)>>介质相对比色法需要保持目标介质色域内的源颜色相对于相应介质白点不变。目标介质色域之外的源颜色将使用各种不同的方法映射到色域边界上的颜色。>>-绝对比色法(**absolute-colorimetric**)>>ICC绝对比色法要求保持目标介质色域内的源颜色相对于采用的白色（完美反射散流器）保持不变。目标介质色域之外的源颜色将使用各种不同的方法映射到色域边界上的颜色。>>-感性的(**perceptual**)>>此方法通常是图像的首选方法，尤其是当源和目标之间存在实质性差异时（例如在反射打印上再现的屏幕显示图像）。它采用源图像的颜色，并使用专有方法重新优化目标介质的外观。>>-饱和(**saturation**)>>创建此选项是为了保持原稿的相对饱和度（色度），并保持纯色。然而，它遇到了互操作性问题，比如感知意图。```css@color-profile--swop5c{src:url('https://example.org/SWOP2006_Coated5v2.icc');}.header{background-color:color(--swop5c0%70%20%0%);}```","CSS\\at-rules\\counter-style.md":"#@counter-style>`@counter-style`是一个[CSS](https://developer.mozilla.org/en-US/CSS)[at-rule](https://developer.mozilla.org/en-US/CSS/At-rule)，它让开发者可以自定义counter的样式。一个`@counter-style规则`定义了如何把一个计数器的值转化为字符串表示。##语法```css@counter-style<counter-style-name>{system:<countersystem>symbols:<countersymbols>additive-symbols:<additive-symbols>negative:<negativesymbol>prefix:<prefix>suffix:<suffix>range:<range>pad:<padding>speak-as:<speak-as>fallback:<counter-style-name>}```##描述>每个`@counter-style`由一个名称标识并具有一组描述符>>-[system(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/system)>>指定一个算法，用于将计数器的整数值转化为字符串表示。>>-[negative(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/negative)>>指定一个符号，当计数器表示的值为负的时候，把这个符号加在值的前面或后面>>-[prefix(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/prefix)>>指定一个符号，加在标记表示符的前面。前缀在最后阶段才会被加上，所以在计数器的最终表示中，它在[negative(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/negative)前。>>-[suffix(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/suffix)>>与[prefix(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/prefix)类似，suffix指定一个符号，加在标记表示符的后面。>>-[range(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/range)>>指定一个counter-style生效的范围，如果计数器的值不再这个范围内，那么自定义的counter-style不会生效，counter-style会后退到[fallback(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/fallback)的style。>>-[pad(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/pad)>>在你想要给标记表示符最小值时使用。比如说，你想要计数器从01开始，经过02，03，04，那么这时可以使用pad了。对于大于pad指定值的表示符，标记会恢复为normal。>>-[fallback(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/fallback)>>定义一个备用的系统，当自定义的系统不能使用或者计数器的值超过了定义的范围时使用。如果备用系统也不能表示计数器的值，那么备用系统的备用系统（如果有的话）将会启用。如果没有指定备用系统，或者备用系统链不能够正确表示一个值，那么最终会降为十进制样式表示。>>-[symbols(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/symbols)>>定义一个符号，用于标记的表示。符号可以包含字符串，图片或自定义的识别码。这个符号怎样构建标记呢？这依赖于system描述符里面所定义的算法。举个例子，如果system的值是fixed,那么symbols属性指定的固定的N个符号，将被用来表示计数器的前N个值。用完了前N个符号后，列表里剩下的值将使用fallback定义的样式来表示。下面的@counter-style规则使用图片而不是字符标记。>>```css>@counter-stylewinners-list{>system:fixed;>symbols:url(gold-medal.svg)url(silver-medal.svg)url(bronze-medal.svg);>suffix:'';>}>```>>-[additive-symbols(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/additive-symbols)>>尽管symbols属性中指定的符号可以被system中定义的大部分算法所使用，但是一些system属性的值，比如additive，依赖于本描述符所描述的加性元组。Eachadditivetupleconsistsofacountersymbolandanonnegativeintegerweight.每个加性元组包含一个可数的符号和一个非负证书的权重。Theadditivetuplesmustbespecifiedinthedescendingorderoftheirweights.>>-[speak-as(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/speak-as)>>定义如何在语音识别器中读出计数器样式，比如屏幕阅读器。例如基于该描述符的值，标记符号的值可以作为有序列表的数字或者字幕作为无序列表的音频提示读出。```css@counter-stylecircled-alpha{system:fixed;symbols:ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ;suffix:'';}.items{list-style:circled-alpha;}``````ⒶOneⒷTwoⒸThreeⒹFourⒺFIve.......ⓎTwentyFiveⓏTwentySix27TwentySeven28TwentyEight29TwentyNine30Thirty```","CSS\\at-rules\\font-face.md":"#@font-face>指定一个用于显示文本的自定义字体；字体能从远程服务器或者用户本地安装的字体加载.如果提供了local()函数，从用户本地查找指定的字体名称，并且找到了一个匹配项,本地字体就会被使用.否则,字体就会使用url()函数下载的资源。>>通过允许作者提供他们自己的字体，@font-face让设计内容成为了一种可能，同时并不会被所谓的\"网络-安全\"字体所限制(字体如此普遍以至于它们能被广泛的使用).指定查找和使用本地安装的字体名称可以让字体的自定义化程度超过基本字体，同时在不依赖网络情况下实现此功能。>>在同时使用url()和local()功能时，为了用户已经安装的字体副本在需要使用时被使用，如果在用户本地没有找到字体副本就会去使用户下载的副本查找字体。>>@font-face规则不仅仅使用在CSS的顶层，还可以用在任何CSS条件组规则中.```css@font-face{font-family:'OpenSans';src:url('/fonts/OpenSans-Regular-webfont.woff2')format('woff2'),url('/fonts/OpenSans-Regular-webfont.woff')format('woff');}```CopytoClipboard##[概述](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#概述)这是一个叫做`@font-face`的[CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS)[@规则](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule)，它允许网页开发者为其网页指定在线字体。通过这种作者自备字体的方式，`@font-face`可以消除对用户电脑字体的依赖。`@font-face`不仅可以放在在CSS的最顶层,也可以放在@规则的[条件规则组](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule#conditional_group_rules)中。##[语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#语法)```css@font-face{[font-family:<family-name>;]||[src:<src>;]||[unicode-range:<unicode-range>;]||[font-variant:<font-variant>;]||[font-feature-settings:<font-feature-settings>;]||[font-variation-settings:<font-variation-settings>;]||[font-stretch:<font-stretch>;]||[font-weight:<font-weight>;]||[font-style:<font-style>;]||[size-adjust:<size-adjust>;]||[ascent-override:<ascent-override>;]||[descent-override:<descent-override>;]||[line-gap-override:<line-gap-override>;]}where<family-name>=<string>|<custom-ident>+```###[取值](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#取值)-[font-family](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-family)所指定的字体名字将会被用于font或font-family属性(i.e.font-family:<family-name>;)-[src](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/src)远程字体文件位置的URL或者用户计算机上的字体名称，可以使用local语法通过名称指定用户的本地计算机上的字体(i.e.src:local('Arial');)。如果找不到该字体，将会尝试其他来源，直到找到它。-[font-variant(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-variant)A[font-variant](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant)value.-[font-stretch(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-stretch)A[font-stretch](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch)value.-[font-weight(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-weight)A[font-weight](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight)value.-[font-style](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-style)对于src所指字体的描述。如果所需字体符合描述，则采用本font-face所定义的字体。-[unicode-range(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range)在该@font-face中定义的unicode字体范围##[示例](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#示例)下面的例子简单定义了一个可下载的字体，并应用到了文档的整个body标签上。[Viewlivesample](https://developer.mozilla.org/@api/deki/files/2935/=webfont-sample.html)```html<html><head><title>WebFontSample</title><styletype=\"text/css\"media=\"screen,print\">@font-face{font-family:'BitstreamVeraSerifBold';src:url('https://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf');}body{font-family:'BitstreamVeraSerifBold',serif;}</style></head><body>ThisisBitstreamVeraSerifBold.</body></html>```在接下来的例子中，用到了用户本地字体\"HelveticaNeueBold\"的备份；如果当前用户(浏览器)未安装该字体(两种可能的字体名都已经试过)，就会用下载的字体\"MgOpenModernaBold.ttf\"来代替：```css@font-face{font-family:MyHelvetica;src:local('HelveticaNeueBold'),local('HelveticaNeue-Bold'),url(MgOpenModernaBold.ttf);font-weight:bold;}```CopytoClipboard接下来的例子在英文原文中已被删除。这个例子新定义了一个字体，正常粗细的字采用字体TimesNewRoman，粗体字采用Consolas。```css@font-face{font-family:myFirstFont;src:local('TimesNewRoman');font-weight:normal;}@font-face{font-family:myFirstFont;src:local(Consolas);font-weight:bold;}```CopytoClipboard##[注意](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#注意)-这里使用的Webfonts仍然受到同域限制(字体文件必须和调用它的网页同一域),但可以使用[HTTPaccesscontrols](https://developer.mozilla.org/en-US/docs/HTTP_access_control)解除这一限制。-因为这里没有为TrueType(ttf),OpenType(otf)和WebOpenFileFormat(WOFF)字体定义MIME，因此不能为这些字体类型设置特定的MIME（实际上WOFF的MIME将会是application/font-woff，但浏览器对此MIME的识别还不统一，其它字体情况也类似，可暂时使用application/octet-stream）。-你不能在一个CSS选择器中定义@font-face。例如，这样写是无效的：```css.className{@font-face{font-family:MyHelvetica;src:local('HelveticaNeueBold'),local('HelveticaNeue-Bold'),url(MgOpenModernaBold.ttf);font-weight:bold;}}```","CSS\\at-rules\\import.md":"#@import##[概述](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import#概述)**`@import`**[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS)[@规则](https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule)，用于从其他样式表导入样式规则。这些规则必须先于所有其他类型的规则，[@charset](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset)规则除外;因为它不是一个[嵌套语句](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Syntax#nested_statements)，@import不能在[条件组的规则](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule#conditional_group_rules)中使用。因此，用户代理可以避免为不支持的媒体类型检索资源，作者可以指定依赖媒体的@import规则。这些条件导入在URI之后指定逗号分隔的[媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)。在没有任何媒体查询的情况下，导入是无条件的。指定所有的媒体具有相同的效果。##[语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import#语法)```css@importurl;@importurllist-of-media-queries;```其中:-_url_是一个表示要引入资源位置的[](https://developer.mozilla.org/zh-CN/docs/Web/CSS/string)或者[(en-US)](<https://developer.mozilla.org/en-US/docs/Web/CSS/url()>)。这个URL可以是绝对路径或者相对路径。要注意的是这个URL不需要指明一个文件；可以只指明包名，然后合适的文件会被自动选择(e.g.**chrome://communicator/skin/**).[Seehere](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Tutorial/The_Chrome_URL)了解更多。-_list-of-media-queries_是一个逗号分隔的[媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)条件列表，决定通过URL引入的CSS规则在什么条件下应用。如果浏览器不支持列表中的任何一条媒体查询条件，就不会引入URL指明的CSS文件。##[正规语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import#正规语法)```css@import[<string>|<url>][layer|layer(<layer-name>)]?[supports([<supports-condition>|<declaration>])]?<media-query-list>?;where<supports-condition>=not<supports-in-parens>|<supports-in-parens>[and<supports-in-parens>]*|<supports-in-parens>[or<supports-in-parens>]*<media-query-list>=<media-query>#where<supports-in-parens>=(<supports-condition>)|<supports-feature>|<general-enclosed><media-query>=<media-condition>|[not|only]?<media-type>[and<media-condition-without-or>]?where<supports-feature>=<supports-decl>|<supports-selector-fn><general-enclosed>=[<function-token><any-value>)]|(<ident>(en-US)<any-value>)<media-condition>=<media-not>|<media-and>|<media-or>|<media-in-parens><media-type>=<ident>(en-US)<media-condition-without-or>=<media-not>|<media-and>|<media-in-parens>where<supports-decl>=(<declaration>)<supports-selector-fn>=selector(<complex-selector>)<media-not>=not<media-in-parens><media-and>=<media-in-parens>[and<media-in-parens>]+<media-or>=<media-in-parens>[or<media-in-parens>]+<media-in-parens>=(<media-condition>)|<media-feature>|<general-enclosed>where<complex-selector>=<compound-selector>[<combinator>?<compound-selector>]*<media-feature>=([<mf-plain>|<mf-boolean>|<mf-range>])where<compound-selector>=[<type-selector>?<subclass-selector>*[<pseudo-element-selector><pseudo-class-selector>*]*]!<combinator>='>'|'+'|'~'|['||']<mf-plain>=<mf-name>:<mf-value><mf-boolean>=<mf-name><mf-range>=<mf-name>['<'|'>']?'='?<mf-value>|<mf-value>['<'|'>']?'='?<mf-name>|<mf-value>'<''='?<mf-name>'<''='?<mf-value>|<mf-value>'>''='?<mf-name>'>''='?<mf-value>where<type-selector>=<wq-name>|<ns-prefix>?'*'<subclass-selector>=<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector><pseudo-element-selector>=':'<pseudo-class-selector><pseudo-class-selector>=':'<ident-token>|':'<function-token><any-value>')'<mf-name>=<ident>(en-US)<mf-value>=<number>|<dimension>|<ident>(en-US)|<ratio>where<wq-name>=<ns-prefix>?<ident-token><ns-prefix>=[<ident-token>|'*']?|<id-selector>=<hash-token><class-selector>='.'<ident-token><attribute-selector>='['<wq-name>']'|'['<wq-name><attr-matcher>[<string-token>|<ident-token>]<attr-modifier>?']'where<attr-matcher>=['~'|||'^'|'$'|'*']?'='<attr-modifier>=i|s```##[示例](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import#示例)```css@importurl('fineprint.css')print;@importurl('bluish.css')projection,tv;@import'custom.css';@importurl('chrome://communicator/skin/');@import'common.css'screen,projection;@importurl('landscape.css')screenand(orientation:landscape);```","CSS\\at-rules\\keyframes.md":"#@keyframes关键帧**`@keyframes`**[at-rule](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule)规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。和[转换transition](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transitions)相比，关键帧keyframes可以控制动画序列的中间步骤。```css@keyframesslidein{from{transform:translateX(0%);}to{transform:translateX(100%);}}```CopytoClipboardJavaScript可以通过CSS对象模型的[CSSKeyframesRule(en-US)](https://developer.mozilla.org/en-US/docs/Web/API/CSSKeyframesRule)接口来访问`@keyframes`。要使用关键帧,先创建一个带名称的`@keyframes`规则，以便后续使用[animation-name](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name)属性将动画同其关键帧声明匹配。每个`@keyframes`规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。可以按任意顺序列出关键帧百分比；它们将按照其应该发生的顺序来处理。###[让关键帧序列生效](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#让关键帧序列生效)如果一个关键帧规则没有指定动画的开始或结束状态（也就是，`0%`/`from`和`100%`/`to`，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。###[重复定义](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#重复定义)如果多个关键帧使用同一个名称，以最后一次定义的为准。`@keyframes`不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。如果一个@keyframes内的关键帧的百分比存在重复的情况，则@keyframes规则中该百分比的所有关键帧都将用于该帧。如果多个关键帧指定了相同的百分比值，则@keyframes规则内是可以使用层叠样式的。###[属性个数不定](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#属性个数不定)如果一个关键帧中没有出现其他关键帧中的属性，那么这个属性将使用插值（不能使用插值的属性除外，这些属性会被忽略掉）。例如：```css@keyframesidentifier{0%{top:0;left:0;}30%{top:50px;}68%,72%{left:50px;}100%{top:100px;left:100%;}}```CopytoClipboard例子中，[top](https://developer.mozilla.org/zh-CN/docs/Web/CSS/top)属性分别出现在关键帧`0%`、`30%`和`100%`的中，而[left](https://developer.mozilla.org/zh-CN/docs/Web/CSS/left)属性分别出现在关键帧`0%`、`68%`、`72%`和`100%`中。###[同一关键帧中的相同属性被重复定义](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#同一关键帧中的相同属性被重复定义)如果某一个关键帧出现了重复的定义，且重复的关键帧中的CSS属性值不同，则以最后一次定义的属性为准。例如：```css@keyframesidentifier{0%{top:0;}50%{top:30px;left:20px;}50%{top:10px;}100%{top:0;}}```CopytoClipboard上面这个例子中，`50%`关键帧中分别最后设置的属性`top:10px`和`left:20px`是有效的，但是其他的属性会被忽略。Firefox14开始支持层叠keyframes。###[关键帧中的!important](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#关键帧中的_!important)关键帧中出现的`!important`将会被忽略。```css@keyframesimportant1{from{margin-top:50px;}50%{margin-top:150px!important;}/*忽略*/to{margin-top:100px;}}@keyframesimportant2{from{margin-top:50px;margin-bottom:100px;}to{margin-top:150px!important;/*忽略*/margin-bottom:50px;}}```CopytoClipboard##[语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#语法)###[取值](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#取值)-[custom-ident](https://developer.mozilla.org/zh-CN/docs/Web/CSS/custom-ident)帧列表的名称。名称必须符合CSS语法中对标识符的定义。-`from`等价于`0%`。-`to`等价于`100%`。-[](https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage)动画序列中触发关键帧的时间点，使用百分值来表示。-形式化语法```css@keyframes<keyframes-name>{<keyframe-block-list>}where<keyframes-name>=<custom-ident>|<string><keyframe-block-list>=<keyframe-block>+where<keyframe-block>=<keyframe-selector>#{<declaration-list>}where<keyframe-selector>=from|to|<percentage>```","CSS\\at-rules\\media.md":"#@media`@media`[CSS](https://developer.mozilla.org/en/CSS)[@规则](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule)可用于基于一个或多个[媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)的结果来应用样式表的一部分。使用它，您可以指定一个媒体查询和一个CSS块，当且仅当该媒体查询与正在使用其内容的设备匹配时，该CSS块才能应用于该文档。**注：**在JavaScript中，可以使用[CSSMediaRule](https://developer.mozilla.org/zh-CN/docs/Web/API/CSSMediaRule)CSS对象模型接口访问使用@media创建的规则。##[语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#语法)`@media`规则可置于您代码的顶层或位于其它任何[@条件规则组](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule#条件规则组)内。```css/*Atthetoplevelofyourcode*/@mediascreenand(min-width:900px){article{padding:1rem3rem;}}/*Nestedwithinanotherconditionalat-rule*/@supports(display:flex){@mediascreenand(min-width:900px){article{display:flex;}}}```###[正式语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#正式语法)```css@media<media-query-list>{<group-rule-body>}where<media-query-list>=<media-query>#where<media-query>=<media-condition>|[not|only]?<media-type>[and<media-condition-without-or>]?where<media-condition>=<media-not>|<media-and>|<media-or>|<media-in-parens><media-type>=<ident>(en-US)<media-condition-without-or>=<media-not>|<media-and>|<media-in-parens>where<media-not>=not<media-in-parens><media-and>=<media-in-parens>[and<media-in-parens>]+<media-or>=<media-in-parens>[or<media-in-parens>]+<media-in-parens>=(<media-condition>)|<media-feature>|<general-enclosed>where<media-feature>=([<mf-plain>|<mf-boolean>|<mf-range>])<general-enclosed>=[<function-token><any-value>)]|(<ident>(en-US)<any-value>)where<mf-plain>=<mf-name>:<mf-value><mf-boolean>=<mf-name><mf-range>=<mf-name>['<'|'>']?'='?<mf-value>|<mf-value>['<'|'>']?'='?<mf-name>|<mf-value>'<''='?<mf-name>'<''='?<mf-value>|<mf-value>'>''='?<mf-name>'>''='?<mf-value>where<mf-name>=<ident>(en-US)<mf-value>=<number>|<dimension>|<ident>(en-US)|<ratio>```##[媒体特性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#媒体特性)_媒体特性_（_Mediafeatures_）描述了[useragent](https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent)、输出设备，或是浏览环境的具体特征。媒体特性表达式是完全可选的，它负责测试这些特性或特征是否存在、值为多少。每条媒体特性表达式都必须用括号括起来。|名称|简介|备注||:----|:----|:----||[any-hover](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/any-hover)|是否有任何可用的输入机制允许用户（将鼠标等）悬停在元素上？|在MediaQueriesLevel4中被添加。||[any-pointer](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/any-pointer)|可用的输入机制中是否有任何指针设备，如果有，它的精度如何？|在MediaQueriesLevel4中被添加。||[aspect-ratio](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/aspect-ratio)|视窗（viewport）的宽高比|||[color(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color)|输出设备每个像素的比特值，常见的有8、16、32位。如果设备不支持输出彩色，则该值为0|||[color-gamut(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color-gamut)|用户代理和输出设备大致程度上支持的色域|在MediaQueriesLevel4中被添加。||[color-index(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color-index)|输出设备的颜色查询表（colorlookuptable）中的条目数量，如果设备不使用颜色查询表，则该值为0|||[device-aspect-ratio(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/device-aspect-ratio)|输出设备的宽高比|已在MediaQueriesLevel4中被弃用。||[device-height](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/device-height)|输出设备渲染表面（如屏幕）的高度|已在MediaQueriesLevel4中被弃用。||[device-width(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/device-width)|输出设备渲染表面（如屏幕）的宽度|已在MediaQueriesLevel4中被弃用。||[display-mode(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/display-mode)|应用程序的显示模式，如webapp的manifest中的[display](https://developer.mozilla.org/zh-CN/docs/Web/Manifest#display)成员所指定|在[WebAppManifestspec](http://w3c.github.io/manifest/#the-display-mode-media-feature)被定义.||[forced-colors(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors)|检测是useragent否限制调色板|在MediaQueriesLevel5中被添加。||[grid(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/grid)|输出设备使用网格屏幕还是点阵屏幕？|||[height(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/height)|视窗（viewport）的高度|||[hover](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/hover)|主要输入模式是否允许用户在元素上悬停|在MediaQueriesLevel4中被添加。||[inverted-colors(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/inverted-colors)|useragent或者底层操作系统是否反转了颜色|在MediaQueriesLevel5中被添加。||`light-level`|环境光亮度|在MediaQueriesLevel5中被添加。||[monochrome(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/monochrome)|输出设备单色帧缓冲区中每个像素的位深度。如果设备并非黑白屏幕，则该值为0|||[orientation](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/orientation)|视窗（viewport）的旋转方向|||[overflow-block(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/overflow-block)|输出设备如何处理沿块轴溢出视窗(viewport)的内容|在MediaQueriesLevel4中被添加。||[overflow-inline(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/overflow-inline)|沿内联轴溢出视窗(viewport)的内容是否可以滚动？|在MediaQueriesLevel4中被添加。||[pointer(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer)|主要输入机制是一个指针设备吗？如果是，它的精度如何？|在MediaQueriesLevel4中被添加。||[prefers-color-scheme](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme)|探测用户倾向于选择亮色还是暗色的配色方案|在MediaQueriesLevel5中被添加。||[prefers-contrast(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast)|探测用户是否有向系统要求提高或降低相近颜色之间的对比度|在MediaQueriesLevel5中被添加。||[prefers-reduced-motion](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-reduced-motion)|用户是否希望页面上出现更少的动态效果|在MediaQueriesLevel5中被添加。||`prefers-reduced-transparency`|用户是否倾向于选择更低的透明度|在MediaQueriesLevel5中被添加。||[resolution(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/resolution)|输出设备的像素密度（分辨率）|||`scan`|输出设备的扫描过程（适用于电视等）|||[scripting(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/scripting)|探测脚本（例如JavaScript）是否可用|在MediaQueriesLevel5中被添加。||[update(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/update-frequency)|输出设备更新内容的渲染结果的频率|在MediaQueriesLevel4中被添加。||[width](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/width)|视窗（viewport）的宽度，包括纵向滚动条的宽度||##[示例](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#示例)```css@mediaprint{body{font-size:10pt;}}@mediascreen{body{font-size:13px;}}@mediascreen,print{body{line-height:1.2;}}@mediaonlyscreenand(min-width:320px)and(max-width:480px)and(resolution:150dpi){body{line-height:1.4;}}```媒体查询第4级引入了一种新的范围语法，在测试接受范围的任何特性时允许更简洁的媒体查询，如下面的示例所示：```css@media(height>600px){body{line-height:1.4;}}@media(400px<=width<=700px){body{line-height:1.4;}}```更多示例，请查看[使用媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries#syntax)。##[可访问性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#可访问性)为了最好地调整网站文本大小，当您需要[](https://developer.mozilla.org/zh-CN/docs/Web/CSS/length)进行[媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)时，请使用`em`。`em`和`px`都是有效单位，但如果用户更改浏览器文本大小，`em`的效果会更好。考虑使用4级媒体查询来改善用户体验。例如，使用`prefers-reduced-motion`以[检测用户是否已请求系统最小化其使用的动画](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion)或动作量。","CSS\\at-rules\\媒体监听.md":"#媒体监听```css@mediamedia-typeand(media-feature-rule){/*CSSrulesgohere*/}```-`media-type`:媒体类型-`media-feature-rule`:媒体表达式-`CSSrules`:css规则,通过媒体查询后生效的css##`media-type`:媒体类型-`screen`:计算机屏幕(默认值,主要使用)-`tty`:电传打字机以及使用等宽字符网格的类似媒介-`tv`:电视类型设备（低分辨率、有限的屏幕翻滚能力）-`projection`:放映机-`handheld`:手持设备（小屏幕、有限的带宽）-`print`:打印预览模式/打印页-`braille`:盲人用点字法反馈设备-`aural`:语音合成器-`all`:适合所有设备##`media-feature-rule`:媒体表达式-媒体属性:`width`|`min-width`|`max-width`|`height`|`min-height`|`max-height`...###颜色（color）>-指定输出设备每个像素单元的比特值。如果设备不支持输出颜色，则该值为0>-向所有能显示颜色的设备应用样式表```css@media(color){}```###颜色索引（color-index）>-颜色索引指定了输出设备中颜色查询表中的条目数量，如果没有使用颜色查询表，则值等于0>-向所有使用至少256个索引颜色的设备应用样式表(下列代码无显示，说明返回值为0)```css@media(min-color-index:256){}```###宽高比（aspect-ratio）>-宽高比描述了输出设备目标显示区域的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例>-向可视区域是正方形或者是宽屏的设备应用样式表```css@media(min-aspect-ratio:1/1){}```###设备宽高比（device-aspect-ratio）>-设备宽高比描述了输出设备的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例>-向宽高比为16:9的特殊宽屏设备应用样式表```css@media(device-aspect-ratio:16/9){}```###设备高度（device-height）>-设备高度描述了输出设备的高度>-向显示在最小高度1000px的屏幕上的文档应用样式表```css@media(min-device-height:1000px){}```###设备宽度（device-width）>-设备宽度描述了输出设备的宽度>-向显示在最小宽度1000px的屏幕上的文档应用样式表```css@media(min-device-width:1000px){}```###网格（grid）>-网格判断输出设备是网格设备还是位图设备。如果设备是基于网格的（例如电传打字机终端或只能显示一种字形的电话），该值为1，否则为0>-向非网格设备应用样式表```css@media(grid:0){}```###高度（height）>高度描述了输出设备渲染区域（如可视区域的高度或打印机纸盒的高度）的高度-`@media(min-height:800px){}`:向高度大于800px的可视区域的设备应用样式表-`@media(max-height:800px){}`:向高度小于800px的可视区域的设备应用样式表###宽度（width）>宽度描述了输出设备渲染区域的宽度-`@media(min-width:800px){}`:向宽度大于800px的可视区域的设备应用样式表-`@media(max-width:800px){}`:向宽度小于800px的可视区域的设备应用样式表###黑白（monochrome）>黑白指定了一个黑白（灰度）设备每个像素的比特数。如果不是黑白设备，值为0>向非黑白设备应用样式表`@media(monochrome:0){}`###方向（orientation）>方向指定了设备处于横屏（宽度大于宽度）模式还是竖屏（高度大于宽度）模式>值：`landscape(横屏)`|`portrait(竖屏)`>向竖屏设备应用样式表`@media(orientation:portrait){}`###分辨率（resolution）>分辨率指定输出设备的分辨率（像素密度）。分辨率可以用每英寸（dpi）或每厘米（dpcm）的点数来表示>向每英寸至少90点的设备应用样式`@media(min-resolution:90dpi){}`###扫描（scan）>扫描描述了电视输出设备的扫描过程>值：`progressive`|`interlace`-媒体查询包含了一个CSS2已有的媒介类型(或称为媒体类型)和CSS3新增的包含一个或多个表达式的媒体属性，这些媒体属性会被解析成真或假-当媒体查询为真时，相关的样式表或样式规则就会按照正常的级联规则被应用。即使媒体查询返回假，<link>标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）-`<linkrel=\"stylesheet\"href=\"style.css\"media=\"print\">`-media并不是'print'，所以媒体查询为假。但是，style.css文件依然被下载##拓展###媒体查询的逻辑运算```css/*and*/@mediascreenand(min-width:400px),screenand(orientation:landscape){}/*not*/@mediaontscreenand(orientation:landscape){}/*only*/@mediaonlyscreenand(min-width:400px),screenand(orientation:landscape){}/*or:逗号就类似or*/@mediascreenand(min-width:400px),screenand(orientation:landscape){}```##js触发媒体表达式###window.matchMedia-`window.matchMedia('(max-width:600px)')`:就可达到js使用媒体表达式监听eg:创建媒体查询，以监控设备分辨率并在每次更改时检查devicePixelRatio的值```jsletpixelRatioBox=document.querySelector('.pixel-ratio')letmqString=`(resolution:${window.devicePixelRatio}dppx)`constupdatePixelRatio=()=>{letpr=window.devicePixelRatioletprString=(pr*100).toFixed(0)pixelRatioBox.innerText=`${prString}%(${pr.toFixed(2)})`}updatePixelRatio()matchMedia(mqString).addListener(updatePixelRatio)```##补充-CSS2中:媒体查询值使用与`<style>`和`<link>`,以media属性存在|值|描述||:----------------------|:------------------------------------------------------------------------------||`aspect-ratio`|定义输出设备中的页面可见区域宽度与高度的比率||color|定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0||color-index|定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0||device-aspect-ratio|定义输出设备的屏幕可见宽度与高度的比率。||device-height|定义输出设备的屏幕可见高度。||device-width|定义输出设备的屏幕可见宽度。||grid|用来查询输出设备是否使用栅格或点阵。||height|定义输出设备中的页面可见区域高度。||max-aspect-ratio|定义输出设备的屏幕可见宽度与高度的最大比率。||max-color|定义输出设备每一组彩色原件的最大个数。||max-color-index|定义在输出设备的彩色查询表中的最大条目数。||max-device-aspect-ratio|定义输出设备的屏幕可见宽度与高度的最大比率。||max-device-height|定义输出设备的屏幕可见的最大高度。||max-device-width|定义输出设备的屏幕最大可见宽度。||max-height|定义输出设备中的页面最大可见区域高度。||max-monochrome|定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。||max-resolution|定义设备的最大分辨率。||max-width|定义输出设备中的页面最大可见区域宽度。||min-aspect-ratio|定义输出设备中的页面可见区域宽度与高度的最小比率。||min-color|定义输出设备每一组彩色原件的最小个数。||min-color-index|定义在输出设备的彩色查询表中的最小条目数。||min-device-aspect-ratio|定义输出设备的屏幕可见宽度与高度的最小比率。||min-device-width|定义输出设备的屏幕最小可见宽度。||min-device-height|定义输出设备的屏幕的最小可见高度。||min-height|定义输出设备中的页面最小可见区域高度。||min-monochrome|定义在一个单色框架缓冲区中每像素包含的最小单色原件个数||min-resolution|定义设备的最小分辨率。min-width定义输出设备中的页面最小可见区域宽度。||monochrome|定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0||orientation|定义输出设备中的页面可见区域高度是否大于或等于宽度。||resolution|定义设备的分辨率。如：96dpi,300dpi,118dpcm||scan|定义电视类设备的扫描工序。||width|定义输出设备中的页面可见区域宽度。|","CSS\\attribute\\animation.md":"#animation>名称：关键帧动画，帧动画>`animation:属性名时长过度方式延迟次数方向填充模式是否暂停;`>`animation:namedurationtiming-functiondelayiteration-countdirectionfill-mode;`|属性|描述||-------------------------|-----------------------------------------------------------------||animation-name|指定@keyframes动画的`名称`。||animation-duration|指定动画完成一个`周期`所需要时间，单位秒（s）或毫秒（ms），默认是||animation-timing-function|指定动画`计时函数`，即动画的速度曲线，默认是\"ease\"。||animation-delay|指定动画`延迟时间`，即动画何时开始，默认是0。||animation-iteration-count|指定动画`播放的次数`，默认是1。||animation-direction|指定动画`播放的方向`。默认是normal。||animation-fill-mode|指定动画`填充模式`。默认是none。||animation-play-state|指定动画`播放状态`，正在运行或暂停。默认是running。|##animation-name>通过`@keyframs`来定义关键帧动画```css/*使用*/animation：[name]2s;/*等价于*/animation-name:[name];animation-duration:2s;/*定义*/@keyframes[name]{....}```###@keyframes>主要两种写法####百分率```css@keyframes[name]{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}@keyframes[name]{0%,66%{transform:translate(0,0);}33%,100%{transform:translate(200px,0);}}```####from&to```css@keyframes[name]{from{transform:rotate(0deg);}to{transform:rotate(360deg);}}```##animation-duration>动画运行时间##animation-timing-function>计时函数>常见值：`linear`,`ease`,`ease-in`,`ease-out`,`ease-in-out`（都是`cubicbezier(n,n,n,n)`的特例）##animation-delay##animation-iteration-count>动画播放次数>`infinite`:无限播放##animation-direction>指定动画按照指定顺序播放>`normal`:默认值；>`reverse`:动画反向播放；>`alternate`:正向和反向交叉进行；>`alternate-reverse`:表反向和正向交叉进行；##animation-fill-mode>填充模式>none:默认值；>forwards:动画完成后保持最后一帧(停在最后一帧)>backwards:有动画颜值时，动画开始前，元素状态保持第一帧的状态>both:前两者均有；##animation-play-state>表示动画播放状态>`running`:播放>`paused`:暂停","CSS\\attribute\\background\\background-clip.md":"#[`background-clip`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip)-控制背景图片/颜色填充范围-默认:`background`:会填充盒模型`content`+`padding`+`border`![](./.assets/background-clip-2024-02-28-16-42-08.png)-`background-clip`:`border-box`|`padding-box`|`content-box`|`text`-`border-box`:填充到`border`(default)-`padding-box`:填充到`padding`-`content-box`:只填充`content`-`text`:只填充`(text)文字`-`webkit`需要使用`-webkit-background-clip:text`-[demo](https://ruihuag-demo.github.io/eg/background-clip.html)[![](./.assets/background-clip-2024-02-28-17-02-06.png)](https://ruihuag-demo.github.io/eg/background-clip.html)","CSS\\attribute\\background\\background.md":"#background##basic>`background`:是简写属性,可以在一次声明中定义或多个属性,除去特定的属性,其他属性可以按照任意位置放置```cssbackground：[background-color]|[background-image]|[background-position][/background-size]|[background-repeat]|[background-attachment]|[background-clip]|[background-origin],...```CSS3`background`支持多重背景，主要是靠`origin`、`clip`和`size`组成新的`background`多次叠加###注意-`background`属性被指定多个背景层时，使用逗号分隔每个背景层。每个属性用空格隔开-如果有`size`的值必须紧跟着`position`，用/隔开-`background-color`只能设置一个值且被包含在最后一层-`border-box/padding-box/content-box`如果出现一次则同时设置`origin`和`clip`，如果出现两次第一个指定`origin`，第二个指定`clip`-多重背景，其他属性只有一个表示所有的背景共用一个属性的属性值###background-color>-`background-color`会设置元素的背景色，属性的值为颜色值或者关键字“transparent”二者选其一。>-`background-color`的优先级比`background-image`低，如果同时存在`background-color`和`background-image`时，image会显示在color上面```css/*Keywordvalues*/background-color:red;/*Hexadecimalvalue*/background-color:#bbff00;/*RGBvalue*/background-color:rgb(255,255,128);/*HSLAvalue*/background-color:hsla(50,33%,25%,0.75);/*Specialkeywordvalues*/background-color:currentColor;/*纯白色*/background-color:transparent;/*Globalvalues*/background-color:inherit;background-color:initial;background-color:unset;```###background-image>background-image属性用于为一个元素设置一个或多个背景图像,过关背景图像用`,`隔开>>`background-image:url('...')||linerat-gradient(渐变)||none[无背景图]````css/*html*/<divclass=\"border-image-color\"></div>/*css*/.border-image-color{width:500px;height:400px;border:20pxdashedyellowgreen;background-image:url(https://user-gold-cdn.xitu.io/2020/3/19/170f20b3c106f518?w=642&h=339&f=png&s=107259);background-repeat:no-repeat;background-origin:border-box;background-color:lightSkyBlue;background-position:-60px-20px;}```>`background-image`的绘制方向在Z轴上堆叠方式，先指定的图像会在后指定图像上面>>`background-image`绘制在`border`之下，`background-color`之上>>`background-image`的绘制、显示位置与`background-position`、`background-clip`、`background-origin`相关![实例](https://user-gold-cdn.xitu.io/2020/3/20/170f597acad1d3a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)###background-origin`background-origin`规定了背景图片`background-image`属性的原点位置的背景相对区域，为`background-position`设置初始位置。但是当`background-attachment`为`fixed`时，此属性将被忽略，不起作用。####属性值：默认值/padding-box-border-box背景图片的摆放以border区域为参考-padding-box背景图片的摆放以padding区域为参考-content-box背景图片的摆放以content区域为参考###background-position`background-position`为每个背景图片设置初始位置，`background-position`的原点是`background-origin`定义的位置，相对偏移量都是以原点为基准。####属性值：默认值/lefttop三种取值类型可以混合使用-关键字-`center`用来居中背景图片-`left`、`right`指定图片放置于X轴的左右边缘-`top`、`bottom`指定图片放置于Y轴的上下边缘-length数值+'px'，指定相对于X,Y坐标的位置-percentage百比分，指定相对于X,Y坐标的位置####值个数-关键字取单个值，另外一个位置默认为center-length、percentage取一个值当前值同时指定X轴与Y轴的坐标-length、percentage取两个值，第一个值定义X轴的方向、第二值定义Y轴的方向-四个值position:bottom10pxright20px;关键字定义位置，length/percentage定义距离####扩展`background-position`属性已经得到扩展，它允许我们指定背景图片距离任意角的偏移量，只要我们在偏移量(`length`/`percentage`)前面指定关键字(`top`,`bottom`,`left`,`right`)####percentage语法百分比值的偏移指定图片的相对位置和容器相对位置重合。值0%表示图片的(左上)边界与容器(左上)边界重合，值100%代表图片的右边界（或下边界）和容器的右边界（或下边界）重合。值50%则代表图片的中点和容器的中点重合。percentage公式：`(containerwidth-imagewidth)*(positionx%)=(xoffsetvalue)``(containerheight-imageheight)*(positiony%)=(yoffsetvalue)`![img](https://user-gold-cdn.xitu.io/2020/3/20/170f5c2c5723acd3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)```css/*html*/<divclass=\"border-image-color\"></div>/*css*//*图片宽度：642px容器宽度:742px容器宽度：，容器box-sizing与背景background-origin同步作用若想X方向上移动20px：20px/(742px-642px)=20%X方向上移动20%，实际移动像素值：(742px-642px)*20%=20px其中若background-origin为padding-box实际容器宽度应为包裹图片时原点origin控制的部分容器宽度则需要减去边框40px，实际为702px，再在X轴移动20%时实际移动的像素：(702px-642px)*20%=12px*/.border-image-color{box-sizing:border-box;width:742px;height:400px;border:20pxdashedyellowgreen;background-image:url(https://user-gold-cdn.xitu.io/2020/3/19/170f20b3c106f518?w=642&h=339&f=png&s=107259);background-repeat:no-repeat;background-origin:border-box;background-color:lightSkyBlue;background-position:20%0px;}```###background-size`background-size`设置背景图片的大小。图片可以保有原有的尺寸，或者拉伸到新的尺寸，或者保持其原有比例的同时缩放到元素的可用空间尺寸####属性值：默认值/autoauto-关键字-auto以背景图片的比例缩放背景图片。-cover缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和contain值相反，cover值尽可能大的缩放背景图像并保持图像的宽高比例(图像不会被压扁)-contain(背景区容纳背景图片)缩放背景图片以完全装入背景区，可能背景区部分空白。contain尽可能的缩放背景并保持图像的宽高比例(图像不会被压缩)![img](https://user-gold-cdn.xitu.io/2020/3/20/170f5f4c42de2970?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)-length指定背景图的宽高，不能为负值-percentage指定背景图片相对背景区(同`position`的容器宽高)的百分比。背景区由`background-origin`设置###background-repeat`background-repeat`属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。|属性|定义||:--------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||repeat|图像会按需**重复来覆盖整个背景图片所在的区域**.最后一个图像会被裁剪,如果它的大小不合适的话.repeat-x、repeat-y指定单方向重复||space|图像会尽可能得重复,但是不会裁剪.第一个和最后一个图像会被固定在元素(element)的相应的边上,同时空白会均匀地分布在图像之间.background-position属性会被忽视,除非只有一个图像能被无裁剪地显示.只在一种情况下裁剪会发生,那就是图像太大了以至于没有足够的空间来完整显示一个图像.||round|随着允许的空间在尺寸上的增长,被重复的图像将会伸展(没有空隙),直到有足够的空间来添加一个图像.当下一个图像被添加后,所有的当前的图像会被压缩来腾出空间.例如,一个图像原始大小是260px,重复三次之后,可能会被伸展到300px,直到另一个图像被加进来.这样他们就可能被压缩到225px.||no-repeat|图像不会被重复(因为背景图像所在的区域将可能没有完全被覆盖).那个没有被重复的背景图像的位置是由background-position属性来决定.||<imgsrc=\"https://user-gold-cdn.xitu.io/2020/3/20/170f60a5313a224c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"round\"style=\"zoom:33%;\"/>|<imgsrc=\"https://user-gold-cdn.xitu.io/2020/3/20/170f609015dc74b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"space\"style=\"zoom:33%;\"/>||----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------||||###background-attachment`background-attachment`属性决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。####属性值-fixed表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动-local表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动，并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。-scroll示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。###background-clip`background-clip`设置元素的背景（背景图片或颜色）是否延伸到边框下面####取值：默认值/border-box-border-box背景延伸至边框外沿（但是在边框下层）-padding-box背景延伸至内边距（padding）外沿。不会绘制到边框处-content-box背景被裁剪至内容区（contentbox）外沿-text背景被裁剪成文字的前景色,属性值为text时属性应设置为`-webkit-background-clip`,字体的颜色使用背景色即`color:transparent`/`-webkit-text-fill-color:transparent`;```css/*html*/<divclass=\"border-image-color\">text</div>/*css*/.border-image-color{box-sizing:border-box;width:642px;height:400px;font-size:100px;line-height:300px;text-align:center;border:20pxdashedyellowgreen;background-image:url(https://user-gold-cdn.xitu.io/2020/3/19/170f20b3c106f518?w=642&h=339&f=png&s=107259);background-repeat:no-repeat;background-origin:border-box;-webkit-background-clip:text;color:transparent;}```![clip:text](https://user-gold-cdn.xitu.io/2020/3/20/170f616e1f91ffb1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)###多重背景使用实例>工作场景：官网主页底部为铺满不同的图片，图片之上再进行基本的图片文字排版>使用多重背景处理可以避免冗余空的html元素格外铺图片，避免伪元素和伪类去进行多余的position定位![多图片为底](https://user-gold-cdn.xitu.io/2020/3/20/170f6d6502c3d6c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)```css/*html*/<divclass=\"border-image-color\"><divclass=\"section\">我是排版一</div><divclass=\"section\">我是排版二</div></div>/*css*/.border-image-color{display:flex;flex-direction:column;box-sizing:border-box;width:600px;height:580px;border:1pxsolidyellowgreen;text-align:center;background:url(https://user-gold-cdn.xitu.io/2020/3/20/170f5f4c42de2970?w=672&h=299&f=png&s=146779)0px0px,url(https://user-gold-cdn.xitu.io/2020/3/19/170f20b3c106f518?w=642&h=339&f=png&s=107259)0px250px;background-size:contain250px;background-repeat:no-repeat;}.section{width:400px;height:200px;line-height:200px;margin:30pxauto;text-align:center;background-color:rgba(0,0,0,0.8);color:#fff;}```##CSSbackgroundImage7个好用的技巧###背景图完美适配视口```cssbody{background-image:url('https://images.unsplash.com/photo-1573480813647-552e9b7b5394?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2253&q=80');background-repeat:no-repeat;background-position:center;background-attachment:fixed;background-size:cover;-webkit-background-size:cover;-moz-background-size:cover;-o-background-size:cover;}```![clipboard.png](https://segmentfault.com/img/bVbHhuO)###在CSS中使用多个背景图片```cssbody{background-image:url(https://image.flaticon.com/icons/svg/748/748122.svg),url(https://images.unsplash.com/photo-1478719059408-592965723cbc?ixlib=rb-1.2.1&auto=format&fit=crop&w=2212&q=80);background-position:center,top;background-repeat:repeat,no-repeat;background-size:contain,cover;}```![clipboard.png](https://segmentfault.com/img/bVbG9V2)###创建一个三角形的背景图像另一个很酷的背景特效就是三角形背景，当我们想展示某些完全不同的选择（例如白天和黑夜或冬天和夏天）时，这种特效就更加棒。思路是这样的，首先创建两个`div`，然后将两个背景都添加到其中，然后，第二个`div`使用`clip-path`属性画出三角形。![clipboard.png](https://segmentfault.com/img/bVbHhsp)```html<body><divclass=\"day\"></div><divclass=\"night\"></div></body>``````cssbody{margin:0;padding:0;}div{position:absolute;height:100vh;width:100vw;}.day{background-image:url('https://images.unsplash.com/photo-1477959858617-67f85cf4f1df?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2613&q=80');background-size:cover;background-repeat:no-repeat;}.night{background-image:url('https://images.unsplash.com/photo-1493540447904-49763eecf55f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80');background-size:cover;background-repeat:no-repeat;clip-path:polygon(100vw0,0%0vh,100vw100vh);}```>`clip-path`:使用裁剪方式穿啊金元素的可显示区域,区域内的部分显示,区域外隐藏>>`clip-path:polygon(100vw0,0%0vh,100vw100vh);`>>-polygon是多边形里面是指定的端点>><https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path>###背景图像上添加叠加渐变有时我们想在背景上添加一些文字，但有的图片太亮，导致字看不清楚，所以这里我们就需要让背景图叠加一些暗乐来突出文字效果。例如，可以通过添加粉红橙色渐变或红色至透明渐变来增强日落图像，这些情况下使用叠加的渐变就很容易做到。![clipboard.png](https://segmentfault.com/img/bVbHhtM)**css**```cssbody{background-image:linear-gradient(4deg,rgba(38,8,31,0.75)30%,rgba(213,49,127,0.3)45%,rgba(232,120,12,0.3)100%),url('https://images.unsplash.com/photo-1503803548695-c2a7b4a5b875?ixlib=rb-1.2.1&auto=format&fit=crop&w=2250&q=80');background-size:cover;background-repeat:no-repeat;background-attachment:fixed;background-position:center;}```###创建一个颜色动态变化的背景如果你很多颜色，你想确认哪种颜色更适合背景图片的颜色，刚动态更改背景颜色的技巧就很有用。```css@keyframesbackground-overlay-animation{0%{background-image:linear-gradient(4deg,rgba(255,78,36,0.3)50%,rgba(255,78,36,0.3)100%),url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");}25%{background-image:linear-gradient(4deg,rgba(213,49,127,0.3)50%,rgba(213,49,127,0.3)100%),url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");}50%{background-image:linear-gradient(4deg,rgba(36,182,255,0.3)50%,rgba(36,182,255,1)100%),url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");}100%{background-image:linear-gradient(4deg,rgba(0,255,254,0.3)50%,rgba(0,255,254,0.3)100%),url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");}}@-webkit-keyframesbackground-overlay-animation{0%{background-image:linear-gradient(4deg,rgba(255,78,36,0.3)50%,rgba(255,78,36,0.3)100%)url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");}25%{background-image:linear-gradient(4deg,rgba(213,49,127,0.3)50%,rgba(213,49,127,0.3)100%),url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");}50%{background-image:linear-gradient(4deg,rgba(36,182,255,0.3)50%,rgba(36,182,255,1)100%),url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");}100%{background-image:linear-gradient(4deg,rgba(0,255,254,0.3)50%,rgba(0,255,254,0.3)100%),```![图片描述](https://segmentfault.com/img/bVbHhtY)###制作网格背景图像![clipboard.png](https://segmentfault.com/img/bVbHhum)```html<body><divclass=\"container\"><divclass=\"item_img\"></div><divclass=\"item\"></div><divclass=\"item_img\"></div><divclass=\"item\"></div><divclass=\"item\"></div><divclass=\"item_img\"></div><divclass=\"item\"></div><divclass=\"item_img\"></div><divclass=\"item\"></div><divclass=\"item\"></div><divclass=\"item_img\"></div><divclass=\"item\"></div><divclass=\"item_img\"></div><divclass=\"item\"></div><divclass=\"item_img\"></div><divclass=\"item\"></div></div></body>``````scssbody{margin:0;padding:0;}.container{position:absolute;width:100%;height:100%;background:black;display:grid;grid-template-columns:25fr30fr40fr15fr;grid-template-rows:20fr45fr5fr30fr;grid-gap:20px;.item_img{background-image:url('https://images.unsplash.com/photo-1499856871958-5b9627545d1a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2207&q=80');background-repeat:no-repeat;background-position:center;background-attachment:fixed;background-size:cover;}}```>`fr`:是一个自适应单位,用于在一系列长度值中分配剩余空间，如果多个已指定了多个部分，则剩下的空间根据各自的数字按比例分配。###将背景图像设置为文本颜色使用`background-image`与`background-clip`，可以实现背景图像对文字的优美效果。在某些情况下，它可能非常有用，尤其是当我们想创建一个较大的文本标题而又不如普通颜色那么枯燥的情况。![图片描述](https://segmentfault.com/img/bVbHhuz)```html<body><h1>Helloworld!</h1></body>``````scssbody{display:flex;align-items:center;justify-content:center;flex-direction:column;width:100%;text-align:center;min-height:100vh;font-size:120px;font-family:Arial,Helvetica,sans-serif;}h1{background-image:url('https://images.unsplash.com/photo-1462275646964-a0e3386b89fa?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2600&q=80');background-clip:text;-webkit-background-clip:text;color:transparent;}```","CSS\\attribute\\box-shadow.md":"#[`box-shadow`](/)-当设置多个阴影渲染属性是倒序,故前面的阴影会在后者之上```css/*x偏移量|y偏移量|阴影颜色*/box-shadow:60px-16pxteal;/*x偏移量|y偏移量|阴影模糊半径|阴影颜色*/box-shadow:10px5px5pxblack;/*x偏移量|y偏移量|阴影模糊半径|阴影扩散半径|阴影颜色*/box-shadow:2px2px2px1pxrgba(0,0,0,0.2);/*插页(阴影向内)|x偏移量|y偏移量|阴影颜色*/box-shadow:inset5em1emgold;/*任意数量的阴影，以逗号分隔*/box-shadow:3px3pxred,-1em00.4emolive;/*全局关键字*/box-shadow:inherit;box-shadow:initial;box-shadow:unset;```-inset:-如果没有指定inset，默认阴影在边框外，即阴影向外扩散。使用inset关键字会使得阴影落在盒子内部，这样看起来就像是内容被压低了。此时阴影会在边框之内(即使是透明边框）、背景之上、内容之下##术语-box-shadow-color:阴影颜色-box-shadow-offset:偏移量-box-shadow-blur:阴影模糊半径-box-shadow-spread:阴影扩散半径##偏移量和blur为零```html<div><p>HelloWorld</p></div>``````cssp{box-shadow:0002em#f4aab9,0004em#66ccff;margin:4em;padding:1em;}```![](./.assets/box-shadow-2024-01-12-09-57-22.png)","CSS\\attribute\\contain.md":"#contain`contain`属性允许我们指定特定的DOM元素和它的子元素，让它们能够独立于整个DOM树结构之外。目的是能够让浏览器有能力只对部分元素进行重绘、重排，而不必每次都针对整个页面。>Thecontainpropertyallowsanauthortoindicatethatanelementanditscontentsare,asmuchaspossible,independentoftherestofthedocumenttree.Thisallowsthebrowsertorecalculatelayout,style,paint,size,oranycombinationofthemforalimitedareaoftheDOMandnottheentirepage.##`contain`语法看看它的语法：```CSS{/*Nolayoutcontainment.*/contain:none;/*Turnonsizecontainmentforanelement.*/contain:size;/*Turnonlayoutcontainmentforanelement.*/contain:layout;/*Turnonstylecontainmentforanelement.*/contain:style;/*Turnonpaintcontainmentforanelement.*/contain:paint;/*Turnoncontainmentforlayout,paint,andsize.*/contain:strict;/*Turnoncontainmentforlayout,andpaint.*/contain:content;}```除去`none`，取值还有6个，我们一个一个来看看。##contain:sizecontain:size:设定了`contain:size`的元素的渲染不会受到其子元素内容的影响。>Thevalueturnsonsizecontainmentfortheelement.Thisensuresthatthecontainingboxcanbelaidoutwithoutneedingtoexamineitsdescendants.我开始看到这个定义也是一头雾水，光看定义很难明白到底是什么意思。还需实践一番：假设我们有如下简单结构：```HTML<divclass=\"container\"></div>.container{width:300px;padding:10px;border:1pxsolidred;}p{border:1pxsolid#333;margin:5px;font-size:14px;}```并且，借助jQuery实现每次点击容器添加一个`<p>Coco</p>`结构：```javascript$('.container').on('click',(e)=>{$('.container').append('<p>Coco</p>')})```那么会得到如下结果：![containsize](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad0040e236d245649f52d199cd25ff6b~tplv-k3u1fbpfcp-watermark.awebp)可以看到，容器`.container`的高度是会随着元素的增加而增加的，这是正常的现象。此刻，我们给容器`.container`添加一个`contain:size`，也就会出现上述说的：**设定了`contain:size`的元素的渲染不会受到其子元素内容的影响**。```CSS.container{width:300px;padding:10px;border:1pxsolidred;+contain:size}```再看看会发生什么：![containsize2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c8e8578776435591bcc23a096e355b~tplv-k3u1fbpfcp-watermark.awebp)正常而言，父元素的高度会因为子元素的增多而被撑高，而现在，子元素的变化不再影响父元素的样式布局，这就是`contain:size`的作用。##contain:style接下来再说说`contain:style`、`contain:layout`、`contain:paint`。先看看contain:style。截止至本文书写的过程中，`contain:style`暂时被移除了。>[CSSContainmentModuleLevel1](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-contain-1%2F):Droptheat-risk“stylecontainment”featurefromthisspecification,moveitLevel2。嗯，官方说辞是因为存在某些风险，暂时被移除，可能在规范的第二版会重新定义吧，那这个属性也暂且放一放。##contain:paintcontain:paint：设定了`contain:paint`的元素即是设定了布局限制，也就是说告知UserAgent，此元素的子元素不会在此元素的边界之外被展示，因此，如果元素不在屏幕上或以其他方式设定为不可见，则还可以保证其后代不可见不被渲染。>Thisvalueturnsonpaintcontainmentfortheelement.Thisensuresthatthedescendantsofthecontainingboxdon’tdisplayoutsideitsbounds,soifanelementisoff-screenorotherwisenotvisible,itsdescendantsarealsoguaranteedtobenotvisible.这个稍微好理解一点，先来看第一个特性：###设定了`contain:paint`的元素的子元素不会在此元素的边界之外被展示-设定了`contain:paint`的元素的子元素不会在此元素的边界之外被展示这个特点有点类似与`overflow:hidden`，也就是明确告知用户代理，子元素的内容不会超出元素的边界，所以超出部分无需渲染。简单示例，假设元素结构如下：```HTML<divclass=\"container\"><p>Coco</p></div>.container{contain:paint;border:1pxsolidred;}p{left:-100px;}```我们来看看，设定了`contain:paint`与没设定时会发生什么：![containsize3](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1edabb7b354493cb0ed38a5c03b9db6~tplv-k3u1fbpfcp-watermark.awebp)[CodePenDemo--contain:paintDemo](https://link.juejin.cn?target=https%3A%2F%2Fcodepen.io%2FChokcoco%2Fpen%2FKKwmgmN)###设定了`contain:paint`的元素在屏幕之外时不会渲染绘制通过使用`contain:paint`，如果元素处于屏幕外，那么用户代理就会忽略渲染这些元素，从而能更快的渲染其它内容。##contain:layoutcontain:layout：设定了`contain:layout`的元素即是设定了布局限制，也就是说告知UserAgent，此元素内部的样式变化不会引起元素外部的样式变化，反之亦然。>Thisvalueturnsonlayoutcontainmentfortheelement.Thisensuresthatthecontainingboxistotallyopaqueforlayoutpurposes;nothingoutsidecanaffectitsinternallayout,andviceversa.启用`contain:layout`可以潜在地将每一帧需要渲染的元素数量减少到少数，而不是重新渲染整个文档，从而为浏览器节省了大量不必要的工作，并显着提高了性能。使用`contain：layout`，开发人员可以指定对该元素任何后代的任何更改都不会影响任何外部元素的布局，反之亦然。因此，浏览器仅计算内部元素的位置（如果对其进行了修改），而其余DOM保持不变。因此，这意味着帧渲染管道中的布局过程将加快。###存在的问题描述很美好，但是在实际Demo测试的过程中（截止至2021/04/27，Chrome90.0.4430.85），仅仅单独使用`contain：layout`并没有验证得到上述那么美好的结果。**设定了`contain:layout`的指定元素，改元素的任何后代的任何更改还是会影响任何外部元素的布局**，点击红框会增加一条`<p>Coco<p>`元素插入到`container`中：简单的代码如下：```HTML<divclass=\"container\"><p>Coco</p>...</div><divclass=\"g-test\"></div>html,body{width:100%;height:100%;display:flex;justify-content:center;align-items:center;flex-direction:column;gap:10px;}.container{width:150px;padding:10px;contain:layout;border:1pxsolidred;}.g-test{width:150px;height:150px;border:1pxsolidgreen;}```![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02c6ecc821d845e593faa7c8f83e1550~tplv-k3u1fbpfcp-watermark.awebp)[CodePenDemo--contain:layoutDemo](https://link.juejin.cn?target=https%3A%2F%2Fcodepen.io%2FChokcoco%2Fpen%2FrNjRELL)目前看来，`contain:layout`的实际作用不那么明显，更多的关于它的用法，你可以再看看这篇文章：[CSS-tricks-contain](https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Falmanac%2Fproperties%2Fc%2Fcontain%2F)##contain:strict|contain:content这两个属性稍微有点特殊，效果是上述介绍的几个属性的聚合效果：-`contain:strict`：同时开启layout、style、paint以及size的功能，它相当于`contain:sizelayoutpaint`-`contain:content`：同时开启layout、style以及paint的功能，它相当于`contain:layoutpaint`所以，这里也提一下，contain属性是可以同时定义几个的。##CaniUse--CSSContain截止至2021-04-27，CaniUse上的CSSContain兼容性，已经可以开始使用起来：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c34ec138a05b4cc6916aad01600ed651~tplv-k3u1fbpfcp-watermark.awebp)##参考文献-[CSSContainmentModuleLevel1](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-contain-1%2F)-[CSScontainment](https://link.juejin.cn?target=https%3A%2F%2Fjustmarkup.com%2Farticles%2F2016-04-05-css-containment%2F)-[CSSContainmentinChrome52](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2016%2F06%2Fcss-containment)","CSS\\attribute\\content-visibility.md":"#content-visibility属性值>`content-visibility`是CSS新增的属性，>主要用来提高页面渲染性能，它可以控制一个元素是否渲染其内容，并且允许浏览器跳过这些元素的布局与渲染。-visible：默认值，没有效果。元素的内容被正常布局和呈现-hidden：元素跳过它的内容。跳过的内容不能被用户代理功能访问，例如在页面中查找、标签顺序导航等，也不能被选择或聚焦。这类似于给内容设置`display:none`-auto：该元素打开布局包含、样式包含和绘制包含。如果该元素与用户不相关，它也会跳过其内容。与hidden不同，跳过的内容必须仍可正常用于用户代理功能，例如在页面中查找、tab顺序导航等，并且必须正常可聚焦和可选择,只有在可视区域才会被渲染##`content-visibility:hidden`手动管理可见性与display:none区别：-`content-visibility:hidden`只是隐藏了子元素，自身不会被隐藏-`content-visibility:hidden`隐藏内容的渲染状态会被缓存，所以当它被移除或者设为可见时，浏览器不会重新渲染，而是会应用缓存，所以对于需要频繁切换显示隐藏的元素，这个属性能够极大地提高渲染性能##`content-visibility:auto`>只有在可视区域才会被渲染###问题>渲染元素前,当前元素的高度为0,滚动时候就会出现混乱>结合`contain-intrinsic-size`来解决##`contain-intrinsic-size`>指定元素的自然大小,确保没有被渲染元素占据控件,同事也保留延迟渲染的好处是以下css的简写-`contain-intrinsic-width`-`contain-intrinsic-height````css/*Keywordvalues*/contain-intrinsic-width:none;/*<length>values*/contain-intrinsic-size:1000px;contain-intrinsic-size:10rem;/*width|height*/contain-intrinsic-size:1000px1.5em;/*auto<length>*/contain-intrinsic-size:auto300px;/*autowidth|autoheight*/contain-intrinsic-size:auto300pxauto4rem;```##实现```css.card_item{content-visibility:auto;contain-intrinsic-size:200px;}```##兼容性>`content-visibility`![](./.assets/content-visibility-2022-11-23-14-11-44.png)>`contain-intrinsic-size`![](./.assets/content-visibility-2022-11-23-14-27-26.png)","CSS\\attribute\\content.md":"#content-值-none:不会产生伪类元素-normal:`:before`和`:after`伪类元素会被视为none-`<string>`:文本内容-`<uri>url()`:uri会指定一个外部资源(比如图片),不能正常显示就会被忽略,或显示一些占位符(无图片标志)-`<counter>`-counter(计数器名[,style])-counters(计数器名称[,string][,style])-attr(X):将元素的X属性以字符串的形式返回,该元素没有该属性就会返回空字符串-open-quote|close-quote:这些值会被quotes中定义的字符串替换-no-open-quote|no-close-quote:不会产生任何内容,但是会改变(增加或降低)引号的层级##contentcounter1.counter属性对多个项目进行连续编号,计数器课任意命名2.counter-increment属性设置counter属性值所指定的计数器名3.使用content追加内容coutent:'第'counter(计数器名称)'个'4.指定彪悍种类:content:counter(计数器名,种类[\"upper-alpha\"])5.编号嵌套需要在大标题中使用counter-reset进行编号重置###插入编号```html<style>h4::before{content:counter(num)'.';color:#f00;}h4{counter-increment:num;}</style><body><h4>标题一</h4><h4>标题二</h4><h4>标题三</h4><h4>标题四</h4><h4>标题五</h4></body>```###指定编号种类```html<style>h4::before{content:counter(num,upper-alpha)'.';color:#f00;}h4{counter-increment:num;}</style><body><h4>标题一</h4><h4>标题二</h4><h4>标题三</h4><h4>标题四</h4><h4>标题五</h4></body>```###编号嵌套```html<style>h1::before{content:counter(num)'.';}h1{counter-increment:num;counter-reset:littenum;/*重置小标题编号*/}h4::before{content:counter(littenum)'.';}h4{counter-increment:littenum;margin-left:40px;}</style><body><h1>标题</h1><h4>小标题</h4><h4>小标题</h4><h4>小标题</h4><h1>标题</h1><h4>小标题</h4><h4>小标题</h4><h4>小标题</h4><h1>标题</h1><h4>小标题</h4><h4>小标题</h4><h4>小标题</h4></body>```","CSS\\attribute\\css-动画.md":"#css动画>CSS动画(transform,transition,animation)##浏览器渲染原理[![0DhCRO.md.png](https://s1.ax1x.com/2020/10/09/0DhCRO.md.png)](https://imgchr.com/i/0DhCRO)###浏览器渲染过程1.根据html标记构建DOM树2.根据CSS构建css树(CSSDOM)3.将两棵树合并成一棵渲染树(rendertree)4.layout布局(文档流,盒模型,大小等)5.paint绘制(边框颜色,背景颜色等)6.compose合成(根据层叠关系展示画面)###更新样式的三种方式####JS/CSS>样式>布局>绘制>合成![img](https://user-gold-cdn.xitu.io/2020/5/4/171dde4a96e82fe1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)-根据浏览器的渲染原理，若是开发者**更新了样式**（即元素的几何属性，类似于宽高，位置等）-则浏览器会检查所有属性然后重新绘制，最后再合成。####JS/CSS>样式>绘制>合成![img](https://user-gold-cdn.xitu.io/2020/5/4/171dde4fe149e0a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)-如果开发者只是更新了`paintonly`的属性（例如背景，文字颜色等）-由于不影响页面布局，则浏览器直接执行绘制。####JS/CSS>样式>合成![img](https://user-gold-cdn.xitu.io/2020/5/4/171dde5405781ebe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)-在开发者只是更改**一个既不更改布局也不需要绘制的属性时**，-浏览器将只执行合成，例如动画和`transform`。","CSS\\attribute\\font-variant-numeric.md":"#`font-variant-numeric`##值```cssfont-variant-numeric:normal;font-variant-numeric:ordinal;font-variant-numeric:slashed-zero;font-variant-numeric:lining-nums;/*<numeric-figure-values>*/font-variant-numeric:oldstyle-nums;/*<numeric-figure-values>*/font-variant-numeric:proportional-nums;/*<numeric-spacing-values>*/font-variant-numeric:tabular-nums;/*<numeric-spacing-values>*/font-variant-numeric:diagonal-fractions;/*<numeric-fraction-values>*/font-variant-numeric:stacked-fractions;/*<numeric-fraction-values>*/font-variant-numeric:oldstyle-numsstacked-fractions;/*Globalvalues*/font-variant-numeric:inherit;font-variant-numeric:initial;font-variant-numeric:unset;```-normal下列特性均不启用。-`ordinal`启用序数形式显示。对序号标记强制启用特殊字形，如英文中的$1^{st}$，$2^{nd}$，$3^{rd}$，$4^{th}$，意大利文中的$1^a$。等同于OpenType特性ordn。-`slashed-zero`启用区分零显示。强制使用带有斜杠的0；常用于区分O和0。等同于OpenType特性zero。-`<numeric-figure-values>`下列值用于控制数字样式，可用值如下：-lining-nums启用内衬数字显示。使数字全部对齐到基线。等同于OpenType特性lnum。-oldstyle-nums启用旧式数字显示。部分数字如3、4、7、9会有下沉。等同于OpenType特性onum。-`<numeric-spacing-values>`下列值用于控制数字宽度，可用值如下：-`proportional-nums`启用比例数字显示。使数字变成基于字形本身形状下的特定宽度表现。等同于OpenType特性`pnum`-`tabular-nums`启用表格数字显示。使数字等宽，易于像表格那样对齐。等同于`OpenType`特性`tnum`-`<numeric-fraction-values>`下列值用于控制分数字形，可用值如下：-`diagonal-fractions`启用斜角分数显示。使分子和分母变成像下标字，并用变长的斜线分隔。等同于`OpenType`特性frac。-`stacked-fractions`启用标准分数显示。使分子在上，分母在下，并用水平线分隔。等同于`OpenType`特性afrc。##兼容性![](./.assets/font-variant-numeric-2022-07-14-15-43-50.png)","CSS\\attribute\\gap.md":"#[`gap`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gap)>属性是用来设置网格行与列之间的间隙（gutters），该属性是row-gap和column-gap的简写形式。![](./.assets/gap-2022-11-04-10-34-12.png)","CSS\\attribute\\isolation.md":"#`isolation`-决定一个元素是否要创建一个新的层叠上下文```html<section><h1><span>Elaboratetitle</span></h1></section><article>Thisisa<spanclass=\"tooltip-parent\"><u>tooltip</u><spanclass=\"tooltip\">Loremipsumdolorsitamet,consecteturadipiscingelit.Inacvulputateaugue,sedconsequatvelit.Praesentrhoncusviverraullamcorper.</span></span>thatisinahoveredstateforyourconvinience.<p>Loremipsumdolorsitamet,consecteturadipiscingelit.Inacvulputateaugue,sedconsequatvelit.Praesentrhoncusviverraullamcorper.</p><p>Ineueratcommodoenimvariusfeugiatacvitaearcu.Aeneanidvariusjusto.Curabituregetmollisnibh.Classaptenttacitisociosquadlitoratorquentperconubianostra,perinceptoshimenaeos.Vestibulumeusapiensedloremimperdietauctorsitametinfelis.Donecnonsemvelturpislaoreetpretiumvitaesitametodio.Insitametfermentumarcu.Utfringillarisusacvenenatiseuismod.Donecnoneleifendpurus.Suspendisseaaliquettellus.Maecenasbibendumcommodoaugueetporta.</p></article>``````css*,*::before{box-content:content-box;}h1{isolation:isolate;font-size:64px;text-transform:uppercase;margin:0;position:relative;display:inline-block;margin-bottom:0.5em;}h1span{position:relative;z-index:999999;padding:00.25em;}h1::before{content:'';width:100%;height:20px;background-color:goldenrod;opacity:0.6;z-index:1;position:absolute;top:60%;left:0;transform:skew(-45deg,0);transform-origin:50%50%;}body{padding:3rem2rem;width:768px;margin:0auto;line-height:1.5;color:#111111;}u{color:darkgoldenrod;font-weight:600;}.tooltip-parent{position:relative;display:inline-block;}.tooltip{isolation:isolate;width:300px;z-index:1;position:absolute;top:0;left:0;transform:translate3d(0,calc(-100%-16px),0);background-color:#ffffff;padding:0.5rem;border:2pxsoliddarkgoldenrod;border-radius:4px;}.tooltip::before{content:'';width:0;height:0;border-left:12pxsolidtransparent;border-right:12pxsolidtransparent;border-top:12pxsoliddarkgoldenrod;position:absolute;top:100%;margin-top:1px;left:12px;z-index:-1;}```<section><h1><span>Elaboratetitle</span></h1></section><article>Thisisa<spanclass=\"tooltip-parent\"><u>tooltip</u><spanclass=\"tooltip\">Loremipsumdolorsitamet,consecteturadipiscingelit.Inacvulputateaugue,sedconsequatvelit.Praesentrhoncusviverraullamcorper.</span></span>thatisinahoveredstateforyourconvinience.<p>Loremipsumdolorsitamet,consecteturadipiscingelit.Inacvulputateaugue,sedconsequatvelit.Praesentrhoncusviverraullamcorper.</p><p>Ineueratcommodoenimvariusfeugiatacvitaearcu.Aeneanidvariusjusto.Curabituregetmollisnibh.Classaptenttacitisociosquadlitoratorquentperconubianostra,perinceptoshimenaeos.Vestibulumeusapiensedloremimperdietauctorsitametinfelis.Donecnonsemvelturpislaoreetpretiumvitaesitametodio.Insitametfermentumarcu.Utfringillarisusacvenenatiseuismod.Donecnoneleifendpurus.Suspendisseaaliquettellus.Maecenasbibendumcommodoaugueetporta.</p></article><style>*,*::before{box-content:content-box;}h1{isolation:isolate;font-size:64px;text-transform:uppercase;margin:0;position:relative;display:inline-block;margin-bottom:0.5em;}h1span{position:relative;z-index:999999;padding:00.25em;}h1::before{content:\"\";width:100%;height:20px;background-color:goldenrod;opacity:0.6;z-index:1;position:absolute;top:60%;left:0;transform:skew(-45deg,0);transform-origin:50%50%;}body{padding:3rem2rem;width:768px;margin:0auto;line-height:1.5;color:#111111;}u{color:darkgoldenrod;font-weight:600;}.tooltip-parent{position:relative;display:inline-block;}.tooltip{isolation:isolate;width:300px;z-index:1;position:absolute;top:0;left:0;transform:translate3d(0,calc(-100%-16px),0);background-color:#ffffff;padding:0.5rem;border:2pxsoliddarkgoldenrod;border-radius:4px;}.tooltip::before{content:\"\";width:0;height:0;border-left:12pxsolidtransparent;border-right:12pxsolidtransparent;border-top:12pxsoliddarkgoldenrod;position:absolute;top:100%;margin-top:1px;left:12px;z-index:-1;}</style>##兼容性![](./.assets/isolation-2022-07-14-14-59-35.png)","CSS\\attribute\\mix-blend-mode.md":"#[mix-blend-mode](https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode)>属性描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合![](./.assets/mix-blend-mode-2022-11-04-10-43-52.png)","CSS\\attribute\\outline-offset.md":"#outline-offset-对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓-规定边框边缘之外15像素处的轮廓：```cssdiv{border:2pxsolidblack;outline:2pxsolidred;outline-offset:15px;}```|appearance|允许您将元素设置为标准用户界面元素的外观||:-------------|:-------------------------------------------------||box-sizing|允许您以确切的方式定义适应某个区域的具体内容。||icon|为创作者提供使用图标化等价物来设置元素样式的能力。||nav-down|规定在使用arrow-down导航键时向何处导航。||nav-index|设置元素的tab键控制次序。||nav-left|规定在使用arrow-left导航键时向何处导航。||nav-right|规定在使用arrow-right导航键时向何处导航。||nav-up|规定在使用arrow-up导航键时向何处导航。||outline-offset|对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。||resize|规定是否可由用户对元素的尺寸进行调整。|","CSS\\attribute\\overflow.md":"#overflow##overflow:clip>视觉上和`overflow:hidden`一样>设置overflow:hidden就会创建BFC，自然没法只限制一个方向；而clip不会创建BFC，这是本质原因。同时，BFC还会带来的一些小区别这里也会有体现，比如float是否能限制在元素内，relative定位的基准啥的","CSS\\attribute\\pointer-events.md":"#pointer-events>指定在什么情况下(如果有)某个特定的图形元素可以成为鼠标事件的target```css/*Keywordvalues*/pointer-events:auto;pointer-events:none;pointer-events:visiblePainted;/*SVGonly*/pointer-events:visibleFill;/*SVGonly*/pointer-events:visibleStroke;/*SVGonly*/pointer-events:visible;/*SVGonly*/pointer-events:painted;/*SVGonly*/pointer-events:fill;/*SVGonly*/pointer-events:stroke;/*SVGonly*/pointer-events:all;/*SVGonly*//*Globalvalues*/pointer-events:inherit;pointer-events:initial;pointer-events:unset;```##auto>与`pointer-events`属性未指定时的表现效果相同，对于SVG内容，该值与`visiblePainted`效果相同##none>**元素永远不会成为鼠标事件的`target`**。但是，当其后代元素的`pointer-events`属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。##visiblePainted>只适用于SVG。元素只有在以下情况才会成为鼠标事件的目标：>>-`visibility`属性值为`visible`，且鼠标指针在元素内部，且fill属性指定了none之外的值>-`visibility`属性值为`visible`，鼠标指针在元素边界上，且stroke属性指定了none之外的值##visibleFill>只适用于SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素内部时,元素才会成为鼠标事件的目标，`fill`属性的值不影响事件处理。##visibleStroke>只适用于SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素边界时,元素才会成为鼠标事件的目标，stroke属性的值不影响事件处理。##visible>只适用于SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素内部或边界时,元素才会成为鼠标事件的目标，fill和stroke属性的值不影响事件处理。##painted>只适用于SVG。元素只有在以下情况才会成为鼠标事件的目标：>鼠标指针在元素内部，且`fill`属性指定了none之外的值>鼠标指针在元素边界上，且`stroke`属性指定了none之外的值>`visibility`属性的值不影响事件处理。##fill>只适用于SVG。只有鼠标指针在元素内部时,元素才会成为鼠标事件的目标，`fill`和`visibilit`属性的值不影响事件处理。##stroke>只适用于SVG。只有鼠标指针在元素边界上时,元素才会成为鼠标事件的目标，`stroke`和`visibility`属性的值不影响事件处理。##all>只适用于SVG。只有鼠标指针在元素内部或边界时,元素才会成为鼠标事件的目标，`fill`、`stroke`和`visibility`属性的值不影响事件处理。","CSS\\attribute\\resize.md":"###resize-可有用户调整大小-`<textarea>`默认就有```cssdiv{resize:both;overflow:auto;}```","CSS\\attribute\\scroll-behavior.md":"#scroll-behavior>-auto>-滚动框立即滚动。>-smooth>-滚动框通过一个用户代理预定义的时长、使用预定义的时间函数，来实现平稳的滚动，用户代理应遵循其平台的约定，如果有的话。```css/*Keywordvalues*/scroll-behavior:auto;scroll-behavior:smooth;/*Globalvalues*/scroll-behavior:inherit;scroll-behavior:initial;scroll-behavior:unset;```![](.assets/GIF2021-6-715-30-05-1623051086791.gif)##栗子```html<style>a{display:inline-block;width:50px;text-decoration:none;}nav,scroll-container{display:block;margin:0auto;text-align:center;}nav{width:339px;padding:5px;border:1pxsolidblack;}scroll-container{display:block;width:350px;height:200px;overflow-y:scroll;scroll-behavior:smooth;}scroll-page{display:flex;align-items:center;justify-content:center;height:100%;font-size:5em;}</style><body><nav><ahref=\"#page-1\">1</a><ahref=\"#page-2\">2</a><ahref=\"#page-3\">3</a></nav><scroll-container><scroll-pageid=\"page-1\">1</scroll-page><scroll-pageid=\"page-2\">2</scroll-page><scroll-pageid=\"page-3\">3</scroll-page></scroll-container></body>```##兼容性![image-20210607153219790](.assets/image-20210607153219790-1623051142758.png)","CSS\\attribute\\scroll-padding-top.md":"#`scroll-padding-top`-用来定义滚动窗口的最佳查看区域对于顶部的偏移量```html<header><div><h1>Somewebsite</h1><nav><ul><li><ahref=\"#section-first\">Section1</a></li><li><ahref=\"#section-second\">Section2</a></li><li><ahref=\"#section-third\">Section3</a></li><li><ahref=\"#section-fourth\">Section4</a></li></ul></nav></div></header><main><sectionid=\"section-first\"><h2>Loremipsumtitle1</h2><article>Loremipsumdolorsitamet,consecteturadipiscingelit.Suspendisseullamcorper,massaeurhoncusporttitor,enimduiscelerisqueaugue,sedeleifendquamdolorrhoncusdolor.Nuncsitametornaremi,euvestibulumlectus.Maurisacultriciesfelis.Praesentutorcivestibulum,tinciduntpurusin,malesuadaelit.Phasellustempordolorataccumsansuscipit.Maecenasefficiturhendreritenimidpellentesque.Nuncplaceratnibhsitametmalesuadavestibulum.Utscelerisquesitametvelitinmattis.Mauriserataugue,eleifendnecposuerenec,vehiculavitaenibh.Inhachabitasseplateadictumst.</article></section><sectionid=\"section-second\"><h2>Loremipsumtitle2</h2><article>Loremipsumdolorsitamet,consecteturadipiscingelit.Suspendisseullamcorper,massaeurhoncusporttitor,enimduiscelerisqueaugue,sedeleifendquamdolorrhoncusdolor.Nuncsitametornaremi,euvestibulumlectus.Maurisacultriciesfelis.Praesentutorcivestibulum,tinciduntpurusin,malesuadaelit.Phasellustempordolorataccumsansuscipit.Maecenasefficiturhendreritenimidpellentesque.Nuncplaceratnibhsitametmalesuadavestibulum.Utscelerisquesitametvelitinmattis.Mauriserataugue,eleifendnecposuerenec,vehiculavitaenibh.Inhachabitasseplateadictumst.</article></section><sectionid=\"section-third\"><h2>Loremipsumtitle3</h2><article>Loremipsumdolorsitamet,consecteturadipiscingelit.Suspendisseullamcorper,massaeurhoncusporttitor,enimduiscelerisqueaugue,sedeleifendquamdolorrhoncusdolor.Nuncsitametornaremi,euvestibulumlectus.Maurisacultriciesfelis.Praesentutorcivestibulum,tinciduntpurusin,malesuadaelit.Phasellustempordolorataccumsansuscipit.Maecenasefficiturhendreritenimidpellentesque.Nuncplaceratnibhsitametmalesuadavestibulum.Utscelerisquesitametvelitinmattis.Mauriserataugue,eleifendnecposuerenec,vehiculavitaenibh.Inhachabitasseplateadictumst.</article></section><sectionid=\"section-fourth\"><h2>Loremipsumtitle4</h2><article>Loremipsumdolorsitamet,consecteturadipiscingelit.Suspendisseullamcorper,massaeurhoncusporttitor,enimduiscelerisqueaugue,sedeleifendquamdolorrhoncusdolor.Nuncsitametornaremi,euvestibulumlectus.Maurisacultriciesfelis.Praesentutorcivestibulum,tinciduntpurusin,malesuadaelit.Phasellustempordolorataccumsansuscipit.Maecenasefficiturhendreritenimidpellentesque.Nuncplaceratnibhsitametmalesuadavestibulum.Utscelerisquesitametvelitinmattis.Mauriserataugue,eleifendnecposuerenec,vehiculavitaenibh.Inhachabitasseplateadictumst.</article></section></main><footer>Footer</footer>``````css*{box-sizing:border-box;}html{scroll-padding-top:6rem;scroll-behavior:smooth;}navul{list-style:none;display:flex;gap:1em;margin:0;padding:0;}header{position:fixed;top:0;left:0;right:0;background-color:#eeeeee;}header>div{display:flex;padding:02rem;justify-content:space-between;align-items:baseline;max-width:768px;margin:0auto;}main{width:768px;margin:0auto;padding-top:6rem;}section{min-height:50vh;background-color:#f9f9f9;padding:1rem2rem;margin-bottom:1.5rem;}footer{min-height:40vh;text-align:center;}```<style>*{box-sizing:border-box;}html{scroll-padding-top:6rem;scroll-behavior:smooth;}navul{list-style:none;display:flex;gap:1em;margin:0;padding:0;}header{position:fixed;top:0;left:0;right:0;background-color:#eeeeee;}header>div{display:flex;padding:02rem;justify-content:space-between;align-items:baseline;max-width:768px;margin:0auto;}main{width:768px;margin:0auto;padding-top:6rem;}section{min-height:50vh;background-color:#f9f9f9;padding:1rem2rem;margin-bottom:1.5rem;}footer{min-height:40vh;text-align:center;}</style>##兼容性![](./.assets/scroll-padding-top-2022-07-14-15-38-52.png)","CSS\\attribute\\shap-outside.md":"#shape-outside>定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装><https://developer.mozilla.org/zh-CN/docs/Web/CSS/shape-outside>","CSS\\attribute\\transform.md":"#transform>`transform:translate(位移)|scale(缩放)|rotete(旋转)|skew(倾斜)`>不支持inline元素,使用时候需要变成block>deg单位为角度单位##translate>位移```csstranslate(x,y);translateX(x);translateY(y);translateZ(z);/*需要在父容器上加上perspective元素*/translate3d(x,y,z);/*需要在父容器上加上perspective元素*/```<style>:root{--w:20px;--h:20px;--bg:#20810f;--box-c:#ff85c0;}table{width:100%;}.td-container{width:100px;height:50px;background:#fff;}.tf{width:var(--w);height:var(--h);background:var(--bg);display:flex;justify-content:center;align-items:center;}</style><style>.tfx{transform:translateX(var(--X));}.tfy{transform:translateY(var(--Y));}.tfxy{transform:translate(var(--X),var(--Y));}.tfz{transform:perspective(30px)translateZ(var(--Z));}.tf3d{transform:perspective(30px)translate3d(var(--X),var(--Y),var(--Z));}</style><tableborder=\"1\"><tr><td>translate</td><td>示例</td></tr><tr><td>translateX(x);</td><td><divclass=\"td-container\"><divclass=\"tftfx\"style=\"--X:30px;\"></div></td></tr><tr><td>translateY(y);</td><td><divclass=\"td-container\"><divclass=\"tftfy\"style=\"--Y:10px;\"></div></td></tr><tr><td>translate(x,y);</td><td><divclass=\"td-container\"><divclass=\"tftfxy\"style=\"--Y:10px;--X:10px;\"></div></td></tr><tr><td>translateZ(z);<br/>需要和perspective配合使用(将观察者相对于z=0处的平面进行定位)<br/>里面的参数就相当于向前移动了多少像素</td><td><divclass=\"td-container\"><divclass=\"tftfz\"style=\"--Z:10px;\"></div></td></tr><tr><td>translate3d(z);<br/>需要和perspective配合使用(将观察者相对于z=0处的平面进行定位)<br/>里面的参数就相当于向前移动了多少像素</br>z轴大小要小于该参数</td><td><divclass=\"td-container\"><divclass=\"tftf3d\"style=\"--Z:10px;--X:10px;--Y:10px;\"></div></td></tr></table>##scale>注意参数都是数字>放大```cssscaleX(x);scaleY(y);scaleZ(z);scale(x,y);scale3d();/*待补充*/scale(整数放大倍数);```<style>.scx{transform:scaleX(var(--X))}.scy{transform:scaleY(var(--Y))}.scz{transform:scaleX(var(--Z))}.sc{transform:scale(var(--X),var(--Y))}.scn{transform:scale(var(--Num))}.sc3d{transform:scale3d(var(--X),var(--Y),var(--Z))}</style><tableborder=\"1\"><tr><td>scale</td><td>示例</td></tr><tr><td>scaleX(x);</td><td><divclass=\"td-container\"><divclass=\"tfscx\"style=\"--X:1.5;\">1.5</div></td></tr><tr><td>scaleY(y);</td><td><divclass=\"td-container\"><divclass=\"tfscy\"style=\"--Y:1.5;\">1.5</div></td></tr><tr><td>scale(x,y);</td><td><divclass=\"td-container\"><divclass=\"tfsc\"style=\"--Y:1.5;--X:1.5;\">(1.5,1.5)</div></td></tr><tr><td>scaleZ(z);<td><divclass=\"td-container\"><divclass=\"tfscz\"style=\"--Z:1.5;\">1.5</div></td></tr><tr><td>scale3d(z);</td><td><divclass=\"td-container\"><divclass=\"tfsc3d\"style=\"--Z:2;--X:3;--Y:2;\">(2,3,2)</div></td></tr></tr><tr><td>scale(Num);(整体放大)</td><td><divclass=\"td-container\"><divclass=\"tfscn\"style=\"--Num:2\">2</div></td></tr></table>##rotate>旋转```cssrotate([<angle>|<zero>])/*顺时针旋转*/rotateZ([<angle>|<zero>])/*绕Z轴旋转*/rotateX([<angle>|<zero>])/*绕X轴旋转*/rotateY([<angle>|<zero>])/*绕Y轴旋转*/rotate3d([number],[number],[number],[<angle>|<zero>])```<style>.rt{transform:rotate(var(--angle))}.rtx{transform:rotateX(var(--angle))}.rty{transform:rotateY(var(--angle))}.rtz{transform:rotateZ(var(--angle))}.rt3d{transform:rotate3d(var(--X),var(--Y),var(--Z),var(--angle))}</style><tableborder=\"1\"><tr><td>rotate</td><td>示例</td></tr><tr><td>rotateX(45deg);</td><td><divclass=\"td-container\"><divclass=\"tfrtx\"style=\"--angle:45deg;\"></div></td></tr><tr><td>rotateY(45deg);</td><td><divclass=\"td-container\"><divclass=\"tfrty\"style=\"--angle:45deg\"></div></td></tr><tr><td>rotate(45deg);</td><td><divclass=\"td-container\"><divclass=\"tfrt\"style=\"--angle:45deg\"></div></td></tr><tr><td>rotateZ(z);<td><divclass=\"td-container\"><divclass=\"tfrtz\"style=\"--angle:-33deg\"></div></td></tr><tr><td>rotate3d(1,2,3,45deg);</td><td><divclass=\"td-container\"><divclass=\"tfrt3d\"style=\"--Z:2;--X:3;--Y:2;--angle:45deg;\"></div></td></table>##skew>歪斜```cssskewX([<angle>|<zero>])skewY([<angle>|<zero>])skew(([<angle>|<zero>],[<angle>|<zero>]?)```<style>.skew{transform:skew(15deg,15deg)}.skewx{transform:skewX(var(--angle))}.skewy{transform:skewY(var(--angle))}</style><tableborder=\"1\"><tr><td>skew</td><td>示例</td></tr><tr><td>skewX(45deg);</td><td><divclass=\"td-container\"><divclass=\"tfskewx\"style=\"--angle:45deg;\"></div></td></tr><tr><td>skewY(45deg);</td><td><divclass=\"td-container\"><divclass=\"tfskewy\"style=\"--angle:45deg\"></div></td></tr><tr><td>skew(15deg,15dep);</td><td><divclass=\"td-container\"><divclass=\"tfskew\"></div></td></tr><tr></table>##matrix>矩阵变换```cssmatrix()matrix(a,b,c,d,tx,ty)=>matrix3d(a,b,0,0,c,d,0,0,0,0,1,0,tx,ty,0,1)=>matrix(scaleX(),skewY(),skewX(),scaleY(),translateX(),translateY())matrix3d()matrix3d(a1,b1,c1,d1,a2,b2,c2,d2,a3,b3,c3,d3,a4,b4,c4,d4)```<style>.matr3d{transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,-5,-10,0,1.1)}.matr{transform:matrix(1,2,-1,1,40,20)}</style><tableborder=\"1\"><tr><td>skew</td><td>示例</td>k</tr><tr><td>matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,-5,-10,0,1.1);</td><td><divclass=\"td-container\"><divclass=\"tfmatr3d\"></div></td></tr><tr><td>matrix(1,2,-1,1,40,20);</td><td><divclass=\"td-container\"><divclass=\"tfmatr\"></div></td></tr></table>##视距`prtspective`>-perspective([length]):就是相当于定义人物（或观察者）＂离显示器中该元素的距离＂>-<bstyle=\"color:red;\">在3D空间中改变元素的形态时,基本上都要赋予元素一定H的视域。</b>>-视域为元素赋予前后深度，而这深度可以根据需要设定。​##移动原点`transform-origin`>-修改元素动画的变形原点>-旋转中心默认中心>-其他变换中心是是不太确定的>-都可以通过该属性进行修改```csstransform-origin:50%,50%;```##变换方式`tansform-style`>在一个三维空间中改变元素的形态，使用translate3d()，或许希望在3D空间中呈现元素。>一般这不是默认行为。默认情况下，不管怎么变形，得到的结果都是扁平的。但是可以使用transform-style修改。|`transform-style`|||-----------------|----------------||取值|`flat||初始值|`flat`||适用于|任何可变形的元素||计算值|指定的值||继承性|否||动画性|否|###原来```html<style>.mbd{border:1pxsolidred;}.outer{display:flex;width:150px;height:125px;justify-content:center;align-items:center;}.inner{width:50px;transform:perspective(750px)translateZ(60px)rotateX(60deg);}</style><divclass=\"outermbd\"><divclass=\"innermbd\">inner</div></div>```<style>.mbd{border:1pxsolidred;}.outer{display:flex;width:150px;height:125px;justify-content:center;align-items:center;}.inner{width:50px;transform:perspective(750px)translateZ(60px)rotateX(60deg);}</style><divclass=\"outermbd\"><divclass=\"innermbd\">inner</div></div>###后```html<divstyle=\"display:flex;width:150px;height:125px;justify-content:center;align-items:center;transform:perspective(750px)translateY(60px)rotateX(-20deg);transform-style:perserve-3d;overflow:visible;filter:none;clip:auto;clip-path:none;mask-image:none;mask-border-source:none;mix-blend-mode:normal;border:1pxsolidred;\"><divstyle=\"width:50px;border:1pxsolidred;transform:perspective(750px)translateZ(60px)rotateX(60deg);\">inner</div></div>```<divstyle=\"display:flex;width:150px;height:125px;justify-content:center;align-items:center;transform:perspective(750px)translateY(60px)rotateX(-20deg);transform-style:perserve-3d;overflow:visible;filter:none;clip:auto;clip-path:none;mask-image:none;mask-border-source:none;mix-blend-mode:normal;border:1pxsolidred;\"><divstyle=\"width:50px;border:1pxsolidred;transform:perspective(750px)translateZ(60px)rotateX(60deg);\">inner</div></div><br/><br/><br/><br/><br/>##处理背面`backface-visibility`>在3D变形中，backface-visibility属性可以看到元素的背面。>一个元素的backface-visibility属性设置为visible，另一个设置为hidden。<style>.card{position:relative;perspective:800px;transform-style:preserve-3d;width:200px;height:280px;transition:all.6s;border:1pxsolid#000;border-radius:4px;}.card:hover{transform:rotateY(180deg);}img{position:absolute;width:100%;height:100%;transition:all.5s;backface-visibility:hidden;}/*由于我们将两个图像都藏在了背面，所以另一面没有任何东西。所以接下来需要再把.front-face翻转180度*/.back-face{transform:rotateY(180deg);}</style><divclass=\"card\"><imgclass=\"front-face\"src=\"https://api.pixivweb.com/anime18r.php?return=img\"><imgclass=\"back-face\"src=\"https://api.pixivweb.com/bw.php?return=img\"></div>","CSS\\attribute\\transition.md":"#transition>vscode可以支持动图>transition-property、transition-duration、transition-timing-function,transition-delay>`transition-duration`:为必填项>简写```csstransition:all5slinear.2s;//以空格隔开属性transition:all5slinear.2s,height3sease-in-out;//可以以逗号隔开多个过渡。```<div><style>.test1{width:300px;height:100px;background:green;transition:all2slinear.2s;}.test1:hover{width:250px;height:50px;background:#ff85c0;}</style><divclass=\"test1\"></div></div>##transition-property>可以选择对某一个属性进行添加特效```csstransition-property:all;//默认为all，所有可被动画的属性都表现出过渡动画。transition-property:none;//没有动画效果transition-property:width,height;//也可以取其他属性的值```###all<div><style>.test2{width:300px;height:100px;background:green;transition:all2slinear.2s;}.test2:hover{width:250px;height:50px;background:#ff85c0;}</style><divclass=\"test2\"></div></div>###none<div><style>.test3{width:300px;height:100px;background:green;transition:none2slinear.2s;}.test3:hover{width:250px;height:50px;background:#ff85c0;}</style><divclass=\"test3\"></div></div>###自选>这里选的是`width`<div><style>.test4{width:300px;height:100px;background:green;transition:width2slinear.2s;}.test4:hover{width:250px;height:50px;background:#ff85c0;}</style><divclass=\"test4\"></div></div>##transition-duration>动画时间```csstransition-duration:1s;transition-duration:1ms;transition-duration:1s,10s,10ms;//对应多个动画的属性```###1s<div><style>.test5{width:300px;height:100px;background:green;transition:all1slinear.2s;}.test5:hover{width:250px;height:50px;background:#ff85c0;}</style><divclass=\"test5\"></div></div>###1ms<div><style>.test7{width:300px;height:100px;background:green;transition:all1mslinear.2s;}.test7:hover{width:250px;heigth:50px;background:#ff85c0;}</style><divclass=\"test7\"></div></div>###1s,3s,10ms<div><style>.test6{width:300px;height:100px;background:green;margin-left:0;/*transition:all1mslinear.2s;*/transition-property:width,margin-left,background;transition-duration:1s,3s,10ms;transition-timing-function:linear;transition-delay:.2s;}.test6:hover{width:250px;heigth:50px;margin-left:10px;background:#ff85c0;}</style><divclass=\"test6\"></div></div>##transition-timing-function>过渡动画<div><style>:root{--w-before:100px;--w-after:50px;--h-before:100px;--h-after:50px;--bg-before:#20810f;--bg-after:#ff85c0;}table{width:100%;}.t-center{text-align:center;}.ttf{width:var(--w-before);height:var(--h-before);background:var(--bg-before);/*transition:all2slinear.2s;*/transition-property:width,height,background;transition-duration:1s,3s,10ms;transition-timing-function:var(--ttf);transition-delay:.2s;display:flex;justify-content:center;align-items:center;}.ttf:hover{width:var(--w-after);height:var(--h-after);background:var(--bg-after);}</style><tableborder=\"1\"><tr><td>transition-timing-function</td><tdclass=\"t-center\">示例</td><tdclass=\"t-center\">描述</td></tr><tr><td>ease</td><td><divclass=\"ttf\"style=\"--ttf:ease;\">ease</div></td><td>默认值，慢速开始，中间变快，慢速结束；相当于cubic-bezier(0.25,0.1,0.25,1)</td></tr><tr><td>linear</td><td><divclass=\"ttf\"style=\"--ttf:linear;\">linear</div></td><td>匀速运动；相当于cubic-bezier(0,0,1,1)</td></tr><tr><td>ease-in</td><td><divclass=\"ttf\"style=\"--ttf:ease-in;\">ease-in</div></td><td>慢速开始；相当于cubic-bezier(0.42,0,1,1)</td></tr><tr><td>ease-out</td><td><divclass=\"ttf\"style=\"--ttf:ease-out;\">ease-out</div></td><td>慢速结束；相当于cubic-bezier(0,0,0.58,1)</td></tr><tr><td>ease-in-out</td><td><divclass=\"ttf\"style=\"--ttf:ease-in-out;\">ease-in-out</div></td><td>慢速开始，慢速结束；相当于cubic-bezier(0.42,0,0.58,1)</td></tr><tr><td>step-start</td><td><divclass=\"ttf\"style=\"--ttf:step-start;\">step-start</div></td><td></td></tr><tr><td>step-end</td><td><divclass=\"ttf\"style=\"--ttf:step-end;\">step-end</div></td><td></td></tr><tr><td>steps(4,end)</td><td><divclass=\"ttf\"style=\"--ttf:step(4,end);\">step(4,end)</div></td><td></td></tr></table></div>##transition-delay>延迟时间```csstransition-delay:1s;```<div><style>.test41{width:300px;height:100px;background:green;transition:all2slinear1s;}.test41:hover{width:250px;height:50px;background:#ff85c0;}</style><divclass=\"test41\"></div></div>##过渡状态切换```css.app{width:300px;transition:all3slinear0.2s;}.app:hover{width:100;transition:all1slinear0.2s;}```","CSS\\attribute\\user-select.md":"#[`user-select`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/user-select)>控制用户能否选中文本。除了文本框内，它对被载入为chrome的内容没有影响。![](./.assets/user-select-2022-11-04-10-37-52.png)##破除当前属性效果```jsdocument.body.contentEditable=false```","CSS\\attribute\\_-content.md":"#\\*-content-`max-content`：内容有多宽，容器就有多宽，不会受父级的限制-`min-content`：宽度是最大内容的最小宽度-`fit-content`：在不超过父级大小的情况下将自己包裹的最大容器","CSS\\attribute\\毛玻璃.md":"#毛玻璃-`backdrop-filter`:元素后面影响-`filter`:元素本身影响```cssbackdrop-filter:blur(10px)blur:模糊brightness:亮度contrast:对比度drop-shadow:投影grayscale:灰度hue-rotate:色调变化invert:反像opacity:透明度saturate:饱和度sepia:褐色```","CSS\\attribute\\颜色\\currentColor.md":"#`currentColor`-`currentColor`经常被叫做『第一个CSS变量』-`currentColor`的值等于当前元素的`color`属性值，看上去有些像继承。它可以被应用于任何可以接收color值的属性中，比如`border-color`,`background`,`box-shadow`等。-当在同一个CSS选择器中，需要将同一个颜色值应用到多个接收color值的CSS属性上（例如`border-color`，`background`,`box-shadow`）时，`currentColor`就派上用场了。```html<asideclass=\"success\">Loremipsumdolorsitamet,consecteturadipiscingelit.Nullamauctortellusactempussollicitudin.Maurisquameros,viverraegetpulvinarat,scelerisquenonvelit.</aside><asideclass=\"warning\">Vestibulumdapibus,liberononvenenatissuscipit,elitliberoscelerisqueodio,neclaoreetipsumsemsednibh.Nullafacilisi.</aside><asideclass=\"error\">Vivamusrhoncusdignissimdiam,iddictumloremtinciduntsitamet.Craseterosurna.Proinpulvinarenimacongueporttitor.</aside>``````css<style>aside{border-left:5pxsolidcurrentColor;box-shadow:5px5px10pxcurrentColor;margin-bottom:20px;}.success{color:darkgreen;}.warning{color:darkgoldenrod;}.error{color:darkred;}```<asideclass=\"success\">Loremipsumdolorsitamet,consecteturadipiscingelit.Nullamauctortellusactempussollicitudin.Maurisquameros,viverraegetpulvinarat,scelerisquenonvelit.</aside><asideclass=\"warning\">Vestibulumdapibus,liberononvenenatissuscipit,elitliberoscelerisqueodio,neclaoreetipsumsemsednibh.Nullafacilisi.</aside><asideclass=\"error\">Vivamusrhoncusdignissimdiam,iddictumloremtinciduntsitamet.Craseterosurna.Proinpulvinarenimacongueporttitor.</aside><style>aside{border-left:5pxsolidcurrentColor;box-shadow:5px5px10pxcurrentColor;margin-bottom:20px;}.success{color:darkgreen;}.warning{color:darkgoldenrod;}.error{color:darkred;}</style>##兼容性![](./.assets/currentColor-2022-07-14-14-43-21.png)","CSS\\attribute\\颜色\\radial-gradient.md":"#radial-gradient>渐变色```cssackground-image:radial-gradient(shapesizeatposition,start-color,...,last-color);```|值|描述||:-----------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||_shape_|确定圆的类型:<br/>ellipse(默认):指定椭圆形的径向渐变。<br/>circle：指定圆形的径向渐变||_size_|定义渐变的大小，可能值：<br/>farthest-corner(默认):指定径向渐变的半径长度为从圆心到离圆心最远的角<br/>closest-side：指定径向渐变的半径长度为从圆心到离圆心最近的边<br/>closest-corner：指定径向渐变的半径长度为从圆心到离圆心最近的角<br/>farthest-side：指定径向渐变的半径长度为从圆心到离圆心最远的边||_position_|定义渐变的位置。可能值：<br/>**center**（默认）：设置中间为径向渐变圆心的纵坐标值。<br/>**top**：设置顶部为径向渐变圆心的纵坐标值。<br/>**bottom**：设置底部为径向渐变圆心的纵坐标值。||_start-color,...,last-color_|用于指定渐变的起止颜色。|","CSS\\background\\index.md":"#backgroundbackground-color:#fff000|rgb(255,255,255)|red|agba(255.255.255.0.9)background-image:url('paper.gif')background-repeat:no-repreat(没有平铺)|repeat-x(水平平铺)|repeat-y(垂直平铺)background-attachment:|值|说明||-------|-----------------------------------------------||scroll|背景图片随页面的其余部分滚动。这是默认||fixed|背景图像是固定的||inherit|指定background-attachment的设置应该从父元素继承||local|背景图片随滚动元素滚动|background-position:center|单一关键字|等价的关键字||:---------|:-----------------------------||center|centercenter||top|topcenter或centertop||bottom|bottomcenter或centerbottom||right|rightcenter或centerright||left|leftcenter或centerleft|##background-size>用于控制背景图片的尺寸的大小>>`background-size`:宽高>>`background-size:cover;`:>>​作用:将背景图片按照比例缩放到最小尺寸,使其可以完整覆盖背景区域>>​主要作用于:背景图片<容器小>>`background:contian;`:>>​作用:将背景图片按比例将图片缩放到最大尺寸,使其高宽都在背景区域总>>​主要作用于:背景图片>容器(背景图片可能会发生扭曲)```cssdiv{background:url(bg_flower.gif);-moz-background-size:63px100px;/*老版本的Firefox*/background-size:63px100px;background-repeat:no-repeat;}```##background-origin:规定背景图片的定位区域>背景图片可以放置于content-box、padding-box或border-box区域。![](https://images.gitee.com/uploads/images/2020/0521/204114_f4fa818f_6545143.png)```cssdiv{background:url(bg_flower.gif);background-repeat:no-repeat;background-size:100%100%;-webkit-background-origin:content-box;/*Safari*/background-origin:content-box;}```![](https://images.gitee.com/uploads/images/2020/0521/204314_74d8bc39_6545143.png)```css//多重背景图片body{background-image:url(bg_flower.gif),url(bg_flower_2.gif);}```##background-clip:规定背景的绘制区域```cssbackground-clip:border-box|padding-box|content-box;```","CSS\\basis\\1px.md":"#1px-设备像素：设备的物理像素，其尺寸大小是绝对的-逻辑像素：CSS的像素单位，其尺寸大小是相对的，也称为独立像素-分辨率：屏长的设备像素×屏宽的设备像素-dpi（dotsperinch）：像素密度，表示水平或垂直方向每英寸长度的像素数目-ppi（pixelsperinch）：像素密度，表示沿对角线每英寸长度的像素数目-缩放因子（ScaleFactor）：逻辑像素相对于设备像素的放大比例，可通过window.devicePixelRatio获得，但二者并不完全等同-关系一：-设备尺寸×像素密度=分辨率（设备像素）-iphone6s对角线长度为5.5inches，像素密度401ppi，分辨率1920\\*1080，计算可得对角线的设备像素为2205.5。-5.5\\*401=2205.5-关系二：-逻辑像素=设备像素×缩放因子-iphone6逻辑像素为375_667，分辨率为750_1334，缩放因子为2-1个逻辑像素=设备宽度的1/375-1个设备像素=设备宽度的1/750-1/375=1/750\\*2","CSS\\basis\\index.md":"##max-device-width与max-width区别-max-width指的是显示区域的宽度，比如浏览器的显示区域宽度\\*\\*-max-device-width指的是设备整个渲染（显示）区域的宽度，比如设备的实际屏幕大小，也就是设备分辨率\\*\\*##FF2.0>父元素不能支持自适应子元素的高度**MozillaFirefox2**是**Firefox**的版本的问题,##置换元素,不可替换元素a)置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。例如：浏览器会根据`<img>`标签的src属性的值来读取图片信息并显示出来，而如果查看(x)html代码，则看不到图片的实际内容；`<input>`标签的type属性来决定是显示输入框，还是单选按钮等。(x)html中的`<img>、<input>、<textarea>、<select>、<object>`都是置换元素。这些元素往往没有实际的内容，即是一个空元素。置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。b)不可替换元素：(x)html的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。例如：`<label>label中的内容</label>`标签`<label>`是一个非置换元素，文字label中的内容”将全被显示。##默认支持跨域的标签-image,iframe,img,##fieldset>legend```html<fieldset><legend>类型名</legend>内容显示</fieldset>```##预备格式化标签```html<pre>>```","CSS\\basis\\W3C和IE盒模型.md":"#W3C盒模型和IE盒模型>E的盒模型问题只会出现在IE5.5及其更早的版本中，因为在IE6及更新的版本在标准兼容模式下使用的是W3C的盒模型标准，但事实上不仅IE5.5，连IE6的使用率也很少了，这里对他们进行讨论只是为了更深刻的理解盒模型。![img](.assets/20150629102231720)##例子```html<!--没有声明--><html><headlang=\"ch\"><metacharset=\"UTF-8\"/><title></title><style>.box{float:left;width:100px;height:100px;background-color:#ff9000;}.container{width:200px;padding:10px;background-color:#f00;overflow:hidden;}</style></head><body><divclass=\"container\"><divclass=\"box\"></div><divclass=\"box\"></div></div><script></script></body></html>```无论IE还是其他都会显示![img](.assets/20150629102836021)但是给container添加padding```css.container{width:200px;background-color:#f00;overflow:hidden;padding:10px;}```则其在非IE下的样式为：![W3C](.assets/20150629103146025)但在IE下为：![IE](.assets/20150629103238709)","CSS\\basis\\优先级.md":"#优先级##媒体查询的语法优化```css/*媒体查询Level4之前*/@media(max-width:30em){/*…*/}/*媒体查询Level4中*/@media(width<=30em){/*…*/}/*媒体查询Level4之前*/@media(min-width:30em)and(max-width:50em){/*…*/}/*媒体查询Level4中*/@media(30em<=width<=50em){/*…*/}```","CSS\\basis\\元素隐藏.md":"#元素隐藏```display:none;设置为隐藏,且不会渲染,不会占据空间visibility:hidden;设置为隐藏,但是还是会占用空间rgba()或opacity改变其透明度为1,也同样可以达到元素隐藏的效果```","CSS\\basis\\内核前缀.md":"#内核前缀>主流浏览器内核私有属性css前缀：>>mozilla内核(firefox,flock等)-moz>webkit内核(safari,chrome等)-webkit>opera内核(opera浏览器)-o>trident内核(ie浏览器)-ms","CSS\\basis\\单位.md":"#单位>-CSS像素、物理像素、逻辑像素、设备像素比、PPI、Viewport>-浏览器内的一切长度都是以css箱数为单位,css像素的单位是px>-css规范中:长度主要有绝对(absolute)单位和相对(relative)单位##PX>-相对长度单位，相对与电脑显示屏的分辨率而言。>-特点：IE无法调整px单位的字体大小>-不是一个确定的值,不同的设备,图像基本采样单元是不同的,显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为`ppi`和`dpi`：>>ppi(dotsperinch)：像素密度,表示沿对角线每英寸长度的像素数目>>dpi(pixelsperinch)：像素密度,表示水平或垂直方向每英寸长度的像素数目>>关于打印机的点距我们不去关心，只要知道当用于描述显示器设备时ppi与dpi是同一个概念。##EM>-相对长度单位，相对于对象内的字体文字的尺寸，如果行内文本没有认为设置文字尺寸，则相对于浏览器的字体默认尺寸。>-一般相对于rootem元素的长度,一般是父元素特点：```js1.em的值不会固定2.em会继承父级元素的字体大小浏览器的字体尺寸默认的大小是16px，没进行过调整的浏览器的符合16px=1em这个规则，所以12px=0.75em，10px=0.625em，为了简化font-size的计算方式，在body选择器里添加font-size=62.5%，由此以来，在使用em单位的时候，10px=1em;```##REM（rootem）>css3新增加的相对长度单位，直接相对于根元素`<html>`，可以忽略层级关系。##vh/vw>-CSS3新增样式，部分浏览器（IE8）不支持。>-vh、vw：相对于视窗（Viewport）的高度和宽度>-1vh等于1/100的视窗高度，1vw等于1/100的视窗宽度。>-视窗:是指浏览器内部的可视区域大小，即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。##vmin/vmax>-CSS3新增样式，部分浏览器（IE8）不支持。>-vmin：取视窗高度和宽度的最小值作为基准。>-vmax：取视窗高度和宽度的最大值作为基准。>-浏览器视窗大小为window.innerWidth=1000px，window.innerHeight=800px，那么，1vmin=800px/100=8px;1vmax=1000px/100=10px。>>使用场景：做移动页面开发时，如果使用vw、wh设置字体大小（比如5vw），在竖屏和横屏状态下显示的字体大小是不一样的。由于vmin和vmax是当前较小的vw和vh和当前较大的vw和vh。这里就可以用到vmin和vmax。使得文字大小在横竖屏下保持一致##%>-相对于父元素的长度高度>-注意1：position:fixed时，无论当前元素放在哪里，将相对于窗口宽度>-注意2：position:absolute时，将相对于其相对的元素宽度（递归父元素直到第一个设置了position的元素）##获取页面,屏幕的大小参数>JavaScript获取获取屏幕、浏览器窗口，浏览器，网页高度、宽度的大小>网页可见区域宽：document.body.clientWidth>网页可见区域高：document.body.clientHeight>网页可见区域宽：document.body.offsetWidth(包括边线的宽)>网页可见区域高：document.body.offsetHeight(包括边线的宽)>网页正文全文宽：document.body.scrollWidth>网页正文全文高：document.body.scrollHeight>网页被卷去的高：document.body.scrollTop>网页被卷去的左：document.body.scrollLeft>网页正文部分上：window.screenTop>网页正文部分左：window.screenLeft>屏幕分辨率的高：window.screen.height>屏幕分辨率的宽：window.screen.width>屏幕可用工作区高度：window.screen.availHeight>屏幕可用工作区宽度：window.screen.availWidth>>HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidth>scrollHeight:获取对象的滚动高度。>scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离>scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离>scrollWidth:获取对象的滚动宽度>offsetHeight:获取对象相对于版面或由父坐标offsetParent属性指定的父坐标的高度>offsetLeft:获取对象相对于版面或由offsetParent属性指定的父坐标的计算左侧位置>offsetTop:获取对象相对于版面或由offsetTop属性指定的父坐标的计算顶端位置>event.clientX相对文档的水平座标>event.clientY相对文档的垂直座标>event.offsetX相对容器的水平坐标>event.offsetY相对容器的垂直坐标>document.documentElement.scrollTop垂直方向滚动的值>event.clientX+document.documentElement.scrollTop相对文档的水平座标+垂直方向滚动的量>>IE，FireFox差异如下：>>IE6.0、FF1.06+：>>clientWidth=width+padding>>clientHeight=height+padding>>offsetWidth=width+padding+border>>offsetHeight=height+padding+border>>IE5.0/5.5：>clientWidth=width-border>>clientHeight=height-border>>offsetWidth=width>>offsetHeight=height>>(需要提一下：CSS中的margin属性，与clientWidth、offsetWidth、clientHeight、offsetHeight均无关)>>网页可见区域宽：document.body.clientWidth>网页可见区域高：document.body.clientHeight>网页可见区域宽：document.body.offsetWidth(包括边线的宽)>网页可见区域高：document.body.offsetHeight(包括边线的高)>网页正文全文宽：document.body.scrollWidth>网页正文全文高：document.body.scrollHeight>网页被卷去的高：document.body.scrollTop>网页被卷去的左：document.body.scrollLeft>网页正文部分上：window.screenTop>网页正文部分左：window.screenLeft>屏幕分辨率的高：window.screen.height>屏幕分辨率的宽：window.screen.width>屏幕可用工作区高度：window.screen.availHeight>屏幕可用工作区宽度：window.screen.availWidth>>div.style.top：相对于div所在的元件的顶部距离","CSS\\basis\\权重.md":"#权重计算|标签选择器|计算权重公式||:---------------------------------------------------|:-----------||继承或者\\*|0,0,0,0||每个元素（标签选择器）|0,0,0,1||每个类，结构伪类(如:hover),属性选择器[type=\"number\"]|0,0,1,0||每个ID|0,1,0,0||每个行内样式style=\"\"|1,0,0,0||h1+p::first-line|0,0,0,3||li>a[href*=\"beige.world\"]>.inline-warning|0,0,2,2||每个!important重要的|∞无穷大|>-值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越","CSS\\basis\\选择器.md":"#选择器|属性|选择器||----------|-----------------------||html元素|直接html标签,h1spanp||id|#||class|.||type|[type=\"属性\"]||!important|最高级选择器|##`[attr](属性)`用法:1.`[attr](有该属性)`2.[attr=xxx](属性值是xxx)3.`[attr^=xxx](属性是xxx开头)`4.`[attr$=xxx](属性是xxx结尾)`5.`[attr*=xxx](属性包含xxx)`##权重计算|选择器|权重||-------------------------|-----||!important|>1000||内联(style='color:#fff')|1000||id|100||class|10||伪类|10||元素|1||\\*|0||继承|无|##选择器的使用>内部样式和外部样式采用就近原则|选择器|书写||--------------|---------------------------------------------------------------------------------------||后代选择器|`h1span`||子代选择器|`h1>span`||伪类选择器|`:hover:link:visted:active`||相邻兄弟选择器|`span+span`||通用兄弟选择器|`p~span`(不一定要紧跟着,但是必须要有一个共同的父元素)<br>`p`元素之后的所有`span`元素||通用选择器|`*`||群组选择器|`span,p,h1`||结构伪类选择器|`:first-child:nth-child(n):last-child`||伪元素选择器|`:after:before`|","CSS\\demo\\div三角形.md":"#div三角形```css*{margin:0;padding:0;}.content{width:0;height:0;margin:0auto;border-width:20px;border-style:solid;border-color:transparenttransparentpinktransparent;}.content2{width:0;height:0;margin:0auto;border:50pxsolidtransparent;border-top:50pxsolidpink;}```","CSS\\demo\\index.md":"##允许您以确切的方式定义适应某个区域的具体内容-box-sizing```cssdiv{box-sizing:border-box;-moz-box-sizing:border-box;/*Firefox*/-webkit-box-sizing:border-box;/*Safari*/width:50%;float:left;}```","CSS\\demo\\templates&slots.md":"#template&slots>`<template>`和`<slot>`元素创建一个可以用来灵活填充Web组件的shadowDOM的模板。```html<style>dl{margin-left:6px;}dt{font-weight:bold;color:#217ac0;font-size:110%;}dt{font-family:Consolas,'LiberationMono',Courier;}dd{margin-left:16px;}</style><templateid=\"element-details-template\"><style>details{font-family:'OpenSansLight',Helvetica,Arial;}.name{font-weight:bold;color:#217ac0;font-size:120%;}h4{margin:10px0-8px0;}h4span{background:#217ac0;padding:2px6px2px6px;}h4span{border:1pxsolid#cee9f9;border-radius:4px;}h4span{color:white;}.attributes{margin-left:22px;font-size:90%;}.attributesh4{margin-bottom:10px;}.attributesp{margin-left:16px;font-style:italic;}</style><details><summary><span><codeclass=\"name\">&lt;<slotname=\"element-name\">NEEDNAME</slot>&gt;</code><iclass=\"desc\"><slotname=\"description\">NEEDDESCRIPTION</slot></i></span></summary><divclass=\"attributes\"><h4><span>Attributes</span></h4><slotname=\"attributes\"><p>None</p></slot></div></details><hr/></template><script>customElements.define('element-details',classextendsHTMLElement{constructor(){super()vartemplate=document.getElementById('element-details-template',).contentconstshadowRoot=this.attachShadow({mode:'open'}).appendChild(template.cloneNode(true),)}},)</script><element-details><spanslot=\"element-name\">slot</span><spanslot=\"description\">Aplaceholderinsideawebcomponentthatuserscanfillwiththeirownmarkup,withtheeffectofcomposingdifferentDOMtreestogether.</span><dlslot=\"attributes\"><dt>name</dt><dd>Thenameoftheslot.</dd></dl></element-details><element-details><spanslot=\"element-name\">template</span><spanslot=\"description\">Amechanismforholdingclient-sidecontentthatisnottoberenderedwhenapageisloadedbutmaysubsequentlybeinstantiatedduringruntimeusingJavaScript.</span></element-details>```![](./.assets/2022-01-10-17-09-40.png)","CSS\\demo\\黑白灰主题.md":"#黑白灰主题```css-webkit-filter:grayscale(100%);-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);```","CSS\\gradient\\linear-gradient.md":"#[linear-gradient](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/linear-gradient)>用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于`<gradient>`数据类型，是一种特别的`<image>`数据类型##线性渐变>线性渐变由一个轴(梯度线)定义，其上的每个点具有两种或多种的颜色，且轴上的每个点都具有独立的颜色。为了构建出平滑的渐变，`linear-gradient()`函数构建一系列垂直于渐变线的着色线，每一条着色线的颜色则取决于与之垂直相交的渐变线上的色点![](./.assets/linear-gradient-2022-12-14-15-16-06.png)-渐变线由包含渐变图形的容器的中心点和一个角度来定义的。渐变线上的颜色值是由不同的点来定义，包括起始点，终点，以及两者之间的可选的中间点（中间点可以有多个）-起始点是渐变线上代表起始颜色值的点。起始点由渐变线和过容器顶点的垂直线之间的交叉点来定义。（垂直线跟渐变线在同一象限内）-同样的，终点是渐变线上代表最终颜色值的点。终点也是由渐变线和从最近的顶点发出的垂直线之间的交叉点定义的，然而从起始点的对称点来定义终点是更容易理解的一种方式，因为终点是起点关于容器的中心点的反射点-关于起点和终点的稍微有些复杂的定义导致了一个有趣的性质，有时候被叫做不可思议的顶点效应：起点附近的点具有跟起点相同的颜色值，终点附近的点具有跟终点相同的颜色值-不仅仅只有起点和终点的颜色值可以指定。通过提供额外的颜色中间点，Web开发者可以构建在起始颜色值和终点颜色值之间的自定义更强的过渡效果，另外还可以提供多种颜色值的渐变线-当颜色中间点的位置被隐式定义，它被放置在位于它之前的点和位于它之后的点之间的中间位置处。利用`<length>`或者`<percentage>`数据类型可以显示定义一个位置```csslinear-gradient(red,orange,yellow,green,blue);linear-gradient(red0%,orange25%,yellow50%,green75%,blue100%);```<divstyle=\"width:100px;height:100px;background:linear-gradient(red,orange,yellow,green,blue);\"></div><divstyle=\"width:100px;height:100px;background:linear-gradient(red0%,orange25%,yellow50%,green75%,blue100%);\"></div>","CSS\\layout\\css-layout.md":"#css-layout##静态布局-制作的网页上的**元素尺寸一律以px为单位**。-布局特点：页面上的布局是按最初写代码时候的布局方式进行布局的，常规的pc网站是进行设置了宽度值进行布局的，不会随着pc端的屏幕的大小而变化。-缺点：不会随着pc端的屏幕大小而变化。##三栏布局>左右固定,中间自适应```html<sectionclass=\"layoutfloat\"><styletype=\"text/css\"media=\"screen\">.layout.float.wrapper>div{min-height:100px;}.layout.float.left{float:left;width:300px;background:red;}.layout.float.center{background:yellow;}.layout.float.right{float:right;width:300px;background:blue;}</style><articleclass=\"wrapper\"><divclass=\"left\"></div><divclass=\"right\"></div><divclass=\"center\"><h1>float布局</h1>1.我是float布局的中间部分2.我是float布局的中间部分</div></article></section><sectionclass=\"layoutabsolute\"><styletype=\"text/css\"media=\"screen\">.layout.absolute.wrapper{width:100%;margin-top:20px;}.layout.absolute.wrapper>div{min-height:100px;}.layout.absolute.left{position:absolute;left:0;width:300px;background:red;}.layout.absolute.center{position:absolute;left:300px;right:300px;background:yellow;}.layout.absolute.right{position:absolute;right:0;width:300px;background:blue;}</style><articleclass=\"wrapper\"><divclass=\"left\"></div><divclass=\"center\"><h1>absolute布局</h1>1.我是absolute布局的中间部分2.我是absolute布局的中间部分</div><divclass=\"right\"></div></article></section><sectionclass=\"layoutflex\"><styletype=\"text/css\"media=\"screen\">.layout.flex.wrapper{width:100%;min-height:100px;display:flex;margin-top:140px;}.layout.flex.left{width:300px;background:red;}.layout.flex.center{flex:1;background:yellow;}.layout.flex.right{width:300px;background:blue;}</style><articleclass=\"wrapper\"><divclass=\"left\"></div><divclass=\"center\"><h1>flex布局</h1>1.我是flex布局的中间部分2.我是flex布局的中间部分</div><divclass=\"right\"></div></article></section><sectionclass=\"layouttable\"><styletype=\"text/css\"media=\"screen\">.layout.table.wrapper{display:table;width:100%;min-height:100px;margin-top:20px;}.layout.table.left{display:table-cell;width:300px;background:red;}.layout.table.center{display:table-cell;background:yellow;}.layout.table.right{display:table-cell;width:300px;background:blue;}</style><articleclass=\"wrapper\"><divclass=\"left\"></div><divclass=\"center\"><h1>table布局</h1>1.我是table布局的中间部分2.我是table布局的中间部分</div><divclass=\"right\"></div></article></section><sectionclass=\"layoutgrid\"><styletype=\"text/css\"media=\"screen\">.layout.grid.wrapper{display:grid;grid-template-columns:300pxauto300px;grid-template-rows:100px;width:100%;margin-top:20px;}.layout.grid.left{background:red;}.layout.grid.center{background:yellow;}.layout.grid.right{background:blue;}</style><articleclass=\"wrapper\"><divclass=\"left\"></div><divclass=\"center\"><h1>grid布局</h1>1.我是grid布局的中间部分2.我是grid布局的中间部分</div><divclass=\"right\"></div></article></section>```##浮动布局浮动布局进行调用浮动属性改变页面中元素的位置，浮动布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂。浮动元素是脱离文档流的，但不脱离文本流。浮动元素有左浮动（float:left）和右浮动（float:right）两种```css.lian{width:90%;padding-left:5%;}.lianimg{float:right;margin-top:-180px;}.phoneulli{list-style:none;margin-top:50px;margin-left:70px;color:#808080;}.phoneulliimg{position:absolute;margin-left:-80px;float:left;margin-top:-5px;}.view{margin-top:50px;margin-left:-5px;float:left;}.viewinput{width:120px;height:40px;border-radius:6px;border:1pxsolid#3cb371;background-color:#3cb371;font-size:16px;color:white;}```-优点：兼容性比较好-缺点：浮动带来的影响比较多，页面宽度不够的时候会影响布局。##响应式布局>响应式设计与自适应设计的区别：>>-响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；>-自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是pc端、平板、手机，从而请求服务层，返回不同的页面。###**1.媒体查询**>-CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。>-移动端优先首先使用的是min-width，PC端优先使用的max-width####PC优先```css/*pcwidth>1024px*/body{background-color:yellow;}/*ipadpro*/@mediascreenand(max-width:1024px){body{background-color:#ff00ff;}}/*ipad*/@mediascreenand(max-width:768px){body{background-color:green;}}/*iphone678plus*/@mediascreenand(max-width:414px){body{background-color:blue;}}/*iphoneX*/@mediascreenand(max-width:375px)and(-webkit-device-pixel-ratio:3){body{background-color:#0ff000;}}/*iphone678*/@mediascreenand(max-width:375px)and(-webkit-device-pixel-ratio:2){body{background-color:#0ff000;}}/*iphone5*/@mediascreenand(max-width:320px){body{background-color:#0ff000;}}```####移动端优先```css/*iphone678*/body{background-color:yellow;}/*iphone5*/@mediascreenand(max-width:320px){body{background-color:red;}}/*iphoneX*/@mediascreenand(min-width:375px)and(-webkit-device-pixel-ratio:3){body{background-color:#0ff000;}}/*iphone678plus*/@mediascreenand(min-width:414px){body{background-color:blue;}}/*ipad*/@mediascreenand(min-width:768px){body{background-color:green;}}/*ipadpro*/@mediascreenand(min-width:1024px){body{background-color:#ff00ff;}}/*pc*/@mediascreenand(min-width:1100px){body{background-color:black;}}```###**2.百分比布局**>-计算复杂,难以还原设计稿```css/*pcwidth>1100px*/html,body{margin:0;padding:0;width:100%;height:100%;}aside{width:10%;height:100%;background-color:red;float:left;}main{height:100%;background-color:blue;overflow:hidden;}/*ipadpro*/@mediascreenand(max-width:1024px){aside{width:8%;background-color:yellow;}}/*ipad*/@mediascreenand(max-width:768px){aside{float:none;width:100%;height:10%;background-color:green;}main{height:calc(100vh-10%);background-color:red;}}/*iphone678plus*/@mediascreenand(max-width:414px){aside{float:none;width:100%;height:5%;background-color:yellow;}main{height:calc(100vh-5%);background-color:red;}}/*iphoneX*/@mediascreenand(max-width:375px)and(-webkit-device-pixel-ratio:3){aside{float:none;width:100%;height:10%;background-color:blue;}main{height:calc(100vh-10%);background-color:red;}}/*iphone678*/@mediascreenand(max-width:375px)and(-webkit-device-pixel-ratio:2){aside{float:none;width:100%;height:3%;background-color:black;}main{height:calc(100vh-3%);background-color:red;}}/*iphone5*/@mediascreenand(max-width:320px){aside{float:none;width:100%;height:7%;background-color:green;}main{height:calc(100vh-7%);background-color:red;}}```###**3.rem布局**>-REM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。>-rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。rem响应式的布局思想：一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值高度值可以设置固定值，设计稿有多大，我们就严格有多大所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值)js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了rem布局的缺点：在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前```css/*将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/functionrefreshRem(){vardocEl=doc.documentElement;varwidth=docEl.getBoundingClientRect().width;varrem=width/10;docEl.style.fontSize=rem+'px';flexible.rem=win.rem=rem;}win.addEventListener('resize',refreshRem);```rem布局适配多屏幕适配的最佳方式```css/*pcwidth>1100px*/html{font-size:100%;}body{background-color:yellow;font-size:1.5rem;}/*ipadpro*/@mediascreenand(max-width:1024px){body{background-color:#ff00ff;font-size:1.4rem;}}/*ipad*/@mediascreenand(max-width:768px){body{background-color:green;font-size:1.3rem;}}/*iphone678plus*/@mediascreenand(max-width:414px){body{background-color:blue;font-size:1.25rem;}}/*iphoneX*/@mediascreenand(max-width:375px)and(-webkit-device-pixel-ratio:3){body{background-color:#0ff000;font-size:1.125rem;}}/*iphone678*/@mediascreenand(max-width:375px)and(-webkit-device-pixel-ratio:2){body{background-color:#0ff000;font-size:1rem;}}/*iphone5*/@mediascreenand(max-width:320px){body{background-color:#0ff000;font-size:0.75rem;}}```###**4.视口单位**>-css3中引入了一个新的单位vw/vh，与视图窗口有关|单位|含义||----|---------------------------------------------------------||vw|相对于视窗的宽度，1vw等于视口宽度的1%，即视窗宽度是100vw||vh|相对于视窗的高度，1vh等于视口高度的1%，即视窗高度是100vh||vmin|vw和vh中的较小值||vmax|vw和vh中的较大值|用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。例如，在桌面端浏览器视口尺寸为650px，那么1vw=650\\*1%=6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。使用视口单位来实现响应式有两种做法：1.仅使用vw作为CSS单位2.搭配vw和rem","CSS\\layout\\display.md":"#display|值|作用||:-------------------|:---------------------------------------------------------------------------||`none`|使用后元素将不会显示||`grid`|定义一个容器属性为网格布局||`flex`|定义一个弹性布局||`block`|使用后元素将变为块级元素显示，元素前后带有换行符||`inline`|display默认值。使用后原色变为行内元素显示，前后无换行符||`list-item`|使用后元素作为列表显示run-in使用后元素会根据上下文作为块级元素或行内元素显示||`table`|使用后将作为块级表格来显示（类似`<table>`），前后带有换行符||`inline-table`|使用后元素将作为内联表格显示（类似`<table>`），前后没有换行符||`table-row-group`|元素将作为一个或多个行的分组来显示（类似`<tbody>`）||`table-header-group`|元素将作为一个或多个行的分组来表示（类似`<thead>`）||`table-footer-group`|元素将作为一个或多个行分组显示（类似`<tfoot>`）||`table-row`|元素将作为一个表格行显示（类似`<tr>`）||`table-column-group`|元素将作为一个或多个列的分组显示（类似`<colgroup>`）||`table-column`|元素将作为一个单元格列显示（类似`<col>`）||`table-cell`|元素将作为一个表格单元格显示（类似`<td>`和`<th>`）||`table-caption`|元素将作为一个表格标题显示（类似`<caption>`）||`inherit`|规定应该从父元素集成display属性的值|```css/*precomposedvalues*/display:block;display:inline;display:inline-block;display:flex;display:inline-flex;display:grid;display:inline-grid;display:flow-root;/*boxgeneration*/display:none;display:contents;/*two-valuesyntax*/display:blockflow;display:inlineflow;display:inlineflow-root;display:blockflex;display:inlineflex;display:blockgrid;display:inlinegrid;display:blockflow-root;/*othervalues*/display:table;display:table-row;/*alltableelementshaveanequivalentCSSdisplayvalue*/display:list-item;/*Globalvalues*/display:inherit;display:initial;display:revert;display:revert-layer;display:unset;```","CSS\\layout\\flex.md":"#flex##弹性布局>-弹性布局可以简便、完整、响应的实现各种页面上的布局。>-与静态不同的是，使用em或rem单位（lem=16px，1rem=10px）进行相对布局，相对使用百分比更加方便、灵活，相应同时支持浏览器的字体大小调整和缩放的等正常显示。>-优点：>>1.适应性强，在做多种不同的屏幕分辨率不同的界面是非常使用。>2.随意按照宽度、比例划分元素的宽高。>3.可以轻松的改变元素的显示顺序。>4.网页布局实现快捷，维护起来更加容易。>>-如果做移动端时，如果客户对细微的之处的要求不高，使用弹性布局进行制作是最好的选择，一份css+一份js调节font-size搞定。>-缺点：浏览器兼容性较差，只能<u>兼容到IE9及以上</u>。>-使用:>>```css>.box{>display:flex;>display:inline-flex;//行内块>//Webkit内核的浏览器>display:-webkit-flex;/*Safari*/>display:flex;>}>```>>-设为Flex布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。![](./.assets/flex-2022-03-29-13-53-02.png)##概念>容器默认存在两根轴：>>-水平的主轴（mainaxis）和垂直的交叉轴（crossaxis）。>-主轴的开始位置（与边框的交叉点）叫做`mainstart`，结束位置叫做`mainend`；>-交叉轴的开始位置叫做`crossstart`，结束位置叫做`crossend`。>>项目默认沿主轴排列。单个项目占据的主轴空间叫做`mainsize`，占据的交叉轴空间叫做`crosssize`。![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)##容器的属性>-`flex-direction:row|row-reverse|column|column-reverse;`=>决定主轴的方向(项目的排列方式)>-`flex-wrap:nowrap|wrap|wrap-reverse;`=>如果一条轴线排不下，如何换行>-`flex-flow:<flex-direction>||<flex-wrap>;`=>是前flex-direction和flex-warp的简写方式>-`justify-content:flex-start|flex-end|center|space-between|space-around;`=>项目在主轴上的对齐方式>-`align-items:flex-start|flex-end|center|baseline|stretch;`=>项目在交叉轴上如何对齐>-`align-content:flex-start|flex-end|center|space-between|space-around|stretch;`=>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用###flex-direction`flex-direction`属性决定主轴的方向（即项目的排列方向）。>```css>.box{>flex-direction:row|row-reverse|column|column-reverse;>}>```>>![](/.assets/img/2022-01-25-14-30-04.png)它可能有4个值。>-`row`（默认值）：主轴为水平方向，起点在左端。>-`row-reverse`：主轴为水平方向，起点在右端。>-`column`：主轴为垂直方向，起点在上沿。>-`column-reverse`：主轴为垂直方向，起点在下沿。###flex-wrap默认情况下，项目都排在一条线（又称\"轴线\"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。>```css>.box{>flex-wrap:nowrap|wrap|wrap-reverse;>}>```它可能取三个值。（1）`nowrap`（默认）：不换行。![](/.assets/img/2022-01-25-14-33-06.png)（2）`wrap`：换行，第一行在上方。![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg)（3）`wrap-reverse`：换行，第一行在下方。![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg)###flex-flow`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`rownowrap`。>```css>.box{>flex-flow:<flex-direction>||<flex-wrap>;>}>```###justify-content`justify-content`属性定义了项目在主轴上的对齐方式。>```css>.box{>justify-content:flex-start|flex-end|center|space-between|>space-around;>}>```<imgsrc=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png\"alt=\"img\"style=\"zoom:80%;\"/>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。>-`flex-start`（默认值）：左对齐>-`flex-end`：右对齐>-`center`：居中>-`space-between`：两端对齐，项目之间的间隔都相等。>-`space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。###align-items`align-items`属性定义项目在交叉轴上如何对齐。>```css>.box{>align-items:flex-start|flex-end|center|baseline|stretch;>}>```![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。>-`flex-start`：交叉轴的起点对齐。>-`flex-end`：交叉轴的终点对齐。>-`center`：交叉轴的中点对齐。>-`baseline`:项目的第一行文字的基线对齐。>-`stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。###align-content`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。>```css>.box{>align-content:flex-start|flex-end|center|space-between|space-around>|stretch;>}>```![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)该属性可能取6个值。>-`flex-start`：与交叉轴的起点对齐。>-`flex-end`：与交叉轴的终点对齐。>-`center`：与交叉轴的中点对齐。>-`space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。>-`space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。>-`stretch`（默认值）：轴线占满整个交叉轴。##项目的属性>-`order:<integer>`=>项目的排列顺序。数值越小，排列越靠前，默认为0>-`flex-grow:<number>`=>项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大>-`flex-shrink:<number>`=>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。>-`flex-basis:<length>|auto;/*defaultauto*/`=>定义了在分配多余空间之前，项目占据的主轴空间（mainsize）>-`flex:none|[<'flex-grow'><'flex-shrink'>?||<'flex-basis'>]`=>默认值为`01auto`>-`align-self:auto|flex-start|flex-end|center|baseline|stretch;`=>允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。###order>定义项目的排列顺序。数值越小，排列越靠前，默认为0。```css.item{order:<integer>;}```<imgsrc=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png\"alt=\"img\"style=\"zoom:80%;\"/>###flex-grow>定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。```css.item{flex-grow:<number>;/*default0*/}```<imgsrc=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png\"alt=\"img\"style=\"zoom:80%;\"/>###flex-shrink>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。```css.item{flex-shrink:<number>;/*default1*/}```![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)-如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。-如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。-负值对该属性无效。###flex-basis>属性定义了在分配多余空间之前，项目占据的主轴空间（mainsize）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。```css.item{flex-basis:<length>|auto;/*defaultauto*/}```它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。###flex>属性是`flex-grow`,`flex-shrink`和`flex-basis`的简写，默认值为`01auto`。后两个属性可选。```css.item{flex:none|[<'flex-grow'><'flex-shrink'>?||<'flex-basis'>];}```>该属性有两个快捷值：`auto`(`11auto`)和none(`00auto`)。>>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值>`flex:2200px`=>先给当前项留200px,再根据前面属性进行均分###align-self>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。```css.item{align-self:auto|flex-start|flex-end|center|baseline|stretch;}```<imgsrc=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png\"alt=\"img\"style=\"zoom:80%;\"/>属性可能取6个值，除了auto，其他都与align-items属性完全一致。","CSS\\layout\\grid.md":"#grid布局##网格布局```cssdisplay:grid|inline-grid;//行列布局grid-template-columns:200px200px200px;|repeat(3,200px)|repeat(auto-fill,200px)[表示列宽200px,只要能容纳得下就可以放置]|200px2fr1fr[后面两项分别占有剩下的2/3,1/3]|1fr1frminmax(300px,2fr)[第三列:300px<=x<=2fr]grid-template-rows:200px200px200px;|repeat(3,200px)|和上个类似//行列间隔grid-row-gap:10px;grid-column-gap:20px;grid-gap:10px20px;[等同于上两行]row-gap:10px;column-gap:20px;//定义区域grid-template-areas:\".headerheader\"[.表示空单元格]\"sidebarcontentcontent\";[这里定义的六个区域]//子元素.header{grid-area:header;}//控制自动布局grid-auto-flow:row|column|rowdense|columndense;[dense:自动填补空白;row:表示先行后列]//控制单元格位置justify-items:start|end|center|stretch[拉伸];[水平方向]align-items:start|end|center|stretch;[垂直方向]place-items:[justify-item][align-items];//同时设置水平和垂直方向//这个是对于单个单元格justify-self:start|end|center|stretch[拉伸];[水平方向]align-self:start|end|center|stretch;[垂直方向]place-self:[justify-item][align-items];//同时设置水平和垂直方向//控制内容区域在容器的位置justify-content:start|end|center|stretch|space-around[每个项目两侧距离相等,项目间间隔比到容器间隙大一倍]|space-between[项目间隔相等,与容器边框没有间隙]|space-evenly[项目与项目的间隙相等,项目间与容器边框间间隙相等];align-content:start|end|center|stretch|space-around|space-between|space-evenly;place-content:[justify-content][align-content]//定义隐式网格属性[当超出grid-template-xxx的定义就会触发]grid-auto-columns:50px;grid-auto-rows:50px;//网格项目所在的四个边框grid-column-start属性：左边框所在的垂直网格线grid-column-end属性：右边框所在的垂直网格线grid-row-start属性：上边框所在的水平网格线grid-row-end属性：下边框所在的水平网格线//合并单元格(可以使用grid-template-areas来定义重复的名字可以达到效果)//'span3':合并往下三个单元格;auto:表示再原有位置进行合并,也可以指定其他行grid-row:auto/span3;//'span2':合并往右边2个单元格;auto:表示再原有位置进行合并,也可以指定其他列grid-column:auto/span2;```##display属性>-`display：grid`>-`display：inline-grid`##grid-template-columns/rows>-`grid-template-columns`属性设置每列宽>-`grid-template-rows`属性设置每行高**固定的列宽和行高**```css.wrapper{display:grid;/*声明了三列，宽度分别为200px100px200px*/grid-template-columns:200px100px200px;grid-gap:5px;/*声明了两行，行高分别为50px50px*/grid-template-rows:50px50px;}```>**repeat()函数**：可以简化重复的值。>>-第一个参数是重复的次数>-第二个参数是所要重复的值```scss.wrapper-1{display:grid;grid-template-columns:200px100px200px;grid-gap:5px;/*2行，而且行高都为50px*/grid-template-rows:repeat(2,50px);}```>**auto-fill关键字**：表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。`grid-template-columns:repeat(auto-fill,200px)`表示列宽是200px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素```css.wrapper-2{display:grid;grid-template-columns:repeat(auto-fill,200px);grid-gap:5px;grid-auto-rows:50px;}```>**fr关键字**：`Grid`布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。`fr`单位代表网格容器中可用空间的一等份。`grid-template-columns:200px1fr2fr`表示第一个列宽设置为200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的1/3和2/3。```css.wrapper-3{display:grid;grid-template-columns:200px1fr2fr;grid-gap:5px;grid-auto-rows:50px;}```**minmax()函数**：我们有时候想给网格元素一个最小和最大的尺寸，`minmax()`函数产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。它接受两个参数，分别为最小值和最大值。`grid-template-columns:1fr1frminmax(300px,2fr)`的意思是，第三个列宽最少也是要300px，但是最大不能大于第一第二列宽的两倍。代码以及效果如下：```css.wrapper-4{display:grid;grid-template-columns:1fr1frminmax(300px,2fr);grid-gap:5px;grid-auto-rows:50px;}```**auto关键字**：由浏览器决定长度。通过`auto`关键字，我们可以轻易实现三列或者两列布局。`grid-template-columns:100pxauto100px`表示第一第三列为100px，中间由浏览器决定长度，代码以及效果如下：```css.wrapper-5{display:grid;grid-template-columns:100pxauto100px;grid-gap:5px;grid-auto-rows:50px;}```##gap(间隙)>`grid-row-gap`属性、`grid-column-gap`属性分别设置行间距和列间距。>>`grid-gap`属性是两者的简写形式。(已经弃用)>`column-gap`和`row-gay`替代```css.wrapper{display:grid;grid-template-columns:200px100px100px;grid-gap:10px20px;grid-auto-rows:50px;}``````.wrapper-1{display:grid;grid-template-columns:200px100px100px;grid-auto-rows:50px;grid-row-gap:10px;grid-column-gap:20px;}```##grid-template-areas/grid-area>`grid-template-areas`属性用于定义区域，一个区域由一个或者多个单元格组成>>`grid-area`:指定放在哪个区域```css.wrapper{display:grid;grid-gap:10px;grid-template-columns:120px120px120px;grid-template-areas:'.headerheader''sidebarcontentcontent';background-color:#fff;color:#444;}```>上面代码表示划分出6个单元格，其中值得注意的是`.`符号代表空的单元格，也就是没有用到该单元格。```css.sidebar{grid-area:sidebar;}.content{grid-area:content;}.header{grid-area:header;}```以上代码表示将类`.sidebar``.content``.header`所在的元素放在上面`grid-template-areas`中定义的`sidebar``content``header`区域中##grid-auto-flow>`grid-auto-flow`属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。默认的放置顺序是\"先行后列\"，即先填满第一行，再开始放入第二行，即下图英文数字的顺序`one`,`two`,`three`...。这个顺序由`grid-auto-flow`属性决定，默认值是`row`。###row```css.wrapper{display:grid;grid-template-columns:100px200px100px;grid-auto-flow:row;grid-gap:5px;grid-auto-rows:50px;}```###dense>`grid-auto-flow:rowdense`=>dense会用后面的项目填充前面的空位```css.wrapper-2{display:grid;grid-template-columns:100px200px100px;grid-auto-flow:rowdense;grid-gap:5px;grid-auto-rows:50px;}```###column可以设置`grid-auto-flow:column`，表示先列后行，代码以及效果如下图所示：```css.wrapper-1{display:grid;grid-auto-columns:100px;grid-auto-flow:column;grid-gap:5px;grid-template-rows:50px50px;}```##项目对齐(item)>-`justify-items`:设置单元格内容的水平位置（左中右）>-`align-items`:设置单元格的垂直位置（上中下）>-`place-items:[align-items]|[justify-items]````css.container{justify-items:start|end|center|stretch;align-items:start|end|center|stretch;}``````css.wrapper,.wrapper-1,.wrapper-2,.wrapper-3{display:grid;grid-template-columns:100px200px100px;grid-gap:5px;grid-auto-rows:50px;justify-items:start;}.wrapper-1{justify-items:end;}.wrapper-2{justify-items:center;}.wrapper-3{justify-items:stretch;}```###start-start：对齐单元格的起始边缘###end>对齐单元格的结束边缘###center>center：单元格内部居中###stretch>拉伸，占满单元格的整个宽度（默认值）##justify-content,align-content,place-content>`justify-content`属性是整个内容区域在容器里面的水平位置（左中右）>>`align-content`属性是整个内容区域的垂直位置（上中下）。它们都有如下的属性值。```css.container{justify-content:start|end|center|stretch|space-around|space-between|space-evenly;align-content:start|end|center|stretch|space-around|space-between|space-evenly;place-content:[align-content][justify-content];}``````css.wrapper,.wrapper-1,.wrapper-2,.wrapper-3,.wrapper-4,.wrapper-5,.wrapper-6{display:grid;grid-template-columns:100px200px100px;grid-gap:5px;grid-auto-rows:50px;justify-content:start;}.wrapper-1{justify-content:end;}.wrapper-2{justify-content:center;}```-space-around-每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍-space-between-项目与项目的间隔相等，项目与容器边框之间没有间隔-space-evenly-项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔-stretch-项目大小没有指定时，拉伸占据整个网格容器```css.wrapper-3{justify-content:space-around;}.wrapper-4{justify-content:space-between;}.wrapper-5{justify-content:space-evenly;}.wrapper-6{justify-content:stretch;}```##grid-auto-columns,grid-auto-rows>-显式网格:包含了你在`grid-template-columns`和`grid-template-rows`属性中定义的行和列。>-如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，**网格将会在隐式网格中创建行和列**>-不指定这隐式网格属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高```css.wrapper{display:grid;grid-template-columns:200px100px;/*只设置了两行，但实际的数量会超出两行，超出的行高会以grid-auto-rows算*/grid-template-rows:100px100px;grid-gap:10px20px;grid-auto-rows:50px;}````grid-template-columns`属性和`grid-template-rows`属性只是指定了两行两列，但实际有九个元素，就会产生隐式网格。通过`grid-auto-rows`可以指定隐式网格的行高为50px##项目属性介绍###grid-column-start/end、grid-row-start/end>可以指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置>>-grid-column-start属性：左边框所在的垂直网格线>-grid-column-end属性：右边框所在的垂直网格线>-grid-row-start属性：上边框所在的水平网格线>-grid-row-end属性：下边框所在的水平网格线```css.wrapper{display:grid;grid-template-columns:repeat(3,1fr);grid-gap:20px;grid-auto-rows:minmax(100px,auto);}.one{grid-column-start:1;grid-column-end:2;background:#19caad;}.two{grid-column-start:2;grid-column-end:4;grid-row-start:1;grid-row-end:2;/*如果有重叠，就使用z-index*/z-index:1;background:#8cc7b5;}.three{grid-column-start:3;grid-column-end:4;grid-row-start:1;grid-row-end:4;background:#d1ba74;}.four{grid-column-start:1;grid-column-end:2;grid-row-start:2;grid-row-end:5;background:#bee7e9;}.five{grid-column-start:2;grid-column-end:2;grid-row-start:2;grid-row-end:5;background:#e6ceac;}.six{grid-column:3;grid-row:4;background:#ecad9e;}```上面代码中，类`.two`所在的网格项目，垂直网格线是从2到4，水平网格线是从1到2。其中它跟`.three`（垂直网格线是从3到4，水平网格线是从1到4）是有冲突的。可以设置`z-index`去决定它们的层级关系###justify/align/place-self>-`justify-self`属性设置单元格内容的水平位置（左中右），跟`justify-items`属性的用法完全一致，但只作用于单个项目>-`align-self`属性设置单元格内容的垂直位置（上中下），跟``align-items`属性的用法完全一致，也是只作用于单个项目```css.item{justify-self:start|end|center|stretch;align-self:start|end|center|stretch;}.item{justify-self:start;}.item-1{justify-self:end;}.item-2{justify-self:center;}.item-3{justify-self:stretch;}```-start：对齐单元格的起始边缘-end：对齐单元格的结束边缘-center：单元格内部居中-stretch：拉伸，占满单元格的整个宽度（默认值）##Grid布局兼容性最后，聊聊`Grid`布局兼容性问题，在[caniuse](https://caniuse.com/#search=grid)中，我们可以看到的结果如下，总体兼容性还不错，但在IE10以下不支持。个人建议在公司的内部系统运用起来是没有问题的，但TOC的话，可能目前还是不太合适|属性|描述||:--------------------------------------:|:-----------------:||display|grid\\|inline-grid||grid-template-columns/grid-template-rows|设置列宽/行高|","CSS\\layout\\position\\index.md":"#position>定位布局时利用position属性控制页面元素设置一些不规则布局。>定位元素的各个属性：1.static静态定位：HTML元素的默认值，即没有定位，元素出现在正常的流中。```cssdiv.static{position:static;border:3pxsolid#73ad21;}```2.fixed固定定位：元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。Fixed定位的元素和其他元素重叠。```cssp.pos_fixed{position:fixed;top:30px;right:5px;}```3.relative相对定位：相对定位元素的定位是以自身为参照物。对象不可层叠、不脱离文档流，移动相对定位元素，但它原本所占的空间不会改变。通过top,bottom,left,right定位。```cssh2.pos_top{position:relative;top:-50px;}```4.absolute绝对定位absolute定位使元素的位置与文档流无关，因此不占据空间。元素和其他元素重叠。通过top,bottom,left,right定位。选取其最近一个最有定位设置的父级对象进行绝对定位，如果对象的父级没有设置定位属性，absolute元素将以body坐标原点进行定位。```cssh2{position:absolute;left:100px;top:150px;}```5.sticky粘性定位基于用户的滚动位置来定位。粘性定位的元素是依赖于用户的滚动，在position:relative与position:fixed定位之间切换。它的行为就像position:relative;而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是top,right,bottom或left之一，换言之，指定top,right,bottom或left四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。```cssdiv.sticky{position:-webkit-sticky;/*Safari*/position:sticky;top:0;background-color:green;border:2pxsolid#4caf50;}```6.z-index因为页面中元素的定位与文档流无关，所以定位的元素可以覆盖在文档流上面。所以z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面/后面）。z-index的值必须取正整数，数值越大显示的优先级就越高。如果两个定位元素重叠，而且还没有指定z-index，name最后定位在HTML代码中的元素将被显示在最前面。","CSS\\layout\\position\\问题\\fixed失效.md":"#[`fixed失效`]()><https://drafts.fxtf.org/filter-effects/#FilterProperty>##与filter使用>当在body中使用了filter滤镜属性的时候，会导致fixed元素定位发生错误，即不再相对viewport进行定位，而是相对整个网页（body元素）进行定位```html<html><head><title>cssfilterissue</title><style>body{height:600px;background:red;filter:grayscale(1);}.fixed{color:yellow;position:fixed;top:0;right:0;}</style></head><body><divclass=\"fixed\">fixeditem</div></body></html>```![](./.assets/fixed-error.gif)###解决方案>产生这个问题的原因就是：当filter不为none的时候，如果该元素或者其子元素具有absolute或fixed属性，那么它会为其创建一个新的包含块/容器，会造成该absolute或fixed元素的定位发生变化（就是改变了absolute或fixed元素的定位<父>元素，变成新创建的元素）。>以上面的例子说明，当在body标签中使用了filter属性后，filter就会生成一个新的包含块，其位置大小和body一样，然后fixed元素就会根据这个包含块进行定位，所以我们会看到fixed元素失去原有的特性；>但是，如果filter作用在根元素（即html标签）时，它是不会为absolute或fixed子元素创建新的包含块的>所以解决方案也就很简单了，只需要将filter属性放在html标签上就好了```csshtml{filter:grayscale(1);}```>`position:fixed`>>当一个元素包含fixed属性时，屏幕视口（viewport）会为其创建一个包含块（containingblock），其大小就是viewport的大小，然后该fixed元素基于该包含块进行定位。所以通常我们会说fixed元素是相对viewport来定位的。>>此外，fixed属性会创建新的层叠上下文。当元素祖先的transform,perspective或filter属性非none时，容器由视口改为该祖先。","CSS\\layout\\table.md":"#table-基于`display:table`的布局-类似于原生的`<table>`标签的使用##原生的table标签的说明-就是使用通过使用CSSTable来说来实现相关属性的。-table：指定对象作为块元素级的表格。类同于html标签<table>（CSS2）-inline-table：指定对象作为内联元素级的表格。类同于html标签<table>（CSS2）-table-caption：指定对象作为表格标题。类同于html标签<caption>（CSS2）-table-cell：指定对象作为表格单元格。类同于html标签<td>（CSS2）-table-row：指定对象作为表格行。类同于html标签<tr>（CSS2）-table-row-group：指定对象作为表格行组。类同于html标签<tbody>（CSS2）-table-column：指定对象作为表格列。类同于html标签<col>（CSS2）-table-column-group：指定对象作为表格列组显示。类同于html标签<colgroup>（CSS2）-table-header-group：指定对象作为表格标题组。类同于html标签<thead>（CSS2）-table-footer-group：指定对象作为表格脚注组。类同于html标签<tfoot>（CSS2）---```csstable{display:table;}tr{display:table-row;}thead{display:table-header-group;}tbody{display:table-row-group;}tfoot{display:table-footer-group;}col{display:table-column;}colgroup{display:table-column-group;}td,th{display:table-cell;}caption{display:table-caption;}```###使用CSS表格-CSS表格能够解决所有那些我们在使用绝对定位和浮动定位进行多列布局时所遇到的问题。例如，“display:table;”的CSS声明能够让一个HTML元素和它的子节点像table元素一样。-使用基于表格的CSS布局，使我们能够轻松定义一个单元格的边界、背景等样式，而不会产生因为使用了table那样的制表标签所导致的语义化问题。-在深入了解这种方法之前，让我们先来写份HTML文档实例：```html<divid=\"wrapper\"><divid=\"main\"><divid=\"nav\">navigationcolumncontent…</div><divid=\"extras\">newsheadlinescolumncontent…</div><divid=\"content\">mainarticlecontent…</div></div></div>```>这份HTML源代码满足了内容呈现方面的要求。先是导航栏，然后是附加栏，最后是内容栏。我们同样需要将以下CSS样式应用上去：```css#main{display:table;border-collapse:collapse;}#nav{display:table-cell;width:180px;background-color:#e7dbcd;}#extras{display:table-cell;width:180px;padding-left:10px;border-right:1pxdotted#d7ad7b;}#content{display:table-cell;width:380px;padding-left:10px;}```>这种基于表格的新CSS布局方式能够正确的在IE8、Firefox、Safari和Opera（译者注：包括FF2/FF3/Google都通过了测试）中显示出来。我们轻松实现了三栏等高布局，而无需使用伪造背景图片之类的技巧，更不用担心定位和清除浮动的问题！###它是怎样实现的？-你可以给HTML元素指定与表格相关的display属性值，使得它们像表格元素那样渲染。以下是这些可用的display属性值：-table使该元素按table样式渲染-table-row使该元素按tr样式渲染-table-cell使该元素按td样式渲染-table-row-group使该元素按tbody样式渲染-table-header-group使该元素按thead样式渲染-table-footer-group使该元素按tfoot样式渲染-table-caption使该元素按caption样式渲染-table-column使该元素按col样式渲染-table-column-group使该元素按colgroup样式渲染###难道用table布局不是错的吗？-可能你会对我们上面给出的布局实例有点不爽——毕竟，正如我自己也是一名WEB标准化的拥护者，我们不都一直坚持不应该使用table来进行布局吗？-table元素在HTML当中是一个包含语义的标签：它描述什么是数据。因此，你只能用它来标记那些需要制表的数据，例如一张财务信息表。如果数据能够以电子表格的形式保存在你的电脑中，那它在HTML文档中很可能需要用到table标签进行标记。从另一方面来看，display的table属性值只是声明了某些元素在浏览器中的样式——它不包含语义。如果使用table元素来进行布局，它将会告诉客户端：这些数据是制表的。使用一些display属性被设置为table和table-cell之类的div标签，除了告诉客户端以某种特定的样式来渲染它们以外，不会告诉客户端任何语义，只要客户端能够支持这些属性值。-当然，我们同样还要注意，当我们真的需要制表数据的时候不要使用一大堆被声明为display:table;的div元素。-我们上面的那个例子是一个简单的单行三列布局，无需费尽心思，我们就能够使用这种技术轻松实现复杂的栅格布局。###匿名表格元素CSS表格除了包含table布局的普通规则之外，同时还有着CSStable布局的超强特性：缺少的表格元素会被浏览器以匿名方式创建。CSS2.1规范中写道：>CSS2.1表格模型中的元素，可能不会全部包含在除HTML之外的文档语言中。这时，那些“丢失”的元素会被模拟出来，从而使得表格模型能够正常工作。所有的表格元素将会自动在自身周围生成所需的匿名table对象，使其符合table/inline-table、table-row、table-cell的三层嵌套关系。这段话的意思是，如果我们为元素使用“display:table-cell;”属性，而不将其父容器设置为“display:table-row;”属性，浏览器会默认创建出一个表格行，就好像文档中真的存在一个被声明的表格行一样。###创建匿名表格元素的规则-这些匿名的盒对象不是用魔术变出来的，它们也不会自动往你的HTML源码中添加新的标签。为了完全发挥出匿名表格元素的优势，你最好能够对创建它们的规则有所了解。如果布局中调用了匿名元素，浏览器将会根据需要创建一个匿名的盒对象并将它的CSSdisplay属性设置为table、table-row或table-cell中的一个。-如果某个元素已经被设置为“display:table-cell;”，而它的父节点（包含它的容器）没有被设置为“display:table-row;”属性，那么浏览器将会创建一个被设置为“display:table-row;”的匿名盒对象来嵌套它。并且与之相邻的属性为“display:table-cell;”的兄弟节点也都会被这个匿名盒对象所包含，直到碰到一个没有被设置为“display:table-cell;”的元素而结束这一行。以下是相关的代码样例：```html<divclass=\"”cell”\">CELLA</div><divclass=\"”cell”\">CELLB</div><divclass=\"”cell”\">CELLC</div><div>Notacell</div>```>3个`cell`的div元素被设置为`display:table-cell;`：会像一个单行三个单元格一样并排排列这。最后一个div元素则不会被包含在这一表格行当中，因为它没有被设置成`display:table-cell;`>>如果某个元素被设置为“display:table-row;”，而它的父节点没有被设置为“display:table;”（或者“display:table-row-group;”），浏览器将会创建一个被设置为“display:table;”的匿名盒对象来嵌套它，与之相邻的属性为“display:table-row;”的兄弟节点也都会被包含其中。>>如果某个元素被设置为“display:table-row;”，但它的内部却缺少“display:table-cell;”的元素，那么一个匿名的table-cell将会被创建，用来包含该table-row中的所有元素。请看以下代码：```html<divclass=\"”row”\">ROWA</div><divclass=\"”row”\">ROWB</div><div>Notarow</div>```>上面两排类名为“row”的div元素被设置了“display:table-row;”属性，它们将会像单列表格中的两行一样依次排列。最后一个div元素则不会包含在这个匿名的table中。>>以此类推，如果某个元素的display属性值被设置为与表格相关的值，如table-row-group、table-header-group、table-footer-group、table-column、table-column-group以及table-caption，但同时又没有一个被设置为“display:table;”的父元素，那么一个匿名的盒对象将会被创建用来包含该元素和它的某些兄弟节点。###其他有用的表格属性>当使用CSS表格时，因为这些元素遵从table布局的普通规则，所以你还可以给它们应用其它表格相关的CSS属性。下面是一些派得上用场的属性：-table-layout将table-layout属性设置为fixed可以让浏览器按照固定算法来渲染单元格的宽度。这在固定宽度布局中非常有用，例如我们最上面的那段布局代码。>-border-collapse和普通的HTML表格一样，你可以使用border-collapse属性来定义你的table布局元素之间使用何种形式的边框，是共用边框（赋值为collapse）还是使用各自独立的边框（赋值为separate）。>-border-spacing如果你声明了“border-collapse:separate;”，那么你就可以使用border-spacing属性来定义相邻两个单元格边框间的距离。###制作完美的栅格>制作等高栅格对于传统CSS布局技术来说已经成为一个难题，然而使用合适的CSS表格则很容易实现。```html<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"utf-8\"><title>等高栅格</title><style>.grid{display:table;/*表格布局*/border-spacing:4px;/*单元格间距4px*/}.row{display:table-row;/*表格th布局*/}.image{display:table-cell;/*表格td布局*/width:240px;background-color:#000;border:8pxsolid#000;vertical-align:middle;text-align:center;}.imagep{color:#fff;font-size:85%;text-align:left;padding-top:8px;}</style><body><divclass='grid'><divclass='row'><divclass='image'><imgsrc='images/11.png'alt='ALily'/><p>AlilyinthegardensofTheVyneCountryHouse</p></div><divclass='image'><imgsrc='images/11.png'alt='AFuchsiaplant'/><p>Fuchsiaplantinmygarden</p></div></div><divclass='row'><divclass='image'><imgsrc='images/11.png'alt='AcrazylookingAlliumflower'/><p>Acrazylookingflower</p></div><divclass='image'><imgsrc='images/11.png'alt='ARobinsittingonafence'/><p>Thisrobinhasbeenvisitingourgardenoverthesummer.Heisveryfriendlyanddoesn’tseemtobetooworriedaboutsharingthegardenwithus.</p></div></div></div></body></html>```>这个采用的是vertical-align:middle;你如果采用top对齐，那么图片就是完全一致对齐啦。##区别>HTMLTable和CSSTable之间的真正区别是：适当地调整CSS属性>CSS的Table能做到许多HTMLTable不能做的事情，可以从Table中择优选择属性使用。","CSS\\layout\\多列瀑布流\\index.md":"#多列瀑布流##多列####column-count:规定元素分隔成多列```css//分隔成三列div{-moz-column-count:3;/*Firefox*/-webkit-column-count:3;/*Safari和Chrome*/column-count:3;}```####column-gap:列间隔```cssdiv{-moz-column-gap:40px;/*Firefox*/-webkit-column-gap:40px;/*Safari和Chrome*/column-gap:40px;}```####column-rule:列规则```cssdiv{-moz-column-rule:3pxoutset#ff0000;/*Firefox*/-webkit-column-rule:3pxoutset#ff0000;/*SafariandChrome*/column-rule:3pxoutset#ff0000;}```|[column-count](https://www.w3school.com.cn/cssref/pr_column-count.asp)|规定元素应该被分隔的列数。||--------------------------------------------------------------------------------|--------------------------------------------------||[column-fill](https://www.w3school.com.cn/cssref/pr_column-fill.asp)|规定如何填充列。||[column-gap](https://www.w3school.com.cn/cssref/pr_column-gap.asp)|规定列之间的间隔。||[column-rule](https://www.w3school.com.cn/cssref/pr_column-rule.asp)|设置所有column-rule-\\*属性的简写属性。||[column-rule-color](https://www.w3school.com.cn/cssref/pr_column-rule-color.asp)|规定列之间规则的颜色。||[column-rule-style](https://www.w3school.com.cn/cssref/pr_column-rule-style.asp)|规定列之间规则的样式。||[column-rule-width](https://www.w3school.com.cn/cssref/pr_column-rule-width.asp)|规定列之间规则的宽度。||[column-span](https://www.w3school.com.cn/cssref/pr_column-span.asp)|规定元素应该横跨的列数。||[column-width](https://www.w3school.com.cn/cssref/pr_column-width.asp)|规定列的宽度。||[columns](https://www.w3school.com.cn/cssref/pr_columns.asp)|规定设置column-width和column-count的简写属性。|","CSS\\layout\\水平垂直居中\\index.md":"#水平垂直居中##absolute+负margin>兼容性也很好，缺点是需要知道子元素的宽高```html<divclass=\"out\"><divclass=\"inner\">12345</div></div><styletype=\"text/css\">.out{position:relative;width:300px;height:300px;background:red;}.inner{position:absolute;width:100px;height:100px;background:yellow;left:50%;top:50%;margin-left:-50px;margin-top:-50px;}</style>```##absolute+automargin>缺点是需要知道子元素的宽高```css.out{position:relative;width:300px;height:300px;background:red;}.inner{position:absolute;width:100px;height:100px;background:yellow;left:0;top:0;right:0;bottom:0;margin:auto;}```##absolute+calc>依赖于calc，且也需要知道宽高```css.out{position:relative;width:300px;height:300px;background:red;}.inner{position:absolute;width:100px;height:100px;background:yellow;left:calc(50%-50px);top:calc(50%-50px);}```##absolute+transform兼容性依赖translate，不需要知道子元素宽高```html<styletype=\"text/css\">.out{position:relative;width:300px;height:300px;background:red;}.inner{position:absolute;background:yellow;left:50%;top:50%;transform:translate(-50%,-50%);}</style>```##tablecss新增的table属性，可以让我们把普通元素，变为table元素的显示效果，通过这个特性也可以实现水平垂直居中。这种方法兼容性也不错。```html<styletype=\"text/css\">.out{display:table-cell;width:300px;height:300px;text-align:center;vertical-align:middle;background:red;}.inner{display:inline-block;background:yellow;width:100px;height:100px;}</style>```##flexflex实现起来比较简单，三行代码即可搞定。可通过父元素指定子元素的对齐方式，也可通过子元素自己指定自己的对齐方式来实现。第二种方式见grid布局。```html<styletype=\"text/css\">.out{display:flex;justify-content:center;align-items:center;width:300px;height:300px;background:red;}.inner{background:yellow;width:100px;height:100px;}</style>```##gridgrid布局也很强大，大体上属性跟flex差不多。```html//方法一：父元素指定子元素的对齐方式<styletype=\"text/css\">.out{display:grid;align-content:center;justify-content:center;width:300px;height:300px;background:red;}.inner{background:yellow;width:100px;height:100px;}</style>//方法二：子元素自己指定自己的对齐方式<styletype=\"text/css\">.out{display:grid;width:300px;height:300px;background:red;}.inner{background:yellow;width:100px;height:100px;align-self:center;justify-self:center;}</style>```","CSS\\plan.md":"<https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/radial-gradient>-datalist,progress,audio,video","CSS\\text\\index.md":"#CSSText(文本)##文本颜色>color:blue|#00ff00|rgb(255,0,0)##对齐方式>text-align:center|left|right|justify[每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）]##文字方向>text-direction:ltr[左到右]|rtl[右到左]|inherit[从父元素继承direction属性值]##字符间距>letter-spacing:normal(默认)|length(数字,可以为负)|inherit(从父元素继承)##行高>line-height:normal(默认)|number(行间距=当前字体尺寸\\*number)|lenght|%|inherit##文本的首行元素缩进>text-indent:length(默认值:0)|%(为父元素的百分比缩进)|inherit##文字阴影>text-shadow:none(默认值)>>语法:`text-shadow:*h-shadowv-shadowblurcolor*;`>>|值|描述|>|:---------|:-------------------------------------------------------------------------------------------|>|_h-shadow_|必需。水平阴影的位置。允许负值。|>|_v-shadow_|必需。垂直阴影的位置。允许负值。|>|_blur_|可选。模糊的距离。|>|_color_|可选。阴影的颜色。参阅[CSS颜色值](https://www.w3cschool.cn/cssref/css-colors-legal.html)。|##元素中的字母>text-transform:>>​none:默认>>​capitalize:文本中每个单词以大写字母开头>>​uppercase:定义仅有大写字母>>​lowercase:定义无大写字母,仅有小写字母>>​inherit:规定从父元素继承text-transform属性##设置或返回文本是否被重写>`unicode-bidi:normal|embed|bidi-override|initial|inherit;`>>|值|描述|测试|>|:------------|:---------------------------------------------------------------------------------------------|:-------------------------------------------------------|>|normal|默认。不使用附加的嵌入层面。|[测试»](https://www.w3cschool.cn/css/css-css_quiz.html)|>|embed|创建一个附加的嵌入层面。|[测试»](https://www.w3cschool.cn/css/css-css_quiz.html)|>|bidi-override|创建一个附加的嵌入层面。重新排序取决于direction属性。|[测试»](https://www.w3cschool.cn/css/css-css_quiz.html)|>|initial|设置该属性为它的默认值。请参阅[_initial_](https://www.w3cschool.cn/cssref/css-initial.html)。|[测试»](https://www.w3cschool.cn/css/css-css_quiz.html)|>|inherit|从父元素继承该属性。请参阅[_inherit_](https://www.w3cschool.cn/cssref/css-inherit.html)。||##元素垂直对齐>vertical-align:>>|值|描述|>|-----------|-------------------------------------------------------------|>|baseline|默认。元素放置在父元素的基线上。|>|sub|垂直对齐文本的下标。|>|super|垂直对齐文本的上标|>|top|把元素的顶端与行中最高元素的顶端对齐|>|text-top|把元素的顶端与父元素字体的顶端对齐|>|middle|把此元素放置在父元素的中部。|>|bottom|把元素的顶端与行中最低的元素的顶端对齐。|>|text-bottom|把元素的底端与父元素字体的底端对齐。|>|length||>|%|使用\"line-height\"属性的百分比值来排列此元素。允许使用负值。|>|inherit|规定应该从父元素继承vertical-align属性的值。|##元素中空白的处理方式>white-space:>>|值|描述|>|:-------|:---------------------------------------------------------------|>|normal|默认。空白会被浏览器忽略。|>|pre|空白会被浏览器保留。其行为方式类似HTML中的`<pre>`标签。|>|nowrap|文本不会换行，文本会在在同一行上继续，直到遇到`<br>`标签为止。|>|pre-wrap|保留空白符序列，但是正常地进行换行。|>|pre-line|合并空白符序列，但是保留换行符。|>|inherit|规定应该从父元素继承white-space属性的值。|##字间距>word-spacing:>>|值|描述|>|:-------|:-------------------------------------------|>|normal|默认。定义单词间的标准空间。|>|_length_|定义单词间的固定空间。|>|inherit|规定应该从父元素继承word-spacing属性的值。|","CSS\\text\\word-break&word-wrap&white-space.md":"#word-break&word-wrap&white-space##white-space>控制空白字符的显示,控制是否换行>>`normal|nowrap|pre|pre-wrap|pre-line````html<style>div#box{border:1pxsolid#000;width:100px;white-space:normal;}</style><divid=\"box\">Hi&nbsp;&nbsp;,Thisisaincomprehensibilitieslongword.<br/>你好&nbsp;&nbsp;，这是一个不可思议的长单词</div>```|`normal`|![](./.assets/image-20211209102306919-16390165906611.png)|默认||----------|---------------------------------------------------------|----------------------------------------------||`nowrap`|![](./.assets/image-20211209102458666.png)|只有`<br>`才可以换行,<br>空格和换行符失效||`pre`|![](./.assets/image-20211209102536365.png)|空格和换行符全都被保留了下来<br>自动换行还是没||`pre-wrap`|![](./.assets/image-20211209102933032.png)|保留空格和换行符,可自动换行||`pre-line`|![](./.assets/image-20211209103105521.png)|空格被合并,换行符发挥作用|##word-break>控制单词如何被拆分换行>>`normal|break-all|keep-all````html<style>div#box{border:1pxsolid#000;width:100px;word-break:normal;}</style><body><divid=\"box\">Hi&nbsp;&nbsp;,Thisisaincomprehensibilitieslongword.<br/>你好&nbsp;&nbsp;，这是一个不可思议的长单词</div></body>```|`normal`|![](./.assets/image-20211209104047949-16390176505692.png)|默认||-----------|---------------------------------------------------------|------------------------------------------------------||`break-all`|![](./.assets/image-20211209104132983.png)|所有单词碰到边界一律拆分换行||`keep-all`|![](./.assets/image-20211209104246886.png)|**所有“单词”一律不拆分换行**,<br>只有空格可以触发换行|##word-wrap(overflow-wrap)>控制单词如何换行>>`normal|break-word`###break-word![image-20211209104919825](./.assets/image-20211209104919825.png)","CSS\\text\\单行超长换行.md":"#[`单行超长换行`](/)```cssdiv{width:350px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}```","CSS\\text\\多行文本实现移除显示省略号.md":"#[`多行文本实现移除显示省略号`]()##单行```css.one-row-warp{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}```webkit浏览器或移动端的页面##多行```css.multi-row-warp{overflow:hidden;text-overflow:ellipsis;//显示省略号display:-webkit-box;//设置对象为弹性盒子模型显示-webkit-line-clamp:2;//限制一个块元素显示的文本的行数-webkit-box-orient:vertical;//必须结合的属性,设置或检索伸缩和对象}```跨浏览器兼容的方案```cssp{position:relative;line-height:1.4em;/*3timestheline-heighttoshow3lines*/height:4.2em;overflow:hidden;}p::after{content:'...';font-weight:bold;position:absolute;bottom:0;right:0;padding:020px1px45px;background:url(/newimg88/2014/09/ellipsis_bg.png)repeat-y;}```","CSS\\text\\多行超长换行.md":"#[`多行超长换行`](/)```cssdiv{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:3;/*changelinenumbers*/overflow:hidden;}```","CSS\\text\\字体.md":"#Fonts(字体)>CSS字体属性定义字体，加粗，大小，文字样式![](./.assets/css-basis-2022-11-22-09-25-43.png)|值|描述|值&描述||:-------------|:-------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||_font-style_|规定字体样式。|normal\\|italic(斜体)\\|bolique(倾斜)\\|inherit||_font-variant_|规定字体异体。|normal\\|small-caps(显示小心大写字母的字体)\\|inherit||_font-weight_|规定字体粗细|normal\\|bold(粗体)\\|bolder(更粗的字符)\\|lighter(更细的字符)\\|100(数字)\\|inherit||_font-size_|字体尺寸和行高|xx-small\\|x-small\\|small\\|medium(默认)\\|large\\|x-large\\|xx-large\\|smaller(比父元素更小的尺寸)\\|larger(比父元素更大的尺寸)\\|length(固定值)\\|%(为父元素的一个百分值)\\|inherit\\|||_line-height_|行高|||_font-family_|规定字体系列。参阅：[font-family](https://www.w3cschool.cn/cssref/pr-font-font-family.html)中可能的值。|||caption|定义被标题控件（比如按钮、下拉列表等）使用的字体。|||icon|定义被图标标记使用的字体。|||menu|定义被下拉列表使用的字体。|||message-box|定义被对话框使用的字体。|||small-caption|caption字体的小型版本。|||status-bar|**定义被窗口状态栏使用的字体**||##@font-face>可以使用自己喜欢的任意字体```css@font-face{font-family:myFirstFont;src:url('Sansation_Light.ttf'),url('Sansation_Light.eot');/*IE9+*/font-weight:bold;//可选}div{font-family:myFirstFont;}```|描述符|值|描述||:------------|:--------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------||font-family|_name_|必需。规定字体的名称。||src|_URL_|必需。定义字体文件的URL。||font-stretch|normal\\|condensed\\|ultra-condensed\\|extra-condensed\\|semi-condensedexpanded\\|semi-expanded\\|extra-expanded\\|ultra-expanded|可选。定义如何拉伸字体。默认是\"normal\"。||font-style|ormalitalicoblique|可选。定义字体的样式。默认是\"normal\"。||font-weight|normalbold100...|可选。定义字体的粗细。默认是\"normal\"。||unicode-range|_unicode-range_|可选。定义字体支持的UNICODE字符范围。默认是\"U+0-10FFFF\"。|","CSS\\text\\文字.md":"#文字##文字效果###text-shadow:文本阴影>水平阴影垂直阴影模糊距离阴影颜色```cssh1{text-shadow:5px5px5px#ff0000;}```![](https://images.gitee.com/uploads/images/2020/0521/205537_5885dc8a_6545143.png)###word-wrap:允许单词换行>```css>word-wrap:normal|break-word;>```###text-overflow:规定当文本溢出包含元素时发生的事情```csstext-overflow:clip|ellipsis|string;```>clip:修剪文本>>ellipsis:显示省略符号来替代被修剪的文本>>string:使用给定的字符串来代表修剪的文本![](https://images.gitee.com/uploads/images/2020/0521/210327_4f5ac834_6545143.png)","CSS\\type\\基础.md":"#type##`<alpha-value>`>颜色的alpha值>数字/百分比##`<number>`>数字`<integer>`##`<percentage>`>-百分比值>-许多CSS属性可以取百分比值，经常用以根据父对象来确定大小。百分比值由一个`<number>`具体数值后跟着%符号构成.>-就像其它在css里的单位一样，在%和数值之间是不允许有空格的。##`<string>`>字符串##`<length*>`###`<length>`>距离尺寸/长度###`<length-percentage>`>距离尺寸百分值##`<angle*>`###`<angle>`>角的大小>位为度（degrees）、百分度（gradians）、弧度（radians）或圈数（turns）####度deg>一个完整的圆是360deg。例：0deg，90deg，14.23deg####百分度grad>一个完整的圆是400grad。例：0grad，100grad，38.8grad####弧度rad>一个完整的圆是2π弧度，约等于6.2832rad。1rad是180/π度。例：0rad，1.0708rad，6.2832rad####圈数turn一个完整的圆是1turn。例：0turn，0.25turn，1.2turn-直角：90deg=100grad=0.25turn≈1.5708rad-平角：180deg=200grad=0.5turn≈3.1416rad-直角（逆时针）：-90deg=-100grad=-0.25turn≈-1.5708rad-零角：0=0deg=0grad=0turn=0rad###`<angle-percentage>`>可以是角度,也可以是百分值>使用:`calc()`##`<color>`>颜色>>-定义>-关键字颜色单词(`blue`)>-十六进制:>-#ffffff(简写#fff)>-#00ff3388(简写#0f38)>-RGB:rgb()/rgba()>-HSL:hsl()/hsla()>补充:rgba比rgb多一个参数,多一个透明值##`<time*>`>`<time>`:时间(单位`s`或`ms`)>`<time-percentage>`:时间/百分比-有效时间```txt12s正整数-456ms负整数4.3ms非整数14mS单位大小写不敏感，虽然不推荐大写+0s0以及前置+号和单位-0ms0以及前置-号和单位```-无效时间```txt0尽管<length>中允许0，其在<time>中无效。12.0此为<number>而非<time>。其缺乏单位。7ms数字与单位间不允许有空格。```##`<custom-ident>`>用户自定义字符串标识符>>组成(区分大小写)>>-字母(A-Z,a-z),>-十进制数(0-9),>-连字符(-),>-下划线(\\_),>-转义字符(\\),>-Unicode编码（格式：转义字符（\\）后跟1到6位十六进制数）-有效标识符```txtnono79字母数字混合ground-level字母-字母-test连字符后跟字母_internal下划线后跟字母\\22totoUnicode编码后跟字母bili\\.bob转义的句号```-无效标识符```txt34rem第一个字符不能是数字-12rad第一个字符连字符后不能跟数字bili.bob只有字母数字、连字符-、下划线_不需要转义--toto第一个字符不能为连字符后跟连字符'bilibob'不能用单引号包起来，这是一个字符串类型\"bilibob\"不能用双引号包起来，这是一个字符串类型```##dimension>带有单位的数据","CSS\\type\\复杂.md":"#type##`<translation-value>`>转换函数参数`translate*()`##`<basic-shape>`>基础图形的CSS数据类型###inset`clip-path:inset(22%12%15px35px);`![](/.assets/img/2022-01-18-18-12-25.png)###circle`clip-path:circle(6remat12rem8rem);`![](/.assets/img/2022-01-18-18-13-06.png)###ellipse`clip-path:ellipse(115px55pxat50%40%);`![](/.assets/img/2022-01-18-18-14-12.png)###polygon`clip-path:polygon(50%2.4%,34.5%33.8%,0%38.8%,25%63.1%,19.1%97.6%,50%81.3%,80.9%97.6%,75%63.1%,100%38.8%,65.5%33.8%);`![](/.assets/img/2022-01-18-18-15-02.png)###path`clip-path:path('M50,245A160,1600,0,1360,120z')`![](/.assets/img/2022-01-18-18-15-34.png)##`<filter-function>`>改变输入图像外观的图形效果。它可以用于filter和backdrop-filter属性>过滤函数>>-`brightness()`:让图像更明亮或更暗淡>-`contrast()`:增加或减少图像的对比度>-`drop-shadow()`:在图像后方应用投影>-`grayscale()`:将图像转为灰度图>-`hue-rotate()`:改变图像的整体色调>-`invert()`:反转图像颜色>-`opacity()`:改变图像透明度>-`saturate()`:超饱和或去饱和输入的图像>-`sepia()`:将图像转为棕褐色##`<blend-mode>`>用于描述元素重合,颜色呈现>用于`background-blend-mode`,`mix-blend-mode`属性>ie不支持###normal>最终颜色:顶层色![](/.assets/img/2022-01-18-17-27-55.png)###multiply>最终颜色:顶层颜色与底层颜色相乘![](/.assets/img/2022-01-18-17-37-23.png)###screen>最终颜色:顶层颜色和底层颜色,反转后相乘,再反转相加之和![](/.assets/img/2022-01-18-17-41-00.png)###overlay>-如果底层颜色比顶层颜色深，则最终颜色是multiply的结果>-如果底层颜色比顶层颜色浅，则最终颜色是screen的结果>-此混合模式相当于顶层与底层互换后的hard-light![](/.assets/img/2022-01-18-17-42-05.png)###darken>显示黑色![](/.assets/img/2022-01-18-17-59-23.png)###lighten>显示最亮值组成的颜色![](/.assets/img/2022-01-18-18-00-31.png)###color-dodge>显示:底部颜色除以顶部颜色的反色![](/.assets/img/2022-01-18-18-05-14.png)###color-burn>反转底部颜色,将反转后的值除以顶层颜色,再反转除以后的值![](/.assets/img/2022-01-18-18-06-02.png)###hard-light>如果顶层颜色比底层颜色深，则最终颜色是multiply的结果，如果顶层颜色比底层颜色浅，则最终颜色是screen的结果。>此混合模式相当于顶层与底层互换后的overlay。>其效果类似于在背景层上（用前景层）打出一片刺眼的聚光灯![](/.assets/img/2022-01-18-18-08-45.png)###soft-light>最终颜色类似于hard-light的结果，但更加柔和一些。>此混合模式的表现类似hard-light。>其效果类似于在背景层上（用前景层）打出一片发散的聚光灯。![](/.assets/img/2022-01-18-18-09-39.png)[其他](https://developer.mozilla.org/zh-CN/docs/Web/CSS/blend-mode)##display\\*###`<display-box>`>一个元素到底是否产生显示盒>值:`none`,`contents`###`<display-legacy>`>指定`display`的属性>值:`block`,`inline`>>-inline-block>-元素会产生一个块元素盒子，并且像内联盒子一样（表现得更像一个被替换的元素），可以融入到周围内容中。>-等同于inlineflow-root>-inline-table>-在HTML中，inline-table没有直接对应关系。它表现为一个HTML`<table>`元素，但是又表现为一个不同于块级盒子的内联盒子。表盒子内部是一个块级上下文。>-等同于inlinetable>-inline-flex>-元素表现为一个内联元素，并对内容采用弹性盒子模型进行布局。>-等同于inlineflex>-inline-grid>-元素表现为一个内联元素，并对内容采用网格模型进行布局。>-等同于inlinegrid###`<display-inside>`>元素内部类型>`flow`:该元素使用流布局（块和内联布局）来布局其内容>`flow-root`:该元素生成一个块元素框，用于建立一个新的块格式设置上下文，定义格式化根的位置。>`table`:这些元素的行为类似于HTML`<table>`elements。它定义了一个块级框。>`flex`:该元素的行为类似于块元素，并根据flexbox模型布置其内容。>`grid`:该元素的行为类似于块元素，并根据网格模型对其内容进行布局。>`ruby`:该元素的行为类似于内联元素，并根据ruby格式模型对其内容进行布局。它的行为类似于相应的HTML`<ruby>`elements。###`<display-internal>`>布局模型>`table-row-group`:这些元素的行为类似于`<tbody>`HTML元素。>`table-header-group`:这些元素的行为类似于`<thead>`HTML元素。>`table-footer-group`:这些元素的行为类似于`<tfoot>`HTML元素。>`table-row`:这些元素的行为类似于`<tr>`HTML元素。>`table-cell`:这些元素的行为类似于`<td>`HTML元素。>`table-column-group`:这些元素的行为类似于`<colgroup>`HTML元素。>`table-column`:这些元素的行为类似于`<col>`HTML元素。>`table-caption`:这些元素的行为类似于`<caption>`HTML元素。>`ruby-base`:这些元素的行为类似于`<rb>`HTML元素。>`ruby-text`:这些元素的行为类似于`<rt>`HTML元素。>`ruby-base-container`:这些元素的行为类似于`<rbc>`匿名框生成的HTML元素。>`ruby-text-container`:这些元素的行为类似于`<rtc>`HTML元素。###`<display-outside>`>-可用值>-block:这个值会生成一个块级元素盒子，同时在该元素之前和之后打断（换行）,会将该元素变成块级元素。>-inline:这个值会生成一个行内元素盒子，该元素之前和之后不会打断（换行）,如果空间充足，该元素后的元素将会在同一行显示。简单来说就是，这个值会将该元素变成行内元素。###`<display-listitem>`>该关键字使元素生成一个伪元素，其中包含由其列表样式属性（例如项目符号点）指定的内容以及为其自己的内容指定的类型的主要框","CSS\\type\\特殊.md":"#type##`<ratio>`>媒体查询中的宽高比`@mediascreen和(min-aspect-ratio：16/9){...}`##`<translation-value>`>用于某些转换函数的参数中，包括translate（）、translateX（）、translateY（）和translate3d（）。##`<position>`>2D空间中的坐标```css[[left|center|right|top|bottom|<percentage>|<length>]|[left|center|right|<percentage>|<length>][top|center|bottom|<percentage>|<length>]|[center|[left|right][<percentage>|<length>]?]&&[center|[top|bottom][<percentage>|<length>]?]]```##`<image>`>2D图形>>-CSS可以处理以下情形中的不同类型图像：>-具有固有尺寸（大小）的图像，即图像具有自己的原始尺寸（大小），比如一个jpeg格式的图像有他自己的固有尺寸（大小）；>-图像具有多个固定尺寸，可在一个文件中存在多个不同版本的尺寸，比如有些.ico格式的图像。在这种情况下，图像表现出来的固有尺寸将是这些尺寸较大的一个，也就是最接近外层包含它的容器纵横比的那个图像；>-没有固定大小但有固定纵横比的图像，像一些矢量图形，比如SVG格式的图像；>-没有固定大小也没有固定宽高比的图像，比如CSS渐变（图像）；##`<gradient>`>image子类型,表两种及以上的颜色过渡变化###线性渐变>颜色值沿着一条隐式的直线逐渐过渡。由`linear-gradient()`产生。```css.linear-gradient{background:linear-gradient(toright,red,orange,yellow,green,blue,indigo,violet);}```![](/.assets/img/2022-01-18-17-07-40.png)###径向渐变>颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值。由`radial-gradient()`函数产生。```css.radial-gradient{background:radial-gradient(red,yellow,rgb(30,144,255));}```![](/.assets/img/2022-01-18-17-08-48.png)###重复渐变>重复多次渐变图案直到足够填满指定元素>由`repeating-linear-gradient()`和`repeating-radial-gradient()`函数产生```css.linear-repeat{background:repeating-linear-gradient(totopleft,lightpink,lightpink5px,white5px,white10px);}.radial-repeat{background:repeating-radial-gradient(powderblue,powderblue8px,white8px,white16px);}```![](/.assets/img/2022-01-18-17-10-04.png)##`<resolution>`>分辨率：用于描述媒体查询中的分辨率的<resolution>CSS数据类型表示输出设备的像素密度。>>-在屏幕上，单位与CSS英寸，厘米或像素有关，而与物理值无关>-单位>-dpi:表示每英寸的点数。屏幕通常每英寸包含72或96个点，但打印文档的dpi通常要大得多。>-dpcm:每厘米上的点数>-dppx:表示每个px的点数。由于CSSpx的固定比率为1:96，因此1dppx相当于96dpi>-x:dppx的别名","CSS\\伪元素\\empty.md":"#[`:empty`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty)>代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格）。注释或处理指令都不会产生影响```css.container:empty::after{content:'暂无数据';}```![](./.assets/empty-2022-11-04-10-27-56.png)","CSS\\伪元素\\focus-within.md":"#[`focus-within`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within)>表示一个元素获得焦点，或该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配:focus伪类![](./.assets/focus-within-2022-11-04-10-41-36.png)","CSS\\伪元素\\invalid.md":"#[`invalid`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid)>表示任意内容未通过验证的`<input>`或其他`<form>`元素![](./.assets/invalid-2022-11-04-10-39-54.png)","CSS\\伪类元素.md":"#伪类元素>Resudo-classes&Pseudo-elements##相关补充```css/*CSS3语法*/element::before{样式}/*（单冒号）CSS2过时语法(仅用来支持IE8)*/element:before{样式}```##before&after>-`before`:>-`after````html<q>一些引用</q>,他说,<q>比没有好。</q>.``````cssq::before{content:'«';color:blue;}q::after{content:'»';color:red;}```![](/.assets/img/2022-01-10-16-06-07.png)##selection-修改选中文本的样式```htmlThistexthasspecialstyleswhenyouhighlightit.<p>Alsotryselectingtextinthisparagraph.</p>``````css::-moz-selection{color:gold;background-color:red;}p::-moz-selection{color:white;background-color:blue;}/*选中的文本是红色背景，金黄色的字体*/::selection{color:gold;background-color:red;}/*选中的是蓝色背景，白色的字体的段落*/p::selection{color:white;background-color:blue;}```![](/.assets/img/2022-01-10-16-09-16.png)##nth\\*-`nth-child(an+b)&nth-of-type(an+b)&nth-last-child(an+b)&nth-last-of-type(an+b)`-CSS伪类首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3...）。示例：-0n+3或简单的3匹配第三个元素。-1n+0或简单的n匹配每个元素。（兼容性提醒：在Android浏览器4.3以下的版本n和1n的匹配方式不一致。1n1n+0是一致的，可根据喜好任选其一来使用。）-2n+0或简单的2n匹配位置为2、4、6、8...的元素（n=0时，2n+0=0，第0个元素不存在，因为是从1开始排序)关键字even来替换此表达式。-2n+1匹配位置为1、3、5、7...的元素。你可以使用关键字odd来替换此表达式。-3n+4匹配位置为4、7、10、13...的元素。0a和b都必须为整数，并且元素的第一个子元素的下标为1。换言之就是，该伪类匹配所有下标在集合{an+b;n=0,1,2,...}中的子元素。另外需要特别注意的是，an必须写在b的前面，不能写成b+an的形式。-`nth-of-type`:忽略掉不符合选择器要求的元素-`nth-last-child(an+b)`:从后往前匹配-`nth-last-of-type(an+b)`:忽略掉不符合选择器要求的元素,从后往前匹配```html<h3><code>span:nth-child(2n+1)</code>,WITHOUTan<code>&lt;em&gt;</code>amongthechildelements.</h3><p>Children1,3,5,and7areselected.</p><divclass=\"first\"><span>Span1!</span><span>Span2</span><span>Span3!</span><span>Span4</span><span>Span5!</span><span>Span6</span><span>Span7!</span></div><br/><h3><code>span:nth-child(2n+1)</code>,WITHan<code>&lt;em&gt;</code>amongthechildelements.</h3><p>Children1,5,and7areselected.<br/>3isusedinthecountingbecauseitisachild,butitisn'tselectedbecauseitisn'ta<code>&lt;span&gt;</code>.</p><divclass=\"second\"><span>Span!</span><span>Span</span><em>Thisisan`em`.</em><span>Span</span><span>Span!</span><span>Span</span><span>Span!</span><span>Span</span></div><br/><h3><code>span:nth-of-type(2n+1)</code>,WITHan<code>&lt;em&gt;</code>amongthechildelements.</h3><p>Children1,4,6,and8areselected.<br/>3isn'tusedinthecountingorselectedbecauseitisan<code>&lt;em&gt;</code>,nota<code>&lt;span&gt;</code>,and<code>nth-of-type</code>onlyselectschildrenofthattype.The<code>&lt;em&gt;</code>iscompletelyskippedoverandignored.</p><divclass=\"third\"><span>Span!</span><span>Span</span><em>Thisisan`em`.</em><span>Span!</span><span>Span</span><span>Span!</span><span>Span</span><span>Span!</span></div>``````csshtml{font-family:sans-serif;}span,divem{padding:5px;border:1pxsolidgreen;display:inline-block;margin-bottom:3px;}.firstspan:nth-child(2n+1),.secondspan:nth-child(2n+1),.thirdspan:nth-of-type(2n+1){background-color:lime;}```![](/.assets/img/2022-01-10-16-17-19.png)##only\\*###only-child>-`only-child`_匹配没有任何兄弟元素的元素._>-等效的选择器还可以写成`:first-child:last-child`或者`:nth-child(1):nth-last-child(1)`,当然,前者的权重会低一点.>-`only-of-type`代表了任意一个元素，这个元素没有其他相同类型的兄弟元素。```html<main><div><i>Iamalonelyonlychild.</i></div><div><i>Ihavesiblings.</i><br/><b>SodoI!</b><br/><span>Ialsohavesiblings,<span>butthisisanonlychild.</span></span></div></main>``````cssmain:only-child{color:red;}```![](/.assets/img/2022-01-10-16-30-43.png)###only-of-type```html<main><div>Iam`div`#1.</div><p>Iamtheonly`p`amongmysiblings.</p><div>Iam`div`#2.</div><div>Iam`div`#3.<i>Iamtheonly`i`child.</i><em>Iam`em`#1.</em><em>Iam`em`#2.</em></div></main>``````cssmain:only-of-type{color:red;}```![](/.assets/img/2022-01-10-16-32-17.png)##first\\*###first-child>一组兄弟元素中的第一个元素>不能改变所有的css属性.你只能改变margins、orphans、widows、文档什么时候换页。别的所有css样式都会被忽略。```html<div><p>Thistextisselected!</p><p>Thistextisn'tselected.</p></div><div><h2>Thistextisn'tselected:it'snota`p`.</h2><p>Thistextisn'tselected.</p></div>``````cssp:first-child{color:lime;background-color:black;padding:5px;}```![](/.assets/img/2022-01-11-09-37-18.png)###first-of-type>一组兄弟元素中其类型的第一个元素```html<h2>Heading</h2><p>Paragraph1</p><p>Paragraph1</p>``````cssp:first-of-type{color:red;font-style:italic;}```![](/.assets/img/2022-01-11-09-40-08.png)###first-letter>-伪元素>-选中某block-levelelement（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格）>只在display属性值为`block,inline-block,table-cell,list-item`或者`table-caption`的元素上才起作用>只有一小部分CSS可以在包含使用了::first-letter伪元素选择器的CSS规则集声明块内运用:>-所有的字体属性:`font,font-style,font-feature-settings,font-kerning,font-language-override,font-stretch,font-synthesis,font-variant,font-variant-alternates,font-variant-caps,font-variant-east-asian,font-variant-ligatures,font-variant-numeric,font-variant-position,font-weight,font-size,font-size-adjust,line-height以及font-family.`>-所有的背景属性:`background-color,background-image,background-clip,background-origin,background-position,background-repeat,background-size,background-attachment以及background-blend-mode.`>-所有的外边距属性:`margin,margin-top,margin-right,margin-bottom,margin-left.`>-所有的内边距属性:`padding,padding-top,padding-right,padding-bottom,padding-left.`>-所有的边框属性:比如一些简短的边框属性`border,border-style,border-color,border-width,border-radius,border-image`,还剩下许多冗长的边框属性等等.>-`color`属性.>-`text-decoration,text-shadow,text-transform,letter-spacing,word-spacing(使用恰当的话),line-height,text-decoration-color,text-decoration-line,text-decoration-style,box-shadow,float,vertical-align`注意此刻必须没有浮动)等属性.```html<divclass=\"fl\">ruihuig</div><divclass=\"fl\">Ruihuig</div>``````css.fl::first-letter{color:red;}```###first-line>-伪元素>-块级元素的第一行应用样式。第一行的长度取决于很多因素，包括元素宽度，文档宽度和文本的文字大小。>-和其他所有的伪元素一样，::first-line不能匹配任何真实存在的html元素。>-::first-line伪元素只能在块容器中,所以,::first-line伪元素只能在一个display值为block,inline-block,table-cell或者table-caption中有用.。在其他的类型中，::first-line是不起作用的.>-允许属性>-所有和字体有关的属性：`font,font-kerning,font-style,font-variant,font-variant-numeric,font-variant-position,font-variant-east-asian(en-US),font-variant-caps,font-variant-alternates,font-variant-ligatures,font-synthesis,font-feature-settings,font-language-override,font-weight,font-size,font-size-adjust,font-stretch,andfont-family`>color>-所有和背景有关的属性：`background-color,background-clip,background-image,background-origin,background-position,background-repeat,background-size,background-attachment,andbackground-blend-modeword-spacing,letter-spacing,text-decoration,text-transform,andline-heighttext-shadow,text-decoration,text-decoration-color,text-decoration-line,text-decoration-style,andvertical-align.````html<p>Loremipsumdolorsitamet,consecteturadipisicingelit,seddoeiusmodtemporincididuntutlabore.</p>``````cssp::first-line{text-transform:uppercase;}```![](/.assets/img/2022-01-18-15-03-49.png)##last\\*###last-child>代表父元素的最后一个子元素```html<ul><li>此元素背景色不是lime</li><li>我的也不是lime。</li><li>我的才是lime！:)</li></ul>``````cssli:last-child{background-color:lime;}```![](/.assets/img/2022-01-18-11-34-13.png)###last-of-type>表示了在（它父元素的）子元素列表中，最后一个给定类型的元素。当代码类似ParenttagName:last-of-type的作用区域包含父元素的所有子元素中的最后一个选定元素，也包括子元素的最后一个子元素并以此类推。```html<p><em>我没有颜色:(</em><br/><strong>我没有颜色:(</strong><br/><em>我有颜色:D</em><br/><strong>我也没有颜色:(</strong><br/></p><p><em>我没有颜色:(</em><br/><span><em>我有颜色!</em></span><br/><strong>我没有颜色:(</strong><br/><em>我有颜色:D</em><br/><span><em>我在子元素里，但没有颜色!</em><br/><spanstyle=\"text-decoration:line-through;\">我没有颜色</span><br/><em>我却有颜色！</em><br/></span><br/><strong>我也没有颜色:(</strong></p>``````csspem:last-of-type{color:lime;}```![](/.assets/img/2022-01-18-11-33-20.png)##slotted>选定那些被放在HTML模板中的元素```css/*Selectsanyelementplacedinsideaslot*/::slotted(*){font-weight:bold;}/*Selectsany<span>placedinsideaslot*/::slotted(span){font-weight:bold;}```##root>表示<html>元素，除了优先级更高之外，与html选择器相同```css/*声明css变量*/:root{--main-color:hotpink;--pane-padding:5px42px;}``````html<pid=\"firstParagraph\">Thisparagraphshouldhaveabluebackgroundandyellowtext.</p><pid=\"secondParagraph\">Thisparagraphshouldhaveayellowbackgroundandbluetext.</p><divid=\"container\"><pid=\"thirdParagraph\">Thisparagraphshouldhaveagreenbackgroundandyellowtext.</p></div>``````css:root{--first-color:#16f;--second-color:#ff7;}#firstParagraph{background-color:var(--first-color);color:var(--second-color);}#secondParagraph{background-color:var(--second-color);color:var(--first-color);}#container{--first-color:#290;}#thirdParagraph{background-color:var(--first-color);color:var(--second-color);}``````css:root{--first-color:#16f;--second-color:#ff7;}#firstParagraph{background-color:var(--first-color);color:var(--second-color);}#secondParagraph{background-color:var(--second-color);color:var(--first-color);}#container{--first-color:#290;}#thirdParagraph{background-color:var(--first-color);color:var(--second-color);}```![](/.assets/img/2022-01-10-17-25-23.png)##link&visited&hover&active>-:active伪类一般被用在`<a>`和`<button>`元素中.这个伪类的一些其他适用对象包括包含激活元素的元素，以及可以通过他们关联的`<label>`标签被激活的表格元素。```html<p>Thisparagraphcontainsalink:<ahref=\"#\">Thislinkwillturnredwhileyouclickonit.</a>Theparagraphwillgetagraybackgroundwhileyouclickonitorthelink.</p>``````cssa:link{color:blue;}/*未访问链接*/a:visited{color:purple;}/*已访问链接*/a:hover{background:yellow;}/*用户鼠标悬停*/a:active{color:red;}/*激活链接*/p:active{background:#eee;}/*激活段落*/```![](/.assets/img/2022-01-10-17-39-39.png)##default>一组相关元素中的默认表单元素```html<inputtype=\"radio\"name=\"season\"id=\"spring\"/><labelfor=\"spring\">Spring</label><inputtype=\"radio\"name=\"season\"id=\"summer\"checked/><labelfor=\"summer\">Summer</label><inputtype=\"radio\"name=\"season\"id=\"fall\"/><labelfor=\"fall\">Fall</label><inputtype=\"radio\"name=\"season\"id=\"winter\"/><labelfor=\"winter\">Winter</label>``````cssinput:default{box-shadow:002px1pxcoral;}input:default+label{color:coral;}```![](/.assets/img/2022-01-10-17-43-49.png)##defined>表示任何已定义的元素。这包括任何浏览器内置的标准元素以及已成功定义的自定义```css/*选择所有已定义的元素*/:defined{font-style:italic;}/*选择指定自定义元素的任何实例*/simple-custom:defined{display:block;}```##checked>处于选中状态的radio(`<inputtype=\"radio\">`),checkbox(`<inputtype=\"checkbox\">`)或(\"select\")元素中的optionHTML元素(\"option\")。```css/*匹配任意被勾选/选中的radio(单选按钮),checkbox(复选框),或者option(select中的一项)*/:checked{margin-left:25px;border:1pxsolidblue;}``````html<div><inputtype=\"radio\"name=\"my-input\"id=\"yes\"/><labelfor=\"yes\">Yes</label><inputtype=\"radio\"name=\"my-input\"id=\"no\"/><labelfor=\"no\">No</label></div><div><inputtype=\"checkbox\"name=\"my-checkbox\"id=\"opt-in\"/><labelfor=\"opt-in\">Checkme!</label></div><selectname=\"my-select\"id=\"fruit\"><optionvalue=\"opt1\">Apples</option><optionvalue=\"opt2\">Grapes</option><optionvalue=\"opt3\">Pears</option></select>``````cssdiv,select{margin:8px;}/*Labelsforcheckedinputs*/input:checked+label{color:red;}/*Radioelement,whenchecked*/input[type='radio']:checked{box-shadow:0003pxorange;}/*Checkboxelement,whenchecked*/input[type='checkbox']:checked{box-shadow:0003pxhotpink;}/*Optionelements,whenselected*/option:checked{box-shadow:0003pxlime;color:red;}```![](/.assets/img/2022-01-10-17-53-43.png)###借用隐藏的checkbox来切换元素的样式（显示/隐藏）```html<inputtype=\"checkbox\"id=\"expand-toggle\"/><table><thead><tr><th>Column#1</th><th>Column#2</th><th>Column#3</th></tr></thead><tbody><trclass=\"expandable\"><td>[moretext]</td><td>[moretext]</td><td>[moretext]</td></tr><tr><td>[celltext]</td><td>[celltext]</td><td>[celltext]</td></tr><tr><td>[celltext]</td><td>[celltext]</td><td>[celltext]</td></tr><trclass=\"expandable\"><td>[moretext]</td><td>[moretext]</td><td>[moretext]</td></tr><trclass=\"expandable\"><td>[moretext]</td><td>[moretext]</td><td>[moretext]</td></tr></tbody></table><labelfor=\"expand-toggle\"id=\"expand-btn\">Togglehiddenrows</label>``````css/*Hidethetogglecheckbox*/#expand-toggle{display:none;}/*Hideexpandablecontentbydefault*/.expandable{visibility:collapse;background:#ddd;}/*Stylethebutton*/#expand-btn{display:inline-block;margin-top:12px;padding:5px11px;background-color:#ff7;border:1pxsolid;border-radius:3px;}/*Showhiddencontentwhenthecheckboxischecked*/#expand-toggle:checked~*.expandable{visibility:visible;}/*Stylethebuttonwhenthecheckboxischecked*/#expand-toggle:checked~#expand-btn{background-color:#ccc;}```![](./../../.assets/gif/checked.gif)##disabled>表示任何被禁用的元素>如果一个元素不能被激活（如选择、点击或接受文本输入）或获取焦点，则该元素处于被禁用状态。元素还有一个启用状态（enabledstate），在启用状态下，元素可以被激活或获取焦点。```css/*Selectsanydisabled<input>*/input:disabled{background:#ccc;}```##empty>代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格）。注释或处理指令都不会产生影响。```html<divclass=\"box\"><!--Iwillbelime--></div><divclass=\"box\">Iwillbepink</div><divclass=\"box\"><!--Iwillberedbecauseofthewhitespacearoundthiscomment--></div>``````css.box{background:pink;height:80px;width:80px;}.box:empty{background:lime;}```![](/.assets/img/2022-01-10-22-56-52.png)##enabled>任何被启用的（enabled）元素。如果一个元素能够被激活（如选择、点击或接受文本输入），或者能够获取焦点，则该元素是启用的。元素也有一个禁用的状态（disabledstate），在被禁用时，元素不能被激活或获取焦点```html<formaction=\"url_of_form\"><labelfor=\"FirstField\">Firstfield(enabled):</label><inputtype=\"text\"id=\"FirstField\"value=\"Lorem\"/><br/><labelfor=\"SecondField\">Secondfield(disabled):</label><inputtype=\"text\"id=\"SecondField\"value=\"Ipsum\"disabled=\"disabled\"/><br/><inputtype=\"button\"value=\"Submit\"/></form>``````cssinput:enabled{color:#2b2;}input:disabled{color:#aaa;}```![](/.assets/img/2022-01-11-09-32-53.png)##focus\\*###focus>表示获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的“tab”键选择它时会被触发。>此伪类仅适用于焦点元素本身。如果要选择包含焦点元素的元素，请使用`:focus-within````html<inputclass=\"red-input\"value=\"I'llberedwhenfocused.\"/><br/><inputclass=\"blue-input\"value=\"I'llbebluewhenfocused.\"/>``````css.red-input:focus{background:yellow;color:red;}.blue-input:focus{background:yellow;color:blue;}```![](/.assets/img/2022-01-11-09-55-39.png)###focus-within>表示一个元素获得焦点，或，该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配`:focus`伪类```html<p>试试在这个表单中输入点什么。</p><form><labelfor=\"given_name\">GivenName:</label><inputid=\"given_name\"type=\"text\"/><br/><labelfor=\"family_name\">FamilyName:</label><inputid=\"family_name\"type=\"text\"/></form>``````cssform{border:1pxsolid;color:gray;padding:4px;}form:focus-within{background:#ff8;color:black;}input{margin:4px;}```![](/.assets/img/2022-01-11-10-01-26.png)###focus-visible>当元素匹配:focus伪类并且客户端(UA)的启发式引擎决定焦点应当可见(在这种情况下很多浏览器默认显示“焦点框”。)时，:focus-visible伪类将生效。>这个选择器可以有效地根据用户的输入方式(鼠标vs键盘)展示不同形式的焦点。>请注意Firefox通过较旧的前缀伪类:-moz-focusring支持类似的功能。更多细节请参考:-moz-focusring(en-US)页面。```html<inputvalue=\"Defaultstyles\"/><br/><button>Defaultstyles</button><br/><inputclass=\"focus-only\"value=\":focusonly\"/><br/><buttonclass=\"focus-only\">:focusonly</button><br/><inputclass=\"focus-visible-only\"value=\":focus-visibleonly\"/><br/><buttonclass=\"focus-visible-only\">:focus-visibleonly</button>``````cssinput,button{margin:10px;}.focus-only:focus{outline:2pxsolidblack;}.focus-visible-only:focus-visible{outline:4pxdasheddarkorange;}```![](/.assets/img/2022-01-11-10-07-28.png)>`focus-visiblebtn`不会触发点击按钮的边框##\\*range###out-of-range>CSS伪类表示一个`<input>`元素，其当前值处于属性min和max限定的范围外。###in-range>CSS伪类代表一个`<input>`元素，其当前值处于属性min和max限定的范围之内.```html<formaction=\"\"id=\"form1\"><ul>Valuesbetween1and10arevalid.<li><inputid=\"value1\"name=\"value1\"type=\"number\"placeholder=\"1to10\"min=\"1\"max=\"10\"value=\"12\"/><labelfor=\"value1\">Yourvalueis</label></li></ul></form>``````cssli{list-style:none;margin-bottom:1em;}input{border:1pxsolidblack;}input:in-range{background-color:rgba(0,255,0,0.25);}input:out-of-range{background-color:rgba(255,0,0,0.25);border:2pxsolidred;}input:in-range+label::after{content:'okay.';}input:out-of-range+label::after{content:'outofrange!';}```![](/.assets/img/2022-01-11-10-30-41.png)![](/.assets/img/2022-01-11-10-31-07.png)##autofill>浏览器自动填充是触发,用户编辑就会停止匹配>注意：许多浏览器的用户代理样式表在其样式声明中使用，使它们无法被网页覆盖，而无需诉诸JavaScript黑客。例如，Chrome在其内部样式表中具有以下内容：!important:-webkit-autofill```html<formmethod=\"post\"action=\"\"><labelfor=\"email\">Email</label><inputtype=\"email\"name=\"email\"id=\"email\"autocomplete=\"email\"/></form>``````cssinput{border:3pxsolidgrey;border-radius:3px;}input:-webkit-autofill{border:3pxsolidblue;}input:autofill{border:3pxsolidblue;}```![](/.assets/img/2022-01-18-11-02-57.png)##not-用来匹配不符合一组选择器的元素。由于它的作用是防止特定的元素被选中，它也被称为反选伪类（negationpseudo-class）。-:not()伪类不能被嵌套，这意味着:not(:not(...))是无效的。-由于伪元素不是简单的选择器，他们不能被当作:not()中的参数，形如:not(p::before)这样的选择器将不会工作。-可以利用这个伪类写一个完全没有用处的选择器。例如，:not(\\*)匹配任何非元素的元素，因此，这个规则将永远不会被应用。-可以利用这个伪类提高规则的优先级。例如，#foo:not(#bar)和#foo会匹配相同的元素，但是前者的优先级更高。-:not(.foo)将匹配任何非.foo的元素，包括`<html>`和`<body>`。-这个选择器只会应用在一个元素上，无法用它来排除所有父元素。比如，body:not(table)a依旧会应用到表格元素`<table>`内部的`<a>`上,因为`<tr>`将会被`:not(table)`这部分选择器匹配。```html<p>我是一个段落。</p><pclass=\"fancy\">我好看极了！</p><div>我「不是」一个段落。</div>``````css.fancy{text-shadow:2px2px3pxgold;}/*类名不是`.fancy`的<p>元素*/p:not(.fancy){color:green;}/*非<p>元素*/body:not(p){text-decoration:underline;}/*既不是<div>也不是<span>的元素*/body:not(div):not(span){font-weight:bold;}/*类名不是`.crazy`或`.fancy`的元素*//*注意，此语法尚未获广泛支持。*/body:not(.crazy,.fancy){font-family:sans-serif;}```![](/.assets/img/2022-01-18-11-26-12.png)##target>代表一个唯一的页面元素(目标元素)，其id与当前URL片段匹配>经常与`<a>`连用```html<h3>TableofContents</h3><ol><li><ahref=\"#p1\">Jumptothefirstparagraph!</a></li><li><ahref=\"#p2\">Jumptothesecondparagraph!</a></li><li><ahref=\"#nowhere\">Thislinkgoesnowhere,becausethetargetdoesn'texist.</a></li></ol><h3>MyFunArticle</h3><pid=\"p1\">Youcantarget<i>thisparagraph</i>usingaURLfragment.Clickonthelinkabovetotryout!</p><pid=\"p2\">Thisis<i>anotherparagraph</i>,alsoaccessiblefromthelinksabove.Isn'tthatdelightful?</p>``````cssp:target{background-color:gold;}/*在目标元素中增加一个伪元素*/p:target::before{font:70%sans-serif;content:'►';color:limegreen;margin-right:0.25em;}/*在目标元素中使用italic样式*/p:targeti{color:red;}```![](/.assets/img/2022-01-18-14-19-51.png)点击`Jumptothefirstparagraph`![](/.assets/img/2022-01-18-14-32-58.png)##scope>作为选择器要匹配的参考点的元素>>不支持IE-当需要获取已检索到的的直接后代元素时，:scope伪类很有用```jsvarcontext=document.getElementById('context')varselected=context.querySelectorAll(':scope>div')document.getElementById('results').innerHTML=Array.prototype.map.call(selected,function(element){return'#'+element.getAttribute('id')}).join(',')``````html<divid=\"context\"><divid=\"element-1\"><divid=\"element-1.1\"></div><divid=\"element-1.2\"></div></div><divid=\"element-2\"><divid=\"element-2.1\"></div></div></div><p>Selectedelementsids:<spanid=\"results\"></span></p>```![](/.assets/img/2022-01-18-14-15-53.png)##read\\*###read-only>元素不可被用户编辑的状态(锁文本输入)```html<inputtype=\"text\"value=\"Typewhateveryouwanthere.\"/><inputtype=\"text\"value=\"Thisisaread-onlyfield.\"readonly/><p>Thisisanormalparagraph.</p><pcontenteditable=\"true\">Youcaneditthisparagraph!</p>``````cssinput{min-width:25em;}input:-moz-read-only{background:cyan;}input:read-only{background:cyan;}p:-moz-read-only{background:lightgray;}p:read-only{background:lightgray;}p[contenteditable='true']{color:blue;}```![](/.assets/img/2022-01-18-11-47-05.png)###read-write>代表一个元素（例如可输入文本的input元素）可以被用户编辑```html<inputtype=\"text\"value=\"Typewhateveryouwanthere.\"/><inputtype=\"text\"value=\"Thisisaread-onlyfield.\"readonly/><p>Thisisanormalparagraph.</p><pcontenteditable=\"true\">Youcaneditthisparagraph!</p>``````cssinput{min-width:25em;}input:-moz-read-write{background:cyan;}input:read-write{background:cyan;}p:-moz-read-write{background:lightgray;}p:read-write{background:lightgray;}p[contenteditable='true']{color:blue;}```![](/.assets/img/2022-01-18-11-48-34.png)##表单元素相关###required>表示任意设置了required属性的`<input>`，`<select>`,或`<textarea>`元素>这个伪类对于高亮显示在提交表单之前必须具有有效数据的字段非常有用。###optional>表示任意`没有required`属性的`<input>`，`<select>`或`<textarea>`元素使用###indeterminate>状态不确定的表单元素(例如checkbox没有初始化)###\\*valid####valid>表示内容验证正确的`<input>`或其他`<form>`元素。这能简单地将校验字段展示为一种能让用户辨别出其输入数据的正确性的样式。>选择正确校验通过的字段元素>`>ie10`####invalid>表示任意内容未通过验证的`<input>`或其他`<form>`元素.```html<form><labelfor=\"url_input\">EnteraURL:</label><inputtype=\"url\"id=\"url_input\"/><br/><br/><labelfor=\"email_input\">Enteranemailaddress:</label><inputtype=\"email\"id=\"email_input\"required/></form>``````cssinput:invalid{background-color:#ffdddd;}form:invalid{border:5pxsolid#ffdddd;}input:valid{background-color:#ddffdd;}form:valid{border:5pxsolid#ddffdd;}****input:required{border-color:#800000;border-width:3px;}input:required:invalid{border-color:#c00000;}```![](/.assets/img/2022-01-18-10-25-37.png)##打印相关###right>必须与@规则@page一起配套使用，表示打印文档的所有右页。>只能用于更改页面的margin,padding,border,andbackground属性。其它属性都将被忽略，只会影响页框，不会影响文档内容。###first>@pageCSS伪类选择器描述的是：打印文档的时候，第一页的样式。```html<p>FirstPage.</p><p>SecondPage.</p><button>Print!</button>``````css@page:first{margin-left:50%;margin-top:50%;}p{page-break-after:always;}``````jsdocument.querySelector('button').onclick=function(){window.print()}```![](/.assets/img/2022-01-11-09-48-13.png)![](/.assets/img/2022-01-11-09-48-35.png)","CSS\\光标.md":"#光标##caret-color>定义插入光标的颜色","CSS\\动画\\@keyframes.md":"#@keyframes>规定某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果。##改变背景颜色```css@keyframesmyfirst{from{background:red;}to{background:yellow;}}@-moz-keyframesmyfirst/*Firefox*/{from{background:red;}to{background:yellow;}}@-webkit-keyframesmyfirst/*Safari和Chrome*/{from{background:red;}to{background:yellow;}}@-o-keyframesmyfirst/*Opera*/{from{background:red;}to{background:yellow;}}div{animation:myfirst5s;-moz-animation:myfirst5s;/*Firefox*/-webkit-animation:myfirst5s;/*Safari和Chrome*/-o-animation:myfirst5s;/*Opera*/}//把\"myfirst\"动画捆绑到div元素，时长：5秒：```####多次改变背景颜色>当动画为25%及50%时改变背景色，然后当动画100%完成时再次改变：```css@keyframesmyfirst{0%{background:red;}25%{background:yellow;}50%{background:blue;}100%{background:green;}}@-moz-keyframesmyfirst/*Firefox*/{0%{background:red;}25%{background:yellow;}50%{background:blue;}100%{background:green;}}@-webkit-keyframesmyfirst/*Safari和Chrome*/{0%{background:red;}25%{background:yellow;}50%{background:blue;}100%{background:green;}}@-o-keyframesmyfirst/*Opera*/{0%{background:red;}25%{background:yellow;}50%{background:blue;}100%{background:green;}}```####改变背景颜色和位置```css@keyframesmyfirst{0%{background:red;left:0px;top:0px;}25%{background:yellow;left:200px;top:0px;}50%{background:blue;left:200px;top:200px;}75%{background:green;left:0px;top:200px;}100%{background:red;left:0px;top:0px;}}@-moz-keyframesmyfirst/*Firefox*/{0%{background:red;left:0px;top:0px;}25%{background:yellow;left:200px;top:0px;}50%{background:blue;left:200px;top:200px;}75%{background:green;left:0px;top:200px;}100%{background:red;left:0px;top:0px;}}@-webkit-keyframesmyfirst/*Safari和Chrome*/{0%{background:red;left:0px;top:0px;}25%{background:yellow;left:200px;top:0px;}50%{background:blue;left:200px;top:200px;}75%{background:green;left:0px;top:200px;}100%{background:red;left:0px;top:0px;}}@-o-keyframesmyfirst/*Opera*/{0%{background:red;left:0px;top:0px;}25%{background:yellow;left:200px;top:0px;}50%{background:blue;left:200px;top:200px;}75%{background:green;left:0px;top:200px;}100%{background:red;left:0px;top:0px;}}```|属性|描述||:-----------------------------------------------------------------------------------------------|:-------------------------------------------------------||[@keyframes](https://www.w3school.com.cn/cssref/pr_keyframes.asp)|规定动画。||[animation](https://www.w3school.com.cn/cssref/pr_animation.asp)|所有动画属性的简写属性，除了animation-play-state属性。||[animation-name](https://www.w3school.com.cn/cssref/pr_animation-name.asp)|规定@keyframes动画的名称。||[animation-duration](https://www.w3school.com.cn/cssref/pr_animation-duration.asp)|规定动画完成一个周期所花费的秒或毫秒。默认是0。||[animation-timing-function](https://www.w3school.com.cn/cssref/pr_animation-timing-function.asp)|规定动画的速度曲线。默认是\"ease\"。||[animation-delay](https://www.w3school.com.cn/cssref/pr_animation-delay.asp)|规定动画何时开始。默认是0。||[animation-iteration-count](https://www.w3school.com.cn/cssref/pr_animation-iteration-count.asp)|规定动画被播放的次数。默认是1。||[animation-direction](https://www.w3school.com.cn/cssref/pr_animation-direction.asp)|规定动画是否在下一周期逆向地播放。默认是\"normal\"。||[animation-play-state](https://www.w3school.com.cn/cssref/pr_animation-play-state.asp)|规定动画是否正在运行或暂停。默认是\"running\"。||[animation-fill-mode](https://www.w3school.com.cn/cssref/pr_animation-fill-mode.asp)|规定对象动画时间之外的状态。|","CSS\\动画\\transform\\2D.md":"#2D转换>能对元素进行移动、缩放、转动、拉长或拉伸##rotate():顺时针旋转```cssdiv{transform:rotate(30deg);-ms-transform:rotate(30deg);/*IE9*/-webkit-transform:rotate(30deg);/*SafariandChrome*/-o-transform:rotate(30deg);/*Opera*/-moz-transform:rotate(30deg);/*Firefox*/}```>deg:单位度##translate(x,y):移动>|translateX(_n_)|定义2D转换，沿着X轴移动元素。|>|---------------|---------------------------------|>|translateY(_n_)|定义2D转换，沿着Y轴移动元素。|```cssdiv{transform:translate(50px,100px);-ms-transform:translate(50px,100px);/*IE9*/-webkit-transform:translate(50px,100px);/*SafariandChrome*/-o-transform:translate(50px,100px);/*Opera*/-moz-transform:translate(50px,100px);/*Firefox*/}```##scale(x,y):放大>宽放大x倍,高扩大y倍>>|scaleX(_n_)|定义2D缩放转换，改变元素的宽度。|>|-----------|----------------------------------|>|scaleY(_n_)|定义2D缩放转换，改变元素的高度。|```cssdiv{transform:scale(2,4);-ms-transform:scale(2,4);/*IE9*/-webkit-transform:scale(2,4);/*Safari和Chrome*/-o-transform:scale(2,4);/*Opera*/-moz-transform:scale(2,4);/*Firefox*/}```##skew():翻转>值skew(30deg,20deg)围绕X轴把元素翻转30度，围绕Y轴翻转20度>>|skewX(_angle_)|定义2D倾斜转换，沿着X轴。|>|--------------|-----------------------------|>|skewY(_angle_)|定义2D倾斜转换，沿着Y轴。|```cssdiv{transform:skew(30deg,20deg);-ms-transform:skew(30deg,20deg);/*IE9*/-webkit-transform:skew(30deg,20deg);/*SafariandChrome*/-o-transform:skew(30deg,20deg);/*Opera*/-moz-transform:skew(30deg,20deg);/*Firefox*/}```##matrix():把所有2D转换方法组合在一起```csstransform:matrix(a,b,c,d,e,f);```![](https://images.gitee.com/uploads/images/2020/0521/232156_7bf18ee4_6545143.png)>​x=>`ax+cy+e`>>​y=>`bx+dy+f````cssdiv{transform:matrix(0.866,0.5,-0.5,0.866,0,0);-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0);/*IE9*/-moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0);/*Firefox*/-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0);/*SafariandChrome*/-o-transform:matrix(0.866,0.5,-0.5,0.866,0,0);/*Opera*/}```","CSS\\动画\\transform\\3D.md":"#3D转换##rotateX():绕X翻转```cssdiv{transform:rotateX(120deg);-webkit-transform:rotateX(120deg);/*Safari和Chrome*/-moz-transform:rotateX(120deg);/*Firefox*/}```##rotateY():绕Y旋转```cssdiv{transform:rotateY(130deg);-webkit-transform:rotateY(130deg);/*Safari和Chrome*/-moz-transform:rotateY(130deg);/*Firefox*/}```|函数|描述||:-------------------------------------------------------------------------|:----------------------------------------||matrix3d(_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_,_n_)|定义3D转换，使用16个值的4x4矩阵。||translate3d(_x_,_y_,_z_)|定义3D转化。||translateX(_x_)|定义3D转化，仅使用用于X轴的值。||translateY(_y_)|定义3D转化，仅使用用于Y轴的值。||translateZ(_z_)|定义3D转化，仅使用用于Z轴的值。||scale3d(_x_,_y_,_z_)|定义3D缩放转换。||scaleX(_x_)|定义3D缩放转换，通过给定一个X轴的值。||scaleY(_y_)|定义3D缩放转换，通过给定一个Y轴的值。||scaleZ(_z_)|定义3D缩放转换，通过给定一个Z轴的值。||rotate3d(_x_,_y_,_z_,_angle_)|定义3D旋转。||rotateX(_angle_)|定义沿X轴的3D旋转。||rotateY(_angle_)|定义沿Y轴的3D旋转。||rotateZ(_angle_)|定义沿Z轴的3D旋转。||perspective(_n_)|定义3D转换元素的透视视图。|","CSS\\动画\\transition.md":"#transition>过渡```cssdiv{transition:width2s,height2s,transform2s;-moz-transition:width2s,height2s,-moz-transform2s;-webkit-transition:width2s,height2s,-webkit-transform2s;-o-transition:width2s,height2s,-o-transform2s;}div:hover{width:200px;height:200px;transform:rotate(180deg);-moz-transform:rotate(180deg);/*Firefox4*/-webkit-transform:rotate(180deg);/*SafariandChrome*/-o-transform:rotate(180deg);/*Opera*/}//实现鼠标移至元素div上,div会变成div:hover{},过渡时间为2s```|属性|描述||:-------------------------------------------------------------------------------------------------|:-------------------------------------------||[transition](https://www.w3school.com.cn/cssref/pr_transition.asp)|简写属性，用于在一个属性中设置四个过渡属性。||[transition-property](https://www.w3school.com.cn/cssref/pr_transition-property.asp)|规定应用过渡的CSS属性的名称。||[transition-duration](https://www.w3school.com.cn/cssref/pr_transition-duration.asp)|定义过渡效果花费的时间。默认是0。||[transition-timing-function](https://www.w3school.com.cn/cssref/pr_transition-timing-function.asp)|规定过渡效果的时间曲线。默认是\"ease\"。||[transition-delay](https://www.w3school.com.cn/cssref/pr_transition-delay.asp)|规定过渡效果何时开始。默认是0。|","CSS\\动画\\高度auto过渡动画.md":"#[`高度auto过渡动画`](/)```css:root{interpolate-size:allow-keywords;}```","CSS\\标签\\input.md":"#input##切换密码的显隐性```css.pwd{text-security:disc;-webkit-text-security:disc;}```","CSS\\标签\\修改radio和checkbox 的样式.md":"#修改radio和checkbox的样式-无法通过css样式来直接修改原生的radio和checkbox-通过label和radio或checkbox的绑定关系,让label当做checkbox来显示```pug//puginput(type='checkbox',id='mycheck')label(for='mycheck')input(type='radio',id='myradio')label(for='myradio')``````css//cssinput[type='radio'],input[type='checkbox']{display:none!important;}input[type='checkbox']+label{background-color:#fff;border-radius:5px;border:1pxsolid#d3d3d3;width:20px;height:20px;display:inline-block;text-align:center;vertical-align:middle;line-height:20px;}//通过checked状态,再通过兄弟组件替换checkbox的labelinput[type='checkbox']:checked+label{background-color:#c0c0c0;}input[type='radio']:checked+label{background-color:#c0c0c0;}//通过after和context来替换radio中点#myCheck:checked+label:after{content:'\\2714';//√display:block;width:20px;height:20px;}```","CSS\\标签\\更改有序列表的样式.md":"#更改有序列表的样式有序列表```html<ol><li>第一行</li><li>第二行</li><li>第三行</li><li>第四行</li></ol>```效果：```1.第一行2.第二行3.第三行4.第四行```新的需求效果```css1、第一行2、第二行3、第三行4、第四行//使用:before伪类//样式：ol{counter-reset:num;}olli:after{content:counter(num)\"、\";counter-increment:num;}//结构<ol><li>第一行</li><li>第二行</li><li>第三行</li><li>第四行</li></ol>```","CSS\\比较.md":"#比较##比较函数>`min()`,`max()`,`clamp()`###`clamp(MIN,VAL,MAX)`>-当首选值比最小值要小时，则使用最小值>-当首选值介于最小值和最大值之间时，用首选值>-当首选值比最大值要大时，则使用最大值>等同于`max(MIN,min(VAL,MAX))`![](/.assets/img/2021-12-28-15-53-53.png)","CSS\\滚动条.md":"#滚动条##滚动贴合-父元素scroll-snap-type，子元素scroll-snap-align。##修改滚动条样式-`::-webkit-scrollbar`:滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样）等。-`::-webkit-scrollbar-button`:滚动条两端的按钮。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。-`::-webkit-scrollbar-track`:外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。-`::-webkit-scrollbar-track-piece`:内层轨道，滚动条中间部分（除去）。-`::-webkit-scrollbar-thumb`:滚动条里面可以拖动的那部分-`::-webkit-scrollbar-corner`:边角-`::-webkit-resizer`定义右下角拖动块的样式```css/*滚动条的宽度*/::-webkit-scrollbar{width:9px;height:9px;}/*外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果*/::-webkit-scrollbar-track{width:6px;background-color:#0d1b20;-webkit-border-radius:2em;-moz-border-radius:2em;border-radius:2em;}/*滚动条的设置*/::-webkit-scrollbar-thumb{background-color:#606d71;background-clip:padding-box;min-height:28px;-webkit-border-radius:2em;-moz-border-radius:2em;border-radius:2em;}/*滚动条移上去的背景*/::-webkit-scrollbar-thumb:hover{background-color:#fff;}```","CSS\\边框\\index.md":"#边框##border-radius:圆角```cssdiv{border:2pxsolid;border-radius:25px;//添加圆角-moz-border-radius:25px;/*OldFirefox*/}```##box-shadow:边框阴影```cssdiv{box-shadow:10px10px5px#888888;}```##border-image:边框图片>语法`box-shadow:h-shadowv-shadowblurspreadcolorinset;`|值|描述||:---------|:---------------------------------------||_h-shadow_|必需。水平阴影的位置。允许负值。||_v-shadow_|必需。垂直阴影的位置。允许负值。||_blur_|可选。模糊距离。||_spread_|可选。阴影的尺寸。||_color_|可选。阴影的颜色。请参阅CSS颜色值。||inset|可选。将外部阴影(outset)改为内部阴影。|```cssdiv{border-image:url(border.png)3030round;-moz-border-image:url(border.png)3030round;/*老的Firefox*/-webkit-border-image:url(border.png)3030round;/*Safari和Chrome*/-o-border-image:url(border.png)3030round;/*Opera*/}```","CSS\\预编译语言\\css-sass-scss-stylus.md":"#CSSSassScssstylus>-css预处理器是为了给css添加一些编程的特性>-无需考虑浏览器的兼容性问题>-使用变量>-简单的程序逻辑>-函数##变量>-sass:$变量名:变量值>-less,css:@变量名:变量值>-stylus:>-可以是任何字符开头(@除外)>-变量之间可以使用冒号,空格隔开>-变量名=变量值>-属性属性值>-栗子:```stylusmaincolor=#092873siteWidth=1024pxborderStyle=dottedbodycolormaincolorborder1pxborderStylemainColormax-widthsiteWidth```##嵌套```scss//scssstyle//-----------------------------------nav{ul{margin:0;padding:0;}li{display:inline-block;}a{display:block;padding:6px12px;text-decoration:none;}}//cssstyle//-----------------------------------navul{margin:0;padding:0;list-style:none;}navli{display:inline-block;}nava{display:block;padding:6px12px;text-decoration:none;```##运算符```cssbody{margin:(14px/2);top:50px+100px;right:80*10%;}```##颜色函数>预处理语言都会内置一些颜色处理函数###sass颜色函数```sasslighten($color,10%);darken($color,10%);saturate($color,10%);desaturate($color,10%);grayscale($color);complement($color);invert($color);mix($color1,$color2,50%);使用@color:#0982C1;border:3pxsoliddarken($color,50%);```###lesscss颜色函数```csslighten(@color,10%);darken(@color,10%);saturate(@color,10%);desaturate(@color,10%);spin(@color,10);spin(@color,-10);mix(@color1,@color2);@color:#0982C1;h1{background:@color;border:3pxsoliddarken(@color,50%);}```###Stylus颜色处理函数```csslighten(color,10%);darken(color,10%);saturate(color,10%);desaturate(color,10%);color=#0982C1h1backgroundcolorborder3pxsoliddarken(color,50%)```##导入(import)##继承###sass```sass.message{border:1pxsolid#ccc;padding:10px;color:#333;}.success{@extend.message;border-color:green;}.error{@extend.message;border-color:red;}.warning{@extend.message;border-color:yellow;}```###lesscss```less.message{border:1pxsolid#ccc;padding:10px;color:#333;}.success{.message;border-color:green;}.error{.message;border-color:red;}.warning{.message;border-color:yellow;}```##Mixins混入###sass```sass@mixinerror($borderWidth:2px){border:$borderWidthsolid#F00;color:#F00;}.generic-error{padding:20px;margin:4px;@includeerror();//这里调用默认border:2pxsolid#F00;}.login-error{left:12px;position:absolute;top:20px;@includeerror(5px);//这里调用border:5pxsolid#F00;}```###less```less.error(@borderWidth:2px){border:@borderWidthsolid#f00;color:#f00;}.generic-error{padding:20px;margin:4px;.error();//这里调用默认border:2pxsolid#F00;}.login-error{left:12px;position:absolute;top:20px;.error(5px);//这里调用border:5pxsolid#F00;}```Stylus```error(borderWidth=2px){border:borderWidthsolid#F00;color:#F00;}.login-error{left:12px;position:absolute;top:20px;error(5px);}```最后编译结果```css.generic-error{padding:20px;margin:4px;border:2pxsolid#f00;color:#f00;}.login-error{left:12px;position:absolute;top:20px;border:5pxsolid#f00;color:#f00;}```##3D文本###Sass```sass@mixintext3d($color){color:$color;text-shadow:1px1px0pxdarken($color,5%),2px2px0pxdarken($color,10%),3px3px0pxdarken($color,15%),4px4px0pxdarken($color,20%),4px4px2px#000;}h1{font-size:32pt;@includetext3d(#0982c1);}```###less```less.text3d(@color){color:@color;text-shadow:1px1px0pxdarken(@color,5%),2px2px0pxdarken(@color,10%),3px3px0pxdarken(@color,15%),4px4px0pxdarken(@color,20%),4px4px2px#000;}span{font-size:32pt;.text3d(#0982c1);}```###stylus```stylustext3d(color)color:colortext-shadow:1px1px0pxdarken(color,5%),2px2px0pxdarken(color,10%),3px3px0pxdarken(color,15%),4px4px0pxdarken(color,20%),4px4px2px#000spanfont-size:32pttext3d(#0982c1)```###css```cssspan{font-size:32pt;color:#0982c1;text-shadow:1px1px0px#097bb7,2px2px0px#0875ae,3px3px0px#086fa4,4px4px0px#07689a,4px4px2px#000;}```##高级语法>sass支持条件控制语句:@if@else@for@while@each###@if@else```sass$lte7:true;$type:monster;.ib{display:inline-block;@if$lte7{*display:inline;*zoom:1;}}p{@if$type==ocean{color:blue;}@elseif$type==matador{color:red;}@elseif$type==monster{color:green;}@else{color:black;}}```###@for两种形式```sass@for$varfrom<start>throuh<end>(包括end这个数)@for$varfrom<start>to<end>(不包括end这个数)```###@while```sass$i:6;@while$i>0{.item-#{$i}{width:2em*$i;}$i:$i-2;}```###@each```sass$animal-list:puma,sea-slug,egret,salamander;@each$animalin$animal-list{.#{$animal}-icon{background-image:url('/images/#{$animal}.png');}}```##Sass和Scss区别>-scss是sass3引入的新的语法>-区别:>-拓展名>-sass不带大括号和分号##Sass和Less区别###Sass和Less编译环境不一样>-Sass的安装需要Ruby环境，是在服务端处理的>-Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。###输出设置不同>Less没有输出设置，Sass提供4中输出选项：nested,compact,compressed和expanded。输出样式的风格可以有四种选择，默认为nested-nested：嵌套缩进的css代码-expanded：展开的多行css代码-compact：简洁格式的css代码-compressed：压缩后的css代码","CSS\\预编译语言\\less\\@plugin At-Rules.md":"#@pluginAt-Rules```less@plugin\"my-plugin\";//automaticallyappends.jsifnoextension.show-me-pi{value:pi();}//output.show-me-pi{value:3.141592653589793;}```-使用模块导出```js//my-plugin.jsmodule.exports={install:function(less,pluginManager,functions){functions.add('pi',function(){returnMath.PI})},}```","CSS\\预编译语言\\less\\CSSGuards.md":"#CSSGuard```less.my-optional-style()when(@my-option=true){button{color:white;}}.my-optional-style();//等同于buttonwhen(@my-option=true){color:white;}```","CSS\\预编译语言\\less\\extend.md":"#Extend```lessnavul{&:extend(.inline);background:blue;}.inline{color:red;}``````cssnavul{background:blue;}.inline,navul{color:red;}```##ExtendSyntax```less.a:extend(.b){}//theaboveblockdoesthesamethingasthebelowblock.a{&:extend(.b);}.c:extend(.dall){//extendsallinstancesof\".d\"e.g.\".x.d\"or\".d.x\"}.c:extend(.d){//extendsonlyinstanceswheretheselectorwillbeoutputasjust\".d\"}.e:extend(.f){}.e:extend(.g){}//theaboveandthebelowdothesamething.e:extend(.f,.g){}```##nthExpression```less[title='identifier']{color:blue;}[title='identifier']{color:blue;}[title='identifier']{color:blue;}.noQuote:extend([title='identifier']){}.singleQuote:extend([title='identifier']){}.doubleQuote:extend([title='identifier']){}``````css[title='identifier'],.noQuote,.singleQuote,.doubleQuote{color:blue;}[title='identifier'],.noQuote,.singleQuote,.doubleQuote{color:blue;}[title='identifier'],.noQuote,.singleQuote,.doubleQuote{color:blue;}```##`extend'all'````less.a.b.test,.test.c{color:orange;}.test{&:hover{color:green;}}.replacement:extend(.testall){}``````css.a.b.test,.test.c,.a.b.replacement,.replacement.c{color:orange;}.test:hover,.replacement:hover{color:green;}```","CSS\\预编译语言\\less\\function\\index.md":"#LessFunction##if```less@some:foo;div{margin:if((2>1),0,3px);color:if((iscolor(@some)),@some,black);}``````cssdiv{margin:0;color:black;}```##boolean```less@bg:black;@bg-light:boolean(luma(@bg)>50%);div{background:@bg;color:if(@bg-light,black,white);}``````cssdiv{background:black;color:white;}```##escape-将URL编码应用于在输入字符串中找到的特殊字符。-未编码字符：，`/`，`？`，`@`，`&amp;`，`+`，`'`，`~`,`！`,`$`。-最常见的编码字符：`\\<space\\>`，`\\`，`^`，`（`，`）`，`{`，`}`，`，`，`：`，`>`，`<`，`；`，`]`，`[`,`=`。-参数：string：要转义的字符串。-返回：不带引号的转义字符串内容。```lessescape('a=1')``````cssa%3D1```##e-字符串转义。-它需要字符串作为参数，并按原样返回其内容，但不带引号。它可以用于输出无效CSS语法的CSS值，或者使用Less无法识别的专有语法。-参数：string-要转义的字符串。-返回：string-转义字符串，不带引号。```less@mscode:'ms:alwaysHasItsOwnSyntax.For.Stuff()'filter:e(@mscode);``````cssfilter:ms:alwaysHasItsOwnSyntax.For.Stuff();```##`%format`-函数%（字符串，参数…）设置字符串格式。-第一个参数是带占位符的字符串。所有占位符都以百分比符号%开头，后跟字母s、s、d、d、a或a。其余参数包含替换占位符的表达式。如果需要打印百分比符号，请按另一个百分比%%将其转义。-如果需要将特殊字符转义到其utf-8转义码中，请使用大写占位符。函数将转义除（）'~！以外的所有特殊字符！。空间编码为%20。小写占位符保留特殊字符。-占位符：-d、d、a、a-可以用任何类型的参数（颜色、数字、转义值、表达式等）替换。如果将它们与字符串结合使用，则将使用整个字符串，包括其引号。但是，引号按原样放在字符串中，它们不会以“/”或任何类似的方式转义。-s、s-可替换为任何表达式。如果将其与字符串一起使用，则只使用字符串值-省略引号。-参数：-`string`：使用占位符格式化字符串-`anything*`：替换占位符的值-返回：格式化`string````lessformat-a-d:%('repetitions:%afile:%d',1+2,'directory/file.less');format-a-d-upper:%('repetitions:%Afile:%D',1+2,'directory/file.less');format-s:%('repetitions:%sfile:%s',1+2,'directory/file.less');format-s-upper:%('repetitions:%Sfile:%S',1+2,'directory/file.less');``````cssformat-a-d:'repetitions:3file:'directory/file.less'';format-a-d-upper:'repetitions:3file:%22directory%2Ffile.less%22';format-s:'repetitions:3file:directory/file.less';format-s-upper:'repetitions:3file:directory%2Ffile.less';```##replace-参数:-`string`:待处理子符串-`pattern`:要搜索的字符串/正则-`replacement`:替换的子串-`flags?`:正则标志-返回:替换过字符串的字符串.```lessreplace(\"Hello,Mars?\",\"Mars\\?\",\"Earth!\");replace(\"One+one=4\",\"one\",\"2\",\"gi\");replace('Thisisastring.',\"(string)\\.$\",\"new$1.\");replace(~\"bar-1\",'1','2');``````css\"Hello,Earth!\";\"2+2=4\";'Thisisanewstring.';bar-2;```","CSS\\预编译语言\\less\\function\\ListFunction.md":"#ListFunction##length```less@list:'banana','tomato','potato','peach';n:length(@list);``````cssn:4;```##extract```less@list:apple,pear,coconut,orange;value:extract(@list,3);``````cssvalue:coconut;```##range-生成列表-参数-`start`:（可选）开始值，例如1或1px-`end`:结束值，例如5px-`step`:（可选）增量```lessvalue:range(4);value:range(10px,30px,10);``````cssvalue:1234;value:10px20px30px;```##each-将规则集的计算绑定到列表的每个成员-参数-`list`:以逗号或空格分隔的值列表。-`rule`:匿名规则集/混合```less@selectors:blue,green,red;each(@selectors,{.sel-@{value}{a:b;}});``````css.sel-blue{a:b;}.sel-green{a:b;}.sel-red{a:b;}``````less@set:{one:blue;two:green;three:red;};.set{each(@set,{@{key}-@{index}:@value;});}``````css.set{one-1:blue;two-2:green;three-3:red;}``````less.set-2(){one:blue;two:green;three:red;}.set-2{each(.set-2(),.(@v,@k,@i){@{k}-@{i}:@v;});}``````css.set-2{one-1:blue;two-2:green;three-3:red;}``````lesseach(range(4),{.col-@{value}{height:(@value*50px);}});``````css.col-1{height:50px;}.col-2{height:100px;}.col-3{height:150px;}.col-4{height:200px;}```","CSS\\预编译语言\\less\\function\\MathFunction.md":"#MathFunction##ceil-向上取整-Example:`ceil(2.4)`-Output:`3`##floor-向下取整-Example:`floor(2.6)`-Output:`2`##percentage-浮点数转百分数-Example:`percentage(0.5)`-Output:`50%`##round-指定位数,四舍五入-Parameters:-number:浮点数-decimalPlaces:需要保留的位数-Returns:number-`Example`:`round(1.67)`-`Output`:`2`-`Example`:`round(1.67,1)`-`Output`:`1.7`##sqrt-开更号运算,单位不变-parameters:number-浮点数.-returns:number-example:```lesssqrt(25cm)```-output:```css5cm```-example:```lesssqrt(18.6%)```-output:```css4.312771730569565%;```##abs-绝对值,单位不变-parameters:`number`-浮点数-returns:`number`-example#1:`abs(25cm)`-output:`25cm`-example#2:`abs(-18.6%)`-output:`18.6%`##sin-正弦运算-assumesradiansonnumberswithoutunits.-parameters:number-浮点数-returns:numberexample:```lesssin(1);//sineof1radiansin(1deg);//sineof1degreesin(1grad);//sineof1gradian```output:```css0.8414709848078965;//sineof1radian0.01745240643728351;//sineof1degree0.015707317311820675;//sineof1gradian```##asincalculatesarcsine(inverseofsine)function.returnsnumberinradianse.g.anumberbetween-π/2andπ/2.parameters:number-floatingpointnumberfrom[-1,1]interval.returns:numberexample:asin(-0.8414709848078965)asin(0)asin(2)output:-1rad0radnanrad##cos-余弦运算-assumesradiansonnumberswithoutunits.-parameters:number-浮点数-returns:numberexample:```lesscos(1)//cosineof1radiancos(1deg)//cosineof1degreecos(1grad)//cosineof1gradian```output:```css0.5403023058681398//cosineof1radian0.9998476951563913//cosineof1degree0.9998766324816606//cosineof1gradian```##acos-反余弦运算-returnsnumberinradianse.g.anumberbetween0andπ.-parameters:number-afloatingpointnumberfrom[-1,1]interval.-returns:numberexample:```lessacos(0.5403023058681398)acos(1)acos(2)```output:```css1rad0radnanrad```##tan-正切运算-Assumesradiansonnumberswithoutunits.-Parameters:number-浮点数-Returns:numberExample:```lesstan(1)//tangentof1radiantan(1deg)//tangentof1degreetan(1grad)//tangentof1gradian```Output:```css1.5574077246549023//tangentof1radian0.017455064928217585//tangentof1degree0.015709255323664916//tangentof1gradian```##atan-正切逆运算-Returnsnumberinradianse.g.anumberbetween-π/2andπ/2.-Parameters:number-浮点数-Returns:numberExample:```lessatan(-1.5574077246549023)atan(0)round(atan(22),6)//arctangentof22roundedto6decimalplaces```Output:```css-1rad0rad1.525373rad;```##pi-`π`-Returnsπ(pi);-Parameters:none-Returns:numberExample:```pi()```Output:```3.141592653589793```##powReturnsthevalueofthefirstargumentraisedtothepowerofthesecondargument.Returnedvaluehasthesamedimensionasthefirstparameterandthedimensionofthesecondparameterisignored.Parameters:number:base-浮点数number:exponent-浮点数Returns:numberExample:pow(0cm,0px)pow(25,-2)pow(25,0.5)pow(-25,0.5)pow(-25%,-0.5)Output:1cm0.00165NaNNaN%##mod-模运算-参数:-number:浮点数.-number:浮点数-Returns:numberExample:```lessmod(0cm,0px)mod(11cm,6px);mod(-26%,-5);```Output:```cssNaNcm;5cm-1%;```##min-最小值-Example:`min(5,10);`-Output:`5`-Example:`min(3px,42px,1px,16px);`-Output:`1px`##max-最大值-Example:`max(5,10)`-Output:`10`-Example:`max(3%,42%,1%,16%)`-Output:`42%`","CSS\\预编译语言\\less\\function\\MiscFunction.md":"#MiscFunctions-杂项方法##color-解析颜色，使表示颜色的字符串成为颜色-Parameters:颜色字符串-Returns:color-Example:`color(\"#aaa\")`-Output:`#aaa`##image-size-获取图片文件尺寸-Parameters:要获取图片尺寸的图片文件-Returns:尺寸-Example:`image-size(\"file.png\")`-Output:`10px10px`##image-width-获取图片文件尺寸宽度-Example:`image-width(\"file.png\")`-Output:`10px`##image-height-获取图片文件尺寸高度-`Example`:`image-height(\"file.png\")`-`Output`:`10px`##convert-转换单位-第一个参数包含一个带单位的数字，第二个参数包含单位。如果单位兼容，则转换数字。如果它们不兼容，则返回第一个参数，不作修改。-可共用单位:-lengths:m,cm,mm,in,ptandpc-time:sandms-angle:rad,deg,gradandturn-Parameters:-number：带单位的浮点数。-标识符:字符串或转义值：单位-Returns:numberExample:```lessconvert(9s,\"ms\")convert(14cm,mm)convert(8,mm)//incompatibletypes```Output:```css9000ms140mm8```##data-uri-如果启用了ieCompat选项且资源太大，或者您在浏览器中使用了该函数，则内联资源并返回url（）。如果未给定MIME类型，则节点使用MIME包确定正确的MIME类型。Parameters:-mimetype：（可选）MIME类型字符串。-url：要内联的文件的url。若并没有mimetype，数据uri函数将根据文件名后缀猜测它。文本和svg文件编码为utf-8，其他文件编码为base64。-如果用户提供了mimetype，如果mimetype参数以结尾，则函数使用base64；base64。例如，图像/jpeg；base64编码为base64，而文本/html编码为utf-8。-`Example`:`data-uri('../data/image.jpg')`-`Output`:`url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==')`-`Output`:inbrowser:`url('../data/image.jpg')`-`Example`:`data-uri('image/jpeg;base64','../data/image.jpg')`-`Output`:`url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==')`-`Example`:`data-uri('image/svg+xml;charset=UTF-8','image.svg')`-`Output`:`url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%3E%3Ccircle%20r%3D%229%22%2F%3E%3C%2Fsvg%3E\")`##default-仅在保护条件内可用，仅当没有其他mixin匹配时才返回true，否则返回false。Example:```less.mixin(1){x:11;}.mixin(2){y:22;}.mixin(@x)when(default()){z:@x;}div{.mixin(3);}div.special{.mixin(1);}```Output:```cssdiv{z:3;}div.special{x:11;}```-可以将默认返回的值与guard运算符一起使用。例如只有当至少有一个以上的mixin定义匹配时，mixin（）whennot（default（））{}才会匹配。mixin（）调用:```less.mixin(@value)when(ispixel(@value)){width:@value;}.mixin(@value)whennot(default()){padding:(@value/5);}div-1{.mixin(100px);}div-2{/*...*/.mixin(100%);}```result:```cssdiv-1{width:100px;padding:20px;}div-2{/*...*/}```-允许在相同的保护条件下或在具有相同名称的mixin的不同条件下进行多个default（）调用:```lessdiv{.m(@x)when(default()),not(default()){always:@x;}.m(@x)when(default())andnot(default()){never:@x;}.m(1);//OK}``````lessdiv{.m(@x)when(default()){}.m(@x)whennot(default()){}.m(1);//Error}```Inaboveexampleitisimpossibletodeterminewhatvalueeachdefault()callshouldreturnsincetheyrecursivelydependoneachother.Advancedmultipledefault()usage:```less.x{.m(red){case-1:darkred;}.m(blue){case-2:darkblue;}.m(@x)when(iscolor(@x))and(default()){default-color:@x;}.m('foo'){case-1:Iam'foo';}.m('bar'){case-2:Iam'bar';}.m(@x)when(isstring(@x))and(default()){default-string:andIamthedefault;}&-blue{.m(blue);}&-green{.m(green);}&-foo{.m('foo');}&-baz{.m('baz');}}```Result:```css.x-blue{case-2:#00008b;}.x-green{default-color:#008000;}.x-foo{case-1:Iam'foo';}.x-baz{default-string:andIamthedefault;}```-默认函数仅在表达式中作为较少的内置函数提供。如果在mixin保护条件之外使用，则将其解释为常规CSS值：Example:```lessdiv{foo:default();bar:default(42);}```Result:```cssdiv{foo:default();bar:default(42);}```##unit-删除或更改标注的-Example:`unit(5,px)`-Output:`5px`-Example:`unit(5em)`-Output:`5`##get-unit-返回带有单位的数字的单位-Example:`get-unit(5px)`-Output:`px`-Example:`get-unit(5)`-Output:`//nothing`##svg-gradient```lessdiv{@list:red,green30%,blue;background-image:svg-gradient(toright,@list);}equivalent-colorstopsinarguments:div{background-image:svg-gradient(toright,red,green30%,blue);}bothresultin:div{background-image:url('data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%22100%25%22%20height%3D%22100%25%22%20viewBox%3D%220%200%201%201%22%20preserveAspectRatio%3D%22none%22%3E%3ClinearGradient%20id%3D%22gradient%22%20gradients%3D%22userSpaceOnUse%22%20x1%3D%220%25%22%20y1%3D%220%25%22%20x2%3D%22100%25%22%20y2%3D%220%25%22%3E%3Cstop%20offset%3D%220%25%22%20stop-color%3D%22%23ff0000%22%2F%3E%3Cstop%20offset%3D%2230%25%22%20stop-color%3D%22%23008000%22%2F%3E%3Cstop%20offset%3D%22100%25%22%20stop-color%3D%22%230000ff%22%2F%3E%3C%2FlinearGradient%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%221%22%20height%3D%221%22%20fill%3D%22url(%23gradient)%22%20%2F%3E%3C%2Fsvg%3E');}```注意：在2.2.0之前的版本中，结果是base64编码的。生成的背景图像左侧为红色，宽度的30%为绿色，最后为蓝色。Base64编码部分包含以下svg渐变：```xml<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"100%\"height=\"100%\"viewBox=\"0011\"preserveAspectRatio=\"none\"><linearGradientid=\"gradient\"gradients=\"userSpaceOnUse\"x1=\"0%\"y1=\"0%\"x2=\"100%\"y2=\"0%\"><stopoffset=\"0%\"stop-color=\"#ff0000\"/><stopoffset=\"30%\"stop-color=\"#008000\"/><stopoffset=\"100%\"stop-color=\"#0000ff\"/></linearGradient><rectx=\"0\"y=\"0\"width=\"1\"height=\"1\"fill=\"url(#gradient)\"/></svg>```","CSS\\预编译语言\\less\\function\\TypeFunction.md":"#TypeFunction##isnumber```lessisnumber(#ff0);//falseisnumber(blue);//falseisnumber(\"string\");//falseisnumber(1234);//trueisnumber(56px);//trueisnumber(7.8%);//trueisnumber(keyword);//falseisnumber(url(...));//false```##isstring```lessisstring(#ff0);//falseisstring(blue);//falseisstring(\"string\");//trueisstring(1234);//falseisstring(56px);//falseisstring(7.8%);//falseisstring(keyword);//falseisstring(url(...));//false```##iscolor```lessiscolor(#ff0);//trueiscolor(blue);//trueiscolor(\"string\");//falseiscolor(1234);//falseiscolor(56px);//falseiscolor(7.8%);//falseiscolor(keyword);//falseiscolor(url(...));//false```##iskeyword-关键字```lessiskeyword(#ff0);//falseiskeyword(blue);//falseiskeyword(\"string\");//falseiskeyword(1234);//falseiskeyword(56px);//falseiskeyword(7.8%);//falseiskeyword(keyword);//trueiskeyword(url(...));//false```##isurl```lessisurl(#ff0);//falseisurl(blue);//falseisurl(\"string\");//falseisurl(1234);//falseisurl(56px);//falseisurl(7.8%);//falseisurl(keyword);//falseisurl(url(...));//true```##ispixel-px```lessispixel(#ff0);//falseispixel(blue);//falseispixel(\"string\");//falseispixel(1234);//falseispixel(56px);//trueispixel(7.8%);//falseispixel(keyword);//falseispixel(url(...));//false```##isem-\\*em```lessisem(#ff0);//falseisem(blue);//falseisem(\"string\");//falseisem(1234);//falseisem(56px);//falseisem(7.8em);//trueisem(keyword);//falseisem(url(...));//false```##ispercentage```lessispercentage(#ff0);//falseispercentage(blue);//falseispercentage(\"string\");//falseispercentage(1234);//falseispercentage(56px);//falseispercentage(7.8%);//trueispercentage(keyword);//falseispercentage(url(...));//false```##isunit```lessisunit(11px,px);//trueisunit(2.2%,px);//falseisunit(33px,rem);//falseisunit(4rem,rem);//trueisunit(56px,\"%\");//falseisunit(7.8%,'%');//trueisunit(1234,em);//falseisunit(#ff0,pt);//falseisunit(\"mm\",mm);//false```##isruleset```less@rules:{color:red;}isruleset(@rules);//trueisruleset(#ff0);//falseisruleset(blue);//falseisruleset(\"string\");//falseisruleset(1234);//falseisruleset(56px);//falseisruleset(7.8%);//falseisruleset(keyword);//falseisruleset(url(...));//false```##isdefined```less@foo:1;isdefined(@foo);//trueisdefined(@bar);//false```","CSS\\预编译语言\\less\\less.md":"#less##变量（Variables）###值变量```less@width:10px;@height:@width+10px;#header{width:@width;height:@height;}```编译为：```css#header{width:10px;height:20px;}```###选择器变量-让选择器变成动态```less/*Less*/@mySelector:#wrap;@Wrap:wrap;@{mySelector}{//变量名必须使用大括号包裹color:#999;width:50%;}.@{Wrap}{color:#ccc;}#@{Wrap}{color:#666;}/*生成的CSS*/#wrap{color:#999;width:50%;}.wrap{color:#ccc;}#wrap{color:#666;}```###属性变量```less/*Less*/@borderStyle:border-style;@Soild:solid;#wrap{@{borderStyle}:@Soild;//变量名必须使用大括号包裹}/*生成的CSS*/#wrap{border-style:solid;}```###url变量```less/*Less*/@images:'../img';//需要加引号body{background:url('@{images}/dog.png');//变量名必须使用大括号包裹}/*生成的CSS*/body{background:url('../img/dog.png');}```###声明变量>结构:`@name:{属性:值};`>使用:`@name();````less@background:{background:red;};#main{@background();}@Rules:{width:200px;height:200px;border:solid1pxred;};#con{@Rules();}/*生成的CSS*/#main{background:red;}#con{width:200px;height:200px;border:solid1pxred;}```###变量运算>-加减:以第一个数据单位为基准>-乘除:注意单位统一```less/*Less*/@width:300px;@color:#222;#wrap{width:@width-20;height:@width-20*5;margin:(@width-20)*5;color:@color*2;background-color:@color+#111;}/*生成的CSS*/#wrap{width:280px;height:200px;margin:1400px;color:#444;background-color:#333;}```###变量作用域>就近原则```less/*Less*/@var:@a;@a:100%;#wrap{width:@var;@a:9%;}/*生成的CSS*/#wrap{width:9%;}```###用变量去定义变量```less/*Less*/@fnord:'Iamfnord.';@var:'fnord';#wrap::after{content:@@var;//将@var替换为其值content:@fnord;}/*生成的CSS*/#wrap::after{content:'Iamfnord.';}```##混合（Mixins）>混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。假设我们定义了一个类（class）如下：```less.bordered{border-top:dotted1pxblack;border-bottom:solid2pxblack;}```>如果我们希望在其它规则集中使用这些属性呢？没问题，我们只需像下面这样输入所需属性的类（class）名称即可，如下所示：```css#menua{color:#111;.bordered();}.posta{color:red;.bordered();}```>.bordered类所包含的属性就将同时出现在#menua和.posta中了。（也可以使用#ids作为mixin使用。）##嵌套（Nesting）>Less提供了使用嵌套（nesting）代替层叠或与层叠结合使用的能力。假设我们有以下CSS代码：```css#header{color:black;}#header.navigation{font-size:12px;}#header.logo{width:300px;}```用Less语言我们可以这样书写代码：```less#header{color:black;.navigation{font-size:12px;}.logo{width:300px;}}```###&用法>`&`:表示当前选择器的父级```less.clearfix{display:block;zoom:1;&:after{//(&表示当前选择器的父级）content:'';display:block;font-size:0;height:0;clear:both;visibility:hidden;}}```###@规则嵌套和冒泡(媒体查询)>@规则（例如@media或@supports）可以与选择器以相同的方式进行嵌套。@规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡（bubbling）。```less.component{width:300px;@media(min-width:768px){width:600px;@media(min-resolution:192dpi){background-image:url(/img/retina2x.png);}}@media(min-width:1280px){width:800px;}}```编译为：```css.component{width:300px;}@media(min-width:768px){.component{width:600px;}}@media(min-width:768px)and(min-resolution:192dpi){.component{background-image:url(/img/retina2x.png);}}@media(min-width:1280px){.component{width:800px;}}```##运算（Operations）###算术运算符+、-、\\*、/可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。==计算的结果以最左侧操作数的单位类型为准==。如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px到cm或rad到%的转换。```less//所有操作数被转换成相同的单位@conversion-1:5cm+10mm;//结果是6cm@conversion-2:2-3cm-5mm;//结果是-1.5cm//conversionisimpossible@incompatible-units:2+5px-3cm;//结果是4px//examplewithvariables@base:5%;@filler:@base*2;//结果是10%@other:@base+@filler;//结果是15%```###乘法和除法不作转换因为这两种运算在大多数情况下都没有意义，一个长度乘以一个长度就得到一个区域，而CSS是不支持指定区域的。Less将按数字的原样进行操作，并将为计算结果指定明确的单位类型。```less@base:2cm*3mm;//结果是6cm```你还可以对颜色进行算术运算：```less@color:#224488/2;//结果是#112244background-color:#112244+#111;//结果是#223355```###calc()特例>为了与CSS保持兼容，calc()并不对数学表达式进行计算，但是在嵌套函数中会计算变量和数学公式的值。```less@var:50vh/2;width:calc(50%+(@var-20px));//结果是calc(50%+(25vh-20px))```##转义（Escaping）>==转义（Escaping）允许你使用任意字符串作为属性或变量值==。任何`~\"anything\"`或`~'anything'`形式的内容都将按原样输出，除非interpolation。```less@min768:~'(min-width:768px)';.element{@media@min768{font-size:1.2rem;}}```编译为：```css@media(min-width:768px){.element{font-size:1.2rem;}}```>==注意，从Less3.5开始，可以简写为：==```less@min768:(min-width:768px);.element{@media@min768{font-size:1.2rem;}}```##函数（Functions）-Less内置了多种函数用于转换颜色、处理字符串、算术运算等函数的用法非常简单。下面这个例子将介绍如何利用percentage函数将0.5转换为50%，将颜色饱和度增加5%，以及颜色亮度降低25%并且色相值增加8等用法：```css@base:#f04615;@width:0.5;.class{width:percentage(@width);//returns`50%`color:saturate(@base,5%);background-color:spin(lighten(@base,25%),8);}```参见：[函数手册](https://less.bootcss.com/functions/)###判断类型|函数名|描述|使用||:-------|:---------|:----------------------||isnumber|判断类型|`isnumber(1234)//true`||iscolor|是否为颜色|`iscolor(123)//false`||isurl|是否为url|`isurl(123)//false`|###颜色操作|函数名|描述|使用||:-------|:-------------------------|:---||saturate|增加一定数值的颜色饱和度||lighten|增加一定数值的颜色亮度||darken|降低一定数值的颜色亮度||fade|给颜色设定一定数值的透明度||mix|根据比例混合两种颜色|###数学相关|函数名|描述|使用||:---------|:-----------------------------|:---||ceil|向上取整||floor|向下取整||percentage|将浮点数转换为百分比字符串||round|四舍五入||sqrt|计算一个数的平方根||abs|计算数字的绝对值，原样保持单位||pow|计算一个数的乘方|##命名空间和访问符(不要和CSS@namespace或namespaceselectors混淆了)。有时，出于组织结构或仅仅是为了提供一些封装的目的，你希望对混合（mixins）进行分组。你可以用Less更直观地实现这一需求。假设你希望将一些混合（mixins）和变量置于#bundle之下，为了以后方便重用或分发：```less#bundle(){.button{display:block;border:1pxsolidblack;background-color:grey;&:hover{background-color:white;}}.tab{...;}.citation{...;}}```现在，如果我们希望把.button类混合到#headera中，我们可以这样做：```less#headera{color:orange;#bundle.button();//还可以书写为#bundle>.button形式}```注意：如果不希望它们出现在输出的CSS中，例如#bundle.tab，请将()附加到命名空间（例如#bundle()）后面。##映射（Maps）从Less3.5版本开始，你还可以将混合（mixins）和规则集（rulesets）作为一组值的映射（map）使用。```less#colors(){primary:blue;secondary:green;}.button{color:#colors[primary];border:1pxsolid#colors[secondary];}```输出符合预期：```css.button{color:blue;border:1pxsolidgreen;}```##作用域（Scope）>Less中的作用域与CSS中的作用域非常类似。首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承。```less@var:red;#page{@var:white;#header{color:@var;//white}}```>与CSS自定义属性一样，混合（mixin）和变量的定义不必在引用之前事先定义。因此，下面的Less代码示例和上面的代码示例是相同的：```less@var:red;#page{#header{color:@var;//white}@var:white;}```参见：懒加载##注释（Comments）块注释和行注释都可以使用：```less/*一个块注释*stylecomment!*/@var:red;//这一行被注释掉了！@var:white;```##导入（Importing）>“导入”的工作方式和你预期的一样。你可以导入一个.less文件，此文件中的所有变量就可以全部使用了。如果导入的文件是.less扩展名，则可以将扩展名省略掉：```less@import'library';//library.less@import'typo.css';```##混合方法```less/*Less*/.generate-columns(4);.generate-columns(@n,@i:1)when(@i=<@n){.column-@{i}{width:(@i*100%/@n);}.generate-columns(@n,(@i+1));}/*生成后的CSS*/.column-1{width:25%;}.column-2{width:50%;}.column-3{width:75%;}.column-4{width:100%;}```###无参方法>直接名称即可(建议还是写上括号,避免混淆)```less/*Less*/.card{//等价于.card()background:#f6f6f6;-webkit-box-shadow:01px2pxrgba(151,151,151,0.58);box-shadow:01px2pxrgba(151,151,151,0.58);}#wrap{.card;//等价于.card();}/*生成的CSS*/#wrap{background:#f6f6f6;-webkit-box-shadow:01px2pxrgba(151,151,151,0.58);box-shadow:01px2pxrgba(151,151,151,0.58);}```###默认参数方法>`@arguments`类似js中的`arguments`指代全部参数```less/*Less*/.border(@a:10px,@b:50px,@c:30px,@color:#000){border:solid1px@color;box-shadow:@arguments;//指代的是全部参数}#main{.border(0px,5px,30px,red);//必须带着单位}#wrap{.border(0px);}#content{.border;//等价于.border()}/*生成的CSS*/#main{border:solid1pxred;box-shadow:0px,5px,30px,red;}#wrap{border:solid1px#000;box-shadow:0px50px30px#000;}#content{border:solid1px#000;box-shadow:10px50px30px#000;}```###方法匹配模式-类似java多态```less/*Less*/.triangle(top,@width:20px,@color:#000){border-color:transparenttransparent@colortransparent;}.triangle(right,@width:20px,@color:#000){border-color:transparent@colortransparenttransparent;}.triangle(bottom,@width:20px,@color:#000){border-color:@colortransparenttransparenttransparent;}.triangle(left,@width:20px,@color:#000){border-color:transparenttransparenttransparent@color;}.triangle(@_,@width:20px,@color:#000){border-style:solid;border-width:@width;}#main{.triangle(left,50px,#999);}/*生成的CSS*/#main{border-color:transparenttransparenttransparent#999;border-style:solid;border-width:50px;}```###方法命名空间```less/*Less*/#card(){background:#723232;.d(@w:300px){width:@w;#a(@h:300px){height:@h;//可以使用上一层传进来的方法}}}#wrap{#card>.d>#a(100px);//父元素不能加括号}#main{#card.d();}#con{//不得单独使用命名空间的方法//.d()如果前面没有引入命名空间#card，将会报错#card;//等价于#card();.d(20px);//必须先引入#card}/*生成的CSS*/#wrap{height:100px;}#main{width:300px;}#con{width:20px;}```###方法的条件筛选```less/*Less*/#card{//and运算符，相当于与运算&&，必须条件全部符合才会执行.border(@width,@color,@style)when(@width>100px)and(@color=#999){border:@style@color@width;}//not运算符，相当于非运算!，条件为不符合才会执行.background(@color)whennot(@color>=#222){background:@color;}//,逗号分隔符：相当于或运算||，只要有一个符合条件就会执行.font(@size:20px)when(@size>50px),(@size<100px){font-size:@size;}}#main{#card>.border(200px,#999,solid);#card.background(#111);#card>.font(40px);}/*生成后的CSS*/#main{border:solid#999200px;background:#111;font-size:40px;}```##继承###extend```less/*Less*/.animation{transition:all0.3sease-out;.hide{transform:scale(0);}}#main{&:extend(.animation);}#con{&:extend(.animation.hide);}/*生成后的CSS*/.animation,#main{transition:all0.3sease-out;}.animation.hide,#con{transform:scale(0);}```###all```less/*Less*/#main{width:200px;}#main{&:after{content:'Lessisgood!';}}#wrap:extend(#mainall){}/*生成的CSS*/#main,#wrap{width:200px;}#main:after,#wrap:after{content:'Lessisgood!';}```##导入###导入less文件```lessimport\"main\";//等价于import\"main.less\";#main{font-size:15px;}//可以随意放置@import\"style\";```###reference>不会编译,值会引入```less/*Less*/@import(reference)'bootstrap.less';#wrap:extend(.navbarall){}```###once>`@import`语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析```less@import(once)'foo.less';@import(once)'foo.less';//thisstatementwillbeignored```###multiple>使用`@import(multiple)`允许导入多个同名文件```less/*Less*///file:foo.less.a{color:green;}//file:main.less@import(multiple)'foo.less';@import(multiple)'foo.less';/*生成后的CSS*/.a{color:green;}.a{color:green;}```##其他###注释>`/**/`CSS原生注释，会被编译在CSS文件中。>`//`Less提供的一种注释，不会被编译在CSS文件中。```less//避免编译/*Less*/#main{width:~'calc(300px-30px)';}/*生成后的CSS*/#main{width:calc(300px-30px);}```结构：`~'值'`###变量拼串在平时工作中，这种需求太常见了。在下面例子中，实现了不同的transtion-delay、animation、@keyframes```less.judge(@i)when(@i=1){@size:15px;}.judge(@i)when(@i>1){@size:16px;}.loopAnimation(@i)when(@i<16){.circle:nth-child(@{i}){.judeg(@i);border-radius:@size@size00;animation:~'circle-@{i}'@durationinfinite@ease;transition-delay:~'@{i}ms';}@keyframes~\"circle-@{i}\"{//dosomething...}.loopAnimation(@i+1);}```结构：`~\"字符@{变量}字符\"`###使用js>less是使用js编写```less/*Less*/@content:`\"aaa\".toUpperCase()`;#randomColor{@randomColor:~'rgb(`Math.round(Math.random()*256)`,`Math.round(Math.random()*256)`,`Math.round(Math.random()*256)`)';}#wrap{width:~'`Math.round(Math.random()*100)`px';&:after{content:@content;}height:~'`window.innerHeight`px';alert:~'`alert(1)`';#randomColor();background-color:@randomColor;}/*生成后的CSS*///弹出1#wrap{width:随机值（0~100）px;height:743px;//由电脑而异background:随机颜色;}#wrap::after{content:'AAA';}```","CSS\\预编译语言\\less\\Merge.md":"#Merge##Comma```less.mixin(){box-shadow+:inset0010px#555;}.myclass{.mixin();box-shadow+:0020pxblack;}``````css.myclass{box-shadow:inset0010px#555,0020pxblack;}```##Space```less.mixin(){transform+_:scale(2);}.myclass{.mixin();transform+_:rotate(15deg);}``````css.myclass{transform:scale(2)rotate(15deg);}```","CSS\\预编译语言\\less\\mixins.md":"#Mixins-添加进已有的样式里```less.a,#b{color:red;}.mixin-class{.a();}.mixin-id{#b();}``````css.a,#b{color:red;}.mixin-class{color:red;}.mixin-id{color:red;}```##MixinsWithParentheses```less.my-mixin{color:black;}//不会添加多一个className.my-other-mixin(){background:white;}.class{.my-mixin();.my-other-mixin();}``````css.my-mixin{color:black;}.class{color:black;background:white;}```##SelectorsinMixins```less.my-hover-mixin(){&:hover{border:1pxsolidred;}}button{.my-hover-mixin();}``````cssbutton:hover{border:1pxsolidred;}```##Namespaces```less#outer(){.inner{color:red;}}.c{#outer.inner();}``````css.c{color:red;}```##GuardedNamespaces-如果名称空间具有保护，则仅当保护条件返回true时，才使用由其定义的混合。命名空间保护的计算方式与mixin上的保护完全相同，因此以下两个mixin的工作方式相同：```less#namespacewhen(@mode=huge){.mixin(){/**/}}#namespace{.mixin()when(@mode=huge){/**/}}```##The`!important`keyword```less.foo(@bg:#f5f5f5;@color:#900){background:@bg;color:@color;}.unimportant{.foo();}.important{.foo()!important;}``````css.unimportant{background:#f5f5f5;color:#900;}.important{background:#f5f5f5!important;color:#900!important;}```##ParametricMixins```less//.border-radius(@radius){这种没有没有默认值.border-radius(@radius:5px){-webkit-border-radius:@radius;-moz-border-radius:@radius;border-radius:@radius;}#header{.border-radius();}``````css#header{-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;}```##Overloadingmixins```less.mixin(@color){color-1:@color;}.mixin(@color,@padding:2){color-2:@color;padding-2:@padding;}.mixin(@color,@padding,@margin:2){color-3:@color;padding-3:@padding;margin:@margin@margin@margin@margin;}.some.selectordiv{.mixin(#008000);}``````css.some.selectordiv{color-1:#008000;color-2:#008000;padding-2:2;}```##NamedParameters```less.mixin(@color:black;@margin:10px;@padding:20px){color:@color;margin:@margin;padding:@padding;}.class1{.mixin(@margin:20px;@color:#33acfe);}.class2{.mixin(#efca44;@padding:40px);}``````css.class1{color:#33acfe;margin:20px;padding:20px;}.class2{color:#efca44;margin:10px;padding:40px;}```##The`@arguments`Variable```less.box-shadow(@x:0,@y:0,@blur:1px,@color:#000){-webkit-box-shadow:@arguments;-moz-box-shadow:@arguments;box-shadow:@arguments;}.big-block{.box-shadow(2px,5px);}``````css.big-block{-webkit-box-shadow:2px5px1px#000;-moz-box-shadow:2px5px1px#000;box-shadow:2px5px1px#000;}```##AdvancedArgumentsandthe`@rest`Variable```less.mixin(@a,@rest...){//@restisboundtoargumentsafter@a//@argumentsisboundtoallarguments}```##Pattern-matching```less.mixin(@s,@color){...;}.class{.mixin(@switch,#888);}``````less.mixin(dark,@color){color:darken(@color,10%);}.mixin(light,@color){color:lighten(@color,10%);}.mixin(@_,@color){display:block;}@switch:light;.class{.mixin(@switch,#888);}``````css.class{color:#a2a2a2;display:block;}```##UsingMixinsasFunctions###Property/valueaccessors```less.average(@x,@y){@result:((@x+@y)/2);}div{//callamixinandlookupits\"@result\"valuepadding:.average(16px,50px)[@result];}``````cssdiv{padding:33px;}```###Overridingmixinvalues```less//library.less#library(){.mixin(){prop:foo;}}//customize.less@import'library';#library(){.mixin(){prop:bar;}}.box{my-value:#library.mixin[prop];}//Outputs:.box{my-value:bar;}```###Unnamedlookups```less.average(@x,@y){@result:((@x+@y)/2);}div{//callamixinandlookupitsfinalvaluepadding:.average(16px,50px)[];}//output:div{padding:33px;}```###Unlockingmixins&variablesintocallerscope```less.mixin(){@width:100%;@height:200px;}.caller{.mixin();width:@width;height:@height;}//Results:.caller{width:100%;height:200px;}``````less.unlock(@value){//outermixin.doSomething(){//nestedmixindeclaration:@value;}}#namespace{.unlock(5);//unlockdoSomethingmixin.doSomething();//nestedmixinwascopiedhereandisusable}//Results:#namespace{declaration:5;}```##RecursiveMixins```less.loop(@counter)when(@counter>0){.loop((@counter-1));//nextiterationwidth:(10px*@counter);//codeforeachiteration}div{.loop(5);//launchtheloop}//Output:div{width:10px;width:20px;width:30px;width:40px;width:50px;}``````less.generate-columns(4);.generate-columns(@n,@i:1)when(@i=<@n){.column-@{i}{width:(@i*100%/@n);}.generate-columns(@n,(@i+1));}//Output:.column-1{width:25%;}.column-2{width:50%;}.column-3{width:75%;}.column-4{width:100%;}```##MixinGuards```less.mixin(@a)when(lightness(@a)>=50%){background-color:black;}.mixin(@a)when(lightness(@a)<50%){background-color:white;}.mixin(@a){color:@a;}.class1{.mixin(#ddd);}.class2{.mixin(#555);}//output:.class1{background-color:black;color:#ddd;}.class2{background-color:white;color:#555;}```###GuardComparisonOperators```less.truth(@a)when(@a){...;}.truth(@a)when(@a=true){...;}@media:mobile;.mixin(@a)when(@media=mobile){...;}.mixin(@a)when(@media=desktop){...;}.max(@a;@b)when(@a>@b){width:@a;}.max(@a;@b)when(@a<@b){width:@b;}```###GuardLogicalOperators```less.mixin(@a)when(isnumber(@a))and(@a>0){...;}.mixin(@a)when(@a>10),(@a<-10){...;}.mixin(@b)whennot(@b>0){...;}```###TypeCheckingFunctions-iscolor-isnumber-isstring-iskeyword-isurl-ispixel-ispercentage-isem-isunit```less.mixin(@a;@b:0)when(isnumber(@b)){...;}.mixin(@a;@b:black)when(iscolor(@b)){...;}```##AliasingMixins```less#theme.dark.navbar{.colors(light){primary:purple;}.colors(dark){primary:black;secondary:grey;}}.navbar{@colors:#theme.dark.navbar.colors(dark);background:@colors[primary];border:1pxsolid@colors[secondary];}//output:.navbar{background:black;border:1pxsolidgrey;}```###Variablecalls```less#library(){.colors(){background:green;}}.box{@alias:#library.colors();@alias();}//Outputs:.box{background:green;}```","CSS\\预编译语言\\less\\variables.md":"#Variables-变量##Overview```less//Variables@link-color:#428bca;//seablue@link-color-hover:darken(@link-color,10%);//Usagea,.link{color:@link-color;}a:hover{color:@link-color-hover;}.widget{color:#fff;background:@link-color;}``````cssa,.link{color:#428bca;}.widget{color:#fff;background:#428bca;}```##Selectors```less//Variables@my-selector:banner;//Usage.@{my-selector}{font-weight:bold;line-height:40px;margin:0auto;}``````css.banner{font-weight:bold;line-height:40px;margin:0auto;}```##URLS```less//Variables@images:'../img';//Usagebody{color:#444;background:url('@{images}/white-sand.png');}```##ImportStatements```less//Variables@themes:'../../src/themes';//Usage@import'@{themes}/tidal-wave.less';```##Properties```less@property:color;.widget{@{property}:#0ee;background-@{property}:#999;}``````css.widget{color:#0ee;background-color:#999;}```##VariableVariables```less@primary:green;@secondary:blue;.section{@color:primary;.element{color:@@color;}}``````css.section.element{color:green;}```##LazyEvaluation```less.lazy-eval{width:@var;@a:9%;}@var:@a;@a:100%;``````css.lazy-eval{width:9%;}``````less@var:0;.class{@var:1;.brass{@var:2;three:@var;@var:3;}one:@var;}``````css.class{one:1;}.class.brass{three:3;}```##PropertiesasVariables```less.widget{color:#efefef;background-color:$color;}``````css.widget{color:#efefef;background-color:#efefef;}``````less.block{color:red;.inner{background-color:$color;}color:blue;}``````css.block{color:red;color:blue;}.block.inner{background-color:blue;}```##DefaultVariables```less//library@base-color:green;@dark-color:darken(@base-color,10%);//useoflibrary@import'library.less';@base-color:red;//在当前文件,可以覆盖掉library的```##ParentSelectors###父选择器`&````lessa{color:blue;&:hover{color:green;}}``````cssa{color:blue;}a:hover{color:green;}``````less.button{&-ok{background-image:url('ok.png');}&-cancel{background-image:url('cancel.png');}&-custom{background-image:url('custom.png');}}``````css.button-ok{background-image:url('ok.png');}.button-cancel{background-image:url('cancel.png');}.button-custom{background-image:url('custom.png');}```###Multiple`&````less.link{&+&{color:red;}&&{color:green;}&&{color:blue;}&,&ish{color:cyan;}}``````css.link+.link{color:red;}.link.link{color:green;}.link.link{color:blue;}.link,.linkish{color:cyan;}```###CombinatorialExplosion```lessp,a,ul,li{border-top:2pxdotted#366;&+&{border-top:0;}}``````cssp,a,ul,li{border-top:2pxdotted#366;}p+p,p+a,p+ul,p+li,a+p,a+a,a+ul,a+li,ul+p,ul+a,ul+ul,ul+li,li+p,li+a,li+ul,li+li{border-top:0;}```","CSS\\预编译语言\\sass.md":"#Sass>SyntacticallyAwesomeStyleSheetsSass是一款强化CSS的辅助工具，它在CSS语法的基础上增加了变量(variables)、嵌套(nestedrules)、混合(mixins)、导入(inlineimports)等高级功能，这些拓展令CSS更加强大与优雅。使用Sass以及Sass的样式库（如Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。##1.特色功能(Features)完全兼容CSS3在CSS基础上增加变量、嵌套(nesting)、混合(mixins)等功能通过函数进行颜色值与属性值的运算提供控制指令(controldirectives)等高级功能自定义输出格式##2.语法格式(Syntax)Sass有两种语法格式。首先是SCSS(SassyCSS)——也是本文示例所使用的格式——这种格式仅在CSS3语法的基础上进行拓展，所有CSS3语法在SCSS中都是通用的，同时加入Sass的特色功能。此外，SCSS也支持大多数CSShacks写法以及浏览器前缀写法(vendor-specificsyntax)，以及早期的IE滤镜写法。这种格式以.scss作为拓展名。另一种也是最早的Sass语法格式，被称为缩进格式(IndentedSass)通常简称\"Sass\"，是一种简化格式。它使用“缩进”代替“花括号”表示属性属于某个选择器，用“换行”代替“分号”分隔属性，很多人认为这样做比SCSS更容易阅读，书写也更快速。缩进格式也可以使用Sass的全部功能，只是与SCSS相比个别地方采取了不同的表达方式，具体请查看theindentedsyntaxreference。这种格式以.sass作为拓展名。###2.1导入和转换成另外一种格式任何一种格式可以直接导入(@import)到另一种格式中使用，或者通过sass-convert命令行工具转换成另一种格式：```#ConvertSasstoSCSS$sass-convertstyle.sassstyle.scss#ConvertSCSStoSass$sass-convertstyle.scssstyle.sass```##3.使用Sass(UsingSass)Sass可以通过以下三种方式使用：作为命令行工具；作为独立的Ruby模块(Rubymodule)；或者作为Rack-enabled框架的插件（例如RubyonRails与Merb）。无论哪种方式都需要先安装Sassgem（Windows系统需要先安装Ruby）：```geminstallsass```在命令行中运行Sass：```sassinput.scssoutput.css```监视单个Sass文件，每次修改并保存时自动编译：```sass--watchinput.scss:output.css```监视整个文件夹：```sass--watchapp/sass:public/stylesheets```更多命令的用法请通过==sass--help==获取帮助。在Ruby中使用Sass也非常容易，Sassgem安装完毕后运行require\"sass\"然后按照下面的方法使用Sass::Engine：```engine=Sass::Engine.new(\"#main{background-color:#0000ff}\",:syntax=>:scss)engine.render#=>\"#main{background-color:#0000ff;}\\n\"```###3.1.Rack/Rails/MerbPlugin```在Rails3之前的版本中使用Sass，需要在environment.rb文件中添加：config.gem\"sass\"Rails3则需要在Gemfile中添加：gem\"sass\"在Merb中使用Sass，需要在config/dependencies.rb中添加：dependency\"merb-haml\"在Rack中使用Sass，需要在config.ru中添加：require'sass/plugin/rack'useSass::Plugin::Rack样式文件与views不同，不包含任何动态内容，因此CSS只需要在Sass文件被修改后再编译生成。默认情况下.sass与.scss文件放置在public/stylesheets/sass中（可通过:template_location修改路径），编译生成的CSS文件放置在public/stylesheets中。例如public/stylesheets/sass/main.scss编译生成public/stylesheets/main.css。```###3.2.缓存(Caching)>Sass自动缓存编译后的模板与partials，这样做能够显著提升重新编译的速度，尤其在处理由@import导入多个子文件的大型项目时。>单独使用Sass，缓存内容保存在.sass-cache文件夹中。在Rails和Merb项目中缓存文件保存在tmp/sass-cache文件夹中（可通过:cache_location修改路径）。禁用缓存可将:cache设为false。###3.3.配置选项(Options)<null>暂未翻译###3.4.判断语法格式(SyntaxSelection)>Sass命令行工具根据文件的拓展名判断所使用的语法格式，没有文件名时sass命令默认编译.sass文件，添加--scss选项或者使用scss命令编译SCSS文件。###3.5.编码格式(Encodings)>在Ruby1.9及以上环境中运行Sass时，Sass对文件的编码格式比较敏感，首先会根据CSSspec判断样式文件的编码格式，如果失败则检测Rubystringencoding。也就是说，Sass首先检查Unicodebyteordermark，然后是@charset声明，最后是Rubystringencoding，假如都没有检测到，默认使用UTF-8编码。>与CSS相同，使用@charset可以声明特定的编码格式。在样式文件的起始位置（前面没有任何空白与注释）插入@charset\"encoding-name\"，Sass将会按照给出的编码格式编译文件。注意所使用的编码格式必须可转换为Unicode字符集。>Sass以UTF-8编码输出CSS文件，当且仅当编译后的文件中包含非ASCII字符时，才会在输出文件中添加@charset声明，而在压缩模式下(compressedmode)使用UTF-8byteordermark代替@charset声明语句。##4.CSS功能拓展(CSSExtensions)###4.1.嵌套规则(NestedRules)>Sass允许将一套CSS样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：```css#mainp{color:#00ff00;width:97%;.redbox{background-color:#ff0000;color:#000000;}}```编译为```#mainp{color:#00ff00;width:97%;}#mainp.redbox{background-color:#ff0000;color:#000000;}```嵌套功能避免了重复输入父选择器，而且令复杂的CSS结构更易于管理：```#main{width:97%;p,div{font-size:2em;a{font-weight:bold;}}pre{font-size:3em;}}```编译为```#main{width:97%;}#mainp,#maindiv{font-size:2em;}#mainpa,#maindiva{font-weight:bold;}#mainpre{font-size:3em;}```###4.2.父选择器&(ReferencingParentSelectors:&)在嵌套CSS规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定hover样式时，或者当body元素有某个classname时，可以用==&代表嵌套规则外层的父选择器==。```a{font-weight:bold;text-decoration:none;&:hover{text-decoration:underline;}body.firefox&{font-weight:normal;}}```编译为```a{font-weight:bold;text-decoration:none;}a:hover{text-decoration:underline;}body.firefoxa{font-weight:normal;}```编译后的CSS文件中&将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递：```css#main{color:black;a{font-weight:bold;&:hover{color:red;}}}```编译为```#main{color:black;}#maina{font-weight:bold;}#maina:hover{color:red;}```&必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如```#main{color:black;&-sidebar{border:1pxsolid;}}```编译为```#main{color:black;}#main-sidebar{border:1pxsolid;}```>当父选择器含有不合适的后缀时，Sass将会报错。###4.3.属性嵌套(NestedProperties)>有些CSS属性遵循相同的命名空间(namespace)，比如font-family,font-size,font-weight都以font作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass允许将属性嵌套在命名空间中，例如：```.funky{font:{family:fantasy;size:30em;weight:bold;}}```编译为```.funky{font-family:fantasy;font-size:30em;font-weight:bold;}```命名空间也可以包含自己的属性值，例如：```.funky{font:20px/24px{family:fantasy;weight:bold;}}```编译为```.funky{font:20px/24px;font-family:fantasy;font-weight:bold;}```###4.4.占位符选择器%foo(PlaceholderSelectors:%foo)Sass额外提供了一种特殊类型的选择器：占位符选择器(placeholderselector)。与常用的id与class选择器写法相似，只是#或.替换成了%。必须通过@extend指令调用，更多介绍请查阅@extend-OnlySelectors。当占位符选择器单独使用时（未通过@extend调用），不会编译到CSS文件中。##5.注释>/**/与//(Comments:/**/and//)Sass支持标准的CSS多行注释/\\*\\*/，以及单行注释//，前者会被完整输出到编译后的CSS文件中，而后者则不会，例如：```/*Thiscommentis*severallineslong.*sinceitusestheCSScommentsyntax,*itwillappearintheCSSoutput.*/body{color:black;}//Thesecommentsareonlyonelinelongeach.//Theywon'tappearintheCSSoutput,//sincetheyusethesingle-linecommentsyntax.a{color:green;}```编译为```/*Thiscommentis*severallineslong.*sinceitusestheCSScommentsyntax,*itwillappearintheCSSoutput.*/body{color:black;}a{color:green;}```将!作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到CSS文件中，通常用于添加版权信息。插值语句(interpolation)也可写进多行注释中输出变量值：```$version:\"1.2.3\";/*ThisCSSisgeneratedbyMySnazzyFrameworkversion#{$version}.*/```编译为```/*ThisCSSisgeneratedbyMySnazzyFrameworkversion1.2.3.*/```##6.SassScript在CSS属性的基础上Sass提供了一些名为SassScript的新功能。SassScript可作用于任何属性，允许属性使用变量、算数运算等额外功能。通过interpolation，SassScript甚至可以生成选择器或属性名，这一点对编写mixin有很大帮助。###6.1.InteractiveShellInteractiveShell可以在命令行中测试SassScript的功能。在命令行中输入sass-i，然后输入想要测试的SassScript查看输出结果：```$sass-i>>\"Hello,SassyWorld!\"\"Hello,SassyWorld!\">>1px+1px+1px3px>>#777+#777#eeeeee>>#777+#888white```###6.2.变量$(Variables:$)SassScript最普遍的用法就是变量，变量以美元符号开头，赋值方法与CSS属性的写法一样：```$width:5em;```直接使用即调用变量：```scss#main{width:$width;}```变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加!global声明：```scss#main{$width:5em!global;width:$width;}#sidebar{width:$width;}```编译为```#main{width:5em;}#sidebar{width:5em;}```###6.3.数据类型(DataTypes)SassScript支持6种主要的数据类型：数字，1,2,13,10px字符串，有引号字符串与无引号字符串，\"foo\",'bar',baz颜色，blue,#04a3f9,rgba(255,0,0,0.5)布尔型，true,false空值，null数组(list)，用空格或逗号作分隔符，1.5em1em02em,Helvetica,Arial,sans-serifmaps,相当于JavaScript的object，(key1:value1,key2:value2)SassScript也支持其他CSS属性值，比如Unicode字符集，或!important声明。然而Sass不会特殊对待这些属性值，一律视为无引号字符串。####6.3.1.字符串(Strings)SassScript支持CSS的两种字符串类型：有引号字符串(quotedstrings)，如\"LucidaGrande\"'http://sass-lang.com'；与无引号字符串(unquotedstrings)，如sans-serifbold，在编译CSS文件时不会改变其类型。只有一种情况例外，使用#{}(interpolation)时，有引号字符串将被编译为无引号字符串，这样便于在mixin中引用选择器名：@mixinfirefox-message($selector){body.firefox#{$selector}:before{content:\"Hi,Firefoxusers!\";}}@includefirefox-message(\".header\");编译为body.firefox.header:before{content:\"Hi,Firefoxusers!\";}####6.3.2.数组(Lists)数组(lists)指Sass如何处理CSS中margin:10px15px00或者font-face:Helvetica,Arial,sans-serif这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组——只包含一个值的数组。数组本身没有太多功能，但Sasslistfunctions赋予了数组更多新功能：nth函数可以直接访问数组中的某一项；join函数可以将多个数组连接在一起；append函数可以在数组中添加新值；而@each指令能够遍历数组中的每一项。数组中可以包含子数组，比如1px2px,5px6px是包含1px2px与5px6px两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成(1px2px)(5px6px)。变化是，之前的1px2px,5px6px使用逗号分割了两个子数组(comma-separated)，而(1px2px)(5px6px)则使用空格分割(space-separated)。当数组被编译为CSS时，Sass不会添加任何圆括号（CSS中没有这种写法），所以(1px2px)(5px6px)与1px2px,5px6px在编译后的CSS文件中是完全一样的，但是它们在Sass文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。用()表示不包含任何值的空数组（在Sass3.3版之后也视为空的map）。空数组不可以直接编译成CSS，比如编译font-family:()Sass将会报错。如果数组中包含空数组或空值，编译时将被清除，比如1px2px()3px或1px2pxnull3px。基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如(1,)表示只包含1的数组，而(123,)表示包含123这个以空格分隔的数组的数组。####6.3.3.MapsMaps可视为键值对的集合，键被用于定位值在css种没有对应的概念。和Lists不同Maps必须被圆括号包围，键值对被都好分割。Maps中的keys和values可以是sassscript的任何对象。（包括任意的sassscript表达式arbitrarySassScriptexpressions）和Lists一样Maps主要为sassscript函数服务，如map-get函数用于查找键值，map-merge函数用于map和新加的键值融合，@each命令可添加样式到一个map中的每个键值对。Maps可用于任何Lists可用的地方，在List函数中Map会被自动转换为List，如(key1:value1,key2:value2)会被List函数转换为key1value1,key2value2，反之则不能。(网友Soledad提供)####6.3.4.颜色(Colors)AnyCSScolorexpressionreturnsaSassScriptColorvalue.Thisincludesalargenumberofnamedcolorswhichareindistinguishablefromunquotedstrings.Incompressedoutputmode,SasswilloutputthesmallestCSSrepresentationofacolor.Forexample,#FF0000willoutputasredincompressedmode,butblanchedalmondwilloutputas#FFEBCD.AcommonissueusersencounterwithnamedcolorsisthatsinceSassprefersthesameoutputformataswastypedinotheroutputmodes,acolorinterpolatedintoaselectorbecomesinvalidsyntaxwhencompressed.Toavoidthis,alwaysquotenamedcolorsiftheyaremeanttobeusedintheconstructionofaselector.###6.4.运算(Operations)所有数据类型均支持相等运算==或!=，此外，每种数据类型也有其各自支持的运算方式。####6.4.1.数字运算(NumberOperations)SassScript支持数字的加减乘除、取整等运算(+,-,\\*,/,%)，如果必要会在不同单位间转换值。```p{width:1in+8pt;}```编译为```p{width:1.111in;}```关系运算<,>,<=,>=也可用于数字运算，相等运算==,!=可用于所有数据类型。6.4.1.1.除法运算/(Divisionand/)/在CSS中通常起到分隔数字的用途，SassScript作为CSS语言的拓展当然也支持这个功能，同时也赋予了/除法运算的功能。也就是说，如果/在SassScript中把两个数字分隔，编译后的CSS文件中也是同样的作用。以下三种情况/将被视为除法运算符号：如果值，或值的一部分，是变量或者函数的返回值如果值被圆括号包裹如果值是算数表达式的一部分```p{font:10px/8px;//PlainCSS,nodivision$width:1000px;width:$width/2;//Usesavariable,doesdivisionwidth:round(1.5)/2;//Usesafunction,doesdivisionheight:(500px/2);//Usesparentheses,doesdivisionmargin-left:5px+8px/2px;//Uses+,doesdivision}```编译为```p{font:10px/8px;width:500px;height:250px;margin-left:9px;}```如果需要使用变量，同时又要确保/不做除法运算而是完整地编译到CSS文件中，只需要用#{}插值语句将变量包裹。```p{$font-size:12px;$line-height:30px;font:#{$font-size}/#{$line-height};}```编译为```p{font:12px/30px;}```####6.4.2.颜色值运算(ColorOperations)颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值：```p{color:#010203+#040506;}```计算01+04=0502+05=0703+06=09，然后编译为```p{color:#050709;}```使用colorfunctions比计算颜色值更方便一些。数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如```p{color:#010203*2;}```计算01_2=0202_2=0403\\*2=06，然后编译为```p{```需要注意的是，如果颜色值包含alphachannel（rgba或hsla两种颜色值），必须拥有相等的alpha值才能进行运算，因为算术运算不会作用于alpha值。```p{color:rgba(255,0,0,0.75)+rgba(0,255,0,0.75);}```编译为```p{color:rgba(255,255,0,0.75);}```颜色值的alphachannel可以通过opacify或transparentize两个函数进行调整。```$translucent-red:rgba(255,0,0,0.5);p{color:opacify($translucent-red,0.3);background-color:transparentize($translucent-red,0.25);}```编译为```p{color:rgba(255,0,0,0.8);background-color:rgba(255,0,0,0.25);}```IE滤镜要求所有的颜色值包含alpha层，而且格式必须固定#AABBCCDD，使用ie_hex_str函数可以很容易地将颜色转化为IE滤镜要求的格式。```$translucent-red:rgba(255,0,0,0.5);$green:#00ff00;div{filter:progid:DXImageTransform.Microsoft.gradient(enabled='false',startColorstr='#{ie-hex-str($green)}',endColorstr='#{ie-hex-str($translucent-red)}');}```编译为```div{filter:progid:DXImageTransform.Microsoft.gradient(enabled='false',startColorstr=#FF00FF00,endColorstr=#80FF0000);}```####6.4.3.字符串运算(StringOperations)-可用于连接字符串```p{cursor:e+-resize;}```编译为```p{cursor:e-resize;}```注意，如果有引号字符串（位于+左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于+左侧）连接有引号字符串，运算结果则没有引号。```p:before{content:\"Foo\"+Bar;font-family:sans-+\"serif\";}```编译为```p:before{content:\"FooBar\";font-family:sans-serif;}```运算表达式与其他值连用时，用空格做连接符：```p{margin:3px+4pxauto;}```编译为```p{margin:7pxauto;}```在有引号的文本字符串中使用#{}插值语句可以添加动态的值：```p:before{content:\"Iate#{5+10}pies!\";}```编译为```p:before{content:\"Iate15pies!\";}```空的值被视作插入了空字符串：```$value:null;p:before{content:\"Iate#{$value}pies!\";}```编译为```p:before{content:\"Iatepies!\";}```####6.4.4.布尔运算(BooleanOperations)SassScript支持布尔型的andor以及not运算。####6.4.5.数组运算(ListOperations)数组不支持任何运算方式，只能使用listfunctions控制。###6.5.圆括号(Parentheses)圆括号可以用来影响运算的顺序：```p{width:1em+(2em*3);}```编译为```p{width:7em;}```###6.6.函数(Functions)SassScript定义了多种函数，有些甚至可以通过普通的CSS语句调用：```p{color:hsl(0,100%,50%);}```编译为```p{color:#ff0000;}```####6.6.1.关键词参数(KeywordArguments)Sass函数允许使用关键词参数(keywordarguments)，上面的例子也可以写成：```p{color:hsl($hue:0,$saturation:100%,$lightness:50%);}```虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。通过Sass::Script::Functions查看完整的Sass函数列表，参数名，以及如何自定义函数。###6.7.插值语句#{}(Interpolation:#{})通过#{}插值语句可以在选择器或属性名中使用变量：```$name:foo;$attr:border;p.#{$name}{#{$attr}-color:blue;}```编译为```p.foo{border-color:blue;}```{}插值语句也可以在属性值中插入SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用#{}可以避免Sass运行运算表达式，直接编译CSS。```p{$font-size:12px;$line-height:30px;font:#{$font-size}/#{$line-height};}```编译为```p{font:12px/30px;}```###6.8.&inSassScriptJustlikewhenit’susedinselectors,&inSassScriptreferstothecurrentparentselector.It’sacomma-separatedlistofspace-separatedlists.Forexample:```.foo.bar.baz.bang,.bip.qux{$selector:&;}```Thevalueof$selectorisnow((\".foo.bar\"\".baz.bang\"),\".bip.qux\").Thecompoundselectorsarequotedheretoindicatethatthey’restrings,butinrealitytheywouldbeunquoted.Eveniftheparentselectordoesn’tcontainacommaoraspace,&willalwayshavetwolevelsofnesting,soitcanbeaccessedconsistently.Ifthereisnoparentselector,thevalueof&willbenull.Thismeansyoucanuseitinamixintodetectwhetheraparentselectorexists:```@mixindoes-parent-exist{@if&{&:hover{color:red;}}@else{a{color:red;}}}```###6.9.变量定义!default(VariableDefaults:!default)可以在变量的结尾添加!default给一个未通过!default声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。```$content:\"Firstcontent\";$content:\"Secondcontent?\"!default;$new_content:\"Firsttimereference\"!default;#main{content:$content;new-content:$new_content;}```编译为```#main{content:\"Firstcontent\";new-content:\"Firsttimereference\";}```变量是null空值时将视为未被!default赋值。```$content:null;$content:\"Non-nullcontent\"!default;#main{content:$content;}```编译为```#main{content:\"Non-nullcontent\";}```##7.@-Rules与指令(@-RulesandDirectives)Sass支持所有的CSS3@-Rules，以及Sass特有的“指令”（directives）。这一节会详细解释，更多资料请查看控制指令(controldirectives)与混合指令(mixindirectives)两个部分。###7.1.@importSass拓展了@import的功能，允许其导入SCSS或Sass文件。被导入的文件将合并编译到同一个CSS文件中，另外，被导入的文件中所包含的变量或者混合指令(mixin)都可以在导入的文件中使用。Sass在当前地址，或Rack,Rails,Merb的Sass文件地址寻找Sass文件，如果需要设定其他地址，可以用:load_paths选项，或者在命令行中输入--load-path命令。通常，@import寻找Sass文件并将其导入，但在以下情况下，@import仅作为普通的CSS语句，不会导入任何Sass文件。文件拓展名是.css；文件名以http://开头；文件名是url()；@import包含mediaqueries。如果不在上述情况内，文件的拓展名是.scss或.sass，则导入成功。没有指定拓展名，Sass将会试着寻找文件名相同，拓展名为.scss或.sass的文件并将其导入。```@import\"foo.scss\";或@import\"foo\";都会导入文件foo.scss，但是@import\"foo.css\";@import\"foo\"screen;@import\"http://foo.com/bar\";@importurl(foo);编译为@import\"foo.css\";@import\"foo\"screen;@import\"http://foo.com/bar\";@importurl(foo);```Sass允许同时导入多个文件，例如同时导入rounded-corners与text-shadow两个文件：```@import\"rounded-corners\",\"text-shadow\";```导入文件也可以使用#{}插值语句，但不是通过变量动态导入Sass文件，只能作用于CSS的url()导入方式：$family:unquote(\"Droid+Sans\");@importurl(\"http://fonts.googleapis.com/css?family=\\#{$family}\");编译为@importurl(\"http://fonts.googleapis.com/css?family=Droid+Sans\");####7.1.1.分音(Partials)如果需要导入SCSS或者Sass文件，但又不希望将其编译为CSS，只需要在文件名前添加下划线，这样会告诉Sass不要编译这些文件，但导入语句中却不需要添加下划线。例如，将文件命名为\\_colors.scss，便不会编译\\_colours.css文件。```@import\"colors\";```上面的例子，导入的其实是\\_colors.scss文件注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。####7.1.2.嵌套@import大多数情况下，一般在文件的最外层（不在嵌套规则内）使用@import，其实，也可以将@import嵌套进CSS样式或者@media中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。假设example.scss文件包含以下样式：```.example{color:red;}```然后导入到#main样式内```#main{@import\"example\";}```将会被编译为```#main.example{color:red;}```Directivesthatareonlyallowedatthebaselevelofadocument,like@mixinor@charset,arenotallowedinfilesthatare@importedinanestedcontext.这一句不理解不可以在混合指令(mixin)或控制指令(controldirectives)中嵌套@import。###7.2.@mediaSass中@media指令与CSS中用法一样，只是增加了一点额外的功能：允许其在CSS规则中嵌套。如果@media嵌套在CSS规则内，编译时，@media将被编译到文件的最外层，包含嵌套的父选择器。这个功能让@media用起来更方便，不需要重复使用选择器，也不会打乱CSS的书写流程。```.sidebar{width:300px;@mediascreenand(orientation:landscape){width:500px;}}```编译为```.sidebar{width:300px;}@mediascreenand(orientation:landscape){.sidebar{width:500px;}}```@media的queries允许互相嵌套使用，编译时，Sass自动添加and```@mediascreen{.sidebar{@media(orientation:landscape){width:500px;}}}```编译为```@mediascreenand(orientation:landscape){.sidebar{width:500px;}}```@media甚至可以使用SassScript（比如变量，函数，以及运算符）代替条件的名称或者值：```$media:screen;$feature:-webkit-min-device-pixel-ratio;$value:1.5;@media#{$media}and($feature:$value){.sidebar{width:500px;}}```编译为```@mediascreenand(-webkit-min-device-pixel-ratio:1.5){.sidebar{width:500px;}}```###7.3.@extend在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在HTML中给元素定义两个class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写：<divclass=\"errorseriousError\">Ohno!You'vebeenhacked!</div>样式如下```.error{border:1px#f00;background-color:#fdd;}.seriousError{border-width:3px;}```麻烦的是，这样做必须时刻记住使用.seriousError时需要参考.error的样式，带来了很多不变：智能比如加重维护负担，导致bug，或者给HTML添加无语意的样式。使用@extend可以避免上述情况，告诉Sass将一个选择器下的所有样式继承给另一个选择器。```.error{border:1px#f00;background-color:#fdd;}.seriousError{@extend.error;border-width:3px;}```上面代码的意思是将.error下的所有样式继承给.seriousError，border-width:3px;是单独给.seriousError设定特殊样式，这样，使用.seriousError的地方可以不再使用.error。其他使用到.error的样式也会同样继承给.seriousError，例如，另一个样式.error.intrusion使用了hacked.png做背景，<divclass=\"seriousErrorintrusion\">也同样会使用hacked.png背景。```.error.intrusion{background-image:url(\"/image/hacked.png\");}```###7.3.1.HowitWorks@extend的作用是将重复使用的样式(.error)延伸(extend)给需要包含这个样式的特殊样式（.seriousError），刚刚的例子：```.error{border:1px#f00;background-color:#fdd;}.error.intrusion{background-image:url(\"/image/hacked.png\");}.seriousError{@extend.error;border-width:3px;}```编译为```.error,.seriousError{border:1px#f00;background-color:#fdd;}.error.intrusion,.seriousError.intrusion{background-image:url(\"/image/hacked.png\");}.seriousError{border-width:3px;}```当合并选择器时，@extend会很聪明地避免无谓的重复，.seriousError.seriousError将编译为.seriousError，不能匹配任何元素的选择器（比如#main#footer）也会删除。####7.3.2.延伸复杂的选择器(ExtendingComplexSelectors)Class选择器并不是唯一可以被延伸(extend)的，Sass允许延伸任何定义给单个元素的选择器，比如.special.cool，a:hover或者a.user[href^=\"http://\"]等，例如：```.hoverlink{@extenda:hover;}```同class元素一样，a:hover的样式将继承给.hoverlink。```.hoverlink{@extenda:hover;}a:hover{text-decoration:underline;}```编译为```a:hover,.hoverlink{text-decoration:underline;}```与上面.error.intrusion的例子一样，所有a:hover的样式将继承给.hoverlink，包括其他使用到a:hover的样式，例如：```.hoverlink{@extenda:hover;}.commenta.user:hover{font-weight:bold;}```编译为```.commenta.user:hover,.comment.user.hoverlink{font-weight:bold;}```####7.3.3.多重延伸(MultipleExtends)同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器：```.error{border:1px#f00;background-color:#fdd;}.attention{font-size:3em;background-color:#ff0;}.seriousError{@extend.error;@extend.attention;border-width:3px;}```编译为```.error,.seriousError{border:1px#f00;background-color:#fdd;}.attention,.seriousError{font-size:3em;background-color:#ff0;}.seriousError{border-width:3px;}```每个.seriousError将包含.error与.attention下的所有样式，这时，后定义的样式享有优先权：.seriousError的背景颜色是#ff0而不是#fdd，因为.attention在.error之后定义。多重延伸可以使用逗号分隔选择器名，比如@extend.error,.attention;与@extend.error;@extend.attention有相同的效果。####7.3.4.继续延伸(ChainingExtends)当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个，例如：```.error{border:1px#f00;background-color:#fdd;}.seriousError{@extend.error;border-width:3px;}.criticalError{@extend.seriousError;position:fixed;top:10%;bottom:10%;left:10%;right:10%;}```现在，每个.seriousError选择器将包含.error的样式，而.criticalError不仅包含.seriousError的样式也会同时包含.error的所有样式，上面的代码编译为：```.error,.seriousError,.criticalError{border:1px#f00;background-color:#fdd;}.seriousError,.criticalError{border-width:3px;}.criticalError{position:fixed;top:10%;bottom:10%;left:10%;right:10%;}```####7.3.5.选择器列(SelectorSequences)暂时不可以将选择器列(SelectorSequences)，比如.foo.bar或.foo+.bar，延伸给其他元素，但是，却可以将其他元素延伸给选择器列：```#fake-links.link{@extenda;}a{color:blue;&:hover{text-decoration:underline;}}```编译为```a,#fake-links.link{color:blue;}a:hover,#fake-links.link:hover{text-decoration:underline;}```#####7.3.5.1.合并选择器列(MergingSelectorSequences)有时会遇到复杂的情况，比如选择器列中的某个元素需要延伸给另一个选择器列，这种情况下，两个选择器列需要合并，比如：```#admin.tabbara{font-weight:bold;}#demo.overview.fakelink{@extenda;}```技术上讲能够生成所有匹配条件的结果，但是这样生成的样式表太复杂了，上面这个简单的例子就可能有10种结果。所以，Sass只会编译输出有用的选择器。当两个列(sequence)合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：```#admin.tabbara{font-weight:bold;}#demo.overview.fakelink{@extenda;}```编译为```#admin.tabbara,#admin.tabbar#demo.overview.fakelink,#demo.overview#admin.tabbar.fakelink{font-weight:bold;}```如果两个列(sequence)包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出。在下面的例子里，两个列都包含#admin，输出结果中它们合并在了一起：```#admin.tabbara{font-weight:bold;}#admin.overview.fakelink{@extenda;}```编译为```#admin.tabbara,#admin.tabbar.overview.fakelink,#admin.overview.tabbar.fakelink{font-weight:bold;}```####7.3.6.@extend-Only选择器(@extend-OnlySelectors)有时，需要定义一套样式并不是给某个元素用，而是只通过@extend指令使用，尤其是在制作Sass样式库的时候，希望Sass能够忽略用不到的样式。如果使用普通的CSS规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass引入了“占位符选择器”(placeholderselectors)，看起来很像普通的id或class选择器，只是#或.被替换成了%。可以像class或者id选择器那样使用，当它们单独使用时，不会被编译到CSS文件中。```//Thisrulesetwon'tberenderedonitsown.#contexta%extreme{color:blue;font-weight:bold;font-size:2em;}```占位符选择器需要通过延伸指令使用，用法与class或者id选择器一样，被延伸后，占位符选择器本身不会被编译。```.notice{@extend%extreme;}```编译为```#contexta.notice{color:blue;font-weight:bold;font-size:2em;}```####7.3.7.!optional声明(The!optionalFlag)如果@extend失败会收到错误提示，比如，这样写a.important{@extend.notice}，当没有.notice选择器时，将会报错，只有h1.notice包含.notice时也会报错，因为h1与a冲突，会生成新的选择器。如果要求@extend不生成新选择器，可以通过!optional声明达到这个目的，例如：```a.important{@extend.notice!optional;}```####7.3.8.在指令中延伸(@extendinDirectives)在指令中使用@extend时（比如在@media中）有一些限制：Sass不可以将@media层外的CSS规则延伸给指令层内的CSS，这样会生成大量的无用代码。也就是说，如果在@media（或者其他CSS指令）中使用@extend，必须延伸给相同指令层中的选择器。下面的例子是可行的：```@mediaprint{.error{border:1px#f00;background-color:#fdd;}.seriousError{@extend.error;border-width:3px;}}```但不可以这样：```.error{border:1px#f00;background-color:#fdd;}@mediaprint{.seriousError{//INVALIDEXTEND:.errorisusedoutsideofthe\"@mediaprint\"directive@extend.error;border-width:3px;}}```希望有一天，浏览器可以原生支持@extend指令，这样就可以在任何指令中使用延伸功能，不再受限制了。###7.4.@at-rootThe@at-rootdirectivecausesoneormorerulestobeemittedattherootofthedocument,ratherthanbeingnestedbeneaththeirparentselectors.Itcaneitherbeusedwithasingleinlineselector:```.parent{...@at-root.child{...}}```Whichwouldproduce:```.parent{...}.child{...}```Oritcanbeusedwithablockcontainingmultipleselectors:```.parent{...@at-root{.child1{...}.child2{...}}.step-child{...}}```Whichwouldoutputthefollowing:```.parent{...}.child1{...}.child2{...}.parent.step-child{...}```####7.4.1.@at-root(without:...)and@at-root(with:...)Bydefault,@at-rootjustexcludesselectors.However,it’salsopossibletouse@at-roottomoveoutsideofnesteddirectivessuchas@mediaaswell.Forexample:```@mediaprint{.page{width:8in;@at-root(without:media){color:red;}}}```produces:```@mediaprint{.page{width:8in;}}.page{color:red;}```Youcanuse@at-root(without:...)tomoveoutsideofanydirective.Youcanalsodoitwithmultipledirectivesseparatedbyaspace:@at-root(without:mediasupports)movesoutsideofboth@mediaand@supportsqueries.Therearetwospecialvaluesyoucanpassto@at-root.“rule”referstonormalCSSrules;@at-root(without:rule)isthesameas@at-rootwithnoquery.@at-root(without:all)meansthatthestylesshouldbemovedoutsideofalldirectivesandCSSrules.Ifyouwanttospecifywhichdirectivesorrulestoinclude,ratherthanlistingwhichonesshouldbeexcluded,youcanusewithinsteadofwithout.Forexample,@at-root(with:rule)willmoveoutsideofalldirectives,butwillpreserveanyCSSrules.###7.5.@debugThe@debugdirectiveprintsthevalueofaSassScriptexpressiontothestandarderroroutputstream.It’susefulfordebuggingSassfilesthathavecomplicatedSassScriptgoingon.Forexample:@debug10em+12em;编译为Line1DEBUG:22em###7.6.@warnThe@warndirectiveprintsthevalueofaSassScriptexpressiontothestandarderroroutputstream.It’susefulforlibrariesthatneedtowarnusersofdeprecationsorrecoveringfromminormixinusagemistakes.Therearetwomajordistinctionsbetween@warnand@debug:Youcanturnwarningsoffwiththe--quietcommand-lineoptionorthe:quietSassoption.Astylesheettracewillbeprintedoutalongwiththemessagesothattheuserbeingwarnedcanseewheretheirstylescausedthewarning.UsageExample:```@mixinadjust-location($x,$y){@ifunitless($x){@warn\"Assuming#{$x}tobeinpixels\";$x:1px*$x;}@ifunitless($y){@warn\"Assuming#{$y}tobeinpixels\";$y:1px*$y;}position:relative;left:$x;top:$y;}```###7.7.@warnThe@errordirectivethrowsthevalueofaSassScriptexpressionasafatalerror,includinganicestacktrace.It’susefulforvalidatingargumentstomixinsandfunctions.Forexample:```@mixinadjust-location($x,$y){@ifunitless($x){@error\"$xmaynotbeunitless,was#{$x}.\";}@ifunitless($y){@error\"$ymaynotbeunitless,was#{$y}.\";}position:relative;left:$x;top:$y;}```Thereiscurrentlynowaytocatcherrors.##8.控制指令(ControlDirectives)SassScript提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令(mixin)配合使用，尤其是用在Compass等样式库中。8.1.if()Thebuilt-inif()functionallowsyoutobranchonaconditionandreturnsonlyoneoftwopossibleoutcomes.Itcanbeusedinanyscriptcontext.Theiffunctiononlyevaluatestheargumentcorrespondingtotheonethatitwillreturn–thisallowsyoutorefertovariablesthatmaynotbedefinedortohavecalculationsthatwouldotherwisecauseanerror(E.g.dividebyzero).###8.2.@if当@if的表达式返回值不是false或者null时，条件成立，输出{}内的代码：```p{@if1+1==2{border:1pxsolid;}@if5<3{border:2pxdotted;}@ifnull{border:3pxdouble;}}```编译为```p{border:1pxsolid;}```@if声明后面可以跟多个@elseif声明，或者一个@else声明。如果@if声明失败，Sass将逐条执行@elseif声明，如果全部失败，最后执行@else声明，例如：```$type:monster;p{@if$type==ocean{color:blue;}@elseif$type==matador{color:red;}@elseif$type==monster{color:green;}@else{color:black;}}```编译为```p{color:green;}```###8.3.@for@for指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：@for$varfrom<start>through<end>，或者@for$varfrom<start>to<end>，区别在于through与to的含义：当使用through时，条件范围包含<start>与<end>的值，而使用to时条件范围只包含<start>的值不包含<end>的值。另外，$var可以是任何变量，比如$i；<start>和<end>必须是整数值。```@for$ifrom1through3{.item-#{$i}{width:2em*$i;}}```编译为```.item-1{width:2em;}.item-2{width:4em;}.item-3{width:6em;}```###8.4.@each@each指令的格式是$varin<list>,$var可以是任何变量名，比如$length或者$name，而<list>是一连串的值，也就是值列表。@each将变量$var作用于值列表中的每一个项目，然后输出结果，例如：```@each$animalinpuma,sea-slug,egret,salamander{.#{$animal}-icon{background-image:url('/images/#{$animal}.png');}}```编译为```.puma-icon{background-image:url('/images/puma.png');}.sea-slug-icon{background-image:url('/images/sea-slug.png');}.egret-icon{background-image:url('/images/egret.png');}.salamander-icon{background-image:url('/images/salamander.png');}```####8.4.1MultipleAssignmentThe@eachdirectivecanalsousemultiplevariables,asin@each$var1,$var2,...in.Ifisalistoflists,eachelementofthesub-listsisassignedtotherespectivevariable.Forexample:```@each$animal,$color,$cursorin(puma,black,default),(sea-slug,blue,pointer),(egret,white,move){.#{$animal}-icon{background-image:url('/images/#{$animal}.png');border:2pxsolid$color;cursor:$cursor;}}```iscompiledto:```.puma-icon{background-image:url('/images/puma.png');border:2pxsolidblack;cursor:default;}.sea-slug-icon{background-image:url('/images/sea-slug.png');border:2pxsolidblue;cursor:pointer;}.egret-icon{background-image:url('/images/egret.png');border:2pxsolidwhite;cursor:move;}```Sincemapsaretreatedaslistsofpairs,multipleassignmentworkswiththemaswell.Forexample:```@each$header,$sizein(h1:2em,h2:1.5em,h3:1.2em){#{$header}{font-size:$size;}}```iscompiledto:```h1{font-size:2em;}h2{font-size:1.5em;}h3{font-size:1.2em;}```###8.5.@while@while指令重复输出格式直到表达式返回结果为false。这样可以实现比@for更复杂的循环，只是很少会用到。例如：```$i:6;@while$i>0{.item-#{$i}{width:2em*$i;}$i:$i-2;}.item-6{width:12em;}.item-4{width:8em;}.item-2{width:4em;}```##9.混合指令(MixinDirectives)混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的class，比如.float-left。混合指令可以包含所有的CSS规则，绝大部分Sass规则，甚至通过参数功能引入变量，输出多样化的样式。###9.1.定义混合指令@mixin(DefiningaMixin:@mixin)混合指令的用法是在@mixin后添加名称与样式，比如名为large-text的混合通过下面的代码定义：```@mixinlarge-text{font:{family:Arial;size:20px;weight:bold;}color:#ff0000;}```混合也需要包含选择器和属性，甚至可以用&引用父选择器：```@mixinclearfix{display:inline-block;&:after{content:\".\";display:block;height:0;clear:both;visibility:hidden;}*html&{height:1px}}```###9.2.引用混合样式@include(IncludingaMixin:@include)使用@include指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）：```.page-title{@includelarge-text;padding:4px;margin-top:10px;}```编译为```.page-title{font-family:Arial;font-size:20px;font-weight:bold;color:#ff0000;padding:4px;margin-top:10px;}```也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。```@mixinsilly-links{a{color:blue;background-color:red;}}@includesilly-links;```编译为```a{color:blue;background-color:red;}```混合样式中也可以包含其他混合样式，比如```@mixincompound{@includehighlighted-background;@includeheader-text;}@mixinhighlighted-background{background-color:#fc0;}@mixinheader-text{font-size:20px;}```混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。###9.3.参数(Arguments)参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号：```@mixinsexy-border($color,$width){border:{color:$color;width:$width;style:dashed;}}p{@includesexy-border(blue,1in);}```编译为```p{border-color:blue;border-width:1in;border-style:dashed;}```混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值：```@mixinsexy-border($color,$width:1in){border:{color:$color;width:$width;style:dashed;}}p{@includesexy-border(blue);}h1{@includesexy-border(blue,2in);}```编译为```p{border-color:blue;border-width:1in;border-style:dashed;}h1{border-color:blue;border-width:2in;border-style:dashed;}```####9.3.1.关键词参数(KeywordArguments)混合指令也可以使用关键词参数，上面的例子也可以写成：```p{@includesexy-border($color:blue);}h1{@includesexy-border($color:blue,$width:2in);}```虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。####9.3.2.参数变量(VariableArguments)有时，不能确定混合指令需要使用多少个参数，比如一个关于box-shadow的混合指令不能确定有多少个'shadow'会被用到。这时，可以使用参数变量…声明（写在参数的最后方）告诉Sass将这些参数视为值列表处理：```@mixinbox-shadow($shadows...){-moz-box-shadow:$shadows;-webkit-box-shadow:$shadows;box-shadow:$shadows;}.shadows{@includebox-shadow(0px4px5px#666,2px6px10px#999);}```编译为```.shadowed{-moz-box-shadow:0px4px5px#666,2px6px10px#999;-webkit-box-shadow:0px4px5px#666,2px6px10px#999;box-shadow:0px4px5px#666,2px6px10px#999;}```参数变量也可以用在引用混合指令的时候(@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用：```@mixincolors($text,$background,$border){color:$text;background-color:$background;border-color:$border;}$values:#ff0000,#00ff00,#0000ff;.primary{@includecolors($values...);}```编译为```.primary{color:#ff0000;background-color:#00ff00;border-color:#0000ff;}```Youcanusevariableargumentstowrapamixinandaddadditionalstyleswithoutchangingtheargumentsignatureofthemixin.Ifyoudoso,evenkeywordargumentswillgetpassedthroughtothewrappedmixin.Forexample:```@mixinwrapped-stylish-mixin($args...){font-weight:bold;@includestylish-mixin($args...);}.stylish{//The$widthargumentwillgetpassedonto\"stylish-mixin\"asakeyword@includewrapped-stylish-mixin(#00ff00,$width:100px);}```上面注释内的意思是：$width参数将会传递给stylish-mixin作为关键词。###9.4.向混合样式中导入内容(PassingContentBlockstoaMixin)在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在@content标志的地方：```@mixinapply-to-ie6-only{*html{@content;}}@includeapply-to-ie6-only{#logo{background-image:url(/logo.gif);}}```编译为```*html#logo{background-image:url(/logo.gif);}```为便于书写，@mixin可以用=表示，而@include可以用+表示，所以上面的例子可以写成：```=apply-to-ie6-only*html@content+apply-to-ie6-only#logobackground-image:url(/logo.gif)```注意：当@content在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。####9.4.1.VariableScopeandContentBlocksTheblockofcontentpassedtoamixinareevaluatedinthescopewheretheblockisdefined,notinthescopeofthemixin.Thismeansthatvariableslocaltothemixincannotbeusedwithinthepassedstyleblockandvariableswillresolvetotheglobalvalue:```$color:white;@mixincolors($color:blue){background-color:$color;@content;border-color:$color;}.colors{@includecolors{color:$color;}}```编译为```.colors{background-color:blue;color:white;border-color:blue;}```Additionally,thismakesitclearthatthevariablesandmixinsthatareusedwithinthepassedblockarerelatedtotheotherstylesaroundwheretheblockisdefined.Forexample:```#sidebar{$sidebar-width:300px;width:$sidebar-width;@includesmartphone{width:$sidebar-width/3;}}```##10.函数指令(FunctionDirectives)Sass支持自定义函数，并能在任何属性值或Sassscript中使用：```$grid-width:40px;$gutter-width:10px;@functiongrid-width($n){@return$n*$grid-width+($n-1)*$gutter-width;}#sidebar{width:grid-width(5);}```编译为```#sidebar{width:240px;}```与mixin相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用@return输出结果。自定义的函数也可以使用关键词参数，上面的例子还可以这样写：```#sidebar{width:grid-width($n:5);}```建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是Sass或者CSS的自带功能。自定义函数与mixin相同，都支持variablearguments##11.输出格式(OutputStyle)Sass默认的CSS输出格式很美观也能清晰反映文档结构，为满足其他需求Sass也提供了多种输出格式。Sass提供了四种输出格式，可以通过:styleoption选项设定，或者在命令行中使用--style选项。###11.1.:nestedNested（嵌套）样式是Sass默认的输出格式，能够清晰反映CSS与HTML的结构关系。选择器与属性等单独占用一行，缩进量与Sass文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型CSS文件时，这种样式可以很容易地分析文件的主要结构。```#main{color:#fff;background-color:#000;}#mainp{width:10em;}.huge{font-size:10em;font-weight:bold;text-decoration:underline;}```###11.2.:expandedExpanded输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。```#main{color:#fff;background-color:#000;}#mainp{width:10em;}.huge{font-size:10em;font-weight:bold;text-decoration:underline;}```###11.3.:compactCompact输出方式比起上面两种占用的空间更少，每条CSS规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。```#main{color:#fff;background-color:#000;}#mainp{width:10em;}.huge{font-size:10em;font-weight:bold;text-decoration:underline;}```###11.4.:compressedCompressed输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。```cssmain{color:#fff;background-color:#000;}#mainp{width:10em;}.huge{font-size:10em;font-weight:bold;text-decoration:underline;}```##12.拓展Sass(ExtendingSass)Sass提供了很多高级自定义功能，使用这些功能需要有良好的Ruby基础。###12.1.自定义Sass函数(DefiningCustomSassFunctions)通过RubyAPI可以自定义Sass函数，具体请查看sourcedocumentation。###12.2.存储缓存(CacheStores)Sasscachesparseddocumentssothattheycanbereusedwithoutparsingthemagainunlesstheyhavechanged.Bydefault,Sasswillwritethesecachefilestoalocationonthefilesystemindicatedby:cache_location.Ifyoucannotwritetothefilesystemorneedtosharecacheacrossrubyprocessesormachines,thenyoucandefineyourowncachestoreandsetthe:cache_storeoption.Fordetailsoncreatingyourowncachestore,pleaseseethesourcedocumentation.###12.3.自定义导入(CustomImporters)Sassimportersareinchargeoftakingpathspassedto@importandfindingtheappropriateSasscodeforthosepaths.Bydefault,thiscodeisloadedfromthefilesystem,butimporterscouldbeaddedtoloadfromadatabase,overHTTP,oruseadifferentfilenamingschemethanwhatSassexpects.Eachimporterisinchargeofasingleloadpath(orwhateverthecorrespondingnotionisforthebackend).Importerscanbeplacedinthe:load_pathsarrayalongsidenormalfilesystempaths.Whenresolvingan@import,Sasswillgothroughtheloadpathslookingforanimporterthatsuccessfullyimportsthepath.Onceoneisfound,theimportedfileisused.User-createdimportersmustinheritfromSass::Importers::Base.Sass中文网（Sass中国）©2017-友情链接-文章/教程征集反馈建议[sass](https://www.sass.hk/docs/)","Data\\Game.md":"#Game##Minecraft###模组-[RealisticCraft](https://modrinth.com/modpack/realisticcraft/version/1.0.2)","Data\\书.md":"#书<https://www.ituring.com.cn/>[JiumoSearch鸠摩搜索-文档搜索引擎(jiumodiary.com)](https://www.jiumodiary.com/)[免费的编程中文书籍索引](https://github.com/justjavac/free-programming-books-zh_CN)[书格](https://new.shuge.org/)-古籍","Data\\像素.md":"#像素><http://www.gmkiss.com/>##像素角色1.2bit生成器：<https://0x72.itch.io/2bitcharactergenerator>2:人物头像生成器：<https://kenney.itch.io/avatar-mixer>3:简单怪物小人：<https://0x72.itch.io/pixeldudesmaker>4:可爱怪物：<https://kenney.itch.io/creature-mixer>5:幻想怪物：<https://deep-fold.itch.io/pixel-sprite-generator>","Data\\其他.md":"#其他[世界统计-实时世界统计(worldometers.info)](https://www.worldometers.info/)","Data\\动画.md":"#动画>-[AutoDraw](https://www.autodraw.com/):在线画图>-[GetWaves–CreateSVGwavesforyournextdesign](https://getwaves.io/):波浪>-[CSSSectionSeparatorGenerator|wweb.dev](https://wweb.dev/resources/css-separator-generator/):分段分离特效>-[cubic-bezier(.73,.2,.36,.85)✿cubic-bezier.com](https://cubic-bezier.com/#.73,.2,.36,.85):曲线>-[Codrops|Creativefront-endresourcesandinspirationforwebprofessionals(tympanus.net)](https://tympanus.net/codrops/)>-[Animate.css](https://animate.style/)开箱即用的跨浏览器CSS动画效果>-[animista](http://animista.net/)按需定制CSS动画效果>-[CSSeffectsSnippets](https://emilkowalski.github.io/css-effects-snippets/)CSS动画效果收集，点击某个效果即可复制相应的代码片段至剪贴板>-[SpinKit](https://tobiasahlin.com/spinkit/)汇集了实现各种加载效果的CSS代码片段","Data\\图画\\icons.md":"#icons[iconfont-阿里巴巴矢量图标库](https://www.iconfont.cn/)<https://unicornicons.com/icons><https://www.aigei.com/s?q=%E6%96%87%E4%BB%B6%E5%A4%B9&type=design_icon>[GIF,SVG,APNGloadinganimations](https://icons8.com/preloaders/en/7/2/loading)##生成icons<https://www.logosc.cn/logo/favicon?s>=[loading.io](https://loading.io/)","Data\\图画\\图标&Logo.md":"#图标&logo","Data\\图画\\图片.md":"#图片网站##画名画-<https://useum.org/download-artworks/free-smartphone-wallpapers>-<https://useum.org/download-artworks/free-laptop-wallpapers>##图片>[动态图片生成](https://dummyimage.com/)>>[免费正版高清图片素材库超过2.3百万张优质图片和视频素材可供免费使用和下载-Pixabay](https://pixabay.com/zh/)>>[WallpaperAbyss-高清壁纸,桌面背景(alphacoders.com)](https://wall.alphacoders.com/?lang=Chinese)>>[SamsungWallpaperGalleryS8HDforAndroid-FreeDownload-Page9(wallpapershome.com)](https://wallpapershome.com/download-wallpapers/samsung/?page=9)>>-[Unsplash](https://unsplash.com/)可供免费使用的图片>-[Pexels](https://www.pexels.com/)精美的免费图片和视频>-[Burst](https://burst.shopify.com/)免费高分辨率图片，可用于网站和商业用途>-[ISORepublic](https://isorepublic.com/)使用CC0许可的免费高分辨率图片和视频>-[Pixabay](https://pixabay.com/)令人惊叹的免费（公共领域）图片和视频站点>-[StockSnap.io](https://stocksnap.io/)精美的免费图片，同样使用CC0许可>-[Photopea](https://www.photopea.com/)在线图片编辑工具，支持大量高级功能>-[OnlineImageCompressor](https://imagecompressor.com/)在线图片压缩工具，一次可以压缩多达20张图片>-[BulkResizePhotos](https://bulkresizephotos.com/en)最快的在线图片缩放工具（图片缩放和压缩在本地完成，无需上传到服务器）1.FOCA<https://focastock.com/>2.SkitterPhoto<https://skitterphoto.com/>3.LifeOfPix<https://www.lifeofpix.com/>4.ImageFinder<https://imagefinder.co/>5.Splitshirewww.splitshire.com6.Foodiesfeed<https://www.foodiesfeed.com/>7.stocksnap<https://stocksnap.io/>8.Pxhere‍<https://pxhere.com/>‍9.Pixabay<https://pixabay.com/>10.Reshot<https://www.reshot.com/>11.OnTap<https://on.thisistap.com/stock-images>12.Magdeleine<https://magdeleine.co/>13.Freeimageswww.freeimages.co.uk14.Brust<https://burst.shopify.com/>15.StyleStock<https://styledstock.co/>16.Gratisography<https://gratisography.com/>17.streetwill<http://streetwill.co/>18.NewOldStock<https://nos.twnsnd.co/>19.Isorepublic<https://isorepublic.com/>20.Resplashed<https://wunderstock.com/>21.FreePhotos.cc<https://freephotos.cc>22.Picography<https://picography.co/>23.Freestocksfreestocks.org24.Jaymantri<https://jaymantri.com/>25.SozaiPage<http://www.sozai-page.com>26.photoAC<https://photo-ac.com/>27.無料写真素材<http://freephoto.bizutart.com>28.Food.foto<https://food.foto.ne.jp>29.modelfoto<https://model-foto.jp/>30.RetroVectors<http://retrovectors.com/category/free-vectors>","Data\\图画\\图画工具.md":"#图画工具##改图鸭[改图鸭](https://www.gaituya.com/?ckt0821)-图片压缩-图片转换-图片转文字-图片改大小-修改分辨率-老照片修复-图片编辑-图片加水印-图片变漫画-图片特效##AI人工智能图片放大[AI人工智能图片放大](https://bigjpg.com/)","Data\\图画\\海报.md":"#海报##模板[创客贴](https://www.chuangkit.com/adlp/haibaolp.html?utm_source=%E7%9F%A5%E4%B9%8E%E5%86%85%E5%AE%B9&utm_medium=&utm_campaign=wz&utm_content=20030360&utm_term=)[Canvas可画](https://www.canva.cn/templates/)-小红书模板","Data\\图画\\画.md":"","Data\\图画\\矢量图.md":"#矢量图##适量半色制作器[VectorHalftoneMaker](https://halftone.xoihazard.com/)","Data\\地图\\index.md":"#地图数据>-[GeoJSONMapsoftheglobe](https://geojson-maps.ash.ms/)>-[地理空间分析工具](https://kepler.gl/)","Data\\多种素材.md":"#多种素材>[DownloadSampleVideos/DummyVideosForDemoUse(sample-videos.com)](https://sample-videos.com/index.php#sample-mp4-video)","Data\\娱乐.md":"#娱乐##视频##表情包>[表情包制作](http://gif.zhiniao.com.cn/content/634.html)##音乐>[音乐专辑下载](https://downloads.khinsider.com/)>[爱给网*音效配乐\\_3D模型*视频素材*游戏素材*免费下载(aigei.com)](https://www.aigei.com/)>>[耳聆网-听见世界之美-(声音分享云|音效素材库)(ear0.com)](https://www.ear0.com/)##乐谱###生日快乐![img](https://iknow-pic.cdn.bcebos.com/f3d3572c11dfa9ecad95962a6fd0f703918fc150?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg)#[卡农钢琴数字简谱-C调初学简单版](https://www.xueqinji.com/2035.html)![卡农钢琴数字简谱-C调初学简单版](https://www.xueqinji.com/wp-content/uploads/2021/04/01j-666x1024.jpg)![卡农钢琴数字简谱-C调初学简单版](https://www.xueqinji.com/wp-content/uploads/2021/04/02j-666x1024.jpg)![卡农钢琴数字简谱-C调初学简单版](https://www.xueqinji.com/wp-content/uploads/2021/04/03j-666x1024.jpg)","Data\\工具.md":"#工具##网页相关-[UserAgent](https://www.ip138.com/useragent/)-[shotcut](https://www.shotcut.org/)剪辑视频-[ipaddress](https://www.ipaddress.com/)##可访问性-[NVAccess](https://www.nvaccess.org/)Windows平台下的屏幕阅读器-[ChromeVoxChromeExtension](https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn)Google出品的Chrome屏幕阅读插件-[axeChromeExtension](https://chrome.google.com/webstore/detail/axe/lhdoppojpmngadmnindnejefpokejbdd)给Chrome开发者工具增加可访问性测试的插件##科学上网>[大机场](https://xn--mesr8b36x.net/#/login)>[快橙](https://content.hmeic.com/preland/binom_directtest?click_id=tXiCLWODWH4&zone_id=12253895813&source=Binom&app=Desktop&trafficSource=ActiveRevenue&platform=Desktop&campaign_name=Zeroclick)##其他-[图片在线转换base64编码-在线base64编码转换成图片工具](http://www.jsons.cn/img2base64/)-[web.dev](https://web.dev/measure/)评测网站性能（基于Lighthouse）-[ShapeDivider](https://www.shapedivider.app/)定制各种形状的网站分区SVG的工具-[GTmetrix](https://gtmetrix.com/)网页性能分析工具-[CanIUse](https://caniuse.com/)前端技术的浏览器支持情况-[Carbon](https://carbon.now.sh/)代码转图片工具-[Wappalyzer](https://www.wappalyzer.com/)检测某个网站使用的技术栈##浏览器插件>[极简插件*Chrome扩展插件商店*优质crx应用(zzzmh.cn)](https://chrome.zzzmh.cn/)##文件转换>[PDF转Word](http://www.pdfdo.com/pdf-to-word.aspx)##工具软件>[下载4k应用|4KDownload](https://www.4kdownload.com/zh-cn/downloads)>[下载视频网站硕鼠](https://www.flvcd.com/index.htm)>[视频下载](https://www.videofk.com/)##软件激活>[jetbrains激活](https://www.macwk.com/article/jetbrains-crack)##梯子>[Clash.for.Windows.7z](https://clo8ud.lanzoui.com/itgf5i2dwxi)><https://xn--mesr8b36x.com/#/login>><https://xn--mesr8b36x.net/#/login>##前端在线编辑工具>-[CodePen](https://codepen.io/trending):在线编辑>-[StackBlitz](https://stackblitz.com/):在线编辑(多语言)>-[兼容性查看](https://www.caniuse.com/?search=console)>-[获取框架包](https://www.bootcdn.cn/)##设计>[切图,UI布局推荐](https://juejin.cn/post/6979821352576352269)","Data\\开发资源.md":"#开发资源##静态资源-[字节跳动静态资源公共库](https://cdn.bytedance.com/)-[阿里巴巴图标库iconfont](https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2)##浏览器版本-[chrome对应版本](https://vikyd.github.io/download-chromium-history-version/#/)##镜像>[清华大学开源软件镜像站|TsinghuaOpenSourceMirror](https://mirrors.tuna.tsinghua.edu.cn/)","Data\\数据.md":"#API##地图数据-[GEOJSON](https://geojson.io/#map=2/0/20)-[aliyunGEOJSON](https://datav.aliyun.com/portal/school/atlas/area_selector)##OMDbOMDbAPI:<http://www.omdbapi.com/?i=tt3896198&apikey=16f467aa>ClickthefollowingURLtoactivateyourkey:<http://www.omdbapi.com/apikey.aspx?VERIFYKEY=3e37538d-046a-48d8-93e2-5fe8f5cd262c>Ifyoudidnotmakethisrequest,pleasedisregardthisemail.##梗百科api:<https://bili.imba97.cn/ji.php?kw>=恶臭##随机图片><https://source.unsplash.com/>>[动态图片](https://dummyimage.com/)>随机不同图片的:<http://placekitten.com/>>>-<http://placekitten.com/300/300>=>获得一张300\\*300的图片##虚拟接口>-[jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users)>-使用指导[JSONPlaceholder-Guide(typicode.com)](http://jsonplaceholder.typicode.com/guide/)>-[DailyForecast16Days-OpenWeatherMap](https://openweathermap.org/forecast16):获取16天的天气>-[OMDbAPI-TheOpenMovieDatabase](https://www.omdbapi.com/)>-[OpenTriviaDB:Freetouse,user-contributedtriviaquestiondatabase.(opentdb.com)](https://opentdb.com/api_config.php)##翻译<http://fanyi.youdao.com/translate?&doctype=json&type=AUTO&i>=计算```json{\"type\":\"ZH_CN2EN\",\"errorCode\":0,\"elapsedTime\":1,\"translateResult\":[[{\"src\":\"计算\",\"tgt\":\"Tocalculate\"}]]}```type的类型有：```ZH_CN2EN中文»英语ZH_CN2JA中文»日语ZH_CN2KR中文»韩语ZH_CN2FR中文»法语ZH_CN2RU中文»俄语ZH_CN2SP中文»西语EN2ZH_CN英语»中文JA2ZH_CN日语»中文KR2ZH_CN韩语»中文FR2ZH_CN法语»中文RU2ZH_CN俄语»中文SP2ZH_CN西语»中文```","Data\\文件\\markdown.md":"#Markdown##图###流程图####横向流程图```mermaidgraphLRA[方形]-->B(圆角)B-->C{条件a}C-->|a=1|D[结果1]C-->|a=2|E[结果2]F[横向流程图]```####竖向流程图```mermaidgraphTDA[方形]-->B(圆角)B-->C{条件a}C-->|a=1|D[结果1]C-->|a=2|E[结果2]F[竖向流程图]```###时序图####标准时序图```mermaid%%时序图例子,->直线，-->虚线，->>实线箭头sequenceDiagramparticipant张三participant李四张三->王五:王五你好吗？loop健康检查王五->王五:与疾病战斗endNoterightof王五:合理食物<br/>看医生...李四-->>张三:很好!王五->李四:你怎么样?李四-->王五:很好!```##数学表达式-需要在TeX或LaTeX格式的数学公式前后添加$$来实现-可以使用数学公式块\"$$\"+回车-快捷键:Ctrl+Shift+m-点击\"段落\"+\"公式块\"-`$2^{2}$`:$2^{2}$$$y(x)=\\begin{cases}\\sqrt\\frac{1}{x},x=0\\\\\\sqrt\\frac{2}{x},x\\neq0\\end{cases}$$|上/下标|x^2,y_2|$x^2,y_2$||--------|--------------------------------------|-----------------------------------------||分式|1/2,\\frac{1}{2}|$1/2$,$\\frac{1}{2}$||省略号|\\cdots|$\\cdots$||开根号|\\sqrt{2}|$\\sqrt{2}$||矢量|\\vec{a}|$\\vec{a}$||积分|\\int{x}dx,\\int\\_{1}^{2}{x}dx|$\\int{x}dx$,$\\int_{1}^{2}{x}dx$||极限|\\lim{a+b},\\lim\\_{n\\rightarrow+\\infty}|$\\lim{a+b}$,$\\lim_{n\\rightarrow+\\infty}$||累加|\\sum{a},\\sum\\_{n=1}^{100}{a_n}|$\\sum{a}$,$\\sum_{n=1}^{100}{a_n}$||累乘|\\prod{x},\\prod\\_{n=1}^{n=99}{x_n}|$\\prod{x}$,$\\prod_{n=1}^{99}{x_n}$||三角函数|\\sin|$\\sin$||对数函数|\\ln2,\\log_2^8,\\lg10|$\\ln2$,$\\log_2^8$,$\\lg10$|###关系运算符|运算符|Markdown||--------|--------||$\\pm$|\\pm||$\\times$|\\times||$\\cdot$|\\cdot||$\\div$|\\div||$\\neq$|\\neq||$\\leq$|\\leq||$\\geq$|\\geq||||###其他特殊字符|符号|Markdown||------------|----------||$\\forall$|\\forall||$\\infty$|\\infty||$\\emptyset$|\\emptyset||$\\exists$|\\exists||$\\nabla$|\\nabla||$\\bot$|\\bot||$\\angle$|\\angle||$\\because$|\\because||$\\therefore$|\\therefore||空格|\\quad||||###希腊字母|大写|Markdown|小写|Markdown||----------|--------|-------------|-----------||$A$|A|$\\alpha$|\\alpha||$B$|B|$\\beta$|\\beta||$\\Gamma$|\\Gamma|$\\gamma$|\\gamma||$\\Delta$|\\Delta|$\\delta$|\\delta||$E$|E|$\\epsilon$|\\epsilon||||$\\varepsilon$|\\varepsilon||$Z$|Z|$\\zeta$|\\zeta||$H$|H|$\\eta$|\\eta||$\\Theta$|\\Theta|$\\theta$|\\theta||$I$|I|$\\iota$|\\iota||$K$|K|$\\kappa$|\\kappa||$\\Lambda$|\\Lambda|$\\lambda$|\\lambda||$M$|M|$\\mu$|\\mu||$N$|N|$\\nu$|\\nu||$\\Xi$|\\Xi|$\\xi$|\\xi||$O$|O|$\\omicron$|\\omicron||$\\Pi$|\\Pi|$\\pi$|\\pi||$P$|P|$\\rho$|\\rho||$\\Sigma$|\\Sigma|$\\sigma$|\\sigma||$T$|T|$\\tau$|\\tau||$\\Upsilon$|\\Upsilon|$\\upsilon$|\\upsilon||$\\Phi$|\\Phi|$\\phi$|\\phi||||$\\varphi$|\\varphi||$X$|X|$\\chi$|\\chi||$\\Psi$|\\Psi|$\\psi$|\\psi||$\\Omega$|\\Omega|$\\omega$|\\omega|","Data\\文件\\pdf.md":"#pdf##工具[Smallpdf](https://smallpdf.com/)","Data\\文本.md":"#文本##字体网站>[100font.com-免版权字体下载、免费商用字体下载网站](https://www.100font.com/)>>[字体下载-求字体网提供中文和英文字体库下载、识别与预览服务，找字体的好帮手(qiuziti.com)](https://www.qiuziti.com/)##常用单词###导航类-导航：nav主导航：mainBav子导航：subBav顶导航：topNav-边导航：sidebar左导航：leftSidebar右导航：rightSidebar菜单：menu-子菜单：submenu标题：title摘要：summary###页面结构-容器：container页头：header内容：content/container页面主体：main-页尾：footer导航：nav侧栏：sidebar栏目：column-页面外围控制整体布局宽度：wrapper左右中：leftrightcenter###功能-标志：logo滚动：scroll广告：banner标签页：tab-登录：login文章列表：list登录条：loginBar提示信息：msg-注册：register当前的：current搜索：search小技巧：tips-功能区：shop图标：icon标题：title注释：note-加入：joinUs指南：guild状态：status服务：service-按钮：btn热点：hot合作伙伴：partner新闻：news-友情链接：friendLink下载：download版权：copyright投票：vote###div英文释译-标题title字体font身体body大小size-列表list文本text样式style对齐align-图像image修饰decoration资源source线line-宽度width穿过through高度height缩进indent-行line斜体italic链接link加粗bold-斜体italic加重weight加粗bold宽width-输入input高height下面的under背景background-顶部top主体main###css英文释译-重复repeat填充padding位置position正常normal-显示类型display父级parent显示可见visibility子级children-隐藏hidden顶部导航topNav显示visible溢出overflow-列表list样式style边框border导航nav-广告图片banner行高line-height边界margin页眉header###样式文件命名-主要的master.css模块module.css基本共用base.css布局，版面layout.css-主题themes.css专栏columns.css文字font.css表单forms.css-补丁mend.css打印print.css###颜色释译-绿green红red蓝blue黑black-灰gray黄yellow紫purple白white-棕brown卡其色khaki###命名参考-登录条loginBar标志：logo侧边栏：sideBar广告：banner-导航：nav子导航：navBar菜单：menu子菜单：subMenu-搜索：search滚动：scroll页面主体：main内容：content-标签页：tab文章列表：list提示信息：msg小技巧：tips-栏目标题：title加入：joins指南：guild服务：service-热点：hot新闻：news按钮：btn投票：vote-状态：status合作伙伴：partner外套：wrap商标：label-顶导航：topNav左导航：leftSideBar右导航：rightSideBar菜单内容：menuContent-菜单容器：menuContainer注释：note边导航图标：sidebarIcon版权：copyright-友情链接：friendLink容器：container页脚：footer当前：current-激活：active购物车：shop登录：login注册：register-下载：download面包屑：breadCrumb","Data\\模型\\资源.md":"#模型资源<https://www.cpengx.cn/1128.html>","Data\\浏览器.md":"#浏览器##一键开启浏览器多线程下载-_Chrome浏览器，地址栏输入并回车：`chrome://flags/#enable-parallel-downloading`_-_Edge新版浏览器，地址栏输入并回车：`edge://flags/#enable-parallel-downloading`_##浏览器插件-[Extfans](https://extfans.com/)","Data\\网页.md":"#网站-[可视化编码]<https://makecode.microbit.org/#editor>","Data\\色彩.md":"#色彩-[MaterialDesignColors](https://www.materialui.co/colors)MaterialDesign色彩-[FlatUIColors2](https://flatuicolors.com/)14组配色、280种颜色-[ColorHunt](https://colorhunt.co/)分享色彩搭配的自由开放平台，包括成千上万人工选取的配色，可以从中获取配色的灵感-[ColorSpace](https://mycolor.space/)配色方案、CSS颜色渐变生成工具-[uiGradients](http://www.uigradients.com/)美观的颜色渐变-[ColorsandFonts](https://colorsandfonts.com/)色彩和字体工具-[Coolors](https://coolors.co/)配色方案生成工具##[中国色](https://www.bilibili.com/video/BV1C8411F7ja/?spm_id_from=444.41.top_right_bar_window_default_collection.content.click&vd_source=880fb5bb8d91c4fa75a3e13e1cf5579f)<https://zhuanlan.zhihu.com/p/440822598><http://zhongguose.com/#gudinghui>|名称|rgb|||:-----|:---------------|:------||凌霄|rgb(233,112,64)|#E97040||十样锦|rgb(248,198,181)|#F8C6B5||丹枫|rgb(216,25,24)|#D81918||金红|rgb(238,120,31)|#EE781F||雄黄|rgb(243,153,58)|#F3993A||黄粱|rgb(233,187,65)|#E9BB41||黄琉璃|rgb(229,158,75)|#E5A84B||桔黄|rgb(244,207,57)|#F4CF39||泥金|rgb(200,160,98)|#C8A062||欧碧|rgb(216,230,153)|#D8E699||四绿|rgb(107,179,146)|#6BB392||绿茶|rgb(145,184,33)|#91B821||品月|rgb(60,118,153)|#3C7699||松石|rgb(117,193,196)|#75C1C4||紫茄|rgb(73,33,74)|#49214A||卵色天|rgb(200,216,225)|#C8D8E1||玉色|rgb(248,247,240)|#F8F7F0||皓白|rgb(245,238,240)|#EBEEF0||月白|rgb(212,229,239)|#D4E5EF||碧落|rgb(174,208,237)|#AED0ED||东方亮|rgb(245,251,254)|#F5FBFE|","Data\\虚拟号码.md":"#虚拟号码>[超级云短信-在线短信接收-ReceiveSMS(bfkdim.com)](http://www.bfkdim.com/)>>[Human-machinesafetyverification(receive-sms-free.cc)](https://receive-sms-free.cc/)>>[免费在线收短信|临时手机号码(freesms-online.com)](https://freesms-online.com/zh)","Data\\视频.md":"#视频##视频制作&修改>[Shotcup剪辑视频工具](https://www.shotcut.org/)##通过台词找影片>[33台词-通过台词找影片素材(agilestudio.cn)](http://33.agilestudio.cn/)##测试资源```http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4``````http://vjs.zencdn.net/v/oceans.mp4``````https://media.w3.org/2010/05/sintel/trailer.mp4``````http://mirror.aarnet.edu.au/pub/TED-talks/911Mothers_2010W-480p.mp4``````http://vfx.mtime.cn/Video/2019/02/04/mp4/190204084208765161.mp4``````http://vfx.mtime.cn/Video/2019/03/21/mp4/190321153853126488.mp4``````http://vfx.mtime.cn/Video/2019/03/19/mp4/190319222227698228.mp4``````http://vfx.mtime.cn/Video/2019/03/19/mp4/190319212559089721.mp4``````http://vfx.mtime.cn/Video/2019/03/18/mp4/190318231014076505.mp4``````http://vfx.mtime.cn/Video/2019/03/18/mp4/190318214226685784.mp4``````http://vfx.mtime.cn/Video/2019/03/19/mp4/190319104618910544.mp4``````http://vfx.mtime.cn/Video/2019/03/19/mp4/190319125415785691.mp4``````http://vfx.mtime.cn/Video/2019/03/17/mp4/190317150237409904.mp4``````http://vfx.mtime.cn/Video/2019/03/14/mp4/190314223540373995.mp4``````http://vfx.mtime.cn/Video/2019/03/14/mp4/190314102306987969.mp4``````http://vfx.mtime.cn/Video/2019/03/13/mp4/190313094901111138.mp4``````http://vfx.mtime.cn/Video/2019/03/12/mp4/190312143927981075.mp4``````http://vfx.mtime.cn/Video/2019/03/12/mp4/190312083533415853.mp4``````http://vfx.mtime.cn/Video/2019/03/09/mp4/190309153658147087.mp4```","Data\\课程.md":"#课程##libpku<https://lib-pku.github.io/>多门课程##北大<https://github.com/tongtzeho/PKUCourse>北京大学信息学院计算机系本科&研究生课程大作业选集计算概论（2011秋大一上）：神奇翻转程序设计实习（2012春大一下）：OpenJudge魔兽世界、Botzone四色地图计算机系统导论（2012秋大二上）：ProxyLab数据结构与算法实习（2012秋大二上）：电梯模拟器、连连看、miniSQLJava程序设计（2013春大二下）：网络爬虫微机实验（2013春大二下）：双面贪吃蛇计算机组织与体系结构（2013秋大三上）：指令级模拟及高级缓存模拟高级编译技术（2015秋研一上）：三地址码到C代码翻译器及编译优化分布式系统概念与设计（2016春研一下）：分布式PageRank##清华<https://github.com/PKUanonym/REKCARC-TSC-UHT>##浙大<https://link.zhihu.com/?target=https%3A//github.com/QSCTech/zju-icicles>##中国科学技术大学<https://link.zhihu.com/?target=https%3A//github.com/USTC-Resource/USTC-Course><https://ustc-resource.github.io/USTC-Course/>##中山大学<https://github.com/sysuexam/SYSU-Exam>##Bilibili<https://github.com/elder-frog/OpenCourseCatalog><https://space.bilibili.com/12721139>","Data\\软件.md":"#软件-[破解软件](https://foxirj.com/)-uTools：工具合集-autohotKey：自定义快捷键(热键等)-deskpins：屏幕置顶-potplayer：播放器-7z：压缩工具-QTTabBar：文件资源增强器-Snipaste：截图工具-[PowerToys](https://github.com/microsoft/PowerToys/releases/)-[MousewithoutBorders](https://www.microsoft.com/en-us/download/confirmation.aspx?id=35460):一套键鼠控制多个windows电脑-[搜狗输入法(精简版)](https://pan.lanzoui.com/b0afxqmwj)##软件站-[果核](https://www.ghxi.com/)","Data\\镜像.md":"#镜像>[清华大学开源软件镜像站|TsinghuaOpenSourceMirror](https://mirrors.tuna.tsinghua.edu.cn/)","Front-End\\Bug\\Antd DatePicker 设置默认值报 clone.weekday is not a function.md":"#AntdDatePicker设置默认值报`clone.weekdayisnotafunction`-`antd`:`^5.16.2`-`dayjs`:`^1.11.10`解决:```jsimportdayjsfrom'dayjs'importadvancedFormatfrom'dayjs/plugin/advancedFormat'importlocaleDatafrom'dayjs/plugin/localeData'importweekdayfrom'dayjs/plugin/weekday'importweekOfYearfrom'dayjs/plugin/weekOfYear'importweekYearfrom'dayjs/plugin/weekYear'dayjs.extend(advancedFormat)dayjs.extend(localeData)dayjs.extend(weekday)dayjs.extend(weekOfYear)dayjs.extend(weekYear)```","Front-End\\Bug\\grid 列布局比例失衡.md":"#[`grid列布局比例失衡`](/)-原因还不清楚```cssgrid-template-columns:1fr1fr1fr;//缩放会有比例失衡问题//改为grid-template-columns:repeat(3,minmax(20vw,1fr));```","Front-End\\Bug\\index.md":"#[`Bug`](/)##positionsticky失效>在Iphone6plus上使用positionsticky不生效解决办法：```cssposition:sticky;position:-webkit-sticky;//兼容写法需要写在下面```##`newDate().toLocaleDateString()`获取当前的日期字符串无效>当系统语言是新加坡英语的时候，使用这个方法获取当前的日期字符串会出现InvalidDate，toLocaleDateString是有两个参数的，不指定语言就会出现这个问题，而且只在手机上出现，不太好排查，newDate().toLocaleDateString('en-Us')调用的时候指定语言就没问题了；##两行溢出显示省略号但是部分手机上出现第三行截断痕迹![](./.assets/index-2025-04-10-15-26-37.png)>例如设置了高度为36px，line-height18px，但是出现了第三行截断痕迹，应该是文字baseline的对其方式问题，试着设置vertical-align也不行。解决办法就是不给文字的盒子设置高度，如果一定要个高度兜底，可以在文字的盒子再套一个盒子，在套的那个盒子设置高度。##泰文字体文本溢出隐藏，但是第二行出现截断痕迹原因，应该是泰语的字体行高要求比较高，暂时的解决办法：加高文本行高##useEffect首次获取dom的clientHeight不对初步感觉是因为css样式加载慢了，导致第一次获取到的高度是没有样式的高度，而且又是偶现的；所以在这个组件或者hooks重新render的时候去获取高度，如果获取到最新的高度发生变化，去同步修改state保存的高度。```jsximport{useEffect,useState}from'react'exportdefaultfunctionuseTop(){const[top,setTop]=useState(0)const[bodyHeight,setBodyHeight]=useState(document.body.clientHeight)constnewestTop=(document.getElementById('nav-header')?.clientHeight||0)-1if(newestTop!==top){//navheaderheightmaychangesetTop(newestTop)setBodyHeight(document.body.clientHeight-(newestTop+1))}useEffect(()=>{constnav=document.getElementById('nav-header')constnavHeight=nav?.clientHeight??0setTop(navHeight-1)setBodyHeight(document.body.clientHeight-navHeight)},[])return{top,bodyHeight}}```##一个页面中有两个滚动条，两个滚动条几乎同时触发滚动条的滚动方法,后执行的不生效>两个滚动条，一个使用scrollBy方法，另一个使用scrollIntoView方法，behavior属性都为smooth，这个属性会让滚动条平滑移动，导致滚动条事件一直在触发状态，另一个滚动方法就执行不了了。解决方法：让先执行的方法behavior属性为auto；或者在第一个滚动条结束之后再执行第二个滚动条的方法，可以让第二个方法setTimeout100ms左右，不能超过300ms，否则用户会感觉卡顿。##iphone6手机上横向或者纵向滑动不了>原因，可能是dom结构问题，导致低端ios机型没有识别到生成滚动条，导致不能滚动，android和其他ios机型正常；```html<divclassName=\"list-tabs-wrap\"><divclassName=\"list-tabs\"><divclassName=\"tab-item\">tab1</div><divclassName=\"tab-item\">tab2</div><divclassName=\"tab-item\">tab3</div></div></div>``````css.list-tabs-wrap{width:100%;background-color:#fff;overflow:hidden;}.list-tabs{overflow-x:scroll;overflow-y:hidden;-webkit-overflow-scrolling:touch;display:flex;flex-direction:row;flex-wrap:nowrap;height:50px;background-color:#fff;}.list-tabs::-webkit-scrollbar{display:none;background-color:transparent;color:transparent;width:0;height:0;}.tab-item{width:50vw;}```>解决办法，新增一个container结构，containerdom宽度为max-content，overflow拆开写```html<divclassName=\"list-tabs-wrap\"><divclassName=\"list-tabs\"><divclassName=\"list-tabs-container\"><divclassName=\"tab-item\">tab1</div><divclassName=\"tab-item\">tab2</div><divclassName=\"tab-item\">tab3</div></div></div></div>``````css.list-tabs-container{overflow-x:scroll;//overflow拆开写overflow-y:hidden;-webkit-overflow-scrolling:touch;width:max-content;//纵向设置height}```>用上面方法解决iPhone6滚动条问题后，又出现一个滚动条隐藏样式不生效的问题；解决办法，设置一个外层的盒子，固定高度然后overflow:hidden，需要滚动的盒子加一个padding-bottom:10px，padding大小看着改，能放下一个滚动条就可以，这样滚动条会出现在padding里，然后又因为外层盒子overflow:hidden了，所以滚动条和padding都看不到了；愿世界再无iphone6.##在Androidwebview中，window.location.reload和replace失效```jsconstreload=()=>{consttimeStamp=newDate().getTime()constoldUrl=window.location.hrefconsturl=`${oldUrl}${oldUrl.includes('?')?'&':'?'}timeStamp=${timeStamp}`window.location.href=url}constlocationReplace=(url)=>{if(history.replaceState){history.replaceState(null,document.title,url)history.go(0)}else{location.replace(url)}}```##部分安卓手机把请求参数的字符串中间的空格转义成+号>发现在谷歌Pixel3XL手机上，会把请求参数的字符串中间的空格转义成+号，比如'[{\"filterField\":\"accommodationType\",\"value\":\"Hotel,Entireapartment\"}]'=>'[{\"filterField\":\"accommodationType\",\"value\":\"Hotel,Entire+apartment\"}]'。调试了下，发现在发起请求前参数打印是正常的，是浏览器在请求的时候在请求体中字段转义的。不过好像对后端的搜索结果并不影响，所以这里就没有改动。>解决办法，对字符串encode下，后端收到参数后再decode。##ios17input聚焦页面出现抖动>解决办法：inputfocus给body添加height:100vh;overflow:hidden;样式。inputblur取消focus添加的样式。","Front-End\\Bug\\ios 17 input 聚焦页面出现抖动.md":"#[`ios17input聚焦页面出现抖动`](/)-解决办法：inputfocus给body添加height:100vh;overflow:hidden;样式。inputblur取消focus添加的样式。","Front-End\\Bug\\new Date().toLocaleDateString() 获取当前的日期字符串无效.md":"#[`newDate().toLocaleDateString()获取当前的日期字符串无效`](/)-当系统语言是新加坡英语的时候，使用这个方法获取当前的日期字符串会出现InvalidDate，toLocaleDateString是有两个参数的，不指定语言就会出现这个问题，而且只在手机上出现，不太好排查，newDate().toLocaleDateString('en-Us')调用的时候指定语言就没问题了；","Front-End\\Bug\\npm错误.md":"#npm错误##npmWARNbuild`npmbuild`calledwithnoarguments.Didyoumeanto`npmrun-scriptbuild`>把指令`npmrun`换成`npmrunbuild`##执行npm命令时报错：Allocationfailed-JavaScriptheapoutofmemory法一：添加参数--max_old_space_size=4096npmrunstart--max_old_space_size=4096法二：修改cmd文件在目录node_modules/.bin下打开ng.cmd和ngc.cmd文件，添加--max_old_space_size=4096![img](https://img-blog.csdnimg.cn/20201030160512476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODg4MzMzOA==,size_16,color_FFFFFF,t_70)","Front-End\\Bug\\position sticky 失效.md":"#positionsticky失效-在Iphone6plus上使用positionsticky不生效解决：```jsposition:stickyposition:-webkit-sticky//兼容写法需要写在下面```","Front-End\\Bug\\sockjs-node.md":"#<http://localhost:8080/sockjs-node/info?t=1556418283950>net::ERR_CONNECTION_REFUSED>sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟、全双工的浏览器和web服务器之间通信通道。>>服务端：sockjs-node（<https://github.com/sockjs/soc>…）>客户端：sockjs-client（<https://github.com/sockjs/soc>…）>>开发时，如果变更网络环境（如切换wifi导致开发服务器的IP地址更换），服务器不知道如何确定访问源，就有可能造成上述情况##方法一>找到/node_modules/sockjs-client/dist/sockjs.js>找到代码的1605行>self.xhr.send(payload);>>可在代码开发完成后关闭，会同步关闭热加载##方法二>/package-lock.json>关闭开发环境时的sockjs接口>dev设置为false","Front-End\\Bug\\useEffect 首次获取 dom 的 clientHeight 不对.md":"#[`useEffect首次获取dom的clientHeight不对`](/)-初步感觉是因为css样式加载慢了，导致第一次获取到的高度是没有样式的高度，而且又是偶现的；所以在这个组件或者hooks重新render的时候去获取高度，如果获取到最新的高度发生变化，去同步修改state保存的高度。```jsimport{useEffect,useState}from'react'exportdefaultfunctionuseTop(){const[top,setTop]=useState(0)const[bodyHeight,setBodyHeight]=useState(document.body.clientHeight)constnewestTop=(document.getElementById('nav-header')?.clientHeight||0)-1if(newestTop!==top){//navheaderheightmaychangesetTop(newestTop)setBodyHeight(document.body.clientHeight-(newestTop+1))}useEffect(()=>{constnav=document.getElementById('nav-header')constnavHeight=nav?.clientHeight??0setTop(navHeight-1)setBodyHeight(document.body.clientHeight-navHeight)},[])return{top,bodyHeight}}```","Front-End\\Bug\\在 Android webview 中，window.location.reload 和 replace 失效.md":"#[`在Androidwebview中，window.location.reload和replace失效`](/)```jsconstreload=()=>{consttimeStamp=newDate().getTime()constoldUrl=window.location.hrefconsturl=`${oldUrl}${oldUrl.includes('?')?'&':'?'}timeStamp=${timeStamp}`window.location.href=url}constlocationReplace=(url)=>{if(history.replaceState){history.replaceState(null,document.title,url)history.go(0)}else{location.replace(url)}}```","Front-End\\Node\\error\\Node.js中使用ES6报错.md":"#[`Node.js中使用ES6报错`](/)背景index.js：```jsimporthellofrom'./cpoy'hello()```cpoy/index.js：```jsconsthello=()=>{console.log('helloworld!')}exportdefaulthello```-在package.json中添加了\"type\":\"module\"配置。报错`DirectoryimportxxxxisnotsupportedresolvingESmodulesimportedfromxxxx`解决正确导入方式为`importhellofrom'./cpoy'/index.js`，而不是`importhellofrom'./cpoy'；`不要忘了`.js`。","Front-End\\Node\\exe.md":"Node.js从**v20.0.0**开始，实验性支持**SingleExecutableApplications(SEA)**，允许你将Node.js应用程序打包成一个独立的可执行文件（如`.exe`或二进制文件），无需依赖外部的Node.js运行时环境。以下是使用Node.jsSEA功能的详细步骤：---###1.确认Node.js版本确保你的Node.js版本是**v20.0.0**或更高版本。可以通过以下命令检查版本：```bashnode-v```如果版本低于v20.0.0，请升级Node.js：-使用[nvm](https://github.com/nvm-sh/nvm)（推荐）：```bashnvminstall20nvmuse20```-或者从[Node.js官网](https://nodejs.org/)下载最新版本。---###2.创建Node.js项目假设你有一个简单的Node.js项目，结构如下：```my-app/├──index.js└──package.json```-**`index.js`**：```javascriptconsole.log('Hello,SingleExecutableApplication!');```-**`package.json`**：```json{\"name\":\"my-app\",\"version\":\"1.0.0\",\"main\":\"index.js\"}```---###3.生成SEA配置文件Node.jsSEA需要一个配置文件来指定入口文件和打包选项。运行以下命令生成配置文件：```bashnode--experimental-sea-configsea-config.json```-这会生成一个`sea-config.json`文件，内容如下：```json{\"main\":\"index.js\",\"output\":\"sea-prep.blob\"}```---###4.准备SEABlob文件运行以下命令，将你的Node.js代码打包成一个`.blob`文件：```bashnode--experimental-sea-configsea-config.json```-这会生成一个`sea-prep.blob`文件，其中包含了你的应用程序代码和必要的元数据。---###5.创建可执行文件接下来，将`sea-prep.blob`文件嵌入到一个Node.js二进制文件中，生成独立的可执行文件。####对于Windows1.下载Node.js的Windows二进制文件（如`node.exe`）。2.使用以下命令将`sea-prep.blob`嵌入到`node.exe`中：```bashnpxpostjectnode.exeNODE_SEA_BLOBsea-prep.blob--sentinel-fuseNODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2```3.重命名生成的可执行文件：```bashmvnode.exemy-app.exe```####对于macOS/Linux1.下载Node.js的macOS/Linux二进制文件（如`node`）。2.使用以下命令将`sea-prep.blob`嵌入到`node`中：```bashnpxpostjectnodeNODE_SEA_BLOBsea-prep.blob--sentinel-fuseNODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2```3.重命名生成的可执行文件：```bashmvnodemy-app```---###6.运行可执行文件现在，你可以直接运行生成的可执行文件，无需安装Node.js：-**Windows**：```bash./my-app.exe```-**macOS/Linux**：```bash./my-app```输出：```Hello,SingleExecutableApplication!```---###7.高级配置####打包静态资源如果你的项目包含静态资源（如HTML、CSS、图片等），可以将这些资源一起打包到`.blob`文件中。在`sea-config.json`中指定资源路径：```json{\"main\":\"index.js\",\"output\":\"sea-prep.blob\",\"resources\":[\"public/**/*\"]}```####压缩可执行文件可以使用工具（如`upx`）进一步压缩生成的可执行文件：```bashupxmy-app.exe```---###8.注意事项-**实验性功能**：Node.jsSEA目前是实验性功能，未来可能会有变化。-**平台支持**：SEA目前支持Windows、macOS和Linux。-**文件大小**：生成的可执行文件会包含Node.js运行时，因此文件体积较大。---###9.示例项目结构```my-app/├──index.js├──package.json├──sea-config.json├──sea-prep.blob└──my-app.exe(或my-app)```---###总结-Node.js的SingleExecutableApplications(SEA)功能允许你将应用程序打包成独立的可执行文件。-通过生成`.blob`文件并将其嵌入到Node.js二进制文件中，可以创建无需外部依赖的可执行文件。-该功能目前是实验性的，适合测试和小型项目。希望这些步骤能帮助你成功打包Node.js应用程序！","Front-End\\Node\\git.md":"#git<https://git-scm.com/docs/pretty-formats>首先肯用到的node的核心模块，不再多说了，具体使用方法可以看一下node.js官网。```jsconstexec=require('child_process').exec//异步子进程constexecSync=require('child_process').execSync//同步子进程constfs=require('fs')//文件读取模块```如果version.txt存在的话，将先读取里边的版本信息```jsif(fs.existsSync(versionPath)){versionStr=fs.readFileSync(versionPath).toString()+'\\n'}```根据版本信息是已存在commit，进行不同处理```jsif(versionStr.indexOf(commit)!=-1){console.warn('\\x1B[33m%s\\x1b[0m','warming:当前的git版本数据已经存在了!\\n')}else{letname=execSync('gitshow-s--format=%cn').toString().trim()//姓名letemail=execSync('gitshow-s--format=%ce').toString().trim()//邮箱letdate=newDate(execSync('gitshow-s--format=%cd').toString())//日期letmessage=execSync('gitshow-s--format=%s').toString().trim()//说明versionStr=`git:${commit}\\n作者:${name}<${email}>\\n日期:${date.getFullYear()+'-'+(date.getMonth()+1)+'-'+date.getDate()+''+date.getHours()+':'+date.getMinutes()}\\n说明:${message}\\n${newArray(80).join('*')}\\n${versionStr}`fs.writeFileSync(versionPath,versionStr)//写入版本信息之后，自动将版本信息提交到当前分支的git上if(autoPush){execSync(`gitcommit${versionPath}-m自动提交版本信息`)execSync(`gitpushorigin${execSync('gitrev-parse--abbrev-refHEAD').toString().trim()}`,)}}```附上获取git指定信息方法（<https://git-scm.com/docs/pretty-formats>）```sh%H:commithash%h:缩短的commithash%T:treehash%t:缩短的treehash%P:parenthashes%p:缩短的parenthashes%an:作者名字%aN:mailmap的作者名字(.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))%ae:作者邮箱%aE:作者邮箱(.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))%ad:日期(--date=制定的格式)%aD:日期,RFC2822格式%ar:日期,相对格式(1dayago)%at:日期,UNIXtimestamp%ai:日期,ISO8601格式%cn:提交者名字%cN:提交者名字(.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))%ce:提交者email%cE:提交者email(.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))%cd:提交日期(--date=制定的格式)%cD:提交日期,RFC2822格式%cr:提交日期,相对格式(1dayago)%ct:提交日期,UNIXtimestamp%ci:提交日期,ISO8601格式%d:ref名称%e:encoding%s:commit信息标题%f:sanitizedsubjectline,suitableforafilename%b:commit信息内容%N:commitnotes%gD:reflogselector,e.g.,refs/stash@{1}%gd:shortenedreflogselector,e.g.,stash@{1}%gs:reflogsubject%Cred:切换到红色%Cgreen:切换到绿色%Cblue:切换到蓝色%Creset:重设颜色%C(...):制定颜色,asdescribedincolor.branch.*configoption%m:left,rightorboundarymark%n:换行%%:araw%%x00:printabytefromahexcode%w([[,[,]]]):switchlinewrapping,likethe-woptionofgit-shortlog(1).```将version文件移植到打包文件中```jsif(fs.existsSync(buildPath)){fs.writeFileSync(`${buildPath}/${versionPath}`,fs.readFileSync(versionPath))}```程序运行后，打印一个字母图案（显得高大上一些），附上一个可以根据输入的字母生成打印的字体的网站（<http://patorjk.com/software/taag/#p=testall&v=2&f=Graffiti&t=PERSAGY>）```js//打包成功并且版本信息写入成功console.info(['██████╗███████╗██████╗███████╗█████╗██████╗██╗██╗','██╔══██╗██╔════╝██╔══██╗██╔════╝██╔══██╗██╔════╝╚██╗██╔╝','██████╔╝█████╗██████╔╝███████╗███████║██║███╗╚████╔╝','██╔═══╝██╔══╝██╔══██╗╚════██║██╔══██║██║██║╚██╔╝','██║███████╗██║██║███████║██║██║╚██████╔╝██║','╚═╝╚══════╝╚═╝╚═╝╚══════╝╚═╝╚═╝╚═════╝╚═╝',].join('\\n'),)```通过node执行该代码之后，就可以得到预期效果了。默认打印的颜色是白色，如果想根据成功失败警告打印不同的颜色的话，也可以加上对应的状态色彩哦。```jsconsole.log('\\x1B[36m%s\\x1B[0m',info)//cyanconsole.log('\\x1B[33m%s\\x1b[0m:',path)//yellowvarstyles={bold:['\\x1B[1m','\\x1B[22m'],italic:['\\x1B[3m','\\x1B[23m'],underline:['\\x1B[4m','\\x1B[24m'],inverse:['\\x1B[7m','\\x1B[27m'],strikethrough:['\\x1B[9m','\\x1B[29m'],white:['\\x1B[37m','\\x1B[39m'],grey:['\\x1B[90m','\\x1B[39m'],black:['\\x1B[30m','\\x1B[39m'],blue:['\\x1B[34m','\\x1B[39m'],cyan:['\\x1B[36m','\\x1B[39m'],green:['\\x1B[32m','\\x1B[39m'],magenta:['\\x1B[35m','\\x1B[39m'],red:['\\x1B[31m','\\x1B[39m'],yellow:['\\x1B[33m','\\x1B[39m'],whiteBG:['\\x1B[47m','\\x1B[49m'],greyBG:['\\x1B[49;5;8m','\\x1B[49m'],blackBG:['\\x1B[40m','\\x1B[49m'],blueBG:['\\x1B[44m','\\x1B[49m'],cyanBG:['\\x1B[46m','\\x1B[49m'],greenBG:['\\x1B[42m','\\x1B[49m'],magentaBG:['\\x1B[45m','\\x1B[49m'],redBG:['\\x1B[41m','\\x1B[49m'],yellowBG:['\\x1B[43m','\\x1B[49m'],}```在package.json里的打包命令上加上执行该程序，（&&为同步执行，&为异步执行）```js\"scripts\":{\"build\":\"vue-cli-servicebuild--modeproduction--destdist&&nodeversion.js\",},```打包之后version.txt效果：","Front-End\\Node\\中台\\egg.md":"#Egg>[官网](https://eggjs.org/zh-cn/intro/quickstart.html)##特性-提供基于Egg[定制上层框架](https://eggjs.org/zh-cn/advanced/framework.html)的能力-高度可扩展的[插件机制](https://eggjs.org/zh-cn/basics/plugin.html)-内置[多进程管理](https://eggjs.org/zh-cn/advanced/cluster-client.html)-基于[Koa](http://koajs.com/)开发，性能优异-框架稳定，测试覆盖率高-[渐进式开发](https://eggjs.org/zh-cn/tutorials/progressive.html)##环境搭建```basic$mkdiregg-example&&cdegg-example$npminitegg--type=simple$npmi#启动$npmrundev$openhttp://localhost:7001```","Front-End\\Node\\中台\\express.md":"#Express##安装###直接安装`cnpminstallexpress--save`###脚手架安装####使用express-generator安装使用命令行进入项目目录，依次执行：```cnpmiexpress-generator```可通过express-h查看命令行的指令含义```express-h``````Usage:express[options][dir]``````basicOptions:--version输出版本号-e,--ejs添加对ejs模板引擎的支持--pug添加对pug模板引擎的支持--hbs添加对handlebars模板引擎的支持-H,--hogan添加对hogan.js模板引擎的支持-v,--view<engine>添加对视图引擎（view）<engine>的支持(ejs|hbs|hjs|jade|pug|twig|vash)（默认是jade模板引擎）--no-view创建不带视图引擎的项目-c,--css<engine>添加样式表引擎<engine>的支持(less|stylus|compass|sass)（默认是普通的css文件）--git添加.gitignore-f,--force强制在非空目录下创建-h,--help输出使用方法```创建了一个名为myapp的Express应用，并使用ejs模板引擎```express--view=ejsapp```进入app，并安装依赖```cdmyappnpminstall```**在Windows下，使用以下命令启Express应用：**```setDEBUG=app:*&npmstart```**在MacOS或Linux下，使用以下命令启Express应用：**```DEBUG=app:*npmstart```##第一个Express应用```jsconstexpress=require('express')//引入express模块varapp=express()//express()是express模块顶级函数app.get('/',function(req,res){//访问根路径时输出helloworldres.send(`<h1style='color:blue'>helloworld</h1>`)})app.listen(8080)//设置访问端口号```##get请求一般在网站开发中，get都用作数据获取和查询，类似于数据库中的查询操作，当服务器解析前台资源后即传输相应内容；而查询字符串是在URL上进行的，形如：```jshttp://localhost:8080/login?goods1=0001&goods2=0002```###二、获取前台get请求通过req.query可以获得用户发送的get请求，之后通过node操作将相应数据返回给用户。如果发送的是：```jshttp://localhost:8080/login?goods1=0001&goods2=0002```响应的话则通过：```jsreq.query```他会获取到全部数据，或```jsreq.query.goods1//0001req.query.goods2//0002```来单独或去每一个数据。总之不同的需求对应不同的业务，大家按自己的需要来获取；###三、实例下面通过一个实例来对获取get参数进行一个总结：HTML:```html<formaction=\"http://localhost:8080/login\"method=\"get\">用户：<inputtype=\"text\"name=\"user\"id=\"user\"placeholder=\"用户名\"/><br/>密码：<inputtype=\"password\"name=\"password\"id=\"password\"placeholder=\"密码\"/><br/><inputtype=\"submit\"value=\"提交\"/></form>```NODE:```javascriptconstexpress=require('express')varapp=express()app.get('/',function(req,res){res.send('主页')})app.get('/login',function(req,res){console.log(req.query)res.send('登录路由，user为：'+req.query.user+'==>password为：'+req.query.password,)})app.listen(8080)```当在html页面中输入用户和密码提交后：就能得到想要的传输数据；总之，虽然获取get参数并不复杂，但使用频率却相当的高，对于任何技术我们都应该秉持认真的态度去了解和学习它。##POST请求post方法作为http请求很重要的一部分，几乎所有的网站都有用到它，与get不同，post请求更像是在服务器上做修改操作，它一般用于数据资源的更新。相比于get请求，post所请求的数据会更加安全。上一章中我们发现get请求会在地址栏显示输入的用户名和密码(有中文时会转化为BASE64加密)，而post请求则会将数据放入http包的包体中，这使得别人无法直接看到用户名和密码！###二、Express如何设置POST请求1.我们的知道，首先我们得知道在form表单进行post请求，enctype属性一般设置为“application/x-www-form-urlencoded”，如果设置成multipart/form-data，则多用于文件上传，如下：```html<formaction=\"#\"method=\"post\"enctype=\"application/x-www-form-urlencoded\"></form>```2设置解析body中间件```jsapp.use(express.urlencoded())```3获取body数据```javascriptreq.body.username```登陆案例：HTML:```html<h1>登陆</h1><formaction=\"/login\"method=\"POST\"><div>用户名：<inputtype=\"text\"name=\"username\"/></div><div>密码：<inputtype=\"password\"name=\"password\"/></div><button>登陆</button></form>```APP.JS```javascriptvarexpress=require('express')varpath=require('path')varapp=express()varsqlQuery=require('./lcMysql')//viewenginesetupapp.set('views',path.join(__dirname,'views'))app.set('viewengine','ejs')app.use(express.static(path.join(__dirname,'public')))//解析post提交的数据app.use(express.urlencoded())//搜索首页app.get('/',(req,res)=>{res.render('index.ejs')})//登陆页app.get('/login',(req,res)=>{res.render('login')})//处理登陆请求app.post('/login',async(req,res)=>{//获取用户名和密码letusername=req.body.usernameletpassword=req.body.password//查询数据库是否由此用户名和密码letsqlStr='select*fromuserwhereusername=?andpassword=?'letarr=[username,password]letresult=awaitsqlQuery(sqlStr,arr)if(result.length==0){res.send('登陆失败')}else{res.send('登陆成功')}})module.exports=app```##中间件>从字面意思，我们可以了解到它大概就是做中间代理操作，事实也是如此；大多数情况下，中间件就是在做接收到请求和发送响应中间的一系列操作。事实上，express是一个路由和中间件的web框架，Express应用程序基本上是一系列中间件函数的调用。1.浏览器发送请求2.express接受请求中间处理的过程3.路由函数处理渲染（req,res）4.res.render渲染中间件函数可以执行以下任务：-执行任何代码。-对请求和响应对象进行更改。-结束请求/响应循环。-调用堆栈中的下一个中间件函数。中间件也分为应用层中间件、路由中间件、内置中间件、错误处理中间件和第三方中间件。下面分别对以下进行说明：###1.应用层中间件应用级中间键绑定到app对象使用app.use和app.METHOD()-需要处理http请求的方法，例如GET、PUT、POST，将之前的get或者post替换为use就行。例如下面实例：```javascriptconstexpress=require(\"express\");varapp=express();//匹配路由之前的操作app.use(function(req,res,next()){console.log(\"访问之前\");});app.get(\"/\",function(req,res){res.send(\"主页\");});app.listen(8080);```这时我们会发现<http://localhost:8080/地址一直在加载，但命令行里显示了“访问之前”，说明程序并不会同步执行，如果使用next>来是路由继续向下匹配，那么就能又得到主页数据了：```jsconstexpress=require('express')varapp=express()//匹配路由之前的操作app.use(function(req,res,next){console.log('访问之前')next()})app.get('/',function(req,res){res.send('主页')})app.listen(8080)```当然也可以简化写法：```jsconstexpress=require('express')varapp=express()app.use(function(req,res,next){console.log('访问之前')next()},function(req,res){res.send('主页')},)app.listen(8080)```因此，在进行路由匹配之前或再录又要继续向下执行时想做个操作，那么应用层中间件无疑是好的选择。###2.路由中间件路由级中间件和应用级中间件类似，只不过他需要绑定express.Router();```jsvarrouter=express.Router()```在匹配路由时，我们使用router.use()或router.VERB(),路由中间件结合多次callback可用于用户登录及用户状态检测。```jsconstexpress=require('express')varapp=express()varrouter=express.Router()router.use('/',function(req,res,next){console.log('匹配前')next()})router.use('/user',function(req,res,next){console.log('匹配地址：',req.originalUrl)next()},function(req,res){res.send('用户登录')},)app.use('/',router)app.listen(8080)```总之在检测用户登录和引导用户应该访问哪个页面是，路由中间件绝对好用。###3.错误处理中间件顾名思义，它是指当我们匹配不到路由时所执行的操作。错误处理中间件和其他中间件基本一样，只不过其需要开发者提供4个自变量参数。```jsapp.use((err,req,res,next)=>{res.sendStatus(err.httpStatusCode).json(err)})```一般情况下，我们把错误处理放在最下面，这样我们即可对错误进行集中处理。```jsconstexpress=require('express')varapp=express()app.get('/',function(req,res,next){consterr=newError('NotFound')res.send('主页')next(err)})app.use('/user',function(err,req,res,next){console.log('用户登录')next(err)},function(req,res,next){res.send('用户登录')next()},)app.use(function(req,res){res.status(404).send('未找到指定页面')})app.listen(8080)```###4.内置中间件从版本4.x开始，Express不再依赖Content，也就是说Express以前的内置中间件作为单独模块，express.static是Express的唯一内置中间件。```jsexpress.static(root,[options])```通过express.static我们可以指定要加载的静态资源。###5.第三方中间件形如之前我们的body-parser，采用引入外部模块的方式来获得更多的应用操作。如后期的cookie和session。```jsvarexpress=require('express')varapp=express()varcookieParser=require('cookie-parser')```以上就是关于express中间件类型，在实际项目中，中间件都是必不可少的，因此熟悉使用各种中间件会加快项目的开发效率。##Cookie###关于Cookie在我们关闭一个登录过的网址并重新打开它后，我们的登录信息依然没有丢失；当我们浏览了商品后历史记录里出现了我们点击过的商品；当我们推回到首页后，推荐商品也为我们选出了相似物品；事实上当我们有过此类操作后，浏览器会将我们的操作信息保存到cookie上面。阿进而言之，cookie就是储存在用户本地终端上的数据。**Cookie的特点**1.cookie保存在浏览器本地，只要不过期关闭浏览器也会存在。2.正常情况下cookie不加密，用户可轻松看到3.用户可以删除或者禁用cookie4.cookie可以被篡改5.cookie可用于攻击6.cookie存储量很小，大小一般是4k7.发送请求自动带上登录信息###Cookie的安装及使用####1.安装```bashcnpminstallcookie-parser--save```####2.引入```constcookieParser=require(\"cookie-parser\");```####3.设置中间件```app.use(cookieParser());```####4.设置cookie```jsres.cookie('name','zhangsan',{maxAge:900000,httpOnly:true})//res.cookie(名称,值,{配置信息})```关于设置cookie的参数说明：1.domain:域名2.name=value：键值对，可以设置要保存的Key/Value，注意这里的name不能和其他属性项的名字一样3.Expires：过期时间（秒），在设置的某个时间点后该Cookie就会失效，如expires=Wednesday,09-Nov-9923:12:40GMT。4.maxAge：最大失效时间（毫秒），设置在多少后失效。5.secure：当secure值为true时，cookie在HTTP中是无效，在HTTPS中才有效。6.Path：表示在那个路由下可以访问到cookie。7.httpOnly：是微软对COOKIE做的扩展。如果在COOKIE中设置了“httpOnly”属性，则通过程序（JS脚本、applet等）将无法读取到COOKIE信息，防止XSS攻击的产生。8.singed：表示是否签名cookie,设为true会对这个cookie签名，这样就需要用res.signedCookies而不是res.cookies访问它。被篡改的签名cookie会被服务器拒绝，并且cookie值会重置为它的原始值。####5.获取cookie```req.cookies.name;```下面是一个基础实例：```jsconstexpress=require('express')constcookieParser=require('cookie-parser')varapp=express()//设置中间件app.use(cookieParser())app.get('/',function(req,res){res.send('首页')})//设置cookieapp.get('/set',function(req,res){res.cookie('userName','张三',{maxAge:20000,httpOnly:true})res.send('设置cookie成功')})//获取cookieapp.get('/get',function(req,res){console.log(req.cookies.userName)res.send('获取cookie成功，cookie为：'+req.cookies.userName)})app.listen(8080)```当访问set路由后会设置cookie，当访问get路由后会获取到设置的cookie值。当然你也可以在其他页面继续获取当前cookie，以实现cookie共享。###多个二级域名共享cookie只需要增加res.cookie中option对象的值，即可实现对相应路由下多个二级路由的cookie进行共享，代码如下：```jsconstexpress=require('express')constcookieParser=require('cookie-parser')varapp=express()//设置中间件app.use(cookieParser())app.get('/',function(req,res){res.send('首页')})//设置cookieapp.get('/set',function(req,res){res.cookie('userName','张三',{maxAge:200000,httpOnly:true,domain:'ccc.com',})res.send('设置cookie成功')})//获取cookieapp.get('/get',function(req,res){console.log(req.cookies.userName)res.send('获取cookie成功，cookie为：'+req.cookies.userName)})app.listen(8080)```我们可以看到不同的二级域名也能访问到相同的cookie，只要满足ccc.com这个顶级域名就行。##Cookie加密cookie加密是让客户端用户无法的获取cookie明文信息，是数据安全的重要部分；一般的我们可以在保存cookie时对cookie信息进行加密，或者在res.cookie中对option对象的signed属性设置设置成true即可。###二、使用signed属性进行cookie加密如下列代码：```jsconstexpress=require('express')constcookieParser=require('cookie-parser')varapp=express()app.use(cookieParser('secret'))app.get('/',function(req,res){res.send('主页')})//获取cookieapp.use(function(req,res,next){console.log(req.signedCookies.name)next()})//设置cookieapp.use(function(req,res,next){console.log(res.cookie('name','zhangsan',{httpOnly:true,maxAge:200000,signed:true,}),)res.end('cookie为：'+req.signedCookies.name)})app.listen(8080)```**签名原理**Express用于对cookie签名，而cookie-parser则是实现对签名的解析。实质是把cookie设置的值和cookieParser(‘secret’);中的secret进行hmac加密，之后和cookie值加“.”的方式拼接起来。当option中signed设置为true后，底层会将cookie的值与“secret”进行hmac加密；**如何解析**cookie-parser中间件在解析签名cookie时做了两件事：1.将签名cookie对应的原始值提取出来2.验证签名cookie是否合法###3、直接对cookie值加密node为我们提供了一个核心安全模块“crypto”，它提供了很多安全相关的功能，如摘要运算、加密、电子签名等。这是，我们便可很轻易的封装一个加密模块：```jsconstcrypto=require('crypto')module.exports={//MD5封装MD5_SUFFIX:'s5w84&&d4d473885s2025s5*4s2',md5:function(str){varobj=crypto.createHash('md5')obj.update(str)returnobj.digest('hex')},}```之后只需要进行相应导入即可```jsconstcommon=require('./MD5')varstr='123456'varstr=common.md5(str+'s5w84&&d4d473885s2025s5*4s2')console.log(str)```设置cookie代码如下：```jsconstexpress=require('express')constcookieParser=require('cookie-parser')varcry=require('./md5')varapp=express()varstr='hello-123'varstr=cry.md5(str+'s5w84&&d4d473885s2025s5*4s2')//设置中间件app.use(cookieParser())//获取加密cookieapp.use(function(req,res,next){console.log(req.cookies.userName)next()})//设置并加密cookieapp.use(function(req,res,next){res.cookie('userName',str,{maxAge:5*60*1000,httpOnly:true})res.end('setok')})app.listen(8080)```如果是在判断登录时，只需将用户输入的账号进行同样加密操作在进行比较即可知道账户是否正确。crypto所涉及的加密方式有很多，推荐大家都写模块引用，这样更方便后期的维护。##session###一、关于sessionsession是另一种记录客户状态的机制，与cookie保存在客户端浏览器不同，session保存在服务器当中；当客户端访问服务器时，服务器会生成一个session对象，对象中保存的是key:value值，同时服务器会将key传回给客户端的cookie当中；当用户第二次访问服务器时，就会把cookie当中的key传回到服务器中，最后服务器会吧value值返回给客户端。因此上面的key则是全局唯一的标识，客户端和服务端依靠这个全局唯一的标识来访问会话信息数据。###二、设置session我们使用express-session模块来设置session#####1.安装express-session```cnpminstallexpress-session--save```#####2.引入express-session模块```constsession=require(\"express-session\");```#####3.设置session```session(options);```如下列代码：```jsconstexpress=require('express')constsession=require('express-session')varapp=express()//配置中间件app.use(session({secret:'keyboardcat',resave:false,saveUninitialized:true,cookie:('name','value',{maxAge:5*60*1000,secure:false}),}),)app.use('/login',function(req,res){//设置sessionreq.session.userinfo='张三'res.send('登陆成功！')})app.use('/',function(req,res){//获取sessionif(req.session.userinfo){res.send('hello'+req.session.userinfo+'，welcome')}else{res.send('未登陆')}})app.listen(8080)```在session(option)中对session进行设置###三、session的常用方法```js//设置sessionreq.session.username='张三'//获取sessionreq.session.username//重新设置cookie的过期时间req.session.cookie.maxAge=1000//销毁sessionreq.session.destroy(function(err){})```以下演示通过销毁session的方式来退出登录```jsconstexpress=require('express')constsession=require('express-session')varapp=express()//配置中间件app.use(session({secret:'keyboardcat',resave:false,saveUninitialized:true,cookie:('name','value',{maxAge:5*60*1000,secure:false,name:'seName',resave:false}),}),)app.use('/login',function(req,res){//设置sessionreq.session.userinfo='张三'res.send('登陆成功！')})app.use('/loginOut',function(req,res){//注销sessionreq.session.destroy(function(err){res.send('退出登录！'+err)})})app.use('/',function(req,res){//获取sessionif(req.session.userinfo){res.send('hello'+req.session.userinfo+'，welcometoindex')}else{res.send('未登陆')}})app.listen(8080)```当我们进入到主页时，未显示任何信息，进入login路由后，自动设置session，这是回到主页则显示session信息，之后进入loginOut路由已注销session信息，再回到首页显示为登陆。##sobooks登陆功能###1-引入session和cookie相关模块```jsvarcookieParser=require('cookie-parser')//引入session模块letsession=require('express-session')```###2-引入session```jsapp.use(session({secret:'xzsagjasoigjasoi',resave:true,//强制保存sessioncookie:{maxAge:7*24*60*60*1000,//设置session的有效期为1周},saveUninitialized:true,//是否保存初始化的session}),)```###3-引入cookie中间件```jsonapp.use(cookieParser('secret'));```###4-写判断是否登陆的中间件```jsfunctionisLoginMid(req,res,next){if(req.session.username==undefined){res.render('info',{title:'未登录',content:'尚未登陆，请进入登陆页面登陆',href:'/login',hrefTxt:'登录页',})}else{//一登录进入正常页面next()}}```###5-引入一个跳转的模板信息页面可以显示登陆成功或者失败的信息内容，并且可以在一定时间内进行跳转。```HTML<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"><metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\"><metahttp-equiv=\"X-UA-Compatible\"content=\"ie=edge\"><title><%-title%></title></head><body><h1><%-title%></h1><h3><%-content%></h3><p><spanclass=\"num\">5</span>秒后跳转至：<ahref=\"<%-href%>\"><%-hrefTxt%></a></p><script>n=5;setInterval(()=>{n--;if(n<0){location.href='<%-href%>';}else{document.querySelector('.num').innerHTML=n;}},1000)</script></body></html>```###6-登陆页面```javascript<formaction='/login'method='POST'><divclass='form-group'><inputclass='form-control'type='email'name='mail'placeholder='邮箱'required='required'/></div><divclass='form-group'><inputclass='form-control'type='password'name='password'placeholder='密码'required='required'/></div><p><ahref='#'>忘记密码?</a></p><buttonclass='btnbtn-lg'>登录</button></form>```###7-处理POST方式提交的请求1-获取表单提交的数据2-查询表单提交的账号密码是否正确3-如果正确，设置session,req.session.username=user.username;4-显示登陆是否成功信息```jsrouter.post('/',asyncfunction(req,res){console.log(req.body)//根据提交的邮箱和密码判断是否是正确的账号密码letstrSql='select*fromuserwheremail=?andpassword=?'letarr=[req.body.mail,req.body.password]letresult=awaitsqlQuery(strSql,arr)if(result.length!=0){//登陆成功user=result[0]req.session.username=user.usernameres.render('info',{title:'登陆成功',content:'账号密码正确，即将进入首页',href:'/',hrefTxt:'首页',})}else{res.render('info',{title:'登陆失败',content:'账号或密码不正确，即将进入登录页',href:'/login',hrefTxt:'登录页',})}})```##sobook注册###1-注册页1-设置表单```HTML<formaction=\"/register\"method=\"POST\"><divclass=\"form-group\"><inputclass=\"form-control\"type=\"email\"name=\"mail\"placeholder=\"邮箱\"required=\"required\"/></div><divclass=\"form-group\"><inputclass=\"form-control\"type=\"text\"name=\"username\"placeholder=\"用户名\"required=\"required\"/></div><divclass=\"form-group\"><inputclass=\"form-control\"type=\"password\"name=\"password\"placeholder=\"密码\"required=\"required\"/></div><divclass=\"form-group\"><inputclass=\"form-control\"type=\"password\"name=\"repassword\"placeholder=\"再次输入密码\"required=\"required\"/></div><p><ahref=\"/login\">登陆</a></p><buttonid=\"registerBtn\"disabled=\"disable\"style=\"cursor:not-allowed;\"class=\"btnbtn-lg\">注册</button></form>```2-前端校验表单数据```javascriptvarformDiv=document.querySelector('form')varinputs=document.querySelectorAll('forminput')varbtn=document.querySelector('#registerBtn')formDiv.oninput=function(){//判断是否有内容为空isAble=trueinputs.forEach((item,i)=>{if(item.value==''){isAble=false}})//正则匹配邮箱地址letreg=/^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$///密码与再次输入的密码是否匹配if(inputs[2].value==inputs[3].value&&isAble&&reg.test(inputs[0].value)){btn.disabled=falsebtn.style.cursor='pointer'}else{btn.disabled=truebtn.style.cursor='not-allow'}}```###2-注册页的路由1-正常浏览器GET请求的路由```router.get('/',function(req,res,next){res.render('register')});```2-表单提交的POST请求路由，先判断是否已注册，没有注册即将数据插入到数据库```javascriptrouter.post('/',asyncfunction(req,res){//获取表单提交的邮箱，密码，用户名console.log(req.body)letmail=req.body.mailletpassword=jiami(req.body.password)letusername=req.body.username//判断邮箱是否已注册，如果已注册，将不在注册；letstrSql='select*fromuserwheremail=?'letresult=awaitsqlQuery(strSql,[mail])if(result.length!=0){//邮箱已注册res.render('info',{title:'注册失败',content:'此邮箱已注册过，可直接登陆，或找寻密码',href:'/register',hrefTxt:'注册页',})}else{//此邮箱尚未注册，可注册strSql='insertintouser(mail,username,password)values(?,?,?)'awaitsqlQuery(strSql,[mail,username,password])res.render('info',{title:'注册成功',content:'注册成功请登陆，即将进入登陆页面',href:'/login',hrefTxt:'登录页',})}})```###3-加密密码并保存至数据库加密：```functionjiami(str){letsalt=\"fjdsoigijasoigjasdiodgjasdiogjoasid\"letobj=crypto.createHash('md5')str=salt+str;obj.update(str)returnobj.digest('hex')}```###4-修改登陆也为加密操作```javascriptfunctionjiami(str){letsalt='fjdsoigijasoigjasdiodgjasdiogjoasid'letobj=crypto.createHash('md5')str=salt+strobj.update(str)returnobj.digest('hex')}router.post('/',asyncfunction(req,res){console.log(req.body)//根据提交的邮箱和密码判断是否是正确的账号密码letstrSql='select*fromuserwheremail=?andpassword=?'letarr=[req.body.mail,jiami(req.body.password)]letresult=awaitsqlQuery(strSql,arr)if(result.length!=0){//登陆成功user=result[0]req.session.username=user.usernameres.render('info',{title:'登陆成功',content:'账号密码正确，即将进入首页',href:'/',hrefTxt:'首页',})}else{res.render('info',{title:'登陆失败',content:'账号或密码不正确，即将进入登录页',href:'/login',hrefTxt:'登录页',})}})```##文件上传###一、multer中间件再上传文件时，我们通常会使用到他。Multer用于处理multipart/form-data类型的表单数据。首先我们先安装它：```cnpminstallmulter--save```###二、使用首先在form表单中我们需要设置enctype为：multipart/form-data表单类型。同时我们也需要用到fs模块对文件重命名。下面是单文件上传实例：```<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"><title></title></head><body><formaction=\"http://localhost:8080/\"method=\"post\"enctype=\"multipart/form-data\"><inputtype=\"file\"name=\"files\"value=\"指定文件\"><br><br><inputtype=\"submit\"value=\"上传\"></form></body></html>```NODE代码：```constexpress=require(\"express\");constmulter=require('multer');//初始化上传对象varupload=multer({dest:'./upload/'});varfs=require('fs');varapp=express();app.use(\"/\",upload.single(\"files\"),function(req,res){//files为inputtype=\"file\"的name值varoldFile=req.file.destination+req.file.filename;//指定旧文件varnewFile=req.file.destination+req.file.originalname;//指定新文件fs.rename(oldFile,newFile,function(err){if(err){res.send('上传失败！');}else{res.send('上传成功！');}});});app.listen(8080);```在这里我们可以指定单个文件上传到根目录的upload文件夹里。这里值得注意的是req.file会返回文件的基本信息：```fieldname:***,//inputtype=\"file\"的name值originalname:***,//用户计算机上的文件的名称encoding:'***',//文件编码mimetype:***',//文件的MIME类型destination:'./***/',//保存路径filename:***,//保存在destination中的文件名path:***,//已上传文件的完整路径size:**//文件大小（字节单位）```###三、上传多个文件在HTML找中inputtype=\"file\"需要加上multiple来实现过滤，multiple不写参数则可以读取·所有文件。而在服务端上，我们需要将single()改为array(“name”,num);的形式来接收多个文件的上传请求。最后对他们全部进行重命名。在这之前我们首先看看multer支持哪些文件上传方式：```.single(fieldname)//接受一个以fieldname命名的文件。.fields(fields).array(fieldname[,maxCount])//接受一个以fieldname命名的文件数组。可以配置maxCount来限制上传的最大数量。.fields(fields)//接受指定fields的混合文件。fields是一个拥有name和maxCount的数组对象。.none()//只接受文本域。如果任何文件上传到这个模式，将发生\"LIMIT_UNEXPECTED_FILE\"错误。.any()//接受一切上传的文件。```下面我们将会演示如何上传多个文件：html：```<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"><title></title></head><body><formaction=\"http://localhost:8080/\"method=\"post\"enctype=\"multipart/form-data\"><inputtype=\"file\"name=\"files\"value=\"指定文件\"multiple><br><br><inputtype=\"submit\"value=\"上传\"></form></body></html>```node代码：```constexpress=require(\"express\");constmulter=require('multer');varupload=multer({dest:'./upload/'});varfs=require('fs');varapp=express();app.use(\"/\",upload.array(\"files\",5),function(req,res,next){req.files.forEach(function(ele,index){console.log(ele);varoldFile=ele.destination+ele.filename;//指定旧文件varnewFile=ele.destination+ele.originalname;//指定新文件fs.rename(oldFile,newFile,function(err){err?console.log('上传失败！'):console.log('上传成功！');});});res.send(\"成功上传\");});app.listen(8080);```这里，我们获取文件信息是通过req.files来获取，他是由数组构成的对象，之后用foreach循环对其进行重命名即可。###四、通过limits来限制上传文件Multer通过使用limits这个对象来对数据进行限制，它允许使用以下参数：```KeyDescriptionDefaultfieldNameSizefield名字最大长度100bytesfieldSizefield值的最大长度1MBfields非文件field的最大数量无限fileSize在multipart表单中，文件最大长度(字节单位)无限files在multipart表单中，文件最大数量无限parts在multipart表单中，part传输的最大数量(fields+files)无限headerPairs在multipart表单中，键值对最大组数2000如果你上传的文件超出这些设定，MulterError模块将会启用，该模块在node_modules/multer/lib/multer-error.js上：```我们可以使用err.code定位到该错误，他有7种code方式，不同设置会返回不同code;```LIMIT_PART_COUNTLIMIT_FILE_SIZELIMIT_FILE_COUNTLIMIT_FIELD_KEYLIMIT_FIELD_VALUELIMIT_FIELD_COUNTLIMIT_FIELD_COUNT```下面就给大家做个简单实例：html依然不变，js代码如下：```constexpress=require(\"express\");constmulter=require('multer');varupload=multer({dest:'./upload/',limits:{fileSize:1024*1024*20,files:5}});varfs=require('fs');varapp=express();app.use(\"/\",upload.array(\"files\",5),function(req,res,next){req.files.forEach(function(ele,index){varoldFile=ele.destination+ele.filename;//指定旧文件varnewFile=ele.destination+ele.originalname;//指定新文件fs.rename(oldFile,newFile,function(err){err?console.log('上传失败！'):console.log('上传成功！');});});next();res.send(\"上传成功！\");});app.use(function(err,req,res,next){if(err.code==='LIMIT_FILE_SIZE'){res.send('Fileistoolarge');}elseif(err.code==='LIMIT_FILE_COUNT'){res.send('Toomanyfiles');}})app.listen(8080);```##文件下载###文件下载文件下载非常简单，仅需通过res.download()执行即可，他可以写为3种形式：```res.download('/report-12345.pdf');```以下是一个对选择对应文件进行下载的实例：html：```<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"><title></title></head><body><formaction=\"http://localhost:8080/\"method=\"post\"enctype=\"application/x-www-form-urlencoded\"><inputtype=\"file\"name=\"files\"value=\"选择下载的文件\"><br><br><inputtype=\"submit\"value=\"下载\"></form></body></html>```js：```constexpress=require(\"express\");constbodyParser=require(\"body-parser\");varapp=express();varjsonParser=bodyParser.json();varurlencodedParser=bodyParser.urlencoded({extended:false});app.post('/',urlencodedParser,function(req,res){res.download(\"./public/\"+req.body.files,err=>{if(err){res.send(\"下载失败！\");}else{console.log(\"下载成功！\");}});});app.listen(8080);```我们可以选择根目录public下的文件对其进行下载。##AJAX上传图片###图片上传实现步骤####图片上传通过jquery监听inputchange事件，这样我们可以获取到上传的图片流信息，从而可以获取到图片的地址、大小、格式以及名称等信息这里创建3个数组，imgName、imgSrc、imgFile分别用于存放上传图片的名称、url地址以及图片流信息```varfileList=this.files;for(vari=0;i<fileList.length;i++){varimgSrcI=getObjectURL(fileList[i]);imgName.push(fileList[i].name);imgSrc.push(imgSrcI);imgFile.push(fileList[i]);}```getObjectURL方法是一个用于获取本地图片的地址，使用该url可以显示图片```functiongetObjectURL(file){varurl=null;if(window.createObjectURL!=undefined){//basicurl=window.createObjectURL(file);}elseif(window.URL!=undefined){//mozilla(firefox)url=window.URL.createObjectURL(file);}elseif(window.webkitURL!=undefined){//webkitorchromeurl=window.webkitURL.createObjectURL(file);}returnurl;}```####控制上传图片大小、格式以及上传数量```$('#upload').on('change',function(){if(imgSrc.length==4){returnalert(\"最多只能上传4张图片\");}varimgSize=this.files[0].size;//bif(imgSize>1024*1024*1){//1Mreturnalert(\"上传图片不能超过1M\");}if(this.files[0].type!='image/png'&&this.files[0].type!='image/jpeg'&&this.files[0].type!='image/gif'){returnalert(\"图片上传格式不正确\");}})```####图片预览创建一个addNewContent方法用于动态展示添加的图片实现图片预览，在每次上传图片的时候调用该方法```functionaddNewContent(obj){$(obj).html(\"\");for(vara=0;a<imgSrc.length;a++){varoldBox=$(obj).html();$(obj).html(oldBox+'<liclass=\"content-img-list-item\"><imgsrc=\"'+imgSrc[a]+'\"alt=\"\"><aindex=\"'+a+'\"class=\"hidedelete-btn\"><iclass=\"ico-delete\"></i></a></li>');}}```####图片删除1.通过监听鼠标的mouseover事件，显示图片删除按钮```$('.content-img-list').on('mouseover','.content-img-list-item',function(){$(this).children('a').removeClass('hide');});```2.监听鼠标的mouseleave事件，隐藏图片删除按钮```$('.content-img-list').on('mouseleave','.content-img-list-item',function(){$(this).children('a').addClass('hide');});```3.获取图片index下标属性，通过js的splice方法删除数组元素，重新调用addNewContent方法遍历图片数组显示预览图片```$(\".content-img-list\").on(\"click\",'.content-img-list-itema',function(){varindex=$(this).attr(\"index\");imgSrc.splice(index,1);imgFile.splice(index,1);imgName.splice(index,1);varboxId=\".content-img-list\";addNewContent(boxId);if(imgSrc.length<4){//显示上传按钮$('.content-img.file').show();}});```####图片上传提交这里主要使用FormData来拼装好数据参数，提交到后台```varformFile=newFormData();```遍历imgFile图片流数组拼装到FormData中```$.each(imgFile,function(i,file){formFile.append('myFile[]',file);});```添加其他参数```formFile.append(\"type\",type);formFile.append(\"content\",content);formFile.append(\"mobile\",mobile);```最后使用ajax提交内容```$.ajax({url:'http://zhangykwww.yind123.com/webapi/feedback',type:'POST',data:formFile,async:true,cache:false,contentType:false,processData:false,//traditional:true,dataType:'json',success:function(res){console.log(res);}})```以上就实现了图片上传、图片预览和图片删除的功能jquery设置ajax属性```processData:false,//告诉jQuery不要去处理发送的数据contentType:false,//告诉jQuery不要去设置Content-Type请求头```","Front-End\\Node\\中台\\koa.md":"#koa>nodejs平台web开发框架>>[Koa项目基础框架搭建](https://blog.csdn.net/weixin_36554693/article/details/105683996)##简介Koa是一个新的web框架，由Express幕后的原班人马打造，致力于成为web应用和API开发领域中的一个更小、更富有表现力、更健壮的基石。通过利用async函数，Koa帮你丢弃回调函数，并有力地增强错误处理。Koa并没有捆绑任何中间件，而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。##安装Koa依赖**nodev7.6.0**或ES2015及更高版本和async方法支持.你可以使用自己喜欢的版本管理器快速安装支持的node版本：```bashnvminstall7npmikoanodemy-koa-app.js```###使用Babel实现Async方法要在node<7.6版本的Koa中使用`async`方法,我们推荐使用[babel'srequirehook](https://www.babeljs.cn/docs/usage/babel-register/).```jsrequire('babel-register')//应用的其余require需要被放到hook后面constapp=require('./app')```要解析和编译async方法,你至少应该有[transform-async-to-generator](https://www.babeljs.cn/docs/plugins/transform-async-to-generator/)或[transform-async-to-module-method](https://www.babeljs.cn/docs/plugins/transform-async-to-module-method/)插件.例如,在你的`.babelrc`文件中,你应该有:```json{\"plugins\":[\"transform-async-to-generator\"]}```你也可以用[envpreset](https://www.babeljs.cn/docs/plugins/preset-env/)的target参数`\"node\":\"current\"`替代.##应用程序Koa应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。Koa类似于你可能遇到过的许多其他中间件系统，例如Ruby的Rack，Connect等，然而，一个关键的设计点是在其低级中间件层中提供高级“语法糖”。这提高了互操作性，稳健性，并使书写中间件更加愉快。这包括诸如内容协商，缓存清理，代理支持和重定向等常见任务的方法。尽管提供了相当多的有用的方法Koa仍保持了一个很小的体积，因为没有捆绑中间件。必修的helloworld应用:```jsconstKoa=require('koa')constapp=newKoa()app.use(async(ctx)=>{ctx.body='HelloWorld'})app.listen(3000)```###级联Koa中间件以更传统的方式级联，您可能习惯使用类似的工具-之前难以让用户友好地使用node的回调。然而，使用async功能，我们可以实现“真实”的中间件。对比Connect的实现，通过一系列功能直接传递控制，直到一个返回，Koa调用“下游”，然后控制流回“上游”。下面以“HelloWorld”的响应作为示例，当请求开始时首先请求流通过`x-response-time`和`logging`中间件，然后继续移交控制给`response`中间件。当一个中间件调用`next()`则该函数暂停并将控制传递给定义的下一个中间件。当在下游没有更多的中间件执行后，堆栈将展开并且每个中间件恢复执行其上游行为。```jsconstKoa=require('koa')constapp=newKoa()//loggerapp.use(async(ctx,next)=>{awaitnext()constrt=ctx.response.get('X-Response-Time')console.log(`${ctx.method}${ctx.url}-${rt}`)})//x-response-timeapp.use(async(ctx,next)=>{conststart=Date.now()awaitnext()constms=Date.now()-startctx.set('X-Response-Time',`${ms}ms`)})//responseapp.use(async(ctx)=>{ctx.body='HelloWorld'})app.listen(3000)```###设置应用程序设置是`app`实例上的属性，目前支持如下：-`app.env`默认是**NODE_ENV**或\"development\"-`app.keys`签名的cookie密钥数组-`app.proxy`当真正的代理头字段将被信任时-忽略`.subdomains`的`app.subdomainOffset`偏移量，默认为2-`app.proxyIpHeader`代理ip消息头,默认为`X-Forwarded-For`-`app.maxIpsCount`从代理ip消息头读取的最大ips,默认为0(代表无限)您可以将设置传递给构造函数:```jsconstKoa=require('koa')constapp=newKoa({proxy:true})```或动态的:```jsconstKoa=require('koa')constapp=newKoa()app.proxy=true```###app.listen(...)Koa应用程序不是HTTP服务器的1对1展现。可以将一个或多个Koa应用程序安装在一起以形成具有单个HTTP服务器的更大应用程序。创建并返回HTTP服务器，将给定的参数传递给`Server#listen()`。这些内容都记录在[nodejs.org](http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback).以下是一个无作用的Koa应用程序被绑定到`3000`端口：```jsconstKoa=require('koa')constapp=newKoa()app.listen(3000)```这里的`app.listen(...)`方法只是以下方法的语法糖:```jsconsthttp=require('http')constKoa=require('koa')constapp=newKoa()http.createServer(app.callback()).listen(3000)```这意味着您可以将同一个应用程序同时作为HTTP和HTTPS或多个地址：```jsconsthttp=require('http')consthttps=require('https')constKoa=require('koa')constapp=newKoa()http.createServer(app.callback()).listen(3000)https.createServer(app.callback()).listen(3001)```###app.callback()返回适用于`http.createServer()`方法的回调函数来处理请求。你也可以使用此回调函数将koa应用程序挂载到Connect/Express应用程序中。###app.use(function)将给定的中间件方法添加到此应用程序。`app.use()`返回`this`,因此可以链式表达.```jsapp.use(someMiddleware)app.use(someOtherMiddleware)app.listen(3000)```它等同于```jsapp.use(someMiddleware).use(someOtherMiddleware).listen(3000)```参阅[Middleware](https://github.com/koajs/koa/wiki#middleware)获取更多信息.###app.keys=设置签名的Cookie密钥。这些被传递给[KeyGrip](https://github.com/crypto-utils/keygrip)，但是你也可以传递你自己的`KeyGrip`实例。例如，以下是可以接受的：```jsapp.keys=['imanewersecret','iliketurtle']app.keys=newKeyGrip(['imanewersecret','iliketurtle'],'sha256')```这些密钥可以倒换，并在使用`{signed:true}`参数签名Cookie时使用。```jsctx.cookies.set('name','tobi',{signed:true})```###app.context`app.context`是从其创建`ctx`的原型。您可以通过编辑`app.context`为`ctx`添加其他属性。这对于将`ctx`添加到整个应用程序中使用的属性或方法非常有用，这可能会更加有效（不需要中间件）和/或更简单（更少的`require()`），而更多地依赖于`ctx`，这可以被认为是一种反模式。例如，要从`ctx`添加对数据库的引用：```jsapp.context.db=db()app.use(async(ctx)=>{console.log(ctx.db)})```注意:-`ctx`上的许多属性都是使用`getter`，`setter`和`Object.defineProperty()`定义的。你只能通过在`app.context`上使用`Object.defineProperty()`来编辑这些属性（不推荐）。查阅<https://github.com/koajs/koa/issues/652>.-安装的应用程序目前使用其父级的`ctx`和设置。因此，安装的应用程序只是一组中间件。####错误处理默认情况下，将所有错误输出到stderr，除非`app.silent`为`true`。当`err.status`是`404`或`err.expose`是`true`时默认错误处理程序也不会输出错误。要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个“error”事件侦听器：```jsapp.on('error',(err)=>{log.error('servererror',err)})```如果req/res期间出现错误，并且_无法_响应客户端，`Context`实例仍然被传递：```jsapp.on('error',(err,ctx)=>{log.error('servererror',err,ctx)})```当发生错误_并且_仍然可以响应客户端时，也没有数据被写入socket中，Koa将用一个500“内部服务器错误”进行适当的响应。在任一情况下，为了记录目的，都会发出应用级“错误”。###上下文(Context)KoaContext将node的`request`和`response`对象封装到单个对象中，为编写Web应用程序和API提供了许多有用的方法。这些操作在HTTP服务器开发中频繁使用，它们被添加到此级别而不是更高级别的框架，这将强制中间件重新实现此通用功能。_每个_请求都将创建一个`Context`，并在中间件中作为接收器引用，或者`ctx`标识符，如以下代码片段所示：```jsapp.use(async(ctx)=>{ctx//这是Contextctx.request//这是koaRequestctx.response//这是koaResponse})```为方便起见许多上下文的访问器和方法直接委托给它们的`ctx.request`或`ctx.response`，不然的话它们是相同的。例如`ctx.type`和`ctx.length`委托给`response`对象，`ctx.path`和`ctx.method`委托给`request`。###API`Context`具体方法和访问器.###ctx.reqNode的`request`对象.###ctx.resNode的`response`对象.绕过Koa的response处理是**不被支持的**.应避免使用以下node属性：-`res.statusCode`-`res.writeHead()`-`res.write()`-`res.end()`###ctx.requestkoa的`Request`对象.###ctx.responsekoa的`Response`对象.###ctx.state推荐的命名空间，用于通过中间件传递信息和你的前端视图。```jsctx.state.user=awaitUser.find(id)```###ctx.app应用程序实例引用###ctx.app.emitKoa应用扩展了内部[EventEmitter](https://nodejs.org/dist/latest-v11.x/docs/api/events.html)。`ctx.app.emit`发出一个类型由第一个参数定义的事件。对于每个事件，您可以连接\"listeners\"，这是在发出事件时调用的函数。有关更多信息，请参阅[错误处理文档](https://koajs.com/#error-handling)。###ctx.cookies.get(name,[options])通过`options`获取cookie`name`:-`signed`所请求的cookie应该被签名koa使用[cookies](https://github.com/pillarjs/cookies)模块，其中只需传递参数。###ctx.cookies.set(name,value,[options])通过`options`设置cookie`name`的`value`:-```maxAge```:一个数字,表示从```Date.now()```得到的毫秒数.-`expires`:一个`Date`对象,表示cookie的到期日期(默认情况下在会话结束时过期).-`path`:一个字符串,表示cookie的路径(默认是`/`).-`domain`:一个字符串,指示cookie的域(无默认值).-`secure`:一个布尔值,表示cookie是否仅通过HTTPS发送(HTTP下默认为`false`,HTTPS下默认为`true`).[阅读有关此参数的更多信息](https://github.com/pillarjs/cookies#secure-cookies).-`httpOnly`:一个布尔值,表示cookie是否仅通过HTTP(S)发送，,且不提供给客户端JavaScript(默认为`true`).-`sameSite`:一个布尔值或字符串,表示该cookie是否为\"相同站点\"cookie(默认为`false`).可以设置为`'strict'`,`'lax'`,`'none'`,或`true`(映射为`'strict'`).-`signed`:一个布尔值,表示是否要对cookie进行签名(默认为`false`).如果为`true`,则还会发送另一个后缀为`.sig`的同名cookie,使用一个27-byteurl-safebase64SHA1值来表示针对第一个[Keygrip](https://www.npmjs.com/package/keygrip)键的_cookie-name_=_cookie-value_的哈希值.此签名密钥用于检测下次接收cookie时的篡改.-`overwrite`:一个布尔值,表示是否覆盖以前设置的同名的cookie(默认是`false`).如果是true,在同一个请求中设置相同名称的所有Cookie（无论路径或域）是否在设置此Cookie时从Set-Cookie消息头中过滤掉.koa使用传递简单参数的[cookies](https://github.com/pillarjs/cookies)模块。###ctx.throw([status],[msg],[properties])用来抛出一个包含`.status`属性错误的帮助方法，其默认值为`500`。这样Koa就可以做出适当地响应。允许以下组合：```jsctx.throw(400)ctx.throw(400,'namerequired')ctx.throw(400,'namerequired',{user:user})```例如`ctx.throw(400,'namerequired')`等效于:```jsconsterr=newError('namerequired')err.status=400err.expose=truethrowerr```请注意，这些是用户级错误，并用`err.expose`标记，这意味着消息适用于客户端响应，这通常不是错误消息的内容，因为您不想泄漏故障详细信息。你可以根据需要将`properties`对象传递到错误中，对于装载上传给请求者的机器友好的错误是有用的。这用于修饰其人机友好型错误并向上游的请求者报告非常有用。```jsctx.throw(401,'access_denied',{user:user})```koa使用[http-errors](https://github.com/jshttp/http-errors)来创建错误。`status`只应作为第一个参数传递。###ctx.assert(value,[status],[msg],[properties])当`!value`时抛出一个类似`.throw`错误的帮助方法。这与node的[assert()](http://nodejs.org/api/assert.html)方法类似.```jsctx.assert(ctx.state.user,401,'Usernotfound.Pleaselogin!')```koa使用[http-assert](https://github.com/jshttp/http-assert)作为断言。###ctx.respond为了绕过Koa的内置response处理，你可以显式设置`ctx.respond=false;`。如果您想要写入原始的`res`对象而不是让Koa处理你的response，请使用此参数。请注意，Koa_不_支持使用此功能。这可能会破坏Koa中间件和Koa本身的预期功能。使用这个属性被认为是一个hack，只是便于那些希望在Koa中使用传统的`fn(req,res)`功能和中间件的人。##Request别名以下访问器和[Request](https://koa.bootcss.com/#request)别名等效：-`ctx.header`-`ctx.headers`-`ctx.method`-`ctx.method=`-`ctx.url`-`ctx.url=`-`ctx.originalUrl`-`ctx.origin`-`ctx.href`-`ctx.path`-`ctx.path=`-`ctx.query`-`ctx.query=`-`ctx.querystring`-`ctx.querystring=`-`ctx.host`-`ctx.hostname`-`ctx.fresh`-`ctx.stale`-`ctx.socket`-`ctx.protocol`-`ctx.secure`-`ctx.ip`-`ctx.ips`-`ctx.subdomains`-`ctx.is()`-`ctx.accepts()`-`ctx.acceptsEncodings()`-`ctx.acceptsCharsets()`-`ctx.acceptsLanguages()`-`ctx.get()`###Response别名以下访问器和[Response](https://koa.bootcss.com/#response)别名等效：-`ctx.body`-`ctx.body=`-`ctx.status`-`ctx.status=`-`ctx.message`-`ctx.message=`-`ctx.length=`-`ctx.length`-`ctx.type=`-`ctx.type`-`ctx.headerSent`-`ctx.redirect()`-`ctx.attachment()`-`ctx.set()`-`ctx.append()`-`ctx.remove()`-`ctx.lastModified=`-`ctx.etag=`##请求(Request)Koa`Request`对象是在node的原生请求对象之上的抽象，提供了诸多对HTTP服务器开发有用的功能。###API###request.header请求头对象。这与node[`http.IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage)上的[`headers`](https://nodejs.org/api/http.html#http_message_headers)字段相同###request.header=设置请求头对象。###request.headers请求头对象。别名为`request.header`.###request.headers=设置请求头对象。别名为`request.header=`.###request.method请求方法。###request.method=设置请求方法，对于实现诸如`methodOverride()`的中间件是有用的。###request.length返回以数字返回请求的Content-Length，或`undefined`。###request.url获取请求URL.###request.url=设置请求URL,对url重写有用。###request.originalUrl获取请求原始URL。###request.origin获取URL的来源，包括`protocol`和`host`。```jsctx.request.origin//=>http://example.com```###request.href获取完整的请求URL，包括`protocol`，`host`和`url`。```jsctx.request.href//=>http://example.com/foo/bar?q=1```###request.path获取请求路径名。###request.path=设置请求路径名，并在存在时保留查询字符串。###request.querystring根据`?`获取原始查询字符串.###request.querystring=设置原始查询字符串。###request.search使用`?`获取原始查询字符串。###request.search=设置原始查询字符串。###request.host存在时获取主机（hostname:port）。当`app.proxy`是**true**时支持`X-Forwarded-Host`，否则使用`Host`。###request.hostname存在时获取主机名。当`app.proxy`是**true**时支持`X-Forwarded-Host`，否则使用`Host`。如果主机是IPv6,Koa解析到[WHATWGURLAPI](https://nodejs.org/dist/latest-v8.x/docs/api/url.html#url_the_whatwg_url_api),_注意_这可能会影响性能。###request.URL获取WHATWG解析的URL对象。###request.type获取请求`Content-Type`,不含\"charset\"等参数。>译者注:这里其实是只获取_mime-type_,详见[源码及其注释](https://github.com/koajs/koa/blob/eda27608f7d39ede86d7b402aae64b1867ce31c6/lib/request.js#L639)```jsconstct=ctx.request.type//=>\"image/png\"```###request.charset存在时获取请求字符集，或者`undefined`：```jsctx.request.charset//=>\"utf-8\"```###request.query获取解析的查询字符串,当没有查询字符串时，返回一个空对象。请注意，此getter_不_支持嵌套解析。例如\"color=blue&size=small\":```js{color:'blue',size:'small'}```###request.query=将查询字符串设置为给定对象。请注意，此setter_不_支持嵌套对象。```jsctx.query={next:'/login'}```###request.fresh检查请求缓存是否“新鲜”，也就是内容没有改变。此方法用于`If-None-Match`/`ETag`,和`If-Modified-Since`和`Last-Modified`之间的缓存协商。在设置一个或多个这些响应头后应该引用它。```js//新鲜度检查需要状态20x或304ctx.status=200ctx.set('ETag','123')//缓存是好的if(ctx.fresh){ctx.status=304return}//缓存是陈旧的//获取新数据ctx.body=awaitdb.find('something')```###request.stale与`request.fresh`相反.###request.protocol返回请求协议，“https”或“http”。当`app.proxy`是**true**时支持`X-Forwarded-Proto`。###request.secure通过`ctx.protocol==\"https\"`来检查请求是否通过TLS发出。###request.ip请求远程地址。当`app.proxy`是**true**时支持`X-Forwarded-Proto`。###request.ips当`X-Forwarded-For`存在并且`app.proxy`被启用时，这些ips的数组被返回，从上游->下游排序。禁用时返回一个空数组。例如，如果值是\"client,proxy1,proxy2\"，将会得到数组`[\"client\",\"proxy1\",\"proxy2\"]`。大多数反向代理（nginx）都通过`proxy_add_x_forwarded_for`设置了x-forwarded-for，这带来了一定的安全风险。恶意攻击者可以通过伪造`X-Forwarded-For`请求头来伪造客户端的ip地址。客户端发送的请求具有'forged'的`X-Forwarded-For`请求头。在由反向代理转发之后，`request.ips`将是['forged','client','proxy1','proxy2']。Koa提供了两种方式来避免被绕过。如果您可以控制反向代理，则可以通过调整配置来避免绕过，或者使用koa提供的`app.proxyIpHeader`来避免读取`x-forwarded-for`获取ips。```jsconstapp=newKoa({proxy:true,proxyIpHeader:'X-Real-IP',})```如果您确切知道服务器前面有多少个反向代理，则可以通过配置`app.maxIpsCount`来避免读取用户的伪造的请求头：```jsconstapp=newKoa({proxy:true,maxIpsCount:1,//服务器前只有一个代理})//request.header['X-Forwarded-For']===['127.0.0.1','127.0.0.2'];//ctx.ips===['127.0.0.2'];```###request.subdomains以数组形式返回子域。子域是应用程序主域之前主机的点分隔部分。默认情况下，应用程序的域名假定为主机的最后两个部分。这可以通过设置`app.subdomainOffset`来更改。例如，如果域名为“tobi.ferrets.example.com”：如果`app.subdomainOffset`未设置,`ctx.subdomains`是`[\"ferrets\",\"tobi\"]`.如果`app.subdomainOffset`是3,`ctx.subdomains`是`[\"tobi\"]`.###request.is(types...)检查传入请求是否包含`Content-Type`消息头字段，并且包含任意的mime`type`。如果没有请求主体，返回`null`。如果没有内容类型，或者匹配失败，则返回`false`。反之则返回匹配的content-type。```js//使用Content-Type:text/html;charset=utf-8ctx.is('html')//=>'html'ctx.is('text/html')//=>'text/html'ctx.is('text/*','text/html')//=>'text/html'//当Content-Type是application/json时ctx.is('json','urlencoded')//=>'json'ctx.is('application/json')//=>'application/json'ctx.is('html','application/*')//=>'application/json'ctx.is('html')//=>false```例如，如果要确保仅将图像发送到给定路由：```jsif(ctx.is('image/*')){//处理}else{ctx.throw(415,'imagesonly!')}```###内容协商Koa的`request`对象包括由[accepts](http://github.com/expressjs/accepts)和[negotiator](https://github.com/federomero/negotiator)提供的内容协商实用函数。这些实用函数是：-`request.accepts(types)`-`request.acceptsEncodings(types)`-`request.acceptsCharsets(charsets)`-`request.acceptsLanguages(langs)`如果没有提供类型，则返回**所有**可接受的类型。如果提供多种类型，将返回最佳匹配。如果没有找到匹配项，则返回一个`false`，你应该向客户端发送一个`406\"NotAcceptable\"`响应。如果接收到任何类型的接收头，则会返回第一个类型。因此，你提供的类型的顺序很重要。###request.accepts(types)检查给定的`type(s)`是否可以接受，如果`true`，返回最佳匹配，否则为`false`。`type`值可能是一个或多个mime类型的字符串，如`application/json`，扩展名称如`json`，或数组`[\"json\",\"html\",\"text/plain\"]`。```js//Accept:text/htmlctx.accepts('html')//=>\"html\"//Accept:text/*,application/jsonctx.accepts('html')//=>\"html\"ctx.accepts('text/html')//=>\"text/html\"ctx.accepts('json','text')//=>\"json\"ctx.accepts('application/json')//=>\"application/json\"//Accept:text/*,application/jsonctx.accepts('image/png')ctx.accepts('png')//=>false//Accept:text/*;q=.5,application/jsonctx.accepts(['html','json'])ctx.accepts('html','json')//=>\"json\"//NoAcceptheaderctx.accepts('html','json')//=>\"html\"ctx.accepts('json','html')//=>\"json\"```你可以根据需要多次调用`ctx.accepts()`，或使用switch：```jsswitch(ctx.accepts('json','html','text')){case'json':breakcase'html':breakcase'text':breakdefault:ctx.throw(406,'json,html,ortextonly')}```###request.acceptsEncodings(encodings)检查`encodings`是否可以接受，返回最佳匹配为`true`，否则为`false`。请注意，您应该将`identity`作为编码之一！```js//Accept-Encoding:gzipctx.acceptsEncodings('gzip','deflate','identity')//=>\"gzip\"ctx.acceptsEncodings(['gzip','deflate','identity'])//=>\"gzip\"```当没有给出参数时，所有接受的编码将作为数组返回：```js//Accept-Encoding:gzip,deflatectx.acceptsEncodings()//=>[\"gzip\",\"deflate\",\"identity\"]```请注意，如果客户端显式地发送`identity;q=0`，那么`identity`编码（这意味着没有编码）可能是不可接受的。虽然这是一个边缘的情况，你仍然应该处理这种方法返回`false`的情况。###request.acceptsCharsets(charsets)检查`charsets`是否可以接受，在`true`时返回最佳匹配，否则为`false`。```js//Accept-Charset:utf-8,iso-8859-1;q=0.2,utf-7;q=0.5ctx.acceptsCharsets('utf-8','utf-7')//=>\"utf-8\"ctx.acceptsCharsets(['utf-7','utf-8'])//=>\"utf-8\"```当没有参数被赋予所有被接受的字符集将作为数组返回：```js//Accept-Charset:utf-8,iso-8859-1;q=0.2,utf-7;q=0.5ctx.acceptsCharsets()//=>[\"utf-8\",\"utf-7\",\"iso-8859-1\"]```###request.acceptsLanguages(langs)检查`langs`是否可以接受，如果为`true`，返回最佳匹配，否则为`false`。```js//Accept-Language:en;q=0.8,es,ptctx.acceptsLanguages('es','en')//=>\"es\"ctx.acceptsLanguages(['en','es'])//=>\"es\"```当没有参数被赋予所有接受的语言将作为数组返回：```js//Accept-Language:en;q=0.8,es,ptctx.acceptsLanguages()//=>[\"es\",\"pt\",\"en\"]```###request.idempotent检查请求是否是幂等的。###request.socket返回请求套接字。###request.get(field)返回请求头(header),`field`不区分大小写.##响应(Response)Koa`Response`对象是在node的原生响应对象之上的抽象，提供了诸多对HTTP服务器开发有用的功能。###API###response.header响应头对象。###response.headers响应头对象。别名是`response.header`。###response.socket响应套接字。作为`request.socket`指向net.Socket实例。###response.status获取响应状态。默认情况下，`response.status`设置为`404`而不是像node的`res.statusCode`那样默认为`200`。###response.status=通过数字代码设置响应状态：-100\"continue\"-101\"switchingprotocols\"-102\"processing\"-200\"ok\"-201\"created\"-202\"accepted\"-203\"non-authoritativeinformation\"-204\"nocontent\"-205\"resetcontent\"-206\"partialcontent\"-207\"multi-status\"-208\"alreadyreported\"-226\"imused\"-300\"multiplechoices\"-301\"movedpermanently\"-302\"found\"-303\"seeother\"-304\"notmodified\"-305\"useproxy\"-307\"temporaryredirect\"-308\"permanentredirect\"-400\"badrequest\"-401\"unauthorized\"-402\"paymentrequired\"-403\"forbidden\"-404\"notfound\"-405\"methodnotallowed\"-406\"notacceptable\"-407\"proxyauthenticationrequired\"-408\"requesttimeout\"-409\"conflict\"-410\"gone\"-411\"lengthrequired\"-412\"preconditionfailed\"-413\"payloadtoolarge\"-414\"uritoolong\"-415\"unsupportedmediatype\"-416\"rangenotsatisfiable\"-417\"expectationfailed\"-418\"I'mateapot\"-422\"unprocessableentity\"-423\"locked\"-424\"faileddependency\"-426\"upgraderequired\"-428\"preconditionrequired\"-429\"toomanyrequests\"-431\"requestheaderfieldstoolarge\"-500\"internalservererror\"-501\"notimplemented\"-502\"badgateway\"-503\"serviceunavailable\"-504\"gatewaytimeout\"-505\"httpversionnotsupported\"-506\"variantalsonegotiates\"-507\"insufficientstorage\"-508\"loopdetected\"-510\"notextended\"-511\"networkauthenticationrequired\"**注意**:不用太在意记住这些字符串,如果你写错了,可以查阅这个列表随时更正.由于`response.status`默认设置为`404`，因此发送没有body且状态不同的响应的操作如下：```jsctx.response.status=200//或其他任何状态ctx.response.status=204```###response.message获取响应的状态消息.默认情况下,`response.message`与`response.status`关联.###response.message=将响应的状态消息设置为给定值。###response.length=将响应的Content-Length设置为给定值。###response.length以数字返回响应的Content-Length，或者从`ctx.body`推导出来，或者`undefined`。###response.body获取响应主体。###response.body=将响应体设置为以下之一：-`string`写入-`Buffer`写入-`Stream`管道-`Object`||`Array`JSON-字符串化-`null`无内容响应如果`response.status`未被设置,Koa将会自动设置状态为`200`或`204`。Koa没有防范作为响应体的所有内容-函数没有有意义地序列化，返回布尔值可能会根据您的应用程序而有意义。并且当错误生效时，它可能无法正常工作错误的属性无法枚举。我们建议在您的应用中添加中间件，以确定每个应用的正文类型。示例中间件可能是：```jsapp.use(async(ctx,next)=>{awaitnext()ctx.assert.equal('object',typeofctx,500,'某些开发错误')})```####StringContent-Type默认为`text/html`或`text/plain`,同时默认字符集是utf-8。Content-Length字段也是如此。####BufferContent-Type默认为`application/octet-stream`,并且Content-Length字段也是如此。####StreamContent-Type默认为`application/octet-stream`。每当流被设置为响应主体时，`.onerror`作为侦听器自动添加到`error`事件中以捕获任何错误。此外，每当请求关闭（甚至过早）时，流都将被销毁。如果你不想要这两个功能，请勿直接将流设为主体。例如，当将主体设置为代理中的HTTP流时，你可能不想要这样做，因为它会破坏底层连接。参阅:<https://github.com/koajs/koa/pull/612>获取更多信息。以下是流错误处理的示例，而不会自动破坏流：```jsconstPassThrough=require('stream').PassThroughapp.use(async(ctx)=>{ctx.body=someHTTPStream.on('error',(err)=>ctx.onerror(err)).pipe(PassThrough())})```####ObjectContent-Type默认为`application/json`.这包括普通的对象`{foo:'bar'}`和数组`['foo','bar']`。###response.get(field)不区分大小写获取响应头字段值`field`。```jsconstetag=ctx.response.get('ETag')```###response.has(field)如果当前在响应头中设置了由名称标识的消息头，则返回`true`.消息头名称匹配不区分大小写.```jsconstrateLimited=ctx.response.has('X-RateLimit-Limit')```###response.set(field,value)设置响应头`field`到`value`:```jsctx.set('Cache-Control','no-cache')```###response.append(field,value)用值`val`附加额外的消息头`field`。```jsctx.append('Link','<http://127.0.0.1/>')```###response.set(fields)用一个对象设置多个响应头`fields`:```jsctx.set({Etag:'1234','Last-Modified':date,})```这将委托给[setHeader](https://nodejs.org/dist/latest/docs/api/http.html#http_request_setheader_name_value)，它通过指定的键设置或更新消息头，并且不重置整个消息头。###response.remove(field)删除消息头`field`。###response.type获取响应`Content-Type`,不含\"charset\"等参数。>译者注:这里其实是只获取_mime-type_,详见[源码及其注释](https://github.com/koajs/koa/blob/eda27608f7d39ede86d7b402aae64b1867ce31c6/lib/response.js#L371)```jsconstct=ctx.type//=>\"image/png\"```###response.type=设置响应`Content-Type`通过mime字符串或文件扩展名。```jsctx.type='text/plain;charset=utf-8'ctx.type='image/png'ctx.type='.png'ctx.type='png'```注意:在适当的情况下为你选择`charset`,比如`response.type='html'`将默认是\"utf-8\".如果你想覆盖`charset`,使用`ctx.set('Content-Type','text/html')`将响应头字段设置为直接值。###response.is(types...)非常类似`ctx.request.is()`.检查响应类型是否是所提供的类型之一。这对于创建操纵响应的中间件特别有用。例如,这是一个中间件，可以削减除流之外的所有HTML响应。```jsconstminify=require('html-minifier')app.use(async(ctx,next)=>{awaitnext()if(!ctx.response.is('html'))returnletbody=ctx.bodyif(!body||body.pipe)returnif(Buffer.isBuffer(body))body=body.toString()ctx.body=minify(body)})```###response.redirect(url,[alt])执行[302]重定向到`url`.字符串“back”是特别提供Referrer支持的，当Referrer不存在时，使用`alt`或“/”。```jsctx.redirect('back')ctx.redirect('back','/index.html')ctx.redirect('/login')ctx.redirect('http://google.com')```要更改“302”的默认状态，只需在该调用之前或之后给`status`赋值。要变更主体请在此调用之后:```jsctx.status=301ctx.redirect('/cart')ctx.body='Redirectingtoshoppingcart'```###response.attachment([filename],[options])将`Content-Disposition`设置为“附件”以指示客户端提示下载。(可选)指定下载的`filename`和部分[参数](https://github.com/jshttp/content-disposition#options)。###response.headerSent检查是否已经发送了一个响应头。用于查看客户端是否可能会收到错误通知。###response.lastModified将`Last-Modified`消息头返回为`Date`,如果存在。###response.lastModified=将`Last-Modified`消息头设置为适当的UTC字符串。您可以将其设置为`Date`或日期字符串。```jsctx.response.lastModified=newDate()```###response.etag=设置包含`\"`包裹的ETag响应，请注意，没有相应的`response.etag`getter。```jsctx.response.etag=crypto.createHash('md5').update(ctx.body).digest('hex')```###response.vary(field)设置`field`的`vary`。###response.flushHeaders()刷新任何设置的消息头，然后是主体(body)。##参与翻译如果您希望贡献力量完善本中文文档，请前往<https://github.com/demopark/koa-docs-Zh-CN.git>仓库。##相关资源Communitylinkstodiscoverthird-partymiddlewareforKoa,fullrunnableexamples,thoroughguidesandmore!IfyouhavequestionsjoinusinIRC!-[GitHubrepository](https://github.com/koajs/koa)-[Examples](https://github.com/koajs/examples)-[Middleware](https://github.com/koajs/koa/wiki)-[Wiki](https://github.com/koajs/koa/wiki)-[G+Community](https://plus.google.com/communities/101845768320796750641)-[Mailinglist](https://groups.google.com/forum/#!forum/koajs)-[Guide](https://github.com/koajs/koa/blob/master/docs/guide.md)-[FAQ](https://github.com/koajs/koa/blob/master/docs/faq.md)-**#koajs**onfreenode","Front-End\\Node\\中台\\Nest.md":"#nest##前言>[文档](https://docs.nestjs.cn/8/firststeps)>node>=10.13.0,v13除外","Front-End\\Node\\中台\\ORM\\typeorm.md":"#typeorm##前言>[文档](https://typeorm.bootcss.com/)","Front-End\\Node\\中台\\中台.md":"#中台>业务中台>>数据中台>>算法中台>>移动中台##中台框架-[fastify](https://www.fastify.cn/docs/latest/ContentTypeParser/)","Front-End\\Node\\中台\\中间件\\multer.md":"#multer##安装```bashnpminstall--savemulter```##使用Multer会添加一个`body`对象以及`file`或`files`对象到express的`request`对象中。`body`对象包含表单的文本域信息，`file`或`files`对象包含对象表单上传的文件信息。基本使用方法:```jsvarexpress=require('express')varmulter=require('multer')varupload=multer({dest:'uploads/'})varapp=express()app.post('/profile',upload.single('avatar'),function(req,res,next){//req.file是`avatar`文件的信息//req.body将具有文本域数据，如果存在的话})app.post('/photos/upload',upload.array('photos',12),function(req,res,next){//req.files是`photos`文件数组的信息//req.body将具有文本域数据，如果存在的话},)varcpUpload=upload.fields([{name:'avatar',maxCount:1},{name:'gallery',maxCount:8},])app.post('/cool-profile',cpUpload,function(req,res,next){//req.files是一个对象(String->Array)键是文件名，值是文件数组////例如：//req.files['avatar'][0]->File//req.files['gallery']->Array////req.body将具有文本域数据，如果存在的话})```如果你需要处理一个只有文本域的表单，你应当使用`.none()`:```jsvarexpress=require('express')varapp=express()varmulter=require('multer')varupload=multer()app.post('/profile',upload.none(),function(req,res,next){//req.body包含文本域})```##API###文件信息每个文件具有下面的信息:|Key|Description|Note||--------------|-------------------------------|---------------||`fieldname`|Fieldname由表单指定|||`originalname`|用户计算机上的文件的名称|||`encoding`|文件编码|||`mimetype`|文件的MIME类型|||`size`|文件大小（字节单位）|||`destination`|保存路径|`DiskStorage`||`filename`|保存在`destination`中的文件名|`DiskStorage`||`path`|已上传文件的完整路径|`DiskStorage`||`buffer`|一个存放了整个文件的`Buffer`|`MemoryStorage`|###`multer(opts)`Multer接受一个options对象，其中最基本的是`dest`属性，这将告诉Multer将上传文件保存在哪。如果你省略options对象，这些文件将保存在内存中，永远不会写入磁盘。为了避免命名冲突，Multer会修改上传的文件名。这个重命名功能可以根据您的需要定制。以下是可以传递给Multer的选项。|Key|Description||-------------------|----------------------------------||`dest`or`storage`|在哪里存储文件||`fileFilter`|文件过滤器，控制哪些文件可以被接受||`limits`|限制上传的数据||`preservePath`|保存包含文件名的完整文件路径|通常，一般的网页应用，只需要设置`dest`属性，像这样：```varupload=multer({dest:'uploads/'})```如果你想在上传时进行更多的控制，你可以使用`storage`选项替代`dest`。Multer具有`DiskStorage`和`MemoryStorage`两个存储引擎；另外还可以从第三方获得更多可用的引擎。####`.single(fieldname)`接受一个以`fieldname`命名的文件。这个文件的信息保存在`req.file`。####`.array(fieldname[,maxCount])`接受一个以`fieldname`命名的文件数组。可以配置`maxCount`来限制上传的最大数量。这些文件的信息保存在`req.files`。####`.fields(fields)`接受指定`fields`的混合文件。这些文件的信息保存在`req.files`。`fields`应该是一个对象数组，应该具有`name`和可选的`maxCount`属性。Example:```js;[{name:'avatar',maxCount:1},{name:'gallery',maxCount:8},]```####`.none()`只接受文本域。如果任何文件上传到这个模式，将发生\"LIMIT_UNEXPECTED_FILE\"错误。这和`upload.fields([])`的效果一样。####`.any()`接受一切上传的文件。文件数组将保存在`req.files`。**警告:**确保你总是处理了用户的文件上传。永远不要将multer作为全局中间件使用，因为恶意用户可以上传文件到一个你没有预料到的路由，应该只在你需要处理上传文件的路由上使用。###`storage`####磁盘存储引擎(`DiskStorage`)磁盘存储引擎可以让你控制文件的存储。```jsvarstorage=multer.diskStorage({destination:function(req,file,cb){cb(null,'/tmp/my-uploads')},filename:function(req,file,cb){cb(null,file.fieldname+'-'+Date.now())},})varupload=multer({storage:storage})```有两个选项可用，`destination`和`filename`。他们都是用来确定文件存储位置的函数。`destination`是用来确定上传的文件应该存储在哪个文件夹中。也可以提供一个`string`(例如`'/tmp/uploads'`)。如果没有设置`destination`，则使用操作系统默认的临时文件夹。**注意:**如果你提供的`destination`是一个函数，你需要负责创建文件夹。当提供一个字符串，multer将确保这个文件夹是你创建的。`filename`用于确定文件夹中的文件名的确定。如果没有设置`filename`，每个文件将设置为一个随机文件名，并且是没有扩展名的。**注意:**Multer不会为你添加任何扩展名，你的程序应该返回一个完整的文件名。每个函数都传递了请求对象(`req`)和一些关于这个文件的信息(`file`)，有助于你的决定。注意`req.body`可能还没有完全填充，这取决于向客户端发送字段和文件到服务器的顺序。####内存存储引擎(`MemoryStorage`)内存存储引擎将文件存储在内存中的`Buffer`对象，它没有任何选项。```varstorage=multer.memoryStorage()varupload=multer({storage:storage})```当使用内存存储引擎，文件信息将包含一个`buffer`字段，里面包含了整个文件数据。**警告**:当你使用内存存储，上传非常大的文件，或者非常多的小文件，会导致你的应用程序内存溢出。###`limits`一个对象，指定一些数据大小的限制。Multer通过这个对象使用busboy，详细的特性可以在[busboy'spage](https://github.com/mscdex/busboy#busboy-methods)找到。可以使用下面这些:|Key|Description|Default||---------------|--------------------------------------------------------|---------||`fieldNameSize`|field名字最大长度|100bytes||`fieldSize`|field值的最大长度|1MB||`fields`|非文件field的最大数量|无限||`fileSize`|在multipart表单中，文件最大长度(字节单位)|无限||`files`|在multipart表单中，文件最大数量|无限||`parts`|在multipart表单中，part传输的最大数量(fields+files)|无限||`headerPairs`|在multipart表单中，键值对最大组数|2000|设置limits可以帮助保护你的站点抵御拒绝服务(DoS)攻击。###`fileFilter`设置一个函数来控制什么文件可以上传以及什么文件应该跳过，这个函数应该看起来像这样：```jsfunctionfileFilter(req,file,cb){//这个函数应该调用`cb`用boolean值来//指示是否应接受该文件//拒绝这个文件，使用`false`，像这样:cb(null,false)//接受这个文件，使用`true`，像这样:cb(null,true)//如果有问题，你可以总是这样发送一个错误:cb(newError(\"Idon'thaveaclue!\"))}```##错误处理机制当遇到一个错误，multer将会把错误发送给express。你可以使用一个比较好的错误展示页([express标准方式](http://expressjs.com/guide/error-handling.html))。如果你想捕捉multer发出的错误，你可以自己调用中间件程序。如果你想捕捉[Multer错误](https://github.com/expressjs/multer/blob/master/lib/multer-error.js)，你可以使用`multer`对象下的`MulterError`类(即`errinstanceofmulter.MulterError`)。```jsvarmulter=require('multer')varupload=multer().single('avatar')app.post('/profile',function(req,res){upload(req,res,function(err){if(errinstanceofmulter.MulterError){//发生错误}elseif(err){//发生错误}//一切都好})})```##定制存储引擎>构建自己的存储引擎，请看[这里](https://github.com/expressjs/multer/blob/master/StorageEngine.md)","Front-End\\Node\\基础\\fs.md":"#fs模块###前言Node.js中赋予了JavaScript很多在浏览器中没有的能力，譬如：文件读写，创建http服务器等等，今天我们就来看看在node中怎样用JavaScript进行文件的读写操作。1.读文件1.我们在data文件夹下新建一个`hello.txt`，并且在里面写入：`hello，node.js!!`，如图：1.我们在`hello.txt`同级目录下创建一个`hello.js`文件，我们在这个js文件中利用Node提供的文件操作API,读取`hello.txt`文件中的内容。-node中对文件相关的操作需要依赖fs模块，这个是node中内置模块之一，我们需要引入。fs--filesystem。```jsletfs=require('fs')fs.readFile()//读文件。readFile函数接受两个参数：读取文件路径，回调函数（error，data两个参数），读取文件成功：data为文件内容，error为null，读取失败：error为错误对象，data为undefined```最后我们`hello.js`中的代码如下:```jsletfs=require('fs')fs.readFile('./hello.txt',(error,data)=>{console.log(data.toString())})```在这里可以说一下，我们读取回来的默认是二进制的内容，所以需要调用toString()方法进行转换。最后，终端可以看到结果如下：可以看到我们刚才在`hello.txt`中写入的文本`hello,node.js!!`已经打印出来。看到这里是不是觉得很牛叉，JavaScript居然可以用来读取文件内容，完全颠覆了我们以前对JavaScript的理解，然而这一切都得归功于Node.js。1.写文件我们在刚才的`hello.js`中写入下面这行代码：```jsfs.writeFile('./hello.md','你好，node.js!',(error)=>{if(!error){console.log('创建成功了。。')}})//写文件。writeFile接受三个参数：写入文件路径，写入内容，回调函数。```写入成功时候：error为null，写入失败时候：error为错误对象最后我们看到在同级目录下出现了一个`hello.md`文件，并且里面的内容为`你好，node.js`.如图：###删除文件###语法以下为删除文件的语法格式：```fs.unlink(path,callback)```###参数参数使用说明如下：-**path**-文件路径。-**callback**-回调函数，没有参数。###实例input.txt文件内容为：```site:www.runoob.com```接下来我们创建file.js文件，代码如下所示：```varfs=require(\"fs\");console.log(\"准备删除文件！\");fs.unlink('input.txt',function(err){if(err){returnconsole.error(err);}console.log(\"文件删除成功！\");});```以上代码执行结果如下：```$nodefile.js准备删除文件！文件删除成功！```再去查看input.txt文件，发现已经不存在了。---###创建目录###语法以下为创建目录的语法格式：```fs.mkdir(path[,options],callback)```###参数参数使用说明如下：-**path**-文件路径。-options参数可以是：-**recursive**-是否以递归的方式创建目录，默认为false。-**mode**-设置目录权限，默认为0777。-**callback**-回调函数，没有参数。###实例接下来我们创建file.js文件，代码如下所示：```jsvarfs=require('fs')//tmp目录必须存在console.log('创建目录/tmp/test/')fs.mkdir('/tmp/test/',function(err){if(err){returnconsole.error(err)}console.log('目录创建成功。')})```以上代码执行结果如下：```$nodefile.js创建目录/tmp/test/目录创建成功。```可以添加recursive:true参数，不管创建的目录/tmp和/tmp/a是否存在：```jsfs.mkdir('/tmp/a/apple',{recursive:true},(err)=>{if(err)throwerr})```---###读取目录###语法以下为读取目录的语法格式：```fs.readdir(path,callback)```###参数参数使用说明如下：-**path**-文件路径。-**callback**-回调函数，回调函数带有两个参数err,files，err为错误信息，files为目录下的文件数组列表。###实例接下来我们创建file.js文件，代码如下所示：```jsvarfs=require('fs')console.log('查看/tmp目录')fs.readdir('/tmp/',function(err,files){if(err){returnconsole.error(err)}files.forEach(function(file){console.log(file)})})```以上代码执行结果如下：```$nodefile.js查看/tmp目录input.outoutput.outtesttest.txt```---###删除目录###语法以下为删除目录的语法格式：```fs.rmdir(path,callback)```###参数参数使用说明如下：-**path**-文件路径。-**callback**-回调函数，没有参数。###实例接下来我们创建file.js文件，代码如下所示：```varfs=require(\"fs\");//执行前创建一个空的/tmp/test目录console.log(\"准备删除目录/tmp/test\");fs.rmdir(\"/tmp/test\",function(err){if(err){returnconsole.error(err);}console.log(\"读取/tmp目录\");fs.readdir(\"/tmp/\",function(err,files){if(err){returnconsole.error(err);}files.forEach(function(file){console.log(file);});});});```输入输出```//引入readline模块varreadline=require('readline');//创建readline接口实例varrl=readline.createInterface({input:process.stdin,output:process.stdout});//question方法rl.question(\"你的名字是？\",function(answer){console.log(\"我的名字是：\"+answer);//不加close，则程序不会结束rl.close();});//close事件监听rl.on(\"close\",function(){//结束程序process.exit(0);})```","Front-End\\Node\\基础\\node-basis.md":"#node-basis##特点>-事件驱动>-非阻塞态IO模型(异步)>-轻量,高效##Node.jsStream(流)Stream是一个抽象接口，Node中有很多对象实现了这个接口。例如，对http服务器发起请求的request对象就是一个Stream，还有stdout（标准输出）。Node.js，Stream有四种流类型：-**Readable**-可读操作。-**Writable**-可写操作。-**Duplex**-可读可写操作.-**Transform**-操作被写入数据，然后读出结果。所有的Stream对象都是EventEmitter的实例。常用的事件有：-**data**-当有数据可读时触发。-**end**-没有更多的数据可读时触发。-**error**-在接收和写入过程中发生错误时触发。-**finish**-所有数据已被写入到底层系统时触发。本教程会为大家介绍常用的流操作。---###从流中读取数据创建input.txt文件，内容如下：```www.sxt.com```创建main.js文件,代码如下：```varfs=require(\"fs\");vardata='';//创建可读流varreaderStream=fs.createReadStream('input.txt');//设置编码为utf8。readerStream.setEncoding('UTF8');//处理流事件-->data,end,anderrorreaderStream.on('data',function(chunk){data+=chunk;});readerStream.on('end',function(){console.log(data);});readerStream.on('error',function(err){console.log(err.stack);});console.log(\"程序执行完毕\");```以上代码执行结果如下：```程序执行完毕地址：www.sxt.com```---###写入流创建main.js文件,代码如下：```varfs=require(\"fs\");vardata='www.sxt.com';//创建一个可以写入的流，写入到文件output.txt中varwriterStream=fs.createWriteStream('output.txt');//使用utf8编码写入数据writerStream.write(data,'UTF8');//标记文件末尾writerStream.end();//处理流事件-->data,end,anderrorwriterStream.on('finish',function(){console.log(\"写入完成。\");});writerStream.on('error',function(err){console.log(err.stack);});console.log(\"程序执行完毕\");```以上程序会将data变量的数据写入到output.txt文件中。代码执行结果如下：```$nodemain.js程序执行完毕写入完成。```查看output.txt文件的内容：```$catoutput.txtwww.sxt.com```---###管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。![img](https://www.sxt.com/wp-content/uploads/2015/09/bVcla61)如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。设置input.txt文件内容如下：```教程官网地址：www.sxt.com管道流操作实例```创建main.js文件,代码如下：```varfs=require(\"fs\");//创建一个可读流varreaderStream=fs.createReadStream('input.txt');//创建一个可写流varwriterStream=fs.createWriteStream('output.txt');//管道读写操作//读取input.txt文件内容，并将内容写入到output.txt文件中readerStream.pipe(writerStream);console.log(\"程序执行完毕\");```代码执行结果如下：```$nodemain.js程序执行完毕```查看output.txt文件的内容：```$catoutput.txt教程官网地址：www.sxt.com管道流操作实例```---###链式流链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。创建compress.js文件,代码如下：```jsvarfs=require('fs')varzlib=require('zlib')//压缩input.txt文件为input.txt.gzfs.createReadStream('input.txt').pipe(zlib.createGzip()).pipe(fs.createWriteStream('input.txt.gz'))console.log('文件压缩完成。')```代码执行结果如下：```$nodecompress.js文件压缩完成。```执行完以上操作后，我们可以看到当前目录下生成了input.txt的压缩文件input.txt.gz。接下来，让我们来解压该文件，创建decompress.js文件，代码如下：```varfs=require(\"fs\");varzlib=require('zlib');//解压input.txt.gz文件为input.txtfs.createReadStream('input.txt.gz').pipe(zlib.createGunzip()).pipe(fs.createWriteStream('input.txt'));console.log(\"文件解压完成。\");```代码执行结果如下：```js$nodedecompress.js文件解压完成。```##Node.js事件循环Node.js是单进程单线程应用程序，但是因为V8引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。Node.js几乎每一个API都是支持回调函数的。Node.js基本上所有的事件机制都是用设计模式中观察者模式实现。Node.js单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.```开启进程开启线程初始化数据，window/document/location...while(true){初始化事件列表根据事件修改数据根据数据去渲染页面if(count=0){运行js代ebtn.onclick=function(){document.body.style.background=\"skyblue\"console.log(123)}console.log(456)count++}}```---###事件驱动程序Node.js使用事件驱动模型，当webserver接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。![img](https://www.sxt.com/wp-content/uploads/2015/09/event_loop.jpg)Node.js有多个内置的事件，我们可以通过引入events模块，并通过实例化EventEmitter类来绑定和监听事件，如下实例：```//引入events模块varevents=require('events');//创建eventEmitter对象vareventEmitter=newevents.EventEmitter();```以下程序绑定事件处理程序：```//绑定事件及事件的处理程序eventEmitter.on('eventName',eventHandler);```我们可以通过程序触发事件：```//触发事件eventEmitter.emit('eventName');```###实例创建main.js文件，代码如下所示：###实例```js//引入events模块varevents=require('events')//创建eventEmitter对象vareventEmitter=newevents.EventEmitter()//创建事件处理程序varconnectHandler=functionconnected(){console.log('连接成功。')//触发data_received事件eventEmitter.emit('data_received')}//绑定connection事件处理程序eventEmitter.on('connection',connectHandler)//使用匿名函数绑定data_received事件eventEmitter.on('data_received',function(){console.log('数据接收成功。')})//触发connection事件eventEmitter.emit('connection')console.log('程序执行完毕。')```接下来让我们执行以上代码：```$nodemain.js连接成功。数据接收成功。程序执行完毕。```---###Node应用程序是如何工作的？在Node应用程序中，执行异步操作的函数将回调函数作为最后一个参数，回调函数接收错误对象作为第一个参数。接下来让我们来重新看下前面的实例，创建一个input.txt,文件内容如下：```官网地址：www.sxt.com```创建main.js文件，代码如下：```jsvarfs=require('fs')fs.readFile('input.txt',function(err,data){if(err){console.log(err.stack)return}console.log(data.toString())})console.log('程序执行完毕')```以上程序中fs.readFile()是异步函数用于读取文件。如果在读取文件过程中发生错误，错误err对象就会输出错误信息。如果没发生错误，readFile跳过err对象的输出，文件内容就通过回调函数输出。执行以上代码，执行结果如下：```程序执行完毕官网地址：www.sxt.com```接下来我们删除input.txt文件，执行结果如下所示：```程序执行完毕Error:ENOENT,open'input.txt'```因为文件input.txt不存在，所以输出了错误信息。###Node.jsEventEmitterNode.js所有的异步I/O操作在完成时都会发送一个事件到事件队列。Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时触发一个事件，一个fs.readStream对象会在文件被打开的时候触发一个事件。所有这些产生事件的对象都是events.EventEmitter的实例。---###EventEmitter类events模块只提供了一个对象：events.EventEmitter。EventEmitter的核心就是事件触发与事件监听器功能的封装。你可以通过require(\"events\");来访问该模块。```js//引入events模块varevents=require('events')//创建eventEmitter对象vareventEmitter=newevents.EventEmitter()```EventEmitter对象如果在实例化时发生错误，会触发error事件。当添加新的监听器时，newListener事件会触发，当监听器被移除时，removeListener事件被触发。下面我们用一个简单的例子说明EventEmitter的用法：```js//event.js文件varEventEmitter=require('events').EventEmittervarevent=newEventEmitter()event.on('some_event',function(){console.log('some_event事件触发')})setTimeout(function(){event.emit('some_event')},1000)```执行结果如下：运行这段代码，1秒后控制台输出了**'some_event事件触发'**。其原理是event对象注册了事件some_event的一个监听器，然后我们通过setTimeout在1000毫秒以后向event对象发送事件some_event，此时会调用some_event的监听器。```$nodeevent.jssome_event事件触发```EventEmitter的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter支持若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。让我们以下面的例子解释这个过程：```//event.js文件varevents=require('events');varemitter=newevents.EventEmitter();emitter.on('someEvent',function(arg1,arg2){console.log('listener1',arg1,arg2);});emitter.on('someEvent',function(arg1,arg2){console.log('listener2',arg1,arg2);});emitter.emit('someEvent','arg1参数','arg2参数');```执行以上代码，运行的结果如下：```$nodeevent.jslistener1arg1参数arg2参数listener2arg1参数arg2参数```以上例子中，emitter为事件someEvent注册了两个事件监听器，然后触发了someEvent事件。运行结果中可以看到两个事件监听器回调函数被先后调用。这就是EventEmitter最简单的用法。EventEmitter提供了多个属性，如**on**和**emit**。**on**函数用于绑定事件函数，**emit**属性用于触发一个事件。接下来我们来具体看下EventEmitter的属性介绍。##http模块开启一个本地服务器需要Node.js中`http`核心模块1.http--模块提供了搭建本地服务器的API,首先我们在项目中引入；```lethttp=require('http')```引入之后我们利用http.createServer()方法得到一个服务器实例。```letserver=http.createServer()//createServer()方法返回一个server实例，所以我们需要一个变量来接收```1.经过以上两步，我们已经搭建好了一个服务器实例，然后我们给服务器实例绑定接收`request`的事情处理函数，代码如下：```server.on('request',(req,res)=>{console.log(req.url)//获取到请求的路径（请求路径永远以“/”开头）})//给服务器绑定接收请求的处理事件，当服务器接收到客户端发送的请求后，会调用后面的处理函数，处理函数接收两个参数：请求信息对象，响应信息对象。```1.绑定监听端口号，开启服务器。代码如下：```server.listen(3000,()=>{console.log('服务器开启成功，可以通过访问http://127.0.0.1:3000/来获取数据~~')})//server.listen()用来绑定监听的端口号，可以传入第二个参数，当服务器开启成功后，触发后面的回调函数```1.最后看到的效果如下图所示：![node演示](D:/note/Front-end/node学习图片资源/07.png)我们看到请求路径被打印在了CMD窗口中。好了，经过这简单的操作是不是已经完成了一个服务器的简单搭建，接下来我们来实现一个需求：-当我们访问“<http://127.0.0.1:3000/login>”,服务器返回“loginpage”-当我们访问“<http://127.0.0.1:3000/register>”,服务器返回“registerpage”-当我们访问“<http://127.0.0.1:3000/>”,服务器返回“indexpage”-当我们访问“<http://127.0.0.1:3000/product>”,服务器返回**产品信息列表**我们实现这个需求，只需要在绑定服务器监听的事件处理函数中获取到用户的请求路径，然后根据不同路径返回不同数据即可，这个也不难。详情代码看下：```jslethttp=require('http')letserver=http.createServer()server.on('request',(req,res)=>{leturl=req.url//得到请求的路径（请求的路径永远以‘/’开头）if(url==='/'){res.end('indexpage')}elseif(url==='/login'){res.end('loginpage')}elseif(url==='/register'){res.end('registerpage')}elseif(url==='/product'){letarr=[{name:'iphoneX',price:8888,},{name:'iphone7',price:4320,},]//响应的数据类型必须是字符串或者二进制数据res.end(JSON.stringify(arr))}else{res.end('404NOTfound')}})server.listen(3000,()=>{console.log('服务器启动成功了，，可以访问http://127.0.0.1:3000/啦')})```最后实现的效果图如下：![node演示](D:/note/Front-end/node学习图片资源/08.gif)我们看到我们请求不同的路径，服务器给我们返回了不同的内容，并且显示在了网页中。###设置状态码和响应头```response.writeHead(200,{'Content-Type':'text/plain'});```###设置响应头```response.setHeader('Content-Type','text/html');```###写入内容```response.write(fileData);```###结束响应```response.end();```###静态服务器定义能够根据需要请求的文件，原封不动的将服务器磁盘中的数据直接返回给到浏览器。1.根据设定的目录，判断用户是否请求的文件时静态文件```//解析路径leturlObj=path.parse(req.url)//判断是否请求静态文件urlObj.dir=='/static'```1.从磁盘读取静态文件并返回```//根据请求的后缀名，返回文件的类型res.setHeader(\"content-type\",getContentType(urlObj.ext))//从服务器磁盘中读取文件，并输出到响应对象中letrs=fs.createReadStream('./static/'+urlObj.base)rs.pipe(res)```1.如何根据后缀名返回文件类型```functiongetContentType(extName){switch(extName){case\".jpg\":return\"image/jpeg\";case\".html\":return\"text/html;charset=utf-8\";case\".js\":return\"text/javascript;charset=utf-8\";case\".json\":return\"text/json;charset=utf-8\";case\".gif\":return\"image/gif\";case\".css\":return\"text/css\"}}```####完整案例```//引入http模块lethttp=require('http');//创建server对象letserver=http.createServer()//引入path模块letpath=require('path')//引入文件模块letfs=require('fs')//监听客户端发送过来的请求//req请求对象包含了请求的相关的信息//res对象用于响应内容，可以通过这个对象帮助我们快速实现HTTP响应server.on('request',function(req,res){//解析路径leturlObj=path.parse(req.url)//识别请求的路径//console.log(urlObj)//进入首页，返回首页的内容if(req.url==\"/\"){res.setHeader(\"content-type\",\"text/html;charset=utf-8\")res.end(`<linkrel=\"stylesheet\"href=\"./static/style.css\"><h1>首页</h1><imgsrc='./static/cxk.jpg'>`)}elseif(urlObj.dir=='/static'){res.setHeader(\"content-type\",getContentType(urlObj.ext))letrs=fs.createReadStream('./static/'+urlObj.base)rs.pipe(res)}else{res.setHeader(\"content-type\",\"text/html;charset=utf-8\")res.end(\"<h1>404页面找不到</h1>\")}})functiongetContentType(extName){switch(extName){case\".jpg\":return\"image/jpeg\";case\".html\":return\"text/html;charset=utf-8\";case\".js\":return\"text/javascript;charset=utf-8\";case\".json\":return\"text/json;charset=utf-8\";case\".gif\":return\"image/gif\";case\".css\":return\"text/css\"}}//启动服务器，监听服务端口server.listen(80,function(){console.log(\"服务已启动：http:127.0.0.1\")})```##模板动态生成页面1.根据规则去解析链接，并且获取ID或者时索引值```js//请求路径：http://127.0.0.1/movies/0letindex=req.pathObj.base```2.根据索引获取数据```jsonletmovies=[{name:\"雪暴\",brief:\"电影《雪暴》讲述了在一座极北的边陲小镇，一伙穷凶极恶、作案手法老到的悍匪为抢夺黄金，打劫运金车，并借助大雪掩盖了所有犯罪痕迹。为了探求真相，警察王康浩暗地里搜集证据，熟悉地形，终于在一场灾难级的暴雪降临时，与谋财害命的悍匪发生了惊心动魄的正面对决……\",author:\"张震\"},{name:\"少年的你\",brief:\"陈念（周冬雨饰）是一名即将参加高考的高三学生，同校女生胡晓蝶（张艺凡饰）的跳楼自杀让她的生活陷入了困顿之中。胡晓蝶死后，陈念遭到了以魏莱（周也饰）为首的三人组的霸凌，魏莱虽然表面上看来是乖巧的优等生，实际上却心思毒辣，胡晓蝶的死和她有着千丝万缕的联系。\",author:\"周冬雨\"}]letpageData=movies[index]```1.根据模板渲染页面```jsres.render(movies[index],'./template/index.html')```1.底层需要实现渲染函数，通过正则匹配，找到需要修改的地方进行一一的修改。```jsfunctionrender(options,path){fs.readFile(path,{encoding:'utf-8',flag:'r'},(err,data)=>{if(err){console.log(err)}else{console.log(data)letreg=/\\{\\{(.*?)\\}\\}/gisletresultwhile((result=reg.exec(data))){//去除2边的空白letstrKey=result[1].trim()letstrValue=options[strKey]data=data.replace(result[0],strValue)}this.end(data)}})}```##async_promise###写法不同ES5正常写法```getAjax(url,(res)=>{})```Promise```get(url).then((res)=>{})```async_await```(async()=>{letres=awaitget(url)})()```总结：-ES5写法和promise写法，主要区别在写法的不同，可以让回调函数，划分出去在.then的函数里去执行，使得代码更加的另外，也可以将两个不同的参数，可以划分开来写。-async和promise的区别，不要在于async时promise的语法糖，这种形式的写法在底层编译之后会自动转化成promise的写法###Promise实现原理promise需要实现的功能```functionfn(resolve,reject){setTimeout(()=>{if(true){resolve()}else{reject()}})}varp1=newLcPromise(fn)p1.then(function(res){document.body.style.background=\"greenyellow\"console.log(\"这是成功做的事情\")console.log(res)})p1.catch(function(res){document.body.style.background=\"pink\"console.log(\"这是失败做的事情\")console.log(res)})```p1promise对象发送了异步操作，必然会有1个未来事件，在未来要执行。这个过程由传入的函数对象fn执行。函数fn里必然需要由成功执行和失败执行的函数1创建类构造对象```classLcPromise{constructor(fn){//将成功的事件函数集成在successList数组里this.successList=[];//这里将所有的失败函数集成到failList里this.failList=[]//pending,fullfilled,rejectedthis.state=\"pending\"//传入的函数对象,(异步操作的函数内容)fn(this.resolveFn.bind(this),this.rejectFn.bind(this))}}```构造函数的作用：-声明成功函数放置的数组对象-声明失败函数放置的数组对象-定义初始化状态-调用传入进行执行异步内容的函数（在未来有成功的结果时调用传入进去的成功函数，在未来失败时调用传入进行的失败函数）2.传入成功或者失败时需要调用的函数```jsclassLcPromise{constructor(fn){//将成功的事件函数集成在successList数组里this.successList=[]//这里将所有的失败函数集成到failList里this.failList=[]//pending,fullfilled,rejectedthis.state='pending'//传入的函数对象,(异步操作的函数内容)fn(this.resolveFn.bind(this),this.rejectFn.bind(this))}then(successFn,failFn){if(typeofsuccessFn=='function'){this.successList.push(successFn)}if(typeoffailFn=='function'){this.failList.push(failFn)}}catch(failFn){if(typeoffailFn=='function'){this.failList.push(failFn)}}}```作用：-将成功和失败的函数传入值成功和失败的数组里定义调用成功和失败的函数```js//promiseasyncawaitproxyIteratrorclassLcPromise{constructor(fn){//将成功的事件函数集成在successList数组里this.successList=[]//这里将所有的失败函数集成到failList里this.failList=[]//pending,fullfilled,rejectedthis.state='pending'//传入的函数对象,(异步操作的函数内容)fn(this.resolveFn.bind(this),this.rejectFn.bind(this))}then(successFn,failFn){if(typeofsuccessFn=='function'){this.successList.push(successFn)}if(typeoffailFn=='function'){this.failList.push(failFn)}}catch(failFn){if(typeoffailFn=='function'){this.failList.push(failFn)}}resolveFn(res){this.state='fullfilled'this.successList.forEach(function(item,index){//将成功的事件循环调用item(res)})}rejectFn(res){this.state='rejected'//注册到的失败所有事件进行调用this.failList.forEach(function(item,index){item(res)})throwError(res)}}```作用：-成功时调用成功数组里所有的函数，失败时调用失败数组里所有的函数。###应用如何将promise与async和await结合使用典型异步读写的回调操作```jsfs.readFile(path,{flag:'r',encoding:'utf-8'},function(err,data){if(err){//console.log(err)//失败执行的内容reject(err)}else{//console.log(data)//成功执行的内容resolve(data)}//console.log(456)})```转换成promise对象```newPromise(function(resolve,reject){fs.readFile(path,{flag:'r',encoding:\"utf-8\"},function(err,data){if(err){reject(err)}else{resolve(data)}})})```由于每次使用，都不想写这么多代码，那么就会把这样的写法直接进行函数的封装```functionfsRead(path){returnnewPromise(function(resolve,reject){fs.readFile(path,{flag:'r',encoding:\"utf-8\"},function(err,data){if(err){reject(err)}else{resolve(data)}})})}```使用的时候，就可以使用promise写法```p1=fsRead(path)//就可以得到promise对象p1.then(function(data){console.log('输出数据:',data)})```asycn_await写法```(async()=>{letdata=awaitfsRead(path)})()```异步async函数调用之后也是一个promise对象```(async()=>{asyncfunctiontest(){letdata=awaitfsRead(path)returndata;}letp=test()//异步函数调用后，也是一个promise对象p.then(function(data){console.log(data)})leta=awaittest()//异步函数调用后，也是一个promise对象console.log(123)})()```##梳理框架流程###1浏览器发送请求1.用户输入网址地址```http://127.0.0.1/```1.浏览器根据请求转变成HTTP的请求包```GET/HTTP/1.1Host:127.0.0.1Connection:keep-alivePragma:no-cacheCache-Control:no-cacheUpgrade-Insecure-Requests:1User-Agent:Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/76.0.3809.132Safari/537.36Sec-Fetch-Mode:navigateSec-Fetch-User:?1Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Sec-Fetch-Site:noneAccept-Encoding:gzip,deflate,brAccept-Language:zh-CN,zh;q=0.9```###2服务器接受到请求​1.http模块里中实例化的server对象，server对象监听每一次浏览器发送过来的请求，每次的请求都会触发`request`事件```this.server.on('request',(req,res)=>{})```1.将HTTP的请求包转化成req的请求对象，并且传入到请求事件触发的函数中。2.会创建生成1个res响应对象，这个对象可以帮助我们快速的实现HTTP的响应###3解析请求路径，调用不同的页面渲染函数1.正则匹配方式进行对路径的匹配2.以匹配的正则字符串作为KEY，找到需要调用执行的渲染函数```//循环匹配正则路径for(letkeyinthis.reqEvent){letregStr=keyletreg=newRegExp(regStr,'igs');console.log(regStr,reg)if(reg.test(req.url)){this.reqEvent[key](req,res)resState=truebreak;}}```1.调用页面的执行函数```app.on('/movies/[01]',(req,res)=>{})//这里的箭头函数即为真正匹配到的页面时执行的函数```1.调用模板的渲染函数```res.render(movies[index],'./template/index0.html')```1.执行渲染函数```functionrender(options,path){fs.readFile(path,{encoding:\"utf-8\",flag:\"r\"},(err,data)=>{if(err){console.log(err)}else{//数组变量的替换data=replaceArr(data,options)//单个变量的替换data=replaceVar(data,options)//最终输出渲染出来的HTMLthis.end(data)}})}```1.数组变量的替换```functionreplaceArr(data,options){//匹配循环的变量，并且替换循环的内容letreg=/\\{\\%for\\{(.*?)\\}\\%\\}(.*?)\\{\\%endfor\\%\\}/igswhile(result=reg.exec(data)){letstrKey=result[1].trim();//提取变量时，去掉左右两边的空格//通过KEY值获取数组内容letstrValueArr=options[strKey]letlistStr=\"\"strValueArr.forEach((item,i)=>{//替换每一项内容里的变量listStr=listStr+replaceVar(result[2],{\"item\":item})})data=data.replace(result[0],listStr)}returndata;}```1.单个变量的替换```functionreplaceVar(data,options){letreg=/\\{\\{(.*?)\\}\\}/igsletresult;console.log(options)while(result=reg.exec(data)){//去除2边的空白letstrKey=result[1].trim()console.log(strKey)//item,item.abc//options.itemletstrValue=eval('options.'+strKey);//执行字符串作为JS表达式，并将计算出来的结果返回data=data.replace(result[0],strValue)}returndata}```###4如果是请求静态文件，那么就按照静态文件的形式输出1.首先判断是否响应过，如果没有响应过，可以判断是否为静态文件，如果是静态文件就正常的输出2.否则，就输出404```if(!resState){if(pathObj.dir==this.staticDir){res.setHeader(\"content-type\",this.getContentType(pathObj.ext))letrs=fs.createReadStream('./static/'+pathObj.base)rs.pipe(res)}else{res.setHeader(\"content-type\",\"text/html;charset=utf-8\")res.end(\"<h1>404!页面找不到</h1>\")}}```###5RES响应对象将res设置的内容最终转化成http的响应包```HTTP/1.1200OKcontent-type:text/html;charset=utf-8Date:Sat,30Nov201907:01:36GMTConnection:keep-aliveContent-Length:46<h1>这是首页</h1><imgsrc='./abc/cxk.jpg'>```###6浏览器解析响应包，并将html渲染在页面上##正则路由的设定要求：可以根据自己设定的正则匹配路径来执行相对应的函数来响应用户的内容。###1.设定正则的匹配路径和响应的执行函数```app.on('^/$',(req,res)=>{res.setHeader(\"content-type\",\"text/html;charset=utf-8\");res.end(\"<h1>这是首页</h1><imgsrc='./abc/cxk.jpg'>\")})```###2.获取正则路径创建正则对象```letreg=newRegExp(regStr,'igs');```###3.匹配路径，并调用相对应的函数```if(reg.test(req.url)){this.reqEvent[key](req,res)resState=truebreak;}```###4.判断是否正则路径响应过，如果响应过，将不再响应，不能重复响应，会报错```javascriptif(!resState){if(pathObj.dir==this.staticDir){res.setHeader('content-type',this.getContentType(pathObj.ext))letrs=fs.createReadStream('./static/'+pathObj.base)rs.pipe(res)}else{res.setHeader('content-type','text/html;charset=utf-8')res.end('<h1>404!页面找不到</h1>')}}```##Node总结Node：一门后端语言（服务器端的程序语言），能够连接数据库存取数据，能够接受和处理网络请求（服务器的响应，发送请求去获取数据），单线程事件驱动，异步执行，不等待，提高IO（input和ouput）的处理速度和效率。服务器：本质上是一台PC主机（linux系统，windows系统），部署了后端语言的执行环境，并且能够长时间提供网络服务。###事件驱动node本身提供了事件对象，帮助我们快速订阅者模式，或者观察者模式，或者事件模式。```js//事件的订阅event.on(‘林俊杰演唱会’，()=>{订阅门票})//事件的触发event.emit(‘林俊杰演唱会’)```###读写事件```jsfs.readfile('path',读取配置,(err,data)=>{})fs.writeFile('path',写入数据，写入配置，()=>{})```###读写的promise封装```javascriptletfs=require('fs')functionfsRead(path){returnnewPromise(function(resolve,reject){fs.readFile(path,{flag:'r',encoding:'utf-8'},function(err,data){if(err){//console.log(err)//失败执行的内容reject(err)}else{//console.log(data)//成功执行的内容resolve(data)}//console.log(456)})})}functionfsWrite(path,content){returnnewPromise(function(resolve,reject){fs.writeFile(path,content,{flag:'a',encoding:'utf-8'},function(err){if(err){//console.log(\"写入内容出错\")reject(err)}else{resolve(err)//console.log(\"写入内容成功\")}},)})}functionfsDir(path){returnnewPromise(function(resolve,reject){fs.mkdir(path,function(err){if(err){reject(err)}else{resolve('成功创建目录')}})})}module.exports={fsRead,fsWrite,fsDir}```####使用方式```(asyncfunction(){letdata=awaitfsRead('path')})()```###网络请求数据request,axios:效率比较高，单局限性比较大puppeteer:效率低，局限性比较小重点掌握的是：页面的分析，数据存放的位置，以及响应内容。###网络响应数据http.createServer：就可以创建1个服务器去监听某个端口，并且通过请求事件来处理每个发送过来的请求。server.on('request',(req,res)=>{​req:请求数据都会放在请求对象里​res：能够做出响应对象})###路由根据不同的路径去响应不同的内容```javascript//循环匹配正则路径for(letkeyinthis.reqEvent){res.setHeader('content-type','text/html;charset=utf-8')letregStr=keyletreg=newRegExp(regStr,'igs')//console.log(regStr,reg)if(reg.test(req.url)){this.reqEvent[key](req,res)resState=truebreak}}```###模板会有个固定样式和结构的HTML模板，根据请求的数据不同，显示页面内容。例如新闻网站```javascriptfunctionrender(options,path){fs.readFile(path,{encoding:'utf-8',flag:'r'},(err,data)=>{if(err){console.log(err)}else{try{data=replaceArr(data,options)data=replaceVar(data,options)}catch(error){console.log(error)}this.end(data)}})}```##回调函数>-异步变成的直接体现就是回调>-node所有api都支持回调函数```jsfunctionfoo(value,callback1,callback){}```###阻塞代码实例input.txt```txtgrhgrh```main.js```jsvarfs=require('fs')vardata=fs.readFileSync('input.txt')console.log(data.toString())console.log('程序执行结束!')```执行代码```cmd$nodemain.jsgrhgrh程序执行结束!```###非阻塞态实例input.txt```txtgrhgrh```main.js```jsvarfs=require('fs')fs.readFile('input.txt',function(err,data){if(err)returnconsole.log(err)consolo.log(data.toString())})console.log('程序执行结束!')```执行代码```cmd$nodemain.js程序执行结束!grhgrh```##事件循环>-node事件机制都是用观察者设计模式来实现的>-单线程进入while(true)的时间循环,知道没有事件观察者退出,每个异步时间都生成一个时间观察者,没有事件发生就调用该回调函数###事件驱动程序>-当webserver接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。>-当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户<imgsrc=\"https://images.gitee.com/uploads/images/2020/0601/115845_6c7a6287_6545143.png\"style=\"zoom:50%;\"/>```js//引入events模块varevents=require('events');//创建eventEmitter对象vareventEmitter=newevents.EventEmitter();//创建事件处理程序varconnectHandler=functionconnected(){console.log('连接成功。');//触发data_received事件eventEmitter.emit('data_received');}//绑定connection事件处理程序eventEmitter.on('connection',connectHandler);//使用匿名函数绑定data_received事件eventEmitter.on('data_received',function(){console.log('数据接收成功。');});//触发connection事件eventEmitter.emit('connection');console.log(\"程序执行完毕。\");执行结果:$nodemain.js连接成功。数据接收成功。程序执行完毕```##EventEmitter>-Node.js所有的异步I/O操作在完成时都会发送一个事件到事件队列。>-Node.js里面的许多对象都会分发事件：>-一个net.Server对象会在每次有新连接时触发一个事件，>-一个fs.readStream对象会在文件被打开的时候触发一个事件。所有这些产生事件的对象都是events.EventEmitter的实例。```js//event.js文件varevents=require('events');varemitter=newevents.EventEmitter();emitter.on('someEvent',function(arg1,arg2){console.log('listener1',arg1,arg2);});emitter.on('someEvent',function(arg1,arg2){console.log('listener2',arg1,arg2);});emitter.emit('someEvent','arg1参数','arg2参数');//执行后$nodeevent.jslistener1arg1参数arg2参数listener2arg1参数arg2参数```>emitter为事件someEvent注册了两个事件监听器，然后触发了someEvent事件###方法|序号|方法&描述||:---|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||1|**addListener(event,listener)**为指定事件添加一个监听器到监听器数组的尾部。||2|**on(event,listener)**为指定事件注册一个监听器，接受一个字符串event和一个回调函数。`server.on('connection',function(stream){console.log('someoneconnected!');});`||3|**once(event,listener)**为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。`server.once('connection',function(stream){console.log('Ah,wehaveourfirstuser!');});`||4|**removeListener(event,listener)**移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。`varcallback=function(stream){console.log('someoneconnected!');};server.on('connection',callback);//...server.removeListener('connection',callback);`||5|**removeAllListeners([event])**移除所有事件的所有监听器，如果指定事件，则移除指定事件的所有监听器。||6|**setMaxListeners(n)**默认情况下，EventEmitters如果你添加的监听器超过10个就会输出警告信息。setMaxListeners函数用于提高监听器的默认限制的数量。||7|**listeners(event)**返回指定事件的监听器数组。||8|**emit(event,[arg1],[arg2],[...])**按监听器的顺序执行执行每个监听器，如果事件有注册监听返回true，否则返回false。|###事件|序号|事件&描述||:---|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------||1|**newListener****event**-字符串，事件名称**listener**-处理事件函数该事件在添加新监听器时被触发。||2|**removeListener****event**-字符串，事件名称**listener**-处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。|###实例main.js```jsvarevents=require('events');vareventEmitter=newevents.EventEmitter();//监听器#1varlistener1=functionlistener1(){console.log('监听器listener1执行。');}//监听器#2varlistener2=functionlistener2(){console.log('监听器listener2执行。');}//绑定connection事件，处理函数为listener1eventEmitter.addListener('connection',listener1);//绑定connection事件，处理函数为listener2eventEmitter.on('connection',listener2);vareventListeners=eventEmitter.listenerCount('connection');console.log(eventListeners+\"个监听器监听连接事件。\");//处理connection事件eventEmitter.emit('connection');//移除监绑定的listener1函数eventEmitter.removeListener('connection',listener1);console.log(\"listener1不再受监听。\");//触发连接事件eventEmitter.emit('connection');eventListeners=eventEmitter.listenerCount('connection');console.log(eventListeners+\"个监听器监听连接事件。\");console.log(\"程序执行完毕。\");执行结果:$nodemain.js2个监听器监听连接事件。监听器listener1执行。监听器listener2执行。listener1不再受监听。监听器listener2执行。1个监听器监听连接事件。程序执行完毕。```---##Buffer(缓冲区)>-JavaScript语言自身只有字符串数据类型，没有二进制数据类型。>-但在处理像TCP流或文件流时，必须使用到二进制数据。因此在Node.js中，定义了一个Buffer类，该类用来创建一个专门存放二进制数据的缓存区。>-在Node.js中，Buffer类是随Node内核一起发布的核心库。Buffer库为Node.js带来了一种存储原始数据的方法，可以让Node.js处理二进制数据，每当需要在Node.js中处理I/O操作中移动的数据时，就有可能使用Buffer库。原始数据存储在Buffer类的实例中。一个Buffer类似于一个整数数组，但它对应于V8堆内存之外的一块原始内存。###node支持的字符编码>-**ascii**-仅支持7位ASCII数据。如果设置去掉高位的话，这种编码是非常快的。>-==**utf8**-多字节编码的Unicode字符。许多网页和其他文档格式都使用UTF-8。==>-**utf16le**-2或4个字节，小字节序编码的Unicode字符。支持代理对（U+10000至U+10FFFF）。>-**ucs2**-**utf16le**的别名。>-**base64**-Base64编码。>-**latin1**-一种把**Buffer**编码成一字节编码的字符串的方式。>-**binary**-**latin1**的别名。>-**hex**-将每个字节编码为两个十六进制字符。eg:```jsconstbuf=Buffer.from('runoob','ascii')//输出72756e6f6f62console.log(buf.toString('hex'))//输出cnVub29iconsole.log(buf.toString('base64'))```###创建Buffer类>Buffer提供了以下API来创建Buffer类：>>-**Buffer.alloc(size[,fill[,encoding]])：**返回一个指定大小的Buffer实例，如果没有设置fill，则默认填满0>-**Buffer.allocUnsafe(size)：**返回一个指定大小的Buffer实例，但是它不会被初始化，所以它可能包含敏感的数据>-**Buffer.allocUnsafeSlow(size)**>-**Buffer.from(array)：**返回一个被array的值初始化的新的Buffer实例（传入的array的元素只能是数字，不然就会自动被0覆盖）>-**Buffer.from(arrayBuffer[,byteOffset[,length]])：**返回一个新建的与给定的ArrayBuffer共享同一内存的Buffer。>-**Buffer.from(buffer)：**复制传入的Buffer实例的数据，并返回一个新的Buffer实例>-**Buffer.from(string[,encoding])：**返回一个被string的值初始化的新的Buffer实例```js//创建一个长度为10、且用0填充的Buffer。constbuf1=Buffer.alloc(10)//创建一个长度为10、且用0x1填充的Buffer。constbuf2=Buffer.alloc(10,1)//创建一个长度为10、且未初始化的Buffer。//这个方法比调用Buffer.alloc()更快，//但返回的Buffer实例可能包含旧数据，//因此需要使用fill()或write()重写。constbuf3=Buffer.allocUnsafe(10)//创建一个包含[0x1,0x2,0x3]的Buffer。constbuf4=Buffer.from([1,2,3])//创建一个包含UTF-8字节[0x74,0xc3,0xa9,0x73,0x74]的Buffer。constbuf5=Buffer.from('tést')//创建一个包含Latin-1字节[0x74,0xe9,0x73,0x74]的Buffer。constbuf6=Buffer.from('tést','latin1')```###写入缓存区```jsbuf.write(string[,offset[,length]][,encoding])```>-**string**-写入缓冲区的字符串。>-**offset**-缓冲区开始写入的索引值，默认为0。>-**length**-写入的字节数，默认为buffer.length>-**encoding**-使用的编码。默认为'utf8'。```jsbuf=Buffer.alloc(256)len=buf.write('www.ruihuag.com')console.log('写入字节数:'+len)```执行以上代码，输出结果为：```js$nodemain.js写入字节数:14```###从缓存区读取数据```jsbuf.toString([encoding[,start[,end]]])```>-**encoding**-使用的编码。默认为'utf8'。>-**start**-指定开始读取的索引位置，默认为0。>-**end**-结束位置，默认为缓冲区的末尾。```jsbuf=Buffer.alloc(26);for(vari=0;i<26;i++){buf[i]=i+97;}console.log(buf.toString('ascii'));//输出:abcdefghijklmnopqrstuvwxyzconsole.log(buf.toString('ascii',0,5));//使用'ascii'编码,并输出:abcdeconsole.log(buf.toString('utf8',0,5));//使用'utf8'编码,并输出:abcdeconsole.log(buf.toString(undefined,0,5));//使用默认的'utf8'编码,并输出:abcde$nodemain.jsabcdefghijklmnopqrstuvwxyzabcdeabcdeabcde```###将Buffer转换为JSON对象```jsbuf.toJSON()```>当字符串化一个Buffer实例时，`JSON.stringify()`会隐式地调用该**toJSON()**。```jsconstbuf=Buffer.from([0x1,0x2,0x3,0x4,0x5]);constjson=JSON.stringify(buf);//输出:{\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}console.log(json);constcopy=JSON.parse(json,(key,value)=>{returnvalue&&value.type==='Buffer'?Buffer.from(value.data):value;});//输出:<Buffer0102030405>console.log(copy);执行结果{\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}<Buffer0102030405>```###缓存区合并```jsBuffer.concat(list[,totalLength])```>-**list**-用于合并的Buffer对象数组列表。>-**totalLength**-指定合并后Buffer对象的总长度。eg;```jsvarbuffer1=Buffer.from(('grh'));varbuffer2=Buffer.from(('www.ruihuag.com'));varbuffer3=Buffer.concat([buffer1,buffer2]);console.log(\"buffer3内容:\"+buffer3.toString());输出:buffer3内容:grhwww.ruihuag.com```###缓存区比较```jsbuf.compare(otherBuffer)```>**otherBuffer**-与**buf**对象比较的另外一个Buffer对象。//返回一个数字eg:```jsvarbuffer1=Buffer.from('ABC')varbuffer2=Buffer.from('ABCD')varresult=buffer1.compare(buffer2)if(result<0){console.log(buffer1+'在'+buffer2+'之前')}elseif(result==0){console.log(buffer1+'与'+buffer2+'相同')}else{console.log(buffer1+'在'+buffer2+'之后')}输出ABC在ABCD之前```###拷贝缓存区```jsbuf.copy(targetBuffer[,targetStart[,sourceStart[,sourceEnd]]])```>-**targetBuffer**-要拷贝的Buffer对象。>-**targetStart**-数字,可选,默认:0>-**sourceStart**-数字,可选,默认:0>-**sourceEnd**-数字,可选,默认:buffer.length>-没有返回值eg:```jsvarbuf1=Buffer.from('abcdefghijkl')varbuf2=Buffer.from('RUNOOB')//将buf2插入到buf1指定位置上buf2.copy(buf1,2)console.log(buf1.toString())结果:abRUNOOBijkl```###缓存区裁剪```jsbuf.slice([start[,end]])```>-**start**-数字,可选,默认:0>-**end**-数字,可选,默认:buffer.length```jsvarbuffer1=Buffer.from('runoob');//剪切缓冲区varbuffer2=buffer1.slice(0,2);console.log(\"buffer2content:\"+buffer2.toString());结果:buffer2content:ru```###缓存区长度buf.length###方法参考手册|序号|方法&描述||:---|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||1|**newBuffer(size)**分配一个新的size大小单位为8位字节的buffer。注意,size必须小于kMaxLength，否则，将会抛出异常RangeError。废弃的:使用Buffer.alloc()代替（或Buffer.allocUnsafe()）。||2|**newBuffer(buffer)**拷贝参数buffer的数据到Buffer实例。废弃的:使用Buffer.from(buffer)代替。||3|**newBuffer(str[,encoding])**分配一个新的buffer，其中包含着传入的str字符串。encoding编码方式默认为'utf8'。废弃的:使用Buffer.from(string[,encoding])代替。||4|**buf.length**返回这个buffer的bytes数。注意这未必是buffer里面内容的大小。length是buffer对象所分配的内存数，它不会随着这个buffer对象内容的改变而改变。||5|**`buf.write(string[,offset[,length]][,encoding])`**根据参数offset偏移量和指定的encoding编码方式，将参数string数据写入buffer。offset偏移量默认值是0,encoding编码方式默认是utf8。length长度是将要写入的字符串的bytes大小。返回number类型，表示写入了多少8位字节流。如果buffer没有足够的空间来放整个string，它将只会只写入部分字符串。length默认是buffer.length-offset。这个方法不会出现写入部分字符。||6|**buf.writeUIntLE(value,offset,byteLength[,noAssert])**将value写入到buffer里，它由offset和byteLength决定，最高支持48位无符号整数，小端对齐，例如：`constbuf=Buffer.allocUnsafe(6);buf.writeUIntLE(0x1234567890ab,0,6);//输出:console.log(buf);`noAssert值为true时，不再验证value和offset的有效性。默认是false。||7|**buf.writeUIntBE(value,offset,byteLength[,noAssert])**将value写入到buffer里，它由offset和byteLength决定，最高支持48位无符号整数，大端对齐。noAssert值为true时，不再验证value和offset的有效性。默认是false。`constbuf=Buffer.allocUnsafe(6);buf.writeUIntBE(0x1234567890ab,0,6);//输出:console.log(buf);`||8|**buf.writeIntLE(value,offset,byteLength[,noAssert])**将value写入到buffer里，它由offset和byteLength决定，最高支持48位有符号整数，小端对齐。noAssert值为true时，不再验证value和offset的有效性。默认是false。||9|**buf.writeIntBE(value,offset,byteLength[,noAssert])**将value写入到buffer里，它由offset和byteLength决定，最高支持48位有符号整数，大端对齐。noAssert值为true时，不再验证value和offset的有效性。默认是false。||10|**buf.readUIntLE(offset,byteLength[,noAssert])**支持读取48位以下的无符号数字，小端对齐。noAssert值为true时，offset不再验证是否超过buffer的长度，默认为false。||11|**buf.readUIntBE(offset,byteLength[,noAssert])**支持读取48位以下的无符号数字，大端对齐。noAssert值为true时，offset不再验证是否超过buffer的长度，默认为false。||12|**buf.readIntLE(offset,byteLength[,noAssert])**支持读取48位以下的有符号数字，小端对齐。noAssert值为true时，offset不再验证是否超过buffer的长度，默认为false。||13|**buf.readIntBE(offset,byteLength[,noAssert])**支持读取48位以下的有符号数字，大端对齐。noAssert值为true时，offset不再验证是否超过buffer的长度，默认为false。||14|**buf.toString([encoding[,start[,end]]])**根据encoding参数（默认是'utf8'）返回一个解码过的string类型。还会根据传入的参数start(默认是0)和end(默认是buffer.length)作为取值范围。||15|**buf.toJSON()**将Buffer实例转换为JSON对象。||16|**buf[index]**获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF或者十进制0至255。||17|**buf.equals(otherBuffer)**比较两个缓冲区是否相等，如果是返回true，否则返回false。||18|**buf.compare(otherBuffer)**比较两个Buffer对象，返回一个数字，表示buf在otherBuffer之前，之后或相同。||19|**buf.copy(targetBuffer[,targetStart[,sourceStart[,sourceEnd]]])**buffer拷贝，源和目标可以相同。targetStart目标开始偏移和sourceStart源开始偏移默认都是0。sourceEnd源结束位置偏移默认是源的长度buffer.length。||20|**buf.slice([start[,end]])**剪切Buffer对象，根据start(默认是0)和end(默认是buffer.length)偏移和裁剪了索引。负的索引是从buffer尾部开始计算的。||21|**buf.readUInt8(offset[,noAssert])**根据指定的偏移量，读取一个无符号8位整数。若参数noAssert为true将不会验证offset偏移量参数。如果这样offset可能会超出buffer的末尾。默认是false。||22|**buf.readUInt16LE(offset[,noAssert])**根据指定的偏移量，使用特殊的endian字节序格式读取一个无符号16位整数。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||23|**buf.readUInt16BE(offset[,noAssert])**根据指定的偏移量，使用特殊的endian字节序格式读取一个无符号16位整数，大端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||24|**buf.readUInt32LE(offset[,noAssert])**根据指定的偏移量，使用指定的endian字节序格式读取一个无符号32位整数，小端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||25|**buf.readUInt32BE(offset[,noAssert])**根据指定的偏移量，使用指定的endian字节序格式读取一个无符号32位整数，大端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||26|**buf.readInt8(offset[,noAssert])**根据指定的偏移量，读取一个有符号8位整数。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||27|**buf.readInt16LE(offset[,noAssert])**根据指定的偏移量，使用特殊的endian格式读取一个有符号16位整数，小端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||28|**buf.readInt16BE(offset[,noAssert])**根据指定的偏移量，使用特殊的endian格式读取一个有符号16位整数，大端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||29|**buf.readInt32LE(offset[,noAssert])**根据指定的偏移量，使用指定的endian字节序格式读取一个有符号32位整数，小端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||30|**buf.readInt32BE(offset[,noAssert])**根据指定的偏移量，使用指定的endian字节序格式读取一个有符号32位整数，大端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||31|**buf.readFloatLE(offset[,noAssert])**根据指定的偏移量，使用指定的endian字节序格式读取一个32位双浮点数，小端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||32|**buf.readFloatBE(offset[,noAssert])**根据指定的偏移量，使用指定的endian字节序格式读取一个32位双浮点数，大端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||33|**buf.readDoubleLE(offset[,noAssert])**根据指定的偏移量，使用指定的endian字节序格式读取一个64位双精度数，小端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||34|**buf.readDoubleBE(offset[,noAssert])**根据指定的偏移量，使用指定的endian字节序格式读取一个64位双精度数，大端对齐。若参数noAssert为true将不会验证offset偏移量参数。这意味着offset可能会超出buffer的末尾。默认是false。||35|**buf.writeUInt8(value,offset[,noAssert])**根据传入的offset偏移量将value写入buffer。注意：value必须是一个合法的无符号8位整数。若参数noAssert为true将不会验证offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则不要使用。默认是false。||36|**buf.writeUInt16LE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：value必须是一个合法的无符号16位整数，小端对齐。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||37|**buf.writeUInt16BE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：value必须是一个合法的无符号16位整数，大端对齐。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||38|**buf.writeUInt32LE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式(LITTLE-ENDIAN:小字节序)将value写入buffer。注意：value必须是一个合法的无符号32位整数，小端对齐。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||39|**buf.writeUInt32BE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式(Big-Endian:大字节序)将value写入buffer。注意：value必须是一个合法的有符号32位整数。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||40|**buf.writeInt8(value,offset[,noAssert])**||41|**buf.writeInt16LE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：value必须是一个合法的signed16位整数。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||42|**buf.writeInt16BE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：value必须是一个合法的signed16位整数。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||43|**buf.writeInt32LE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：value必须是一个合法的signed32位整数。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||44|**buf.writeInt32BE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：value必须是一个合法的signed32位整数。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||45|**buf.writeFloatLE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：当value不是一个32位浮点数类型的值时，结果将是不确定的。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||46|**buf.writeFloatBE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：当value不是一个32位浮点数类型的值时，结果将是不确定的。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||47|**buf.writeDoubleLE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：value必须是一个有效的64位double类型的值。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||48|**buf.writeDoubleBE(value,offset[,noAssert])**根据传入的offset偏移量和指定的endian格式将value写入buffer。注意：value必须是一个有效的64位double类型的值。若参数noAssert为true将不会验证value和offset偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成value被丢弃。除非你对这个参数非常有把握，否则尽量不要使用。默认是false。||49|**`buf.fill(value[,offset][,end])`**使用指定的value来填充这个buffer。如果没有指定offset(默认是0)并且end(默认是buffer.length)，将会填充整个buffer。|##Stream(流)>**Stream四种类型**>>-Readable\\*\\*-可读操作。>-**Writable**-可写操作。>-**Duplex**-可读可写操作.>-**Transform**-操作被写入数据，然后读出结果。>>所有的Stream对象都是EventEmitter的实例。>>常用的事件有：>>-**data**-当有数据可读时触发。>-**end**-没有更多的数据可读时触发。>-**error**-在接收和写入过程中发生错误时触发。>-**finish**-所有数据已被写入到底层系统时触发。###从流中读取数据input.js```txtgrh```main.js```jsvarfs=require(\"fs\");vardata='';//创建可读流varreaderStream=fs.createReadStream('input.txt');//设置编码为utf8。readerStream.setEncoding('UTF8');//处理流事件-->data,end,anderrorreaderStream.on('data',function(chunk){data+=chunk;});readerStream.on('end',function(){console.log(data);});readerStream.on('error',function(err){console.log(err.stack);});console.log(\"程序执行完毕\");结果:程序执行完毕grh官网地址：www.runoob.com```###写入流main.js```jsvarfs=require('fs')vardata='grh官网地址：www.runoob.com'//创建一个可以写入的流，写入到文件output.txt中varwriterStream=fs.createWriteStream('output.txt')//使用utf8编码写入数据writerStream.write(data,'UTF8')//标记文件末尾writerStream.end()//处理流事件-->data,end,anderrorwriterStream.on('finish',function(){console.log('写入完成。')})writerStream.on('error',function(err){console.log(err.stack)})console.log('程序执行完毕')结果程序执行完毕写入完成```###管道流>-一个输出流流到流入的机制>-我们用于从一个流中获取数据并将数据传递到另一个流中>-可以慢慢的实现大文件的复制过程```jsvarfs=require('fs')//创建一个可读流varreaderStream=fs.createReadStream('input.txt')//创建一个可写流varwriterStream=fs.createWriteStream('output.txt')//管道读写操作//读取input.txt文件内容，并将内容写入到output.txt文件中readerStream.pipe(writerStream)console.log('程序执行完毕')```###链式流>-一般用于管道操作>-通过连接输出流到另外一个流并创建多个流操作链的机制```js//compress.js压缩文件varfs=require('fs')varzlib=require('zlib')//压缩input.txt文件为input.txt.gzfs.createReadStream('input.txt').pipe(zlib.createGzip()).pipe(fs.createWriteStream('input.txt.gz'))console.log('文件压缩完成。')``````js//decompress.js解压文件varfs=require('fs')varzlib=require('zlib')//解压input.txt.gz文件为input.txtfs.createReadStream('input.txt.gz').pipe(zlib.createGunzip()).pipe(fs.createWriteStream('input.txt'))console.log('文件解压完成。')```##模块系统>**exports和module.exports的使用**>>-如果要对外暴露属性或方法，就用**exports**就行，要暴露对象(类似class，包含了很多属性和方法)，就用**module.exports**。>-不用同时使用两个###创建模块自封装一个对象```jsmodule.exports=function(){//...}//hello.jsfunctionHello(){varnamethis.setName=function(thyName){name=thyName}this.sayHello=function(){console.log('Hello'+name)}}module.exports=Hello//main.jsvarHello=require('./hello')hello=newHello()hello.setName('BYVoid')hello.sayHello()```hello.js```jsexports.world=function(){console.log('HelloWorld')}```main.js```jsvarhello=require('./hello')hello.world()```###服务器的模块```jsvarhttp=require(\"http\");...http.createServer(...);```####require方法执行过程<imgsrc=\"https://images.gitee.com/uploads/images/2020/0601/215608_19475bd4_6545143.png\"style=\"zoom:50%;\"/>##函数>函数中传输参数的地方可以直接定义函数>>```js>functionsay(word){>console.log(word)>}>>functionexecute(someFunction,value){>someFunction(value)>}>>execute(say,'Hello')>```###匿名函数>我们可以把一个函数作为变量传递。>>但是我们不一定要绕这个\"==先定义，再传递==\"的圈子，>>我们可以直接在另一个函数的括号中定义和传递这个函数：```jsfunctionexecute(someFunction,value){someFunction(value)}execute(function(word){console.log(word)},'Hello')```###函数传递是如何让HTTP服务器工作的```jsvarhttp=require('http')http.createServer(function(request,response){response.writeHead(200,{'Content-Type':'text/plain'})response.write('HelloWorld')response.end()}).listen(8888)``````jsvarhttp=require('http')functiononRequest(request,response){response.writeHead(200,{'Content-Type':'text/plain'})response.write('HelloWorld')response.end()}http.createServer(onRequest).listen(8888)```###路由<imgsrc=\"https://images.gitee.com/uploads/images/2020/0601/223037_4fbde394_6545143.png\"style=\"zoom:50%;\"/>server.js```jsvarhttp=require('http')varurl=require('url')functionstart(){functiononRequest(request,response){varpathname=url.parse(request.url).pathnameconsole.log('Requestfor'+pathname+'received.')response.writeHead(200,{'Content-Type':'text/plain'})response.write('HelloWorld')response.end()}http.createServer(onRequest).listen(8888)console.log('Serverhasstarted.')}exports.start=start```router.js```jsfunctionroute(pathname){console.log('Abouttoroutearequestfor'+pathname)}exports.route=route```index.js```jsvarserver=require('./server')varrouter=require('./router')server.start(router.route)```启动```shell$nodeindex.jsServerhasstarted.```浏览器访问**<http://127.0.0.1:8888/>**##全局对象>-在程序的任何地方都可以访问,即全局变量>-通常window是全局对象,node中的全局对象是global>-按照ECMAScript定义,全局变量的条件:>-在最外层定义的变量>-全局对象的属性>-隐式定义的变量(未定义直接赋值的变量)>-不要使用var定义变量,全局变量会污染命名空间###\\_\\_filename>-表示当前正在执行的脚本的文件名>-输出文件说在位置的绝对路径>-如果是在模块中,返回的值是模块文件的路径main.js```js//输出全局变量__filename的值console.log(__filename);执行:$nodemain.js/web/com/runoob/nodejs/main.js```###\\_\\_dirname>表示当前执行脚本说在的目录main.js```js//输出全局变量__dirname的值console.log(__dirname);执行main.js文件，代码如下所示:输出:$nodemain.js/web/com/runoob/nodejs```###clearTimeout(t)>-全局函数用于停止一个之前通过setTimeout()创建的定时器。>-参数**t**是通过setTimeout()函数创建的定时器。```jsfunctionprintHello(){console.log('Hello,World!')}//两秒后执行以上函数vart=setTimeout(printHello,2000)//清除定时器clearTimeout(t)```###setInterval(cb,ms)>-指定在每ms数执行>-直到clearInterval()被调用或窗口关闭```jsfunctionprintHello(){console.log('Hello,World!')}//两秒后执行以上函数setInterval(printHello,2000)```###console>console用于提供控制台标准输出，它是由InternetExplorer的JScript引擎提供的调试工具，后来逐渐成为浏览器的实施标准。>>Node.js沿用了这个标准，提供与习惯行为一致的console对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。|序号|方法&描述||:---|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||1|**`console.log([data][,...])`**向标准输出流打印字符并以换行符结束。该方法接收若干个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则以类似于C语言printf()命令的格式输出。||2|**`console.info([data][,...])`**该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。||3|**`console.error([data][,...])`**输出错误消息的。控制台在出现错误时会显示是红色的叉子。||4|**`console.warn([data][,...])`**输出警告消息。控制台出现有黄色的惊叹号。||5|**console.dir(obj[,options])**用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。||6|**console.time(label)**输出时间，表示计时开始。||7|**console.timeEnd(label)**结束时间，表示计时结束。||8|**console.trace(message[,...])**当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入console.trace就行了。||9|**`console.assert(value[,message][,...])`**用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。|####console.log()```jsconsole.log('Helloworld');console.log('byvoid%diovyb');console.log('byvoid%diovyb',1991);运行结果:Helloworldbyvoid%diovybbyvoid1991iovyb```####console.error()>与console.log()用法相同，只是向标准错误流输出。####console.trace()>向标准流输出当前的调用栈```jsconsole.trace()Trace:atObject.<anonymous>(/home/byvoid/consoletrace.js:1:71)atModule._compile(module.js:441:26)atObject..js(module.js:459:10)atModule.load(module.js:348:31)atFunction._load(module.js:308:12)atArray.0(module.js:479:10)atEventEmitter._tickCallback(node.js:192:40)```eg:```jsconsole.info(\"程序开始执行：\");varcounter=10;console.log(\"计数:%d\",counter);console.time(\"获取数据\");////执行一些代码//console.timeEnd('获取数据');console.info(\"程序执行完毕。\")$nodemain.js程序开始执行：计数:10获取数据:0ms程序执行完毕```###process>-全局变量,即global对象属性|序号|事件&描述||:---|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------||1|**exit**当进程准备退出时触发。||2|**beforeExit**当node清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时node退出，但是'beforeExit'的监听器可以异步调用，这样node就会继续执行。||3|**uncaughtException**当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。||4|**Signal事件**当进程接收到信号时就触发。信号列表详见标准的POSIX信号名，如SIGINT、SIGUSR1等。|```jsprocess.on('exit',function(code){//以下代码永远不会执行setTimeout(function(){console.log(\"该代码不会执行\");},0);console.log('退出码为:',code);});console.log(\"程序执行结束\")$nodemain.js程序执行结束退出码为:0```####退出状态码|状态码|名称&描述||:-----|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||1|**UncaughtFatalException**有未捕获异常，并且没有被域或uncaughtException处理函数处理。||2|**Unused**保留||3|**InternalJavaScriptParseError**JavaScript的源码启动Node进程时引起解析错误。非常罕见，仅会在开发Node时才会有。||4|**InternalJavaScriptEvaluationFailure**JavaScript的源码启动Node进程，评估时返回函数失败。非常罕见，仅会在开发Node时才会有。||5|**FatalError**V8里致命的不可恢复的错误。通常会打印到stderr，内容为：FATALERROR||6|**Non-functionInternalExceptionHandler**未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。||7|**InternalExceptionHandlerRun-TimeFailure**未捕获的异常，并且异常处理函数处理时自己抛出了异常。例如，如果process.on('uncaughtException')或domain.on('error')抛出了异常。||8|**Unused**保留||9|**InvalidArgument**可能是给了未知的参数，或者给的参数没有值。||10|**InternalJavaScriptRun-TimeFailure**JavaScript的源码启动Node进程时抛出错误，非常罕见，仅会在开发Node时才会有。||12|**InvalidDebugArgument**设置了参数--debug和/或--debug-brk，但是选择了错误端口。||128|**SignalExits**如果Node接收到致命信号，比如SIGKILL或SIGHUP，那么退出代码就是128加信号代码。这是标准的Unix做法，退出信号代码放在高位。|####Process属性|序号.|属性&描述||:----|:---------------------------------------------------------------------------------------------------------------------------------------------||1|**stdout**标准输出流。||2|**stderr**标准错误流。||3|**stdin**标准输入流。||4|**argv**argv属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。||5|**execPath**返回执行当前脚本的Node二进制文件的绝对路径。||6|**execArgv**返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。||7|**env**返回一个对象，成员为当前shell的环境变量||8|**exitCode**进程退出时的代码，如果进程优通过process.exit()退出，不需要指定退出码。||9|**version**Node的版本，比如v0.10.18。||10|**versions**一个属性，包含了node的版本和依赖.||11|**config**一个包含用来编译当前node执行文件的javascript配置选项的对象。它与运行./configure脚本生成的\"config.gypi\"文件相同。||12|**pid**当前进程的进程号。||13|**title**进程名，默认值为\"node\"，可以自定义该值。||14|**arch**当前CPU的架构：'arm'、'ia32'或者'x64'。||15|**platform**运行程序所在的平台系统'darwin','freebsd','linux','sunos'或'win32'||16|**mainModule**require.main的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。|```js//输出到终端process.stdout.write(\"HelloWorld!\"+\"\\n\");//通过参数读取process.argv.forEach(function(val,index,array){console.log(index+':'+val);});//获取执行路径console.log(process.execPath);//平台信息console.log(process.platform);$nodemain.jsHelloWorld!0:node1:/web/www/node/main.js/usr/local/node/0.10.36/bin/nodedarwin```####方法参考手册|序号|方法&描述||:---|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||1|**abort()**这将导致node触发abort事件。会让node退出并生成一个核心文件。||2|**chdir(directory)**改变当前工作进程的目录，如果操作失败抛出异常。||3|**cwd()**返回当前进程的工作目录||4|**exit([code])**使用指定的code结束进程。如果忽略，将会使用code0。||5|**getgid()**获取进程的群组标识（参见getgid(2)）。获取到得时群组的数字id，而不是名字。注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。||6|**setgid(id)**设置进程的群组标识（参见setgid(2)）。可以接收数字ID或者群组名。如果指定了群组名，会阻塞等待解析为数字ID。注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。||7|**getuid()**获取进程的用户标识(参见getuid(2))。这是数字的用户id，不是用户名。注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。||8|**setuid(id)**设置进程的用户标识（参见setuid(2)）。接收数字ID或字符串名字。果指定了群组名，会阻塞等待解析为数字ID。注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。||9|**getgroups()**返回进程的群组iD数组。POSIX系统没有保证一定有，但是node.js保证有。注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。||10|**setgroups(groups)**设置进程的群组ID。这是授权操作，所以你需要有root权限，或者有CAP_SETGID能力。注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。||11|**initgroups(user,extra_group)**读取/etc/group，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有root权限，或者有CAP_SETGID能力。注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。||12|**kill(pid[,signal])**发送信号给进程.pid是进程id，并且signal是发送的信号的字符串描述。信号名是字符串，比如'SIGINT'或'SIGHUP'。如果忽略，信号会是'SIGTERM'。||13|**memoryUsage()**返回一个对象，描述了Node进程所用的内存状况，单位为字节。||14|**nextTick(callback)**一旦当前事件循环结束，调用回调函数。||15|**umask([mask])**设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask参数有效，返回旧的掩码。否则，返回当前掩码。||16|**uptime()**返回Node已经运行的秒数。||17|**hrtime()**返回当前进程的高分辨时间，形式为[seconds,nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的process.hrtime()，会返回两者间的时间差，用来基准和测量时间间隔。|```js//输出当前目录console.log('当前目录:'+process.cwd());//输出当前版本console.log('当前版本:'+process.version);//输出内存使用情况console.log(process.memoryUsage());$nodemain.js当前目录:/web/com/runoob/nodejs当前版本:v0.10.36{rss:12541952,heapTotal:4083456,heapUsed:2157056}```##常用工具###util`consturil=require('util')`####util.callbackify>util.callbackify(orginal)将async异步函数(或者一个返回值为Promise的函数)转换为遵循`异常优先回调风格`的函数,例如将(err,value)=>...回调作为最后一个参数.在回答函数中,第一个参数为拒绝的原因(如果Promise解决,则为null),第二个参数则是解决的值.```jsconstutil=require('util');asyncfunctionfn(){return'helloworld';}constcallbackFunction=util.callbackify(fn);callbackFunction((err,ret)=>{if(err)throwerr;console.log(ret);})执行结果:helloworld```>-回调函数是异步执行的，并且有异常堆栈错误追踪。如果回调函数抛出一个异常，进程会触发一个'uncaughtException'异常，如果没有被捕获，进程将会退出。>-null在回调函数中作为一个参数有其特殊的意义，如果回调函数的首个参数为Promise拒绝的原因且带有返回值，且值可以转换成布尔值false，这个值会被封装在Error对象里，可以通过属性reason获取```jsfunctionfn(){returnPromise.reject(null)}constcallbackFunction=util.callbackify(fn)callbackFunction((err,ret)=>{//当Promise被以`null`拒绝时，它被包装为Error并且原始值存储在`reason`中。err&&err.hasOwnProperty('reason')&&err.reason===null//true})```>original为async异步函数,改函数返回传统回调函数####util.inherits>-util.inherits(constructor,superConstructor)是一个实现对象间原型继承的函数>-javaScript的面向对象特性是基于原型的,与常见的基于类的不同.>-JavaScript没有提供对象继承的语言级别特性,而是通过原型复制来实现的.```jsvarutil=require('util');funcitonBase(){this.name='base';this.base='1999';this.sayHello=function(){console.log('Hello'+this.name);};}Base.prototype.showName=function(){console.log(this.name);}functionSub(){this.name='sub';}util.inherits(Sub,Base);//这里实现了sub继承了BasevarobjBase=newBase();objBase.showname();objBase.sayHello();console.log(objBase);varobjSub=newSub();objSub.showName();//objSub.sayHello();console.log(objSub);```>-定义一个基础对象Base和一个继承自Base的Sub,Base有三个构造函数类定义的属性和一个原型中定义的函数,>-通过util.inherits实现继承```js执行结果baseHellobase{name:'base',base:1999,sayHello:[Funciton]}sub{name:'sub'}```>-sub仅仅继承了Base在原型中定义的函数>-而构造函数内部创造函数内部创造的base属性和sayHello函数都没有被Sub继承>-==在原型定义的属性不会被console.log作为对象的属性输出==>-可以继承原型方法####util.inspect>-`util.inspect(object,[showHidden],[depth],[colors])`>-将任意对象转换为字符串的方法,通常用于挑食和错误输出>-至少接受一个参数object,即要转换的对象>-showHidden:可选,如果为true,会输出更多隐藏信息>-depth表示最大的层次,>-如果对象很复杂,你可以指定成熟以控制输出信息的多少.>-如果不指定depth,默认会递归2层,>-指定为null表示不递归成熟完成遍历对象>-colors值true,输出格式将会ANSI编码,通常用于在终端显示更加漂亮的效果```jsvarutil=require('util');functionPerson(){this.name='byvoid';this.toString=function(){returnthis.name;};}varobj=newPerson();console.log(util.inspect(obj));console.log(util.inspect(obj,true));运行结果:Person{name:'byvoid',toString:[Function]}Person{name:'byvoid',toString:{[Function][length]:0,[name]:'',[arguments]:null,[caller]:null,[prototype]:{[constructor]:[Circular]}}}```|方法|描述||---------------------|--------------||util.isArray(object)|是数组返回true||util.isRegExp(object)|是正则返回true||util.isDate(object)|是日期返回true|##文件系统>-`varfs=require(\"fs\")`>-node有异步[fs.readFile()]和同步[fs.readFileSync()]两个版本>-异步方法函数最后一个参数为回调函数,会带函数的第一个参数包含错误信息(error)>-建议使用异步file.js```jsvarfs=require('fs')//异步读取fs.readFIle('input.txt',function(err,data){if(err){returnconsole.error(err)}console.log('异步读取:'+data.toString())})//同步读取vardata=fs.readFileSync('input.txt')console.log('同步读取:'+data.toString())console.log('程序执行完毕')```###打开文件>异步模式打开文件的语法:`fs.open(path,flags[,model],callback)`>>-flags:文件的打开行为>-mode:设置文件模式(权限),文件创建默认权限为0666(可读可写)>-callback:回调函数,带有两个参数:callback(err,fd)flags参数|Flag|描述||:---|:---------------------------------------------------||r|以读取模式打开文件。如果文件不存在抛出异常。||r+|以读写模式打开文件。如果文件不存在抛出异常。||rs|以同步的方式读取文件。||rs+|以同步的方式读取和写入文件。||w|以写入模式打开文件，如果文件不存在则创建。||wx|类似'w'，但是如果文件路径存在，则文件写入失败。||w+|以读写模式打开文件，如果文件不存在则创建。||wx+|类似'w+'，但是如果文件路径存在，则文件读写失败。||a|以追加模式打开文件，如果文件不存在则创建。||ax|类似'a'，但是如果文件路径存在，则文件追加失败。||a+|以读取追加模式打开文件，如果文件不存在则创建。||ax+|类似'a+'，但是如果文件路径存在，则文件读取追加失败|```jsvarfs=require('fs')//异步打开文件console.log('准备打开文件！')fs.open('input.txt','r+',function(err,fd){if(err){returnconsole.error(err)}console.log('文件打开成功！')})```###获取文件信息>-`fs.stat(path,callback)`>-callback:回调函数,带有两个参数(err,stats),stats是fs.Stats对象```js//fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。例如判断是否为文件：varfs=require('fs')fs.stat('/Users/liuht/code/itbilu/demo/fs.js',function(err,stats){console.log(stats.isFile())//true})```stats类中的方法|方法|描述||:------------------------|:---------------------------------------------------------------------------||stats.isFile()|如果是文件返回true，否则返回false。||stats.isDirectory()|如果是目录返回true，否则返回false。||stats.isBlockDevice()|如果是块设备返回true，否则返回false。||stats.isCharacterDevice()|如果是字符设备返回true，否则返回false。||stats.isSymbolicLink()|如果是软链接返回true，否则返回false。||stats.isFIFO()|如果是FIFO，返回true，否则返回false。FIFO是UNIX中的一种特殊类型的命令管道。||stats.isSocket()|如果是Socket返回true，否则返回false。|```jsvarfs=require(\"fs\");console.log(\"准备打开文件！\");fs.stat('input.txt',function(err,stats){if(err){returnconsole.error(err);}console.log(stats);console.log(\"读取文件信息成功！\");//检测文件类型console.log(\"是否为文件(isFile)?\"+stats.isFile());console.log(\"是否为目录(isDirectory)?\"+stats.isDirectory());});运行结果:$nodefile.js准备打开文件！{dev:16777220,mode:33188,nlink:1,uid:501,gid:20,rdev:0,blksize:4096,ino:40333161,size:61,blocks:8,atime:MonSep07201517:43:55GMT+0800(CST),mtime:MonSep07201517:22:35GMT+0800(CST),ctime:MonSep07201517:22:35GMT+0800(CST)}读取文件信息成功！是否为文件(isFile)?true是否为目录(isDirectory)?false```###写入文件>-`fs.writeFile(file,data[,options],callback)`>-打开方式默认w模式(文件存在写入内容会覆盖)>-**file**-文件名或文件描述符。>-**data**-要写入文件的数据，可以是String(字符串)或Buffer(缓冲)对象。>-**options**-该参数是一个对象，包含{encoding,mode,flag}。默认编码为utf8,模式为0666，flag为'w'>-**callback**-回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。```jsvarfs=require(\"fs\");console.log(\"准备写入文件\");fs.writeFile('input.txt','我是通过fs.writeFile写入文件的内容',function(err){if(err){returnconsole.error(err);}console.log(\"数据写入成功！\");console.log(\"--------我是分割线-------------\")console.log(\"读取写入的数据！\");fs.readFile('input.txt',function(err,data){if(err){returnconsole.error(err);}console.log(\"异步读取文件数据:\"+data.toString());});});执行结果如下：$nodefile.js准备写入文件数据写入成功！--------我是分割线-------------读取写入的数据！异步读取文件数据:我是通过fs.writeFile写入文件的内容```###读取文件>-```js>fs.read(fd,buffer,offset,length,position,callback)>```>-**fd**-通过fs.open()方法返回的文件描述符。>-**buffer**-数据写入的缓冲区。>-**offset**-缓冲区写入的写入偏移量。>-**length**-要从文件中读取的字节数。>-**position**-文件读取的起始位置，如果position的值为null，则会从当前文件指针的位置读取。>-**callback**-回调函数，有三个参数err,bytesRead,buffer，err为错误信息，bytesRead表示读取的字节数，buffer为缓冲区对象。```jsvarfs=require(\"fs\");varbuf=newBuffer.alloc(1024);console.log(\"准备打开已存在的文件！\");fs.open('input.txt','r+',function(err,fd){if(err){returnconsole.error(err);}console.log(\"文件打开成功！\");console.log(\"准备读取文件：\");fs.read(fd,buf,0,buf.length,0,function(err,bytes){if(err){console.log(err);}console.log(bytes+\"字节被读取\");//仅输出读取的字节if(bytes>0){console.log(buf.slice(0,bytes).toString());}});});以上代码执行结果如下：$nodefile.js准备打开已存在的文件！文件打开成功！准备读取文件：42字节被读取grh官网地址：www.runoob.com```###关闭文件>```>fs.close(fd,callback)>```>>-**fd**-通过fs.open()方法返回的文件描述符。>-**callback**-回调函数，没有参数。```jsvarfs=require(\"fs\");varbuf=newBuffer.alloc(1024);console.log(\"准备打开文件！\");fs.open('input.txt','r+',function(err,fd){if(err){returnconsole.error(err);}console.log(\"文件打开成功！\");console.log(\"准备读取文件！\");fs.read(fd,buf,0,buf.length,0,function(err,bytes){if(err){console.log(err);}//仅输出读取的字节if(bytes>0){console.log(buf.slice(0,bytes).toString());}//关闭文件fs.close(fd,function(err){if(err){console.log(err);}console.log(\"文件关闭成功\");});});});以上代码执行结果如下：$nodefile.js准备打开文件！文件打开成功！准备读取文件！grh官网地址：www.runoob.com文件关闭成功```###截取文件```fs.ftruncate(fd,len,callback)```参数使用说明如下：-**fd**-通过fs.open()方法返回的文件描述符。-**len**-文件内容截取的长度。-**callback**-回调函数，没有参数。input.txt文件内容为：```site:www.runoob.com```接下来我们创建file.js文件，代码如下所示：```jsvarfs=require('fs')varbuf=newBuffer.alloc(1024)console.log('准备打开文件！')fs.open('input.txt','r+',function(err,fd){if(err){returnconsole.error(err)}console.log('文件打开成功！')console.log('截取10字节内的文件内容，超出部分将被去除。')//截取文件fs.ftruncate(fd,10,function(err){if(err){console.log(err)}console.log('文件截取成功。')console.log('读取相同的文件')fs.read(fd,buf,0,buf.length,0,function(err,bytes){if(err){console.log(err)}//仅输出读取的字节if(bytes>0){console.log(buf.slice(0,bytes).toString())}//关闭文件fs.close(fd,function(err){if(err){console.log(err)}console.log('文件关闭成功！')})})})})```以上代码执行结果如下：```js$nodefile.js准备打开文件！文件打开成功！截取10字节内的文件内容，超出部分将被去除。文件截取成功。读取相同的文件site:www.r文件关闭成功```###删除文件```fs.unlink(path,callback)```参数使用说明如下：-**path**-文件路径。-**callback**-回调函数，没有参数。input.txt文件内容为：```site:www.runoob.com```接下来我们创建file.js文件，代码如下所示：```jsvarfs=require('fs')console.log('准备删除文件！')fs.unlink('input.txt',function(err){if(err){returnconsole.error(err)}console.log('文件删除成功！')})```以上代码执行结果如下：```$nodefile.js准备删除文件！文件删除成功！```###创建目录```fs.mkdir(path[,options],callback)```参数使用说明如下：-**path**-文件路径。-options参数可以是：-**recursive**-是否以递归的方式创建目录，默认为false。-**mode**-设置目录权限，默认为0777。-**callback**-回调函数，没有参数。接下来我们创建file.js文件，代码如下所示：```varfs=require(\"fs\");//tmp目录必须存在console.log(\"创建目录/tmp/test/\");fs.mkdir(\"/tmp/test/\",function(err){if(err){returnconsole.error(err);}console.log(\"目录创建成功。\");});```以上代码执行结果如下：```$nodefile.js创建目录/tmp/test/目录创建成功。```可以添加recursive:true参数，不管创建的目录/tmp和/tmp/a是否存在：```fs.mkdir('/tmp/a/apple',{recursive:true},(err)=>{if(err)throwerr;});```---###读取目录```fs.readdir(path,callback)```参数使用说明如下：-**path**-文件路径。-**callback**-回调函数，回调函数带有两个参数err,files，err为错误信息，files为目录下的文件数组列表。接下来我们创建file.js文件，代码如下所示：```jsvarfs=require('fs')console.log('查看/tmp目录')fs.readdir('/tmp/',function(err,files){if(err){returnconsole.error(err)}files.forEach(function(file){console.log(file)})})```以上代码执行结果如下：```js$nodefile.js查看/tmp目录input.outoutput.outtesttest.txt```###读取目录```fs.readdir(path,callback)```-**path**-文件路径。-**callback**-回调函数，回调函数带有两个参数err,files，err为错误信息，files为目录下的文件数组列表。接下来我们创建file.js文件，代码如下所示：```varfs=require(\"fs\");console.log(\"查看/tmp目录\");fs.readdir(\"/tmp/\",function(err,files){if(err){returnconsole.error(err);}files.forEach(function(file){console.log(file);});});```以上代码执行结果如下：```$nodefile.js查看/tmp目录input.outoutput.outtesttest.txt```###删除目录>-fs.rmdir(path,callback)>-path-文件路径。>-callback-回调函数，没有参数。```jsvarfs=require(\"fs\");//执行前创建一个空的/tmp/test目录console.log(\"准备删除目录/tmp/test\");fs.rmdir(\"/tmp/test\",function(err){if(err){returnconsole.error(err);}console.log(\"读取/tmp目录\");fs.readdir(\"/tmp/\",function(err,files){if(err){returnconsole.error(err);}files.forEach(function(file){console.log(file);});});});以上代码执行结果如下：$nodefile.js准备删除目录/tmp/test读取/tmp目录……```###文件模块方法参考手册|序号|方法&描述||:---|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------||1|**fs.rename(oldPath,newPath,callback)**异步rename().回调函数没有参数，但可能抛出异常。||2|**fs.ftruncate(fd,len,callback)**异步ftruncate().回调函数没有参数，但可能抛出异常。||3|**fs.ftruncateSync(fd,len)**同步ftruncate()||4|**fs.truncate(path,len,callback)**异步truncate().回调函数没有参数，但可能抛出异常。||5|**fs.truncateSync(path,len)**同步truncate()||6|**fs.chown(path,uid,gid,callback)**异步chown().回调函数没有参数，但可能抛出异常。||7|**fs.chownSync(path,uid,gid)**同步chown()||8|**fs.fchown(fd,uid,gid,callback)**异步fchown().回调函数没有参数，但可能抛出异常。||9|**fs.fchownSync(fd,uid,gid)**同步fchown()||10|**fs.lchown(path,uid,gid,callback)**异步lchown().回调函数没有参数，但可能抛出异常。||11|**fs.lchownSync(path,uid,gid)**同步lchown()||12|**fs.chmod(path,mode,callback)**异步chmod().回调函数没有参数，但可能抛出异常。||13|**fs.chmodSync(path,mode)**同步chmod().||14|**fs.fchmod(fd,mode,callback)**异步fchmod().回调函数没有参数，但可能抛出异常。||15|**fs.fchmodSync(fd,mode)**同步fchmod().||16|**fs.lchmod(path,mode,callback)**异步lchmod().回调函数没有参数，但可能抛出异常。OnlyavailableonMacOSX.||17|**fs.lchmodSync(path,mode)**同步lchmod().||18|**fs.stat(path,callback)**异步stat().回调函数有两个参数err,stats，stats是fs.Stats对象。||19|**fs.lstat(path,callback)**异步lstat().回调函数有两个参数err,stats，stats是fs.Stats对象。||20|**fs.fstat(fd,callback)**异步fstat().回调函数有两个参数err,stats，stats是fs.Stats对象。||21|**fs.statSync(path)**同步stat().返回fs.Stats的实例。||22|**fs.lstatSync(path)**同步lstat().返回fs.Stats的实例。||23|**fs.fstatSync(fd)**同步fstat().返回fs.Stats的实例。||24|**fs.link(srcpath,dstpath,callback)**异步link().回调函数没有参数，但可能抛出异常。||25|**fs.linkSync(srcpath,dstpath)**同步link().||26|**fs.symlink(srcpath,dstpath[,type],callback)**异步symlink().回调函数没有参数，但可能抛出异常。type参数可以设置为'dir','file',或'junction'(默认为'file')。||27|**fs.symlinkSync(srcpath,dstpath[,type])**同步symlink().||28|**fs.readlink(path,callback)**异步readlink().回调函数有两个参数err,linkString。||29|**fs.realpath(path[,cache],callback)**异步realpath().回调函数有两个参数err,resolvedPath。||30|**fs.realpathSync(path[,cache])**同步realpath()。返回绝对路径。||31|**fs.unlink(path,callback)**异步unlink().回调函数没有参数，但可能抛出异常。||32|**fs.unlinkSync(path)**同步unlink().||33|**fs.rmdir(path,callback)**异步rmdir().回调函数没有参数，但可能抛出异常。||34|**fs.rmdirSync(path)**同步rmdir().||35|**fs.mkdir(path[,mode],callback)**S异步mkdir(2).回调函数没有参数，但可能抛出异常。访问权限默认为0777。||36|**fs.mkdirSync(path[,mode])**同步mkdir().||37|**fs.readdir(path,callback)**异步readdir(3).读取目录的内容。||38|**fs.readdirSync(path)**同步readdir().返回文件数组列表。||39|**fs.close(fd,callback)**异步close().回调函数没有参数，但可能抛出异常。||40|**fs.closeSync(fd)**同步close().||41|**fs.open(path,flags[,mode],callback)**异步打开文件。||42|**fs.openSync(path,flags[,mode])**同步versionoffs.open().||43|**fs.utimes(path,atime,mtime,callback)**||44|**fs.utimesSync(path,atime,mtime)**修改文件时间戳，文件通过指定的文件路径。||45|**fs.futimes(fd,atime,mtime,callback)**||46|**fs.futimesSync(fd,atime,mtime)**修改文件时间戳，通过文件描述符指定。||47|**fs.fsync(fd,callback)**异步fsync.回调函数没有参数，但可能抛出异常。||48|**fs.fsyncSync(fd)**同步fsync.||49|**fs.write(fd,buffer,offset,length[,position],callback)**将缓冲区内容写入到通过文件描述符指定的文件。||50|**fs.write(fd,data[,position[,encoding]],callback)**通过文件描述符fd写入文件内容。||51|**fs.writeSync(fd,buffer,offset,length[,position])**同步版的fs.write()。||52|**fs.writeSync(fd,data[,position[,encoding]])**同步版的fs.write().||53|**fs.read(fd,buffer,offset,length,position,callback)**通过文件描述符fd读取文件内容。||54|**fs.readSync(fd,buffer,offset,length,position)**同步版的fs.read.||55|**fs.readFile(filename[,options],callback)**异步读取文件内容。||56|**fs.readFileSync(filename[,options])**||57|**fs.writeFile(filename,data[,options],callback)**异步写入文件内容。||58|**fs.writeFileSync(filename,data[,options])**同步版的fs.writeFile。||59|**fs.appendFile(filename,data[,options],callback)**异步追加文件内容。||60|**fs.appendFileSync(filename,data[,options])**The同步versionoffs.appendFile.||61|**fs.watchFile(filename[,options],listener)**查看文件的修改。||62|**fs.unwatchFile(filename[,listener])**停止查看filename的修改。||63|**`fs.watch(filename[,options][,listener])`**查看filename的修改，filename可以是文件或目录。返回fs.FSWatcher对象。||64|**fs.exists(path,callback)**检测给定的路径是否存在。||65|**fs.existsSync(path)**同步版的fs.exists.||66|**fs.access(path[,mode],callback)**测试指定路径用户权限。||67|**fs.accessSync(path[,mode])**同步版的fs.access。||68|**fs.createReadStream(path[,options])**返回ReadStream对象。||69|**fs.createWriteStream(path[,options])**返回WriteStream对象。||70|**fs.symlink(srcpath,dstpath[,type],callback)**异步symlink().回调函数没有参数，但可能抛出异常。|##GET/POST请求###获取GET请求内容```jsvarhttp=require('http')varurl=require('url')varutil=require('util')http.createServer(function(req,res){res.writeHead(200,{'Content-Type':'text/plain;charset=utf-8'})res.end(util.inspect(url.parse(req.url,true)))}).listen(3000)//获取url参数http.createServer(function(req,res){res.writeHead(200,{'Content-Type':'text/plain'})//解析url参数varparams=url.parse(req.url,true).queryres.write('网站名：'+params.name)res.write('\\n')res.write('网站URL：'+params.url)res.end()}).listen(3000)```<imgsrc=\"https://images.gitee.com/uploads/images/2020/0602/182627_1b8e7ecd_6545143.png\"style=\"zoom:67%;\"/>###获取post请求内容```jsvarhttp=require('http');varquerystring=require('querystring');varutil=require('util');http.createServer(function(req,res){//定义了一个post变量，用于暂存请求体的信息varpost='';//通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中req.on('data',function(chunk){post+=chunk;});//在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。req.on('end',function(){post=querystring.parse(post);res.end(util.inspect(post));});``````jsvarhttp=require('http')varquerystring=require('querystring')varpostHTML='<html><head><metacharset=\"utf-8\"><title>grhNode.js实例</title></head>'+'<body>'+'<formmethod=\"post\">'+'网站名：<inputname=\"name\"><br>'+'网站URL：<inputname=\"url\"><br>'+'<inputtype=\"submit\">'+'</form>'+'</body></html>'http.createServer(function(req,res){varbody=''req.on('data',function(chunk){body+=chunk})req.on('end',function(){//解析参数body=querystring.parse(body)//设置响应头部信息及编码res.writeHead(200,{'Content-Type':'text/html;charset=utf8'})if(body.name&&body.url){//输出提交的数据res.write('网站名：'+body.name)res.write('<br>')res.write('网站URL：'+body.url)}else{//输出表单res.write(postHTML)}res.end()})}).listen(3000)```","Front-End\\Node\\基础\\node-demo.md":"#express##简单使用`npmi`npmiexpress`npminodemon````js//server.jsvarexpress=require('express')varapp=express()app.get('/',function(req,res){res.send('thisisthehomepage')})app.listen(3000)```运行`nodemonserver.js`浏览器打开`http://localhost:3000/`##id的使用```jsvarexpress=require('express')varapp=express()app.get('/user/:id/and/:name',function(req,res){console.log(req.params)res.send(req.params.id+''+req.params.name)//可以输出id和name的值})app.listen(3000)```##url中使用正则```jsvarexpress=require('express')varapp=express()//这里的?就是正则表达式app.get('/user/ab?cd',function(req,res){console.log(req.params)res.send('匹配成功')})app.listen(3000)//输入http://localhost:3000/acd也可以匹配成功```##查询字符串```js//server.jsvarexpress=require('express')varapp=express()app.get('/',function(req,res){console.log(req.query)res.send('thisisaepage'+req.query.user)//req.query.user可以拿到值})app.listen(3000)```>`http://localhost:3000/?user=grh`req.query可以返回{user:'grh'}##使用body-parser中间件>`npminstallbody-parser--save`>>[官网](https://www.expressjs.com.cn/en/resources/middleware/body-parser.html)###Express/Connecttop-levelgeneric>这个示例演示了添加一个通用的JSON和URL编码的解析器作为顶级中间件，它将解析所有传入请求的主体。这是最简单的设置。```javascriptvarexpress=require('express')varbodyParser=require('body-parser')varapp=express()//parseapplication/x-www-form-urlencodedapp.use(bodyParser.urlencoded({extended:false}))//parseapplication/jsonapp.use(bodyParser.json())app.use(function(req,res){res.setHeader('Content-Type','text/plain')res.write('youposted:\\n')res.end(JSON.stringify(req.body,null,2))})```###Expressroute-specific>此示例演示了将主体解析器专门添加到需要它们的路由。通常，这是与Express结合使用body解析器的最推荐方法。```javascriptvarexpress=require('express')varbodyParser=require('body-parser')varapp=express()//createapplication/jsonparservarjsonParser=bodyParser.json()//createapplication/x-www-form-urlencodedparservarurlencodedParser=bodyParser.urlencoded({extended:false})//POST/logingetsurlencodedbodiesapp.post('/login',urlencodedParser,function(req,res){res.send('welcome,'+req.body.username)})//POST/api/usersgetsJSONbodiesapp.post('/api/users',jsonParser,function(req,res){//createuserinreq.body})```###Changeacceptedtypeforparsers>所有解析器都接受一个“类型”选项，该选项允许您更改中间件将解析的“内容类型”。```javascriptvarexpress=require('express')varbodyParser=require('body-parser')varapp=express()//parsevariousdifferentcustomJSONtypesasJSONapp.use(bodyParser.json({type:'application/*+json'}))//parsesomecustomthingintoaBufferapp.use(bodyParser.raw({type:'application/vnd.custom-type'}))//parseanHTMLbodyintoastringapp.use(bodyParser.text({type:'text/html'}))```##HTML5`<form>`enctype属性|值|描述||:--------------------------------|:-------------------------------------------------------------||application/x-www-form-urlencoded|在发送前对所有字符进行编码（默认）。||multipart/form-data|不对字符编码。当使用有==文件上传==控件的表单时，该值是必需的。||text/plain|将空格转换为\"+\"符号，但不编码特殊字符。|##req.params,req.query,req.body的差别||对应的url||-----------------|--------------------------------------||`req.params`|`http://localhost:3000/10`||`req.query[\"id\"]`|`http://localhost:3000/?id=10`||`req.body.id`|`http://localhost:3000`一般不在url显示|##上传文件使用multerMulter是一个node.js中间件，用于处理`multipart/form-data`类型的表单数据，它主要用于上传文件。它是写在[busboy](https://github.com/mscdex/busboy)之上非常高效。**注意**:Multer不会处理任何非`multipart/form-data`类型的表单数据。server.js```javascriptvarexpress=require('express')varapp=express()//上传文件app.post('/form_file',upload.single('logo'),function(req,res,next){//varform=fs.readFileSync('./form.html',{encoding:\"utf8\"});//res.send(form);console.log(req.file)res.send({ret_code:0})})//通过http://localhost:3000/form打开formhtmlapp.get('/form',function(req,res){//方法一//varform=fs.readFileSync('./form.html',{encoding:\"utf8\"});//res.send(form);//方法二res.sendFile(__dirname+'/form.html')})app.listen(3000)```form.html```html<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"/><metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\"/><metahttp-equiv=\"X-UA-Comptatible\"content=\"ie=edge\"/><title>Document</title></head><body><!--这里的action填/form_file也是可以的--><formaction=\"http://localhost:3000/form_file\"method=\"post\"enctype=\"multipart/form-data\"><h2>单图上传</h2><inputtype=\"file\"name=\"logo\"/><inputtype=\"submit\"value=\"提交\"/></form></body></html>```##使用模板引擎ejs###安装`npminstallejs--save````jsvarexpress=require('express')varapp=express()app.set('viewengine','ejs')app.get('/ejs/:name',function(req,res){varmyname=req.params.name//这里也可以传输对象等数据类型res.render('ejs_text',{pn:myname})})//这里的ejs_text是指向iview的文件app.listen(3000)```ejs_text.ejs```html<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"/><metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\"/><title>Document</title></head><body><h1><%=pn%></h1></body></html>```>通过`localhost:3000/ejs/grh`访问##中间件server.js```javaScriptvarexpress=require('express');varapp=express();app.use(function(req,res,next){console.log('firstmiddleware');next();//可以接着运行下一个})app.use(function(req,res,next){console.log('secondmiddleware');res.send('ok');})app.listen(3000);```##Express托管静态文件`express.static(root,[options])````javascriptapp.use(express.static('public'))```现在，你就可以访问`public`目录中的所有文件了：```plain-texthttp://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/app.jshttp://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html````app.use('/aset',express.static('public'))`通过`http://localhost:3000/aset/images/kitten.jpg`来访问##路由中间件###原server.js```javascriptvarexpress=require('express')varapp=express()app.get('/home',function(req,res,next){res.send('home')})app.get('/users',function(req,res,next){res.send('users')})app.get('/',function(req,res,next){res.send('root')})app.listen(3000)```###使用路由中间件后>1.先新建routes文件夹>2.然后再在这文件夹下,建立模块index.js,users,js>3.再在server.js引入这两个路由index.js```javascriptvarexpress=require('express')varrouter=express.Router()router.get('/',function(req,res,next){res.send('root')})module.exports=router```users.js```javascriptvarexpress=require('express')varrouter=express.Router()router.get('/',function(req,res,next){res.send('users')})module.exports=router```server.js```javascriptvarexpress=require('express')varapp=express()varindexRouter=require('./routes/index')varuserRouter=require('./route/users')app.use('/',indexRouter)app.use('/users',usersRouter)app.listen(3000)```","Front-End\\Node\\基础\\node-expand.md":"#node-expand##nodejs使用fetchnode中没有实现fetch，你可以使用[node-fetch](https://github.com/bitinn/node-fetch)，使得在node中也可以使用fetch.安装node-fetch:```npminstallnode-fetch```使用fetch之前先加载：```constfetch=require('node-fetch')```简单使用方法：```fetch('https://api.github.com/users/github').then(res=>res.json()).then(json=>console.log(json));```关于fetch的使用介绍<https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch>##Nodemon自动重启项目1.安装：`npminstall-gnodemon`2.使用`nodemon`运行项目，取代之前的`nodeapp.js`。```nodemon[yourapp.js]```项目运行之后，`nodemon`会自动监听代码的改动，并且重新启动服务，大大增加我们开发效率。1.`nodemon`常见配置-在命令行指定应用的端口号：`nodemon./server.jslocalhost8080`-查看帮助，帮助里面有很多选项都是一目了然：`nodemon-h或者nodemon--help`-运行debug模式：`nodemon--debug./server.js80`-手动重启项目：`Nodemon`命令运行的终端窗口中输入`rs`两个字符，然后再按下回车键，就能手动重启`Nodemon`了。##爬虫###1.爬虫介绍通过模拟浏览器的请求，服务器就会根据我们的请求返回我们想要的数据，将数据解析出来，并且进行保存。###2.爬虫流程####1-目标：确定你想要获取的数据1.确定想要的数据在什么页面上（一般详细的数据会在详情页）2.确定在哪些页面可以链接到这些页面（一般分类列表页面会有详情页的链接数据）3.寻找页面之间和数据之间的规律####2-分析页面1.获取数据的方式（正则，cherrio）2.分析数据是通过ajax请求的数据，还是html里自带的数据3.如果是通过AJAX请求的数据，那么需要获取ajax请求的链接，一般请求到的数据都为JSON格式数据，那么就会比较容易解析。4.如何数据在HTML里面，那么就用cherrio通过选择器将内容选中####3-编写单个数据获取的案例1.解析出分类页的链接地址2.解析出列表页的链接地址3.解析出详情页的链接地址4.解析详情页里面想要获取的数据5.将数据进行保存到本地或者是数据库####4-如果遇到阻碍进行反爬虫对抗1.User-Agent是否是正常浏览器的信息2.将请求头设置成跟浏览器一样的内容3.因为爬虫的爬取速度过快，会导致封号。1那么可以降低速度进行解决，2可以使用代理进行解决4.如果设置需要凭证，那么可以采用无界浏览器真实模拟。###2.请求数据的库request，axios：通过库，帮助我们快速实现HTTP请求包的打包```request.get('请求地址',{'请求头字段':'请求头的value值'},(res)=>{处理返回的内容});```axios优势会更明显，前后端通杀，前后端调用的方式一致。```jsaxios.get('请求地址',参数对象).then(function(response){console.log(response)})```axios获取图片```jsaxios({method:'get',url:'http://bit.ly/2mTM3nY',responseType:'stream',}).then(function(response){response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))})```puppeteer:完全模拟浏览器打开浏览器```jsletoptions={headless:true,//是否是无界面浏览器slowMo:250,//调试时可以减慢操作速度defaultViewport:{width:1200,//设置视窗的宽高height:800},timeout:3000，//默认超时3秒}letbrowser=awaitpuppeteer.launch(options);```打开新标签页```jsletpage=awaitbrowser.newPage()```获取所有浏览器中的页面```jsletpages=awaitbrowser.pages()```关闭浏览器```jsbrowser.close()```将页面跳转至```awaitpage.goto(url)```获取页面的对象,并进行操作```letbtn=awaitpage.$(selector)letinput=awaitpage.$(selector)//点击按钮btn.click()//聚焦到输入框input.forcus()```在页面上写入内容或者键盘按键```awaitpage.keyboard.type('HelloWorld!');awaitpage.keyboard.press('ArrowLeft');awaitpage.keyboard.down('Shift');```设置鼠标的移动```awaitpage.mouse.move(0,0);awaitpage.mouse.down();awaitpage.mouse.move(0,100);awaitpage.mouse.move(100,100);awaitpage.mouse.move(100,0);awaitpage.mouse.move(0,0);awaitpage.mouse.up();```截获页面请求```awaitpage.setRequestInterception(true);page.on('request',request=>{request.url()//可以获取请求的网址，request，包含了所有的请求信息if(你想要的条件){request.continue()}else{request.abort([errorCode])}});```获取浏览器的信息和内容```page.$eval(selector,(item)=>{returnitem})page.$$eval(selectors,(items)=>{returnitems})```##静态服务器##网络通信原理**1、协议及协议栈的基本概念****1.1、什么是协议**协议是网络中计算机或设备之间进行通信的一系列规则的集合。常用协议有IP、TCP、HTTP、POP3、SMTP等。**1.2、什么是协议栈**在网络中，为了完成通信，必须使用多层上的多种协议。这些协议按照层次顺序组合在一起，构成了协议栈(ProtocolStack)，也称为协议族(ProtocolSuite)。**1.3、协议的作用**一个网络协议的作用主要有两个：一是建立对等层之间的虚拟通信，二是实现层次之间的无关性。**1.4、层次间的无关性**所谓层次间无关性，就是指较高层次和相邻的相低层次进行通信时，只是利用较低层次提供的接口和服务，而不需了解底层实现该功能所采用的算法和协议的细节；较低层次也仅是使用从高层系统传送来的参数和控制信息，这就是层次间的无关性。**2、网络协议族/栈组成**网络通信协议的作用是负责在网络上建立通信通道和控制通过通道的信息流的规则。为了进行网络通信，通信双方必须遵守通信协议<imgsrc=\"https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=482594737,1881689515&amp;fm=173&amp;app=49&amp;f=JPEG?w=640&amp;h=506&amp;s=5986BE1A490E44CA5A4104EB03005032\"alt=\"img\"style=\"zoom:50%;\"/>说明：网络协议与标准是基于OSI七层模型，每一层都有其对应的协议。**3、常见的网络协议**TCP/IP：工业标准、开放式协议，Internet网络的标准IPX/SPX：Novell开发的Netware操作系统使用的协议，IPX为网际数据包交换协议，工作在网络层，SPX为序列数据包交换协议，工作在传输层。NetBIOS/NetBEUI：较小的协议栈，应用于IBM和早期的Windows系统，现在Windows仍然支持。AppleTalk：Apple公司的MacOS中所采用的网络协议。**（1）TCP/IP协议**TCP/IP是分层协议，如层次图所示：从底层到应用层，分别是物理层，链路层，网络层，传输层，应用层。数据是层层封装，封装的方式一般都是在原有数据的前面加一个数据控制头。![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2298966842,1075106660&fm=173&app=49&f=JPEG?w=640&h=388&s=C018C53889DF40C85EED91460300A0F1)**（2）Telnet协议**Telnet是TCP/IP中的一种应用协议，可以为终端仿真提供支持。可使用户连接到主机上，使主机响应起来就像它直接连接在终端上一样。Telnet在发送端和接收端使用TCP的23号端口以进行专用的通信。IPV4IP:1.1.1.1---255.255.255.255IPV610亿10亿10亿10亿**（3）FTP协议**FTP协议使用TCP20号和21号端口，20号端口用于数据交换，21号端口用于建立连接，允许目录和文件访问，上传下载，不能远程执行文件。TFTP是简单文件传输协议（TrivialFileTransferProtocol，TFTP），TFTP是无连接的，使用UDP的69号端口，用于当数据传输错误无关紧要而且无须安全性时的小型文件的传输。**（4）SMTP协议**SMTP是简单邮件传输协议（SimpleMailTransferProtocol，SMTP）是为网络系统间的电子邮件交换而设计的。使用25端口。SMTP只需要在接收端的一个电子邮件地址即可发送邮件。POP3协议用来接收邮件.使用110端口**（5）DNS服务**DNS是域名解析服务（DomainNameService,DNS），作用是将域名转换为IP地址，或将IP地址转换为域名，用于解析完全合格域名（FQDN）。使用53号端口。**（6）DHCP服务**DHCP是动态主机配置协议(DHCP)，服务器可以提供的信息有:1、IP地址2、子网掩码(subnetmask)3、域名(domainname)4、默认网关(defaultgateway)5、DNS##HTTP协议HTTP协议是HyperTextTransferProtocol（超文本传输协议）的缩写,是用于从万维网（WWW:WorldWideWeb）服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件,图片文件,查询结果等）。HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(NextGenerationofHTTP)的建议已经提出。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。###HTTP协议的主要特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式###HTTP协议与URL的关系HTTP使用统一资源标识符（UniformResourceIdentifiers,URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。URL,全称是UniformResourceLocator,中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：```http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name```#####从上面的URL可以看出，一个完整的URL包括以下几部分1.协议部分：该URL的协议部分为“http”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在\"HTTP\"后面的“//”为分隔符。2.域名部分：该URL的域名部分为“[www.aspxfans.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.aspxfans.com)”。一个URL中，也可以使用IP地址作为域名使用。3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口。4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”。5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。\\####URI和URL的区别#####URI，是uniformresourceidentifier，统一资源标识符，用来唯一的标识一个资源Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。#####URL是uniformresourcelocator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等#####URN，uniformresourcename，统一资源命名，是通过名字来标识资源，比如[mailto:java-net@java.sun.com](https://links.jianshu.com/go?to=mailto%3Ajava-net%40java.sun.com)URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称(URN)，它命名资源但不指定如何定位资源。上面的mailto、news和isbnURI都是URN的示例。在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。>HTTP之请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式：#####请求行（requestline）、请求头部（header）、空行和请求数据四个部分组成![img](https:////upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip|imageView2/2/w/466/format/webp)image-请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。#####Get请求例子，使用Charles抓取的request\\#```GET/562f25980001b1b106000338.jpgHTTP/1.1Hostimg.mukewang.comUser-AgentMozilla/5.0(WindowsNT10.0;WOW64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/51.0.2704.106Safari/537.36Acceptimage/webp,image/*,*/*;q=0.8Refererhttp://www.imooc.com/Accept-Encodinggzip,deflate,sdchAccept-Languagezh-CN,zh;q=0.8```#####第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。#####第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等#####第三部分：空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。#####第四部分：请求数据也叫主体，可以添加任意的其他数据这个例子的请求数据为空。#####POST请求例子，使用Charles抓取的request\\#```POST/HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0(compatible;MSIE6.0;WindowsNT5.1;SV1;.NETCLR2.0.50727;.NETCLR3.0.04506.648;.NETCLR3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection:Keep-Alivename=Professional%20Ajax&publisher=Wiley```第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。>HTTP之响应消息Response一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。#####HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文![img](https:////upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp)image#####例子```HTTP/1.1200OKDate:Fri,22May200906:07:21GMTContent-Type:text/html;charset=UTF-8<html><head></head><body><!--bodygoeshere--></body></html>```#####第一部分：状态行，由HTTP协议版本号，状态码，状态消息三部分组成第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）#####第二部分：消息报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8#####第三部分：空行，消息报头后面的空行是必须的#####第四部分：响应正文，服务器返回给客户端的文本信息空行后面的html部分为响应正文。>HTTP协议之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:######1xx：指示信息--表示请求已接收，继续处理######2xx：成功--表示请求已被成功接收、理解、接受######3xx：重定向--要完成请求必须进行更进一步的操作######4xx：客户端错误--请求有语法错误或请求无法实现######5xx：服务器端错误--服务器未能实现合法的请求常见状态码：200OK//客户端请求成功400BadRequest//客户端请求有语法错误，不能被服务器所理解401Unauthorized//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403Forbidden//服务器收到请求，但是拒绝提供服务404NotFound//请求资源不存在，eg：输入了错误的URL500InternalServerError//服务器发生不可预期的错误503ServerUnavailable//服务器当前不能处理客户端的请求，一段时间后可能恢复正常###HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法：GET,POST和HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS,PUT,DELETE,TRACE和CONNECT方法。GET请求指定的页面信息，并返回实体主体。HEAD类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT从客户端向服务器传送的数据取代指定的文档的内容。DELETE请求服务器删除指定的页面。CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS允许客户端查看服务器的性能。TRACE回显服务器收到的请求，主要用于测试或诊断。`>HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。以下是HTTP请求/响应的步骤：######1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.oakcms.cn。](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.oakcms.cn.%2F)######2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。######3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。######4、释放连接[TCP连接](https://www.jianshu.com/p/ef892323e68f)若connection模式为close，则服务器主动关闭[TCP连接](https://www.jianshu.com/p/ef892323e68f)，客户端被动关闭连接，释放[TCP连接](https://www.jianshu.com/p/ef892323e68f);若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;######5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：1、浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址;2、解析出IP地址后，根据该IP地址和默认端口80，和服务器建立[TCP连接](https://www.jianshu.com/p/ef892323e68f);3、浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP请求，该请求报文作为[TCP三次握手](https://www.jianshu.com/p/ef892323e68f)的第三个报文的数据发送给服务器;4、服务器对浏览器请求作出响应，并把对应的html文本发送给浏览器;5、释放[TCP连接](https://www.jianshu.com/p/ef892323e68f);6、浏览器将该html文本并显示内容;>GET和POST请求的区别######GET请求```GET/books/?sex=man&name=ProfessionalHTTP/1.1Host:www.wrox.comUser-Agent:Mozilla/5.0(Windows;U;WindowsNT5.1;en-US;rv:1.7.6)Gecko/20050225Firefox/1.0.1Connection:Keep-Alive```注意最后一行是空行######POST请求````POST/HTTP/1.1Host:www.wrox.comUser-Agent:Mozilla/5.0(Windows;U;WindowsNT5.1;en-US;rv:1.7.6)Gecko/20050225Firefox/1.0.1Content-Type:application/x-www-form-urlencodedContent-Length:40Connection:Keep-Alive```name=Professional%20Ajax&publisher=Wiley`1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接；例如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据######因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：**GET**:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。**POST**:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。3、安全性POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-siterequestforgery攻击4、Httpget,post,soap协议都是在http上运行的（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全（2）post：请求参数是在http标题的一个不同部分（名为entitybody）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form-urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。（3）soap：是httppost的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为:text/xml任何数据都可以xml化。Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE.一个URL地址用于描述一个网络上的资源，而HTTP中的GET,POST,PUT,DELETE就对应着对这个资源的查，改，增，删4个操作。我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.我们看看GET和POST的区别1.GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456.POST方法是把提交的数据放在HTTP包的Body中.2.GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.3.GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。4.GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.##工具模块|序号|模块名&描述||:---|:------------------------------------------------------------------------||1|**OS模块**提供基本的系统操作函数。||2|**Path模块**提供了处理和转换文件路径的工具。||3|**Net模块**用于底层的网络通信。提供了服务端和客户端的的操作。||4|**DNS模块**用于解析域名。||5|**Domain模块**简化异步代码的异常处理，可以捕捉处理trycatch无法捕捉的。|##web模块<imgsrc=\"https://images.gitee.com/uploads/images/2020/0602/183736_ca5004eb_6545143.png\"style=\"zoom:87%;\"/>>-**Client**-客户端，一般指浏览器，浏览器可以通过HTTP协议向服务器请求数据。>-**Server**-服务端，一般指Web服务器，可以接收客户端请求，并向客户端发送响应数据。>-**Business**-业务层，通过Web服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。>-**Data**-数据层，一般由数据库组成。###Node创建Web服务器server.js```jsvarhttp=require('http')varfs=require('fs')varurl=require('url')//创建服务器http.createServer(function(request,response){//解析请求，包括文件名varpathname=url.parse(request.url).pathname//输出请求的文件名console.log('Requestfor'+pathname+'received.')//从文件系统中读取请求的文件内容fs.readFile(pathname.substr(1),function(err,data){if(err){console.log(err)//HTTP状态码:404:NOTFOUND//ContentType:text/htmlresponse.writeHead(404,{'Content-Type':'text/html'})}else{//HTTP状态码:200:OK//ContentType:text/htmlresponse.writeHead(200,{'Content-Type':'text/html'})//响应文件内容response.write(data.toString())}//发送响应数据response.end()})}).listen(8080)//控制台会输出以下信息console.log('Serverrunningathttp://127.0.0.1:8080/')```index.html```js<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"><title>grh(grh.com)</title></head><body><h1>我的第一个标题</h1><p>我的第一个段落。</p></body></html>```###Node创建Web客户端client.js```jsvarhttp=require('http')//用于请求的选项varoptions={host:'localhost',port:'8080',path:'/index.html',}//处理响应的回调函数varcallback=function(response){//不断更新数据varbody=''response.on('data',function(data){body+=data})response.on('end',function(){//数据接收完成console.log(body)})}//向服务端发送请求varreq=http.request(options,callback)req.end()```##Express框架>Express框架核心特性：>>-可以设置中间件来响应HTTP请求。>-定义了路由表用于执行不同的HTTP请求动作。>-可以通过向模板传递参数来动态渲染HTML页面。###安装`$npminstallexpress--save`>会安装到node_modules目录中几个重要的模块>-**body-parser**-node.js中间件，用于处理JSON,Raw,Text和URL编码的数据。>-**cookie-parser**-这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。>-**multer**-node.js中间件，用于处理enctype=\"multipart/form-data\"（设置表单的MIME编码）的表单数据。```cnpminstallbody-parser--savecnpminstallcookie-parser--savecnpminstallmulter--save```###Express实例```js//express_demo.js文件varexpress=require('express')varapp=express()app.get('/',function(req,res){res.send('HelloWorld')})varserver=app.listen(8081,function(){varhost=server.address().addressvarport=server.address().portconsole.log('应用实例，访问地址为http://%s:%s',host,port)})``````shell$nodeexpress_demo.js应用实例，访问地址为http://0.0.0.0:8081```###请求和响应>Express应用使用回调函数的参数：**request**和**response**对象来处理请求和响应的数据。```jsapp.get('/',function(req,res){//--})```####**Request对象**>-request对象表示HTTP请求，包含了请求查询字符串，参数，内容，HTTP头部等属性。常见属性有：>>1.req.app：当callback为外部文件时，用req.app访问express的实例>2.req.baseUrl：获取路由当前安装的URL路径>3.req.body/req.cookies：获得「请求主体」/Cookies>4.req.fresh/req.stale：判断请求是否还「新鲜」>5.req.hostname/req.ip：获取主机名和IP地址>6.req.originalUrl：获取原始请求URL>7.req.params：获取路由的parameters>8.req.path：获取请求路径>9.req.protocol：获取协议类型>10.req.query：获取URL的查询参数串>11.req.route：获取当前匹配的路由>12.req.subdomains：获取子域名>13.req.accepts()：检查可接受的请求的文档类型>14.req.acceptsCharsets/req.acceptsEncodings/req.acceptsLanguages：返回指定字符集的第一个可接受字符编码>15.req.get()：获取指定的HTTP请求头>16.req.is()：判断请求头Content-Type的MIME类型####**Response对象**>-response对象表示HTTP响应，即在接收到请求时向客户端发送的HTTP响应数据。常见属性有：>>1.res.app：同req.app一样>2.res.append()：追加指定HTTP头>3.res.set()在res.append()后将重置之前设置的头>4.res.cookie(name，value[，option])：设置Cookie>5.opition:domain/expires/httpOnly/maxAge/path/secure/signed>6.res.clearCookie()：清除Cookie>7.res.download()：传送指定路径的文件>8.res.get()：返回指定的HTTP头>9.res.json()：传送JSON响应>10.res.jsonp()：传送JSONP响应>11.res.location()：只设置响应的LocationHTTP头，不设置状态码或者closeresponse>12.res.redirect()：设置响应的LocationHTTP头，并且设置状态码302>13.res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。>14.res.send()：传送HTTP响应>15.res.sendFile(path[，options][，fn])：传送指定路径的文件-会自动根据文件extension设定Content-Type>16.res.set()：设置HTTP头，传入object可以一次设置多个头>17.res.status()：设置HTTP状态码>18.res.type()：设置Content-Type的MIME类型###路由>路由决定了由谁(指定脚本)去响应客户端请求。```jsvarexpress=require('express')varapp=express()//主页输出\"HelloWorld\"app.get('/',function(req,res){console.log('主页GET请求')res.send('HelloGET')})//POST请求app.post('/',function(req,res){console.log('主页POST请求')res.send('HelloPOST')})///del_user页面响应app.get('/del_user',function(req,res){console.log('/del_user响应DELETE请求')res.send('删除页面')})///list_user页面GET请求app.get('/list_user',function(req,res){console.log('/list_userGET请求')res.send('用户列表页面')})//对页面abcd,abxcd,ab123cd,等响应GET请求app.get('/ab*cd',function(req,res){console.log('/ab*cdGET请求')res.send('正则匹配')})varserver=app.listen(8081,function(){varhost=server.address().addressvarport=server.address().portconsole.log('应用实例，访问地址为http://%s:%s',host,port)})```###静态文件>-Express提供了内置的中间件**express.static**来设置静态文件如：图片，CSS,JavaScript等。>-使用**express.static**中间件来设置静态文件路径。>-例如，如果你将图片，CSS,JavaScript文件放在public目录下```jsvarexpress=require('express')varapp=express()app.use('/public',express.static('public'))/*node_modulesserver.jspublic/public/imagespublic/images/logo.png*/app.get('/',function(req,res){res.send('HelloWorld')})varserver=app.listen(8081,function(){varhost=server.address().addressvarport=server.address().portconsole.log('应用实例，访问地址为http://%s:%s',host,port)})````http://127.0.0.1:8081/public/images/logo.png`可以访问到图片###文件上传```js<html><head><title>文件上传表单</title></head><body><h3>文件上传：</h3>选择一个文件上传:<br/><formaction='/file_upload'method='post'enctype='multipart/form-data'><inputtype='file'name='image'size='50'/><br/><inputtype='submit'value='上传文件'/></form></body></html>``````jsvarexpress=require('express')varapp=express()varfs=require('fs')varbodyParser=require('body-parser')varmulter=require('multer')app.use('/public',express.static('public'))app.use(bodyParser.urlencoded({extended:false}))app.use(multer({dest:'/tmp/'}).array('image'))app.get('/index.html',function(req,res){res.sendFile(__dirname+'/'+'index.html')})app.post('/file_upload',function(req,res){console.log(req.files[0])//上传的文件信息vardes_file=__dirname+'/'+req.files[0].originalnamefs.readFile(req.files[0].path,function(err,data){fs.writeFile(des_file,data,function(err){if(err){console.log(err)}else{response={message:'Fileuploadedsuccessfully',filename:req.files[0].originalname,}}console.log(response)res.end(JSON.stringify(response))})})})varserver=app.listen(8081,function(){varhost=server.address().addressvarport=server.address().portconsole.log('应用实例，访问地址为http://%s:%s',host,port)})```###Cookie管理```js//express_cookie.js文件varexpress=require('express')varcookieParser=require('cookie-parser')varutil=require('util')varapp=express()app.use(cookieParser())app.get('/',function(req,res){console.log('Cookies:'+util.inspect(req.cookies))})app.listen(8081)```##多进程>-node是单线程的模式运行的>-使用事件驱动来处理并发,有助于我们在多核cpu的系统上创建多个子进程,从而太高性能>-每个子进程有三个对象>-child.stdin>-child.stdout>-child.stder>-可能会共享父进程的stdio流,或者是独立的被导流的流对象>-Node提供child_process模块来创建子进程>-exec-child_process.exec使用值进程执行命令,缓存子进程的输出,并将子进程的输出以回调函数参数的形式返回>-spawn-child_process.spawn使用指定命令参数创建新进程>-fork-child_process.fork是spawn()的特殊形式,用于在子进程的模块,如fork('./json.js')相当于spawn('node',['./son.js'].>-和spwan()方法不同,fork会在父进程与子进程自己拿,建立一个通信管道,用于进程中之间的通信###exec()方法child_process.exec使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。语法如下所示：```child_process.exec(command[,options],callback)```####参数参数说明如下：**command：**字符串，将要运行的命令，参数使用空格隔开**options：对象，可以是：**-cwd，字符串，子进程的当前工作目录-env，对象环境变量键值对-encoding，字符串，字符编码（默认：'utf8'）-shell，字符串，将要执行命令的Shell（默认:在UNIX中为`/bin/sh`，在Windows中为`cmd.exe`，Shell应当能识别`-c`开关在UNIX中，或`/s/c`在Windows中。在Windows中，命令行解析应当能兼容`cmd.exe`）-timeout，数字，超时时间（默认：0）-maxBuffer，数字，在stdout或stderr中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死（默认:200\\*1024）-killSignal，字符串，结束信号（默认：'SIGTERM'）-uid，数字，设置用户进程的ID-gid，数字，设置进程组的ID**callback：**回调函数，包含三个参数error,stdout和stderr。**exec()方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。**####实例####support.js文件代码`console.log(\"进程\"+process.argv[2]+\"执行。\");`####master.js文件代码```jsconstfs=require('fs')constchild_process=require('child_process')for(vari=0;i<3;i++){varworkerProcess=child_process.exec('nodesupport.js'+i,function(error,stdout,stderr){if(error){console.log(error.stack)console.log('Errorcode:'+error.code)console.log('Signalreceived:'+error.signal)}console.log('stdout:'+stdout)console.log('stderr:'+stderr)},)workerProcess.on('exit',function(code){console.log('子进程已退出，退出码'+code)})}```执行以上代码，输出结果为：```$nodemaster.js子进程已退出，退出码0stdout:进程1执行。stderr:子进程已退出，退出码0stdout:进程0执行。stderr:子进程已退出，退出码0stdout:进程2执行。stderr:```###spawn()方法child_process.spawn使用指定的命令行参数创建新进程，语法格式如下：```child_process.spawn(command[,args][,options])```参数说明如下：**command：**将要运行的命令**args：**Array字符串参数数组**optionsObject**-cwdString子进程的当前工作目录-envObject环境变量键值对-stdioArray|String子进程的stdio配置-detachedBoolean这个子进程将会变成进程组的领导-uidNumber设置用户进程的ID-gidNumber设置进程组的IDspawn()方法返回流(stdout&stderr)，在进程返回大量数据时使用。进程一旦开始执行时spawn()就开始接收响应。####实例让我们创建两个js文件support.js和master.js。####support.js文件代码`console.log(\"进程\"+process.argv[2]+\"执行。\");`####master.js文件代码```jsconstfs=require('fs')constchild_process=require('child_process')for(vari=0;i<3;i++){varworkerProcess=child_process.spawn('node',['support.js',i])workerProcess.stdout.on('data',function(data){console.log('stdout:'+data)})workerProcess.stderr.on('data',function(data){console.log('stderr:'+data)})workerProcess.on('close',function(code){console.log('子进程已退出，退出码'+code)})}```执行以上代码，输出结果为：```$nodemaster.jsstdout:进程0执行。子进程已退出，退出码0stdout:进程1执行。子进程已退出，退出码0stdout:进程2执行。子进程已退出，退出码0```###fork方法child_process.fork是spawn()方法的特殊形式，用于创建进程，语法格式如下：```child_process.fork(modulePath[,args][,options])```参数说明如下：**modulePath**：String，将要在子进程中运行的模块**args**：Array字符串参数数组**options**：Object-cwdString子进程的当前工作目录-envObject环境变量键值对-execPathString创建子进程的可执行文件-execArgvArray子进程的可执行文件的字符串参数数组（默认：process.execArgv）-silentBoolean如果为`true`，子进程的`stdin`，`stdout`和`stderr`将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：`false`）-uidNumber设置用户进程的ID-gidNumber设置进程组的ID返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。####实例让我们创建两个js文件support.js和master.js。####support.js文件代码`console.log(\"进程\"+process.argv[2]+\"执行。\");`####master.js文件代码```jsconstfs=require('fs')constchild_process=require('child_process')for(vari=0;i<3;i++){varworker_process=child_process.fork('support.js',[i])worker_process.on('close',function(code){console.log('子进程已退出，退出码'+code)})}```执行以上代码，输出结果为：```$nodemaster.js进程0执行。子进程已退出，退出码0进程1执行。子进程已退出，退出码0进程2执行。子进程已退出，退出码0```##Node连接mongoDB###安装驱动```cnpminstallmongodb```---###创建数据库>要在MongoDB中创建一个数据库，首先我们需要创建一个MongoClient对象，然后配置好指定的URL和端口号。>>如果数据库不存在，MongoDB将创建数据库并建立连接。###创建连接```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/grh'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrconsole.log('数据库已创建!')db.close()})```---###创建集合我们可以使用createCollection()方法来创建集合：```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/grh'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrconsole.log('数据库已创建')vardbase=db.db('grh')dbase.createCollection('site',function(err,res){if(err)throwerrconsole.log('创建集合!')db.close()})})```---###数据库操作(CURD)####插入一条数据insertOne()```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')varmyobj={name:'grh',url:'www.grh'}dbo.collection('site').insertOne(myobj,function(err,res){if(err)throwerrconsole.log('文档插入成功')db.close()})})```执行以下命令输出就结果为：```$nodetest.js文档插入成功```从输出结果来看，数据已插入成功。我们也可以打开MongoDB的客户端查看数据，如：```>showdbsgrh0.000GB#自动创建了grh数据库>showtablessite#自动创建了site集合（数据表）>db.site.find(){\"_id\":ObjectId(\"5a794e36763eb821b24db854\"),\"name\":\"grh\",\"url\":\"www.grh\"}>```####插入多条数据**insertMany()**```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')varmyobj=[{name:'菜鸟工具',url:'https://c.grh.com',type:'cn'},{name:'Google',url:'https://www.google.com',type:'en'},{name:'Facebook',url:'https://www.google.com',type:'en'},]dbo.collection('site').insertMany(myobj,function(err,res){if(err)throwerrconsole.log('插入的文档数量为:'+res.insertedCount)db.close()})})```res.insertedCount为插入的条数。####查询数据find()```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')dbo.collection('site').find({}).toArray(function(err,result){//返回集合中所有数据if(err)throwerrconsole.log(result)db.close()})})```####查询指定条件的数据>以下实例检索name为\"grh\"的实例：```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')varwhereStr={name:'grh'}//查询条件dbo.collection('site').find(whereStr).toArray(function(err,result){if(err)throwerrconsole.log(result)db.close()})})```执行以下命令输出就结果为：```json[{_id:5a794e36763eb821b24db854,name:'grh',url:'www.grh.com'}]```####更新一条数据>将name为\"grh\"的url改为`https://www.grh.com`：```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')varwhereStr={name:'grh'}//查询条件varupdateStr={$set:{url:'https://www.grh.com'}}dbo.collection('site').updateOne(whereStr,updateStr,function(err,res){if(err)throwerrconsole.log('文档更新成功')db.close()})})```执行成功后，进入mongo管理工具查看数据已修改：```>db.site.find().pretty(){\"_id\":ObjectId(\"5a794e36763eb821b24db854\"),\"name\":\"grh\",\"url\":\"https://www.grh.com\"//已修改为https}```如果要更新所有符合条的文档数据可以使用**updateMany()**：####更新多条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')varwhereStr={type:'en'}//查询条件varupdateStr={$set:{url:'https://www.grh.com'}}dbo.collection('site').updateMany(whereStr,updateStr,function(err,res){if(err)throwerrconsole.log(res.result.nModified+'条文档被更新')db.close()})})```result.nModified为更新的条数。---####删除一条数据>将name为\"grh\"的数据删除:```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')varwhereStr={name:'grh'}//查询条件dbo.collection('site').deleteOne(whereStr,function(err,obj){if(err)throwerrconsole.log('文档删除成功')db.close()})})```执行成功后，进入mongo管理工具查看数据已删除：```>db.site.find()>```---####删除多条数据>将type为en的所有数据删除:>>删除多条语句可以使用**deleteMany()**方法```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')varwhereStr={type:'en'}//查询条件dbo.collection('site').deleteMany(whereStr,function(err,obj){if(err)throwerrconsole.log(obj.result.n+'条文档被删除')db.close()})})```obj.result.n删除的条数。####排序排序使用sort()方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。```{type:1}//按type字段升序{type:-1}//按type字段降序```按type升序排列:```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')varmysort={type:1}dbo.collection('site').find().sort(mysort).toArray(function(err,result){if(err)throwerrconsole.log(result)db.close()})})```####查询分页如果要设置指定的返回条数可以使用**limit()**方法，该方法只接受一个参数，指定了返回的条数。#####limit()：读取两条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')dbo.collection('site').find().limit(2).toArray(function(err,result){if(err)throwerrconsole.log(result)db.close()})})```如果要指定跳过的条数，可以使用**skip()**方法。#####skip():跳过前面两条数据，读取两条数据```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')dbo.collection('site').find().skip(2).limit(2).toArray(function(err,result){if(err)throwerrconsole.log(result)db.close()})})```####连接操作mongoDB不是一个关系型数据库，但我们可以使用**$lookup**来实现左连接。例如我们有两个集合数据分别为：集合1：orders```[{_id:1,product_id:154,status:1}]```集合2：products```[{_id:154,name:'笔记本电脑'},{_id:155,name:'耳机'},{_id:156,name:'台式电脑'}]```####$lookup实现左连接```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://127.0.0.1:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')dbo.collection('orders').aggregate([{$lookup:{from:'products',//右集合localField:'product_id',//左集合join字段foreignField:'_id',//右集合join字段as:'orderdetails',//新生成字段（类型array）},},]).toArray(function(err,res){if(err)throwerrconsole.log(JSON.stringify(res))db.close()})})```####删除集合drop()```jsvarMongoClient=require('mongodb').MongoClientvarurl='mongodb://localhost:27017/'MongoClient.connect(url,{useNewUrlParser:true},function(err,db){if(err)throwerrvardbo=db.db('grh')//删除test集合dbo.collection('test').drop(function(err,delOK){//执行成功delOK返回true，否则返回falseif(err)throwerrif(delOK)console.log('集合已删除')db.close()})})```","Front-End\\Node\\基础\\node-mysql.md":"#Node.js连接MySQL介绍如何使用Node.js来连接MySQL，并对数据库进行操作。###安装驱动```cnpminstallmysql```###连接数据库在以下实例中根据你的实际配置修改数据库用户名、及密码及数据库名：##test.js文件代码```javascriptvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',database:'test',})connection.connect()connection.query('SELECT1+1ASsolution',function(error,results,fields){if(error)throwerrorconsole.log('Thesolutionis:',results[0].solution)})```执行以下命令输出结果为：>$nodetest.js>Thesolutionis:2##数据库操作(CURD)###查询数据将上面我们提供的SQL文件导入数据库后，执行以下代码即可查询出数据：##查询数据```javascriptvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',port:'3306',database:'test',})connection.connect()varsql='SELECT*FROMwebsites'//查connection.query(sql,function(err,result){if(err){console.log('[SELECTERROR]-',err.message)return}console.log('------SELECT------')console.log(result)console.log('------------------')})connection.end()```执行以下命令输出就结果为：```shell$nodetest.js--------------------------SELECT----------------------------[RowDataPacket{id:1,name:'Google',url:'https://www.google.cm/',alexa:1,country:'USA'},RowDataPacket{id:2,name:'淘宝',url:'https://www.taobao.com/',alexa:13,country:'CN'}]------------------------------------------------------------```###插入数据我们可以向数据表websties插入数据：##插入数据```javascriptvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',port:'3306',database:'test',})connection.connect()varaddSql='INSERTINTOwebsites(Id,name,url,alexa,country)VALUES(0,?,?,?,?)'varaddSqlParams=['工具','https://c.sxb.com','23453','CN']//增connection.query(addSql,addSqlParams,function(err,result){if(err){console.log('[INSERTERROR]-',err.message)return}console.log('------INSERT------')//console.log('INSERTID:',result.insertId);console.log('INSERTID:',result)console.log('--------------\\n\\n')})connection.end()```执行以下命令输出就结果为：```$nodetest.js--------------------------INSERT----------------------------INSERTID:OkPacket{fieldCount:0,affectedRows:1,insertId:6,serverStatus:2,warningCount:0,message:'',protocol41:true,changedRows:0}-----------------------------------------------------------------```执行成功后，查看数据表，即可以看到添加的数据###更新数据我们也可以对数据库的数据进行修改：##更新数据```javascriptvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',port:'3306',database:'test',})connection.connect()varmodSql='UPDATEwebsitesSETname=?,url=?WHEREId=?'varmodSqlParams=['移动站','https://m.sxt.com',6]//改connection.query(modSql,modSqlParams,function(err,result){if(err){console.log('[UPDATEERROR]-',err.message)return}console.log('--------UPDATE--------')console.log('UPDATEaffectedRows',result.affectedRows)console.log('----------\\n\\n')})connection.end()```执行以下命令输出就结果为：```shell--------------------------UPDATE----------------------------UPDATEaffectedRows1-----------------------------------------------------------------```执行成功后，查看数据表###删除数据我们可以使用以下代码来删除id为6的数据:##删除数据```javascriptvarmysql=require('mysql')varconnection=mysql.createConnection({host:'localhost',user:'root',password:'123456',port:'3306',database:'test',})connection.connect()vardelSql='DELETEFROMwebsiteswhereid=6'//删connection.query(delSql,function(err,result){if(err){console.log('[DELETEERROR]-',err.message)return}console.log('-----DELETE-------')console.log('DELETEaffectedRows',result.affectedRows)console.log('----------------\\n\\n')})connection.end()```执行以下命令输出就结果为：```--------------------------DELETE----------------------------DELETEaffectedRows1-----------------------------------------------------------------```执行成功后，查看数据表","Front-End\\Node\\基础\\接收参数.md":"#Node接收参数>利用node内置对象`process`##命令行接收参数```jsprocess.argv.forEach((val,index)=>{console.log({index,val});})nodeindex.jsa=1bc{index:0,val:'node程序的路径'}{index:1,val:'当前执行文件的路径'}{index:2,val:'a=1'}{index:3,val:'b'}{index:4,val:'c'}```##命令行接收输入```jsconstreadline=require('readline').createInterface({input:process.stdin,output:process.stdout})readline.question(`你叫什么名字?`,name=>{console.log(`你好${name}!`)readline.close()})你叫什么名字?guanruihua你好guanruihua!```如果需要密码，则最好不要回显密码，而是显示`*`符号。最简单的方式是使用[`readline-sync`软件包](https://www.npmjs.com/package/readline-sync)，其在API方面非常相似。[Inquirer.js软件包](https://github.com/SBoudrias/Inquirer.js)则提供了更完整、更抽象的解决方案。可以使用`npminstallinquirer`进行安装，然后复用上面的代码如下：```jsJScopyconstinquirer=require('inquirer')varquestions=[{type:'input',name:'name',message:\"你叫什么名字?\"}]inquirer.prompt(questions).then(answers=>{console.log(`你好${answers['name']}!`)})```Inquirer.js可以执行许多操作，例如询问多项选择、展示单选按钮、确认等。所有的可选方案都值得了解，尤其是Node.js提供的内置方案，但是如果打算将CLI输入提升到更高的水平，则Inquirer.js是更优的选择。","Front-End\\Node\\基础\\模块化.md":"#模块化-Node.js采用的是CommonJs规范，在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。-在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。-Node.js中模块的分类：-核心模块（已经封装好的内置模块）-自己定义的模块-第三方的模块（npm下载下来的）##require-`require`函数用来在一个模块中引入另外一个模块。传入一个模块名，返回一个模块导出对象。-用法：`constcc=require(\"模块名\")`，其中模块名可以用绝对路径也可以用相对路径,模块的后缀名.js可以省略。例如：```jsconstcc1=require('./main.js')constcc2=require('home/src/main.js')constcc3=require('./main')```require()函数用两个作用：-执行导入的模块中的代码；-返回导入模块中的接口对象；##exports`exports`对象用来导出当前模块的公共方法或属性，别的模块通过`require`函数使用当前模块时得到的就是当前模块的`exports`对象。用法：`exports.name`,name为导出的对象名。例子：```jsexports.add=function(){leti=0console.log(++i)}//导出一个add方法供其他模块使用```-其实exports类似于ES6中的export的用法，用来导出一个指定名字的对象。##module.exports`module.exports`用来导出一个默认对象，没有指定对象名，常见于修改模块的原始导出对象。比如原本模块导出的是一个对象，我们可以通过module.exports修改为导出一个函数。如下：```jsmodule.exports=function(){console.log('helloworld！')}```1.模块的初始化一个模块中的JS代码仅在模块**第一次被使用时**执行一次，并且在使用的过程中进行*初始化*，之后缓存起来便于后续继续使用。1.主模块通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，main.js就是主模块。```shnodemain.js//运行main.js启动程序，main.js称为主模块```完整实例：在项目中我们有个`hello.js`文件，里面定义了一个求和的函数```jsvara=1functionadd(){return++a}exports.add=add```我们在项目的主模块`main.js`中引入`hello.js````jsvaradd1=require('./hello')varadd2=require('./hello')console.log(add1.add())console.log(add2.add())```该程序运行的结果如下：```shell$nodemain.js23```我们可以看到`hello.js`并没有别引入两次而初始化两次，说明模块只会在执行的过程中被初始化一次。##module.exports和exports的区别###前言-Node中，每个模块都有一个`exports`接口对象，我们需要把公共的方法或者字符串挂载在这个接口对象中，其他的模块才可以使用。-Node.js中只有模块作用域，默认两个模块之间的变量，方法互不冲突，互不影响，这样就导致一个问题，我们怎样使用加载进来的模块中的方法呢？这就需要在另外一个模块`exports`接口对象中挂载模块中公共的方法。1.exports我们在`a.js`中有以下代码：```jsletfoo='hello'functionadd(x,y){returnx+y}exports.add=add//在接口对象中挂载公共的add方法exports.foo=foo//在接口对象中挂载foo属性```此时，在`b.js`中如果需要使用`add`方法,只需引入`a.js`即可。`b.js`代码如下：```jsleta=require('./a.js')//a.js和b.js在同级目录下，注意：同级目录必须加“./”console.log(a.add(20,30))//使用a.js中的add方法```相反，如果我们没有在`a.js`exports接口对象中挂载add方法，那么这里就得不到结果。1.module.exports对于1中的例子，我们同样可以利用`module.exports`来写，只需把暴露的方式改成如下：```jsmodule.exports.add=addmodule.exports.foo=foo```###总结1.Node中每个模块都有一个`module`对象，`module`对象中的有一个`exports`属性为一个接口对象，我们需要把模块之间公共的方法或属性挂载在这个接口对象中，方便其他的模块使用这些公共的方法或属性。2.Node中每个模块的最后，都会`return:module.exports`。3.Node中每个模块都会把`module.exports`指向的对象赋值给一个变量`exports`，也就是说：`exports=module.exports`。4.`module.exports=XXX`，表示当前模块导出一个单一成员，结果就是XXX。5.如果需要导出多个成员时必须使用`exports.add=XXX;exports.foo=XXX;`或者使用`module.exports.add=XXX;module.export.foo=XXX;`。##require加载第三方包的规则Node.js中使用`CommonJs`模块化机制，通过`npm`下载的第三方包，我们在项目中引入第三方包都是：`letxx=require('第三方包名')`，究竟`require`方法加载第三方包的原理机制是什么，今天我们来探讨下。1.`require('第三方包名')`优先在加载该包的模块的同级目录`node_modules`中查找第三方包。```jslettemplate=require('art-template')//加载第三方包```1.找到该第三方包中的`package.json`文件，并且找到里面的`main`属性对应的入口模块，该入口模块即为加载的第三方模块。2.如果在要加载的第三方包中没有找到`package.json`文件或者是`package.json`文件中没有`main`属性，则默认加载第三方包中的`index.js`文件。3.如果在加载第三方模块的文件的同级目录没有找到`node_modules`文件夹，或者以上所有情况都没有找到，则会向上一级父级目录下查找`node_modules`文件夹，查找规则如上一致。4.如果一直找到该模块的磁盘根路径都没有找到，则会报错：`cannotfindmodulexxx`。","Front-End\\Node\\虚拟机.md":"#[`虚拟机`]()-<https://nodejs.cn/api/vm.html>","Front-End\\Node\\读取git信息.md":"#[读取git信息](https://blog.csdn.net/wang1006008051/article/details/103699669)","Front-End\\Package\\dumi\\index.md":"#[dumi](https://d.umijs.org)>资源路径问题,目前不打算使用##初始化环境准备确保正确安装Node.js且版本为14+即可。```shell$node-vv14.19.1```##脚手架```shell#先找个地方建个空目录$mkdirmyapp&&cdmyapp#通过官方工具创建项目，选择你需要的模板$npxcreate-dumi#安装依赖后启动项目$npmstart```##目录结构一个普通的、使用dumi做研发的组件库目录结构大致如下：```.├──docs#组件库文档目录│├──index.md#组件库文档首页│├──guide#组件库其他文档路由表（示意）││├──index.md││└──help.md├──src#组件库源码目录│├──Button#单个组件││├──`index.tsx`#组件源码││├──`index.less`#组件样式││└──index.md#组件文档│└──index.ts#组件库入口文件├──`.dumirc.ts`#dumi配置文件└──`.fatherrc.ts`#father-build的配置文件，用于组件库打包```如果是单纯的文档站点、不包含组件源码，忽略上面的src目录结构即可。>注意，此处仅对目录结构做说明，如果要初始化一个dumi项目，建议直接使用create-dumi的脚手架进行创建。###约定式路由为了使得路由生成更容易理解、更易于控制，dumi对`Markdown`文档的目录解析做了『文档路由』及『资产路由』的概念拆分。默认情况下，docs目录下的`Markdown`文档及`.dumi/pages`下的`React`组件会根据目录结构解析为文档路由，src目录下第一层级的`Markdown`文档会被解析为`/components`下的资产路由，我们可以通过配置项`resolve.atomDirs`对资产路由前缀及解析目录进行更改。举几个例子方便理解：|磁盘路径|解析结果||:------------------------------------|:---------------------------------------------------------||`/path/to/.dumi/pages/hello.tsx`|-导航：Hello<br/>-页面路由：/hello||`/path/to/docs/hello.md`|-导航：Hello<br/>-页面路由：/hello||`/path/to/docs/hello/index.md`|-导航：Hello<br/>-页面路由：/hello||`/path/to/docs/hello/world/dumi.md`|-导航：Hello<br/>-页面路由：`/hello/world/dumi`||`/path/to/src/hello.md`|-导航：`Components`<br/>-页面路由：`/components/hello`||`/path/to/src/hello/index.md`|-导航：`Components`<br/>-页面路由：`/components/hello`||`/path/to/src/hello/world.md`|不识别||`/path/to/src/hello/another/world.md`|不识别|除此之外，以下内容也不会被识别：-以.开头的目录及文档-以\\_开头的目录及文档###自定义导航、分组和标题>如果希望控制导航/分组/页面标题的生成，可以通过在Markdown文件顶部编写`FrontMatter`实现：```md---title:自定义页面名称nav:title:自定义导航名称order:控制导航顺序，数字越小越靠前，默认以路径长度和字典序排序group:title:自定义分组名称order:控制分组顺序，数字越小越靠前，默认以路径长度和字典序排序---<!--其他Markdown内容-->```","Front-End\\Package\\dva\\问题.md":"#dva问题##项目打包后,要刷新才正常-date:2022-11-1610:28:11>有问题浏览器:>>-Chrome(Version109.0.5410.0(OfficialBuild)dev(64-bit))>-Chrome(Version107.0.5304.107(OfficialBuild)(64-bit))>-edge(版本107.0.1418.42(正式版本)(64位))>>正常浏览器:火狐>>-强制清理缓存,重复多次,也有概率复现![](./.assets/问题-2022-11-16-10-27-35.png)##react+dva+antd打包运行，项目时常出现报错：Loadingchunknfailed.——求解决>表现的形式:页面空白，控制栏报错如下：除非强制刷新页面才可以正常展示。不是每个页面都会出现，偶尔出现>![](./.assets/问题-2022-11-16-10-32-23.png)","Front-End\\Package\\hexo.md":"#**hexo**>-[官网](https://hexo.io/zh-cn/docs/)##hexo常用指令|指令|指令||------------------|-------------------------|-------||清理缓存|`hexoclean`||生成静态文件|`hexogenerate|hexog`||部署到git上|`hexodeploy|hexod`||执行上面三条指令|`hexogenerate--deploy`||写作|`hexonewnoteName`||本地服务器打开运行|`hexoserver`|##注意点>写笔记尽量不要少写链接,可能会出现错误##新建blog```basichexoinit<folder>cd<folder>npminstall//安装依赖包hexoserver//运行```##问题1.部署到码云上没有样式修改配置文件\\_config.yml```yml#URL##Ifyoursiteisputinasubdirectory,seturlas'http://yoursite.com/child'androotas'/child/'url:http://grh-gitee.gitee.io/grh/root:/grh/permalink::year/:month/:day/:title/permalink_defaults:```2.hexo推送到多个平台```shelldeploy:type:gitrepo:github:git@github.com:AshinWang/AshinWang.github.io.gitcoding:git@git.coding.net:AshinWang/AshinWang.coding.me.gitgitee:git@gitee.com:AshinWang/AshinWang.gitbranch:master```##修改主题默认样式###1.问题:li和p默认居中显示修改source/css/\\_partial/aricle.styl```stylusullitext-align:leftptext-align:left```###2.关闭tags的渲染,但是不关闭tagcloud修改themes\\landscape\\layout_partial\\sidebar.ejs```ejs<asideid=\"sidebar\"<%if(theme.sidebar==='bottom'){%>class=\"outer\"<%}%>><%theme.widgets.forEach(function(widget){%><%if(widget!='tag'){%><%-partial('_widget/'+widget)%><%}%><%})%></aside>```##从零开始制作hexo主题>config变量:包含站点配置(即\\_config.yml中的配置)>>page.posts:获取单篇文章的数据,并获取文章的标题,内容等数据填充到模板中>>无需刷新加载插件[jquery-pjax](<[http://bsify.admui.com/jquery-pjax/?id=%e6%94%b9%e5%8f%98%e6%b5%8f%e8%a7%88%e5%99%a8url](http://bsify.admui.com/jquery-pjax/?id=改变浏览器url)>)>>代码高亮插件[highlight](https://highlightjs.org/download/)>>[图标和字体](https://highlightjs.org/download/)>>[开发参考](https://www.cnblogs.com/yyhh/p/11058985.html)```ejs<%page.posts.each(function(post){%><%console.log(post)%><%})%>``````<%site.posts.forEach(function(post){%><%-post.path%><br/><%-post.slug%>//笔记文件相对路径<br/><%-post._id%><br/><%-post.title%><br/><%-post.date%><br/><ahref=\"/<%-post.path%>\"><%-post.title%></a><%})%><%console.log(site.posts)%>这里是layout.ejs<%-include('index')%><%-include('post')%>```引入高亮插件问题```jslocalhost/:1拒绝从“http://localhost:4000/lib/lighligh/styles/agate”应用样式。因为它的MIME类型('text/html')不是一个受支持的样式表MIME类型，并且启用了严格的MIME检查。``````html//换成该方法<linkrel=\"stylesheet\"type=\"text/html\"href=\"../source/lib/highlight/styles/dark.css\"/>```##更换主题","Front-End\\Package\\http-server..md":"#http-server>-http-server是一个简单的零配置命令行静态HTTP服务器>-它足够强大，可以用于生产用途，但它足够简单且易于破解，可用于测试，本地开发和学习##安装`npminstall--globalhttp-server`##运行`npxhttp-server[path][options]`##用法`http-server[path][options]`>[path]如果文件夹存在，则默认为，否则。./public./>>现在，您可以访问<http://localhost:8080>查看您的服务器>注意：默认情况下，缓存处于打开状态。添加为禁用缓存的选项。-c-1可用选项：|命令|描述|默认||:-------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------:|:------:||-p或--port|要使用的端口。用于查找从8080开始的开放端口。它还将从中读取。-p0process.env.PORT|8080||-a|要使用的地址|0.0.0.0||-d|显示目录列表|true||-i|显示自动索引|true||-g或--gzip|启用后，它将代替文件的gzip版本存在并且请求接受gzip编码时使用。如果还启用了brotli，它将尝试先提供brotli。`./public/some-file.js.gz./public/some-file.js`|false||-b或--brotli|启用后，它将代替文件的brotli压缩版本存在并且请求接受编码的情况。如果gzip也启用了，它将尝试先提供brotli。`./public/some-file.js.br./public/some-file.jsbr`|false||-e或--ext|默认文件扩展名（如果未提供）|html||-s或--silent|禁止显示输出中的日志消息||--cors|通过标头启用CORSAccess-Control-Allow-Origin||-o[path]|启动服务器后打开浏览器窗口。（可选）提供要打开的URL路径。例如：-o/other/dir/||-c|为缓存控制最大期限标头设置缓存时间（以秒为单位），例如持续10秒钟。要禁用缓存，请使用。-c10-c-1|3600||-U或--utc|在日志消息中使用UTC时间格式。||--log-ip|启用客户端IP地址的日志记录|false||-P或--proxy|将所有无法在本地解析的请求代理到给定的URL。例如：-P<http://someurl.com>||--proxy-options|使用嵌套的虚线对象传递代理选项。例如：--proxy-options.secure|false||--username|用于基本身份验证的用户名||--password|基本身份验证的密码||-S或--tls--ssl|启用使用TLS/SSL（HTTPS）提供安全请求服务|false||-C或--certSSL|证书文件的路径|cert.pem||-K或--keySSL|密钥文件的路径|key.pem||-r或--robots|自动提供/robots.txt（其内容默认为User-agent:\\*\\nDisallow:/)|false||--no-dotfiles|不显示点文件||--mimetypes|用于自定义mimetype定义的.types文件的路径||-h或--help|打印此列表并退出||-v或--version|打印版本并退出|###魔术文件>index.html将作为任何目录请求的默认文件。>404.html如果未找到文件，将送达。这可用于单页应用（SPA）托管以服务入口页面。###捕获所有重定向>要实现无限别名重定向，请使用索引页本身作为代理，并执行以下操作：>`http-server--proxy<http://localhost:8080>?`>请注意代理URL末尾的###断续器/域名解析>首先，您需要确保openssl已正确安装，并且您拥有和文件。您可以使用以下命令生成它们：key.pemcert.pem>>`opensslreq-newkeyrsa:2048-new-nodes-x509-days3650-keyoutkey.pem-outcert.pem`>输入命令后，系统将提示您几个问题。如果您希望能够在操作系统的根证书存储或浏览器中安装证书，以便它受信任，则将其用作值。127.0.0.1Commonname>>这将生成一个证书密钥对，有效期为3650天（约10年）>然后，您需要运行用于启用SSL和证书文件的服务器。-S-C>`http-server-S-Ccert.pem`>如果您希望对私钥使用密码，则可以通过-passout参数（使用foobar的密码）在openssl命令中包含一个密码短语>例如opensslreq-newkeyrsa:2048-passoutpass:foobar-keyoutkey.pem-x509-days365-outcert.pem>出于安全原因，密码短语将仅从环境变量中读取。NODE_HTTP_SERVER_SSL_PASSPHRASE>如果成功，应输出以下内容：```jsStartinguphttp-server,serving./throughhttpshttp-serversettings:CORS:disabledCache:3600secondsConnectionTimeout:120secondsDirectoryListings:visibleAutoIndex:visibleServeGZIPFiles:falseServeBrotliFiles:falseDefaultFileExtension:noneAvailableon:<https://127.0.0.1:8080><https://192.168.1.101:8080><https://192.168.1.104:8080>HitCTRL-Ctostoptheserver```","Front-End\\Package\\Quagga.md":"#Quagga>实现扫码功能","Front-End\\Package\\roadhog.md":"#roadhog>cli工具##命令###server>本地开发:`roadhogserver`###build>打包发布:`roadhogserver`###test>测试:`roadhogserver`##环境变量可环境变量临时配置一些参数，包括：PORT，端口号，默认8000HOST，默认localhostHTTPS，是否开启https，默认关闭BROWSER，设为none时，不自动打开浏览器CLEAR_CONSOLE，设为none时清屏```shell//OSX,Linux$PORT=3000roadhogserver//Windows$setPORT=3000&&roadhogserver```","Front-End\\Package\\全屏\\react-flip-toolkit.md":"#[react-flip-toolkit](https://codesandbox.io/s/74q85nq1qq?file=/src/index.js:109-127)>全屏最大化","Front-End\\Package\\兼容性.md":"#兼容性##标签兼容性>1.[caniuse](https://caniuse.com/)>2.安装使用caniuse-cmd>1.安装`npminstall-gcaniuse-cmd`>2.使用`caniuse+<elementname>[标签名]`","Front-End\\Package\\国际化.md":"#国际化>[React项目国际化介绍（react-i18next、react-intl)](https://www.jianshu.com/p/2f8d6e0b4adb)>>[React项目多语言国际化：react-i18next插件实现——本地数据篇-SegmentFault思否](https://segmentfault.com/a/1190000040477248)","Front-End\\Package\\工具包\\index.md":"#工具包-[uuid](https://www.npmjs.com/package/uuid)","Front-End\\Package\\工具包\\jquery\\jquery-demo.md":"#jquery-demo##鼠标悬停时,弹出下拉菜单[重要]```html<!DOCTYPEhtml><html><headlang=\"en\"><metacharset=\"UTF-8\"/><title></title><styletype=\"text/css\">*{margin:0;padding:0;}ul{list-style:none;}.wrap{width:330px;height:30px;margin:100pxauto0;padding-left:10px;background-color:pink;}.wrapli{background-color:yellowgreen;}.wrap>ul>li{float:left;margin-right:10px;position:relative;}.wrapa{display:block;height:30px;width:100px;text-decoration:none;color:#000;line-height:30px;text-align:center;}.wrapliul{position:absolute;top:30px;display:none;}</style></head><body><divclass=\"wrap\"><ul><li><ahref=\"javascript:void(0);\">一级菜单1</a><ul><li><ahref=\"javascript:void(0);\">二级菜单1</a></li><li><ahref=\"javascript:void(0);\">二级菜单2</a></li><li><ahref=\"javascript:void(0);\">二级菜单3</a></li></ul></li><li><ahref=\"javascript:void(0);\">一级菜单1</a><ul><li><ahref=\"javascript:void(0);\">二级菜单1</a></li><li><ahref=\"javascript:void(0);\">二级菜单2</a></li><li><ahref=\"javascript:void(0);\">二级菜单3</a></li></ul></li><li><ahref=\"javascript:void(0);\">一级菜单1</a><ul><li><ahref=\"javascript:void(0);\">二级菜单1</a></li><li><ahref=\"javascript:void(0);\">二级菜单2</a></li><li><ahref=\"javascript:void(0);\">二级菜单3</a></li></ul></li></ul></div><scriptsrc=\"https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.min.js\"></script><script>//入口函数$(document).ready(function(){//需求：鼠标放入一级li中，让他里面的ul显示。移开隐藏。varjqli=$('.wrap>ul>li')//绑定事件jqli.mouseenter(function(){//这个位置用到了this.//console.log(this);//打印结果是js中的dom对象。注意：jquery对象绑定的事件中，this指js中的dom对象。【重要】//让this中的ul显示出来。//原生js的做法是：this.children[1].style.display=\"block\";//把js的dom对象包装为jquery对象，然后用jquery方法操作$(this).children('ul').show()})//绑定事件：鼠标移开时，隐藏下拉菜单jqli.mouseleave(function(){$(this).children('ul').hide()})})</script></body></html>```![img](http://img.smyhvae.com/20180205_1030.gif)##突出显示```html<!DOCTYPEhtml><html><headlang=\"en\"><metacharset=\"UTF-8\"/><title></title><styletype=\"text/css\">*{margin:0;padding:0;}ul{list-style:none;}body{background:#000;}.wrap{margin:100pxauto0;width:630px;height:394px;padding:10px0010px;background:#000;overflow:hidden;border:1pxsolid#fff;}.wrapli{float:left;margin:010px10px0;}.wrapimg{display:block;border:0;}</style><scriptsrc=\"jquery-1.11.1.js\"></script><script>jQuery(window).ready(function(){//需求：鼠标放入li中，其他的li半透明，当前盒子的opacity值为1$('.wrap').find('li').mouseenter(function(){//链式编程$(this).css('opacity',1).siblings('li').css('opacity',0.4)})//离开wrap的时候所有的li的全部opacity值为1；$('.wrap').mouseleave(function(){$(this).children().children('li').css('opacity',1)//$(\".wrapli\").css(\"opacity\",1);})})</script></head><body><divclass=\"wrap\"><ul><li><ahref=\"#\"><imgsrc=\"images/01.jpg\"alt=\"\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/02.jpg\"alt=\"\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/03.jpg\"alt=\"\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/04.jpg\"alt=\"\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/05.jpg\"alt=\"\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/06.jpg\"alt=\"\"/></a></li></ul></div></body></html>```![img](http://img.smyhvae.com/20180205_1118_2.gif)##淘宝精品服饰广告```html<!DOCTYPEhtml><html><headlang=\"en\"><metacharset=\"UTF-8\"/><title></title><styletype=\"text/css\">*{margin:0;padding:0;font-size:12px;}ul{list-style:none;}a{text-decoration:none;}.wrapper{width:298px;height:248px;margin:100pxauto0;border:1pxsolidpink;overflow:hidden;}#left,#center,#right{float:left;}#leftli,#rightli{background:url(images/lili.jpg)repeat-x;}#leftlia,#rightlia{display:block;width:48px;height:27px;border-bottom:1pxsolidpink;line-height:27px;text-align:center;color:black;}#leftlia:hover,#rightlia:hover{background-image:url(images/abg.gif);}#center{border-left:1pxsolidpink;border-right:1pxsolidpink;}</style><scriptsrc=\"jquery-1.11.1.js\"></script><script>jQuery(function(){//需求：鼠标放入两侧的li中，让中间的ul中对应索引值的li显示出来，其他的隐藏。（右侧的li要+9）//左侧先绑。获取绑mouseenter$('#leftli').mouseenter(function(){//显示对应索引值的中间的li//alert($(this).index());获取索引值$('#centerli').eq($(this).index()).show().siblings('li').hide()})//右侧$('#rightli').mouseenter(function(){//显示对应索引值的中间的li//alert($(this).index());获取索引值$('#centerli:eq('+($(this).index()+9)+')').show().siblings('li').hide()})})</script></head><body><divclass=\"wrapper\"><ulid=\"left\"><li><ahref=\"#\">女靴</a></li><li><ahref=\"#\">雪地靴</a></li><li><ahref=\"#\">冬裙</a></li><li><ahref=\"#\">呢大衣</a></li><li><ahref=\"#\">毛衣</a></li><li><ahref=\"#\">棉服</a></li><li><ahref=\"#\">女裤</a></li><li><ahref=\"#\">羽绒服</a></li><li><ahref=\"#\">牛仔裤</a></li></ul><ulid=\"center\"><li><ahref=\"#\"><imgsrc=\"images/女靴.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/雪地靴.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/冬裙.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/呢大衣.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/毛衣.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/棉服.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/女裤.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/羽绒服.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/牛仔裤.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/女包.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/男包.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/登山鞋.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/皮带.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/围巾.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/皮衣.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/男毛衣.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/男棉服.jpg\"width=\"200\"height=\"250\"/></a></li><li><ahref=\"#\"><imgsrc=\"images/男靴.jpg\"width=\"200\"height=\"250\"/></a></li></ul><ulid=\"right\"><li><ahref=\"#\">女包</a></li><li><ahref=\"#\">男包</a></li><li><ahref=\"#\">登山鞋</a></li><li><ahref=\"#\">皮带</a></li><li><ahref=\"#\">围巾</a></li><li><ahref=\"#\">皮衣</a></li><li><ahref=\"#\">男毛衣</a></li><li><ahref=\"#\">男棉服</a></li><li><ahref=\"#\">男靴</a></li></ul></div></body></html>```![img](http://img.smyhvae.com/20180205_1135.gif)##手风琴效果```html<!DOCTYPEhtml><html><headlang=\"en\"><metacharset=\"UTF-8\"/><title></title><styletype=\"text/css\">*{padding:0;margin:0;}ul{list-style-type:none;}.parentWrap{width:200px;text-align:center;}.menuGroup{border:1pxsolid#999;background-color:#e0ecff;}.groupTitle{display:block;height:20px;line-height:20px;font-size:16px;border-bottom:1pxsolid#ccc;cursor:pointer;}.menuGroup>div{height:200px;background-color:#fff;display:none;}</style></head><body><ulclass=\"parentWrap\"><liclass=\"menuGroup\"><spanclass=\"groupTitle\">标题1</span><div>我是弹出来的div1</div></li><liclass=\"menuGroup\"><spanclass=\"groupTitle\">标题2</span><div>我是弹出来的div2</div></li><liclass=\"menuGroup\"><spanclass=\"groupTitle\">标题3</span><div>我是弹出来的div3</div></li><liclass=\"menuGroup\"><spanclass=\"groupTitle\">标题4</span><div>我是弹出来的div4</div></li></ul><scriptsrc=\"https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.js\"></script><script>$(function(){//需求：鼠标点击span，让他下面的div显示出来。让其他的div隐藏。$('.parentWrapspan').click(function(){//$(this).next().show();//让其他的隐藏//点击的span的父亲li，的所有的兄弟元素li，的孩子元素div全部隐藏。//$(this).parent(\"li\").siblings(\"li\").children(\"div\").hide();//连式编程$(this).next().show().parent('li').siblings('li').find('div').hide()})})</script></body></html>```![img](http://img.smyhvae.com/20180205_1120.gif)","Front-End\\Package\\工具包\\jquery\\jquery.md":"#jQuery>-官网：<http://jquery.com/>>-官网API文档：<http://api.jquery.com/>>-中文汉化API文档：<http://www.css88.com/jqapi-1.9/>>-[jQuery3.3.1)(html.cn)](https://www.html.cn/jqapi-1.9/category/utilities/)在用js写代码时，会遇到一些问题：-window.onload事件有事件覆盖的问题，因此只能写一个事件。-代码容错性差。-浏览器兼容性问题。-书写很繁琐，代码量多。-代码很乱，各个页面到处都是。-动画效果很难实现。![img](.assets/20180204_1710.png)```jsstyle.div{display:none;}htmlbutton|显示五个div盒子和设置内容-for(vari=0;i<5;i++)div<scriptsrc=\"https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.min.js\"></script><script>$(document).ready(function(){varbtn=$('button')vardiv=$('div')btn.click(function(){div.show(1000);div.html('tomorrow!');div.show(3000).html(1111);})})</script>```##jquery两大特点1.**链式编程**:比如`.show()`和`.html()`可以连写成`.show().html()`>链式编程原理:returnthis2.**隐式迭代**:在方法的内部会匹配到所有元素进行循环遍历,执行响应的方法;而不用我们在进行循环,简化操作>多元素的值,大部分情况会返回第一个元素的值##jquery版本>jquery-1.11.1.js:未压缩版>>jquery-1.11.1.min.js:压缩版(项目上线时候使用)##jquery入口函数|写法|描述||----------------------------------------|------------------------------------------------------||`$(document).ready(function(){...})`|文档加载完毕，**图片不加载**的时候，就可以执行||`$(function(){...})`|文档加载完成后,**图片不加载**的时候就执行||`$(window).ready(function(){...})`|文档加载完毕,**图片也加载完毕**的时候,在执行这个函数|**jQuery入口函数与js入口函数的区别**：区别一：书写个数不同：-Js的入口函数只能出现一次，出现多次会存在事件覆盖的问题。-jQuery的入口函数，可以出现任意多次，并不存在事件覆盖问题。区别二：执行时机不同：-Js的入口函数是在**所有的文件资源加载**完成后，才执行。这些**文件资源**包括：页面文档、外部的js文件、外部的css文件、图片等。-jQuery的入口函数，是在文档加载完成后，就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的**外部资源**都加载完成。文档加载的顺序：从上往下，边解析边执行。##jquery基础>$===jQuery>>jQuery对象转换为DOM对象:`jqbox=$(mybox)`>>```js>$();//调用上面我们自定义的函数$>$(document）.ready(function(){});//调用入口函数>$(function(){});//调用入口函数>$(“#btnShow”)//获取id属性为btnShow的元素>$(“div”)//获取所有的div标签元素>```##选择器###jquery基本选择器![img](.assets/20180204_2125.png)###层级选择器![img](.assets/20180204_2138.png)###基本过滤选择器![img](http://img.smyhvae.com/20180204_2150.png)>`:not(selector)`:除了selector都要选择$(\":not(selector)\")>>`:header`:选择标题元素(就是h标签)$(\":header\")###属性选择器![img](.assets/20180204_2155.png)##过滤器###子元素过滤器```js:first-child:last-child:nth-child():选择第n个子元素:nth-last-child():选择倒数第n个子元素:only-child选择唯一的子元素```###内容过滤器```js:contains(str):选择内容含有str的元素:empty:选择元素内容为空的:parent:选择拥有子节点的:has():选择包含指定选择器```###可见过滤器>:hidden不可见元素>>:visible可见元素###筛选选择器![img](.assets/20180204_2200.png)##事件###**常用事件**```js$(selector).action(function(){.......});```###常见文档/窗口事件```jsready()就绪load()加载unload()卸载(跳到其他页面)```###键盘事件```jskeydown()按下keypress()按下并快速释放keyup()释放```###鼠标事件```jsclick()dbclick()hover()mousedown()mouseenter()鼠标刚进入被选中元素mouseleave()鼠标刚离开被选中元素mousemove()鼠标移动事件mouseout()离开(离开子元素也会触发)mouseover()穿过mouseup()鼠标按键被释放事件toggle()一次绑定多个函数,指定元素被点击依次执行其中一个函数$(selector).toggle(function(){},function(){},function(){}....);```###**JQuery事件绑定解除**####事件绑定>bind()可以给指定元素绑定一个或多个事件```js//绑定一个事件$(selector).bind(event(事件名称),[data,]function(){})//可以绑定多个事件$(selector).bind(event1(事件名称)event2(事件名称)event3(事件名称),[data,]function(){})//可以绑定多个事件和方法$(selector).bind({event1(事件名称),[data,]function(){},event2(事件名称),[data,]function(){},event3(事件名称),[data,]function(){}})```delegate():给指定元素的**子元素**绑定一个或多个事件```js$(selector).delegate(childSelector,event,[data,]function)```==on():给指定元素或子元素绑定一个或多个事件(包含前两个的用法)==```js$(selector).on(event,[childSelector,][data,]function)```####事件解除```js//unbind()$(selector).unbind([event][,function])//undelegate$(selector).undelegate([childSelector][,event][,function])//off()$(selector).off(event,[childSelector,][data,]function)```###**jQuery特效**####**隐藏和显示**```jshide()show()toggle()用来切换hide和show```####**淡入和淡出**>【duration可以选择slow，fast】```jsfadeIn():淡入fadeOut():淡出直到隐藏fadeToggle():切换淡入和淡出fadeTo():用于将元素变成指定通明度$(selector).fadeTo(duration(持续时间),opacity(通明度)[,callback])```####**滑动**```jsslideDown():向下滑动slideUp():向上滑动slideToggle():切换向上向下滑动```####**动画**>animate({params}[,duration],[,callback])>>>params是形成动画的css属性(可以设置多个)>>>>duration:表示规定的效果时长>>>>callback:动画结束后执行的函数####**方法链接**```js$(selector).action1(),action2().action3()...;```####**停止动画**```js$(selector).stop([stopAll][,gotoEnd]);//这两个都是布尔值```##**jQueryHTMLDOM**###jQuery获取和设置####获取和设置常用的方法```jstext():文本内容html():包括html标签本身val():表单字段的值attr():指定元素的属性值css():指定元素的css值```####jQuery添加```jsappend():在指定元素内部的结尾插入内容prepend():在只当以元素的内部的开头插入内容after():在指定元素之后添加内容before():在指定元素之前添加内容```####删除remove()```js$('p').remove('.style01')//删除class=\"style01\"所有的p标签```####清空empty()####清空removeAttr()>删除元素的指定属性####类属性```jsaddClass()//添加classremoveClass()toggleClass()```####尺寸```jswidth:heightinnerWidth包括内边距innerHeightouterWidth包括内边距和边框outerHeight```###**jQuery遍历****后代遍历**```js$(selector).children([selector2]['.style1'])$(selector).find(selector2)//查找后代全部元素$(selector).filter(selector2)//过滤器,只会选择符合selector2的元素```**同胞遍历(具有相同的父元素)**```jssiblings:所有兄弟节点next:指定的下一个nextAll:指定元素后全部nextUntil(selector,selector):指定元素后的指定范围prev:指定的前一个prevAll:指定前全部prevUntil(selector,selector):指定元素前的指定范围```**祖先遍历(父,祖父,曾祖父等)**```jsparent():指定元素的直接父元素parents():指定元素的全部祖先元素parentsUntil():指定元素向上指定范围的所有祖先元素```##**AJAX技术**###**load()方法**>$(selector).load(URL[,data][,callback])>>-URL规定获取数据的URL地址,可以是文本,XML,JSON>-data:用于规定与请求一起发送给服务器的字符串(该字符串以键/值对合集)>-callback:load()完成后执行的函数```js$(\"#demo\").load(\"test.txt\")$(\"#demo\").load(\"test.txtdiv.style01\")$(selector).load(URL[,data],function(response,status,xhr){//回调函数代码//response:调用成功时的结果内容//status:调用状态,eg:success和error//xhr:表示XMLHttpRequest对象})```###**get()方法**>$.get(URL[,data][,success][,dataType]);>>​dataType规定从服务器端获取的数据类型,eg:XML,JSON,HTML等###**post()方法**>$.post(URL[,data][,success][,dataType]);###**ajax()方法**```js$.ajax({url:'demo.php',method:'POST',data:{username:'admin',password:'123'},dataType:'json',success:function(){alert('请求成功')},error:function(){alert('请求失败')},})```","Front-End\\Package\\工具包\\lodash.md":"#Lodash##前言>Lodash是一个一致性,模块化,高性能的javascript使用工具库>>[官网](https://www.lodashjs.com/)>>[LodashDocumentation](https://lodash.com/docs/4.17.15)###安装```html<scriptsrc=\"lodash.js\"></script>``````shellnpmiloadash--save``````js//Loadthefullbuild.var_=require('lodash')//Loadthecorebuild.var_=require('lodash/core')//LoadtheFPbuildforimmutableauto-curriediteratee-firstdata-lastmethods.varfp=require('lodash/fp')//Loadmethodcategories.vararray=require('lodash/array')varobject=require('lodash/fp/object')//Cherry-pickmethodsforsmallerbrowserify/rollup/webpackbundles.varat=require('lodash/at')varcurryN=require('lodash/fp/curryN')```##数组##集合##函数##对象###pick```jsvarobject={a:1,b:'2',c:3}_.pick(object,['a','c'])//=>{'a':1,'c':3}```###pickBy>第二参数,就是过滤出只要获取的值类型```jsvarobject={a:1,b:'2',c:3}_.pickBy(object,_.isNumber)//=>{'a':1,'c':3}```###omit```jsvarobject={a:1,b:'2',c:3}_.omit(object,['a','c'])//=>{'b':'2'}```##字符串##Seq##number>-clamp:限制数据的输出范围>-inRange:判断范围>-random：生成随机树```jslet_=require('lodash')letrunArray=[()=>[//后两个参数分别是上限和下限_.clamp(-10,-5,5),_.clamp(10,-5,5),],()=>[//判断第一个值是否在后两个参数定义的范围中//若总共只有两个参数第二参数为上限下限为0,若第二个参数为负数,上限为0,下限为该参数_.inRange(3,2,4),_.inRange(3,4),_.inRange(3,-4),_.inRange(-2,-4),],()=>[//三个参数分别为:上限[0],下限[1],是否为浮点数_.random(5),//改范围为0-5_.random(1,5),_.random(1,5,true),_.random(1.1,5.1),//前两个参数为浮点型,就会认为是浮点型],]runArray[runArray.length-1]().map((item)=>console.log(item))```##lang>-castArray:强制转换为数组>-clone:浅拷贝>-deepDeep:深拷贝```jslet_=require('lodash')letrunArray=[()=>[//强制转换为数组_.castArray(1),//=>[1]_.castArray({a:1}),//=>[{'a':1}]_.castArray('abc'),//=>['abc']_.castArray(null),//=>[null]_.castArray(undefined),//=>[undefined]_.castArray(),//=>[]],()=>[(()=>{//浅拷贝letobjects=[{a:1},{b:2}]letshallow=_.clone(objects)console.log(shallow[0]===objects[0])//=>true})(),(()=>{//深拷贝letobjects=[{a:1},{b:2}]letdeep=_.cloneDeep(objects)console.log(objects[0]===deep[0])console.log(deep)console.log(objects[0]['a']===deep[0]['a'])//=>false})(),],]runArray[runArray.length-1]().map((item)=>console.log(item))```","Front-End\\Package\\工具包\\mock.md":"#mock>[官网](http://mockjs.com/)>>[示例](http://mockjs.com/examples.html)>>[文档](https://github.com/nuysoft/Mock/wiki)>>用于生成随机数据,帮助前端可以提前工作##安装```bashnpminstallmockjsnpminstallmockjs-g#全局安装$randomurl#=>http://rmcpx.org/funzwc$random-h#帮助``````js//使用MockvarMock=require('mockjs')vardata=Mock.mock({//属性list的值是一个数组，其中含有1到10个元素'list|1-10':[{//属性id是一个自增数，起始值为1，每次增1'id|+1':1,},],})//输出结果console.log(JSON.stringify(data,null,4))```##语法规范>1.数据模板定义规范>2.数据占位定义规范###数据模板定义规范```bash//属性名name//生成规则rule//属性值value'name|rule':value```>七种格式>>1.'name|min-max':value>2.'name|count':value>3.'name|min-max.dmin-dmax':value>4.'name|min-max.dcount':value>5.'name|count.dmin-dmax':value>6.'name|count.dcount':value>7.'name|+step':value##Mock.mock()###Mock.mock(rurl?,rtype?,template|function(options))>根据数据模板生成模拟数据。####Mock.mock(template)>根据数据模板生成模拟数据。####Mock.mock(rurl,template)>记录数据模板。当拦截到匹配`rurl`的Ajax请求时，将根据数据模板`template`生成模拟数据，并作为响应数据返回。####Mock.mock(rurl,function(options))>记录用于生成响应数据的函数。当拦截到匹配`rurl`的Ajax请求时，函数`function(options)`将被执行，并把执行结果作为响应数据返回。####Mock.mock(rurl,rtype,template)>记录数据模板。当拦截到匹配`rurl`和`rtype`的Ajax请求时，将根据数据模板`template`生成模拟数据，并作为响应数据返回。####Mock.mock(rurl,rtype,function(options))>记录用于生成响应数据的函数。当拦截到匹配`rurl`和`rtype`的Ajax请求时，函数`function(options)`将被执行，并把执行结果作为响应数据返回。####rurl>可选。>>表示需要拦截的URL，可以是URL字符串或URL正则。例如`/\\/domain\\/list\\.json/`、`'/domian/list.json'`。####rtype>可选。>>表示需要拦截的Ajax请求类型。例如`GET`、`POST`、`PUT`、`DELETE`等。####template>可选。>表示数据模板，可以是对象或字符串。例如`{'data|1-10':[{}]}`、`'@EMAIL'`。####function(options)>可选。>>表示用于生成响应数据的函数。#####options指向本次请求的Ajax选项集，含有`url`、`type`和`body`三个属性，参见[XMLHttpRequest规范](https://xhr.spec.whatwg.org/)。>从1.0开始，Mock.js通过覆盖和模拟原生XMLHttpRequest的行为来拦截Ajax请求，不再依赖于第三方Ajax工具库（例如jQuery、Zepto等）。##Mock.setup(settings)-Mock.setup(settings)配置拦截Ajax请求时的行为。支持的配置项有：`timeout`。###settings必选。配置项集合。####timeout可选。指定被拦截的Ajax请求的响应时间，单位是毫秒。值可以是正整数，例如`400`，表示400毫秒后才会返回响应内容；也可以是横杠`'-'`风格的字符串，例如`'200-600'`，表示响应时间介于200和600毫秒之间。默认值是`'10-100'`。```Mock.setup({timeout:400})Mock.setup({timeout:'200-600'})```>目前，接口`Mock.setup(settings)`仅用于配置Ajax请求，将来可能用于配置Mock的其他行为。##Mock.RandomMock.Random是一个工具类，用于生成各种随机数据。**Mock.Random的方法在数据模板中称为『占位符』，书写格式为`@占位符(参数[,参数])`。**```jsvarRandom=Mock.RandomRandom.email()//=>\"n.clark@miller.io\"Mock.mock('@email')//=>\"y.lee@lewis.org\"Mock.mock({email:'@email'})//=>{email:\"v.lewis@hall.gov\"}```**注意**###方法Mock.Random提供的完整方法（占位符）如下：|Type|Method||-------------|-------------------------------------------------------------------------------------||Basic|boolean,natural,integer,float,character,string,range,date,time,datetime,now||Image|image,dataImage||Color|color||Text|paragraph,sentence,word,title,cparagraph,csentence,cword,ctitle||Name|first,last,name,cfirst,clast,cname||Web|url,domain,email,ip,tld||Address|region,province,city,county,zip||Helper|capitalize,upper,lower,pick,shuffle||Miscellaneous|guid,id|###扩展Mock.Random中的方法与数据模板的`@占位符`一一对应，在需要时还可以为Mock.Random扩展方法，然后在数据模板中通过`@扩展方法`引用。例如：```jsRandom.extend({constellation:function(date){varconstellations=['白羊座','金牛座','双子座','巨蟹座','狮子座','处女座','天秤座','天蝎座','射手座','摩羯座','水瓶座','双鱼座',]returnthis.pick(constellations)},})Random.constellation()//=>\"水瓶座\"Mock.mock('@CONSTELLATION')//=>\"天蝎座\"Mock.mock({constellation:'@CONSTELLATION',})//=>{constellation:\"射手座\"}```##Mock.valid()###Mock.valid(template,data)-Mock.valid(template,data)校验真实数据`data`是否与数据模板`template`匹配。####template必选。表示数据模板，可以是对象或字符串。例如`{'list|1-10':[{}]}`、`'@EMAIL'`。####data必选。表示真实数据。```jsvartemplate={name:'value1',}vardata={name:'value2',}Mock.valid(template,data)[//=>{path:['data','name'],type:'value',actual:'value2',expected:'value1',action:'equalto',message:\"[VALUE]ExpectROOT.name'valueisequaltovalue1,butisvalue2\",}]```##Mock.toJSONSchema()###Mock.toJSONSchema(template)-Mock.toJSONSchema(template)把Mock.js风格的数据模板`template`转换成[JSONSchema](http://json-schema.org/)。####template必选。表示数据模板，可以是对象或字符串。例如`{'list|1-10':[{}]}`、`'@EMAIL'`。```jsvartemplate={'key|1-10':'★'}Mock.toJSONSchema(template)//=>{\"name\":undefined,\"path\":[\"ROOT\"],\"type\":\"object\",\"template\":{\"key|1-10\":\"★\"},\"rule\":{},\"properties\":[{\"name\":\"key\",\"path\":[\"ROOT\",\"key\"],\"type\":\"string\",\"template\":\"★\",\"rule\":{\"parameters\":[\"key|1-10\",\"key\",null,\"1-10\",null],\"range\":[\"1-10\",\"1\",\"10\"],\"min\":1,\"max\":10,\"count\":3,\"decimal\":undefined,\"dmin\":undefined,\"dmax\":undefined,\"dcount\":undefined}}]}vartemplate={'list|1-10':[{}]}Mock.toJSONSchema(template)//=>{\"name\":undefined,\"path\":[\"ROOT\"],\"type\":\"object\",\"template\":{\"list|1-10\":[{}]},\"rule\":{},\"properties\":[{\"name\":\"list\",\"path\":[\"ROOT\",\"list\"],\"type\":\"array\",\"template\":[{}],\"rule\":{\"parameters\":[\"list|1-10\",\"list\",null,\"1-10\",null],\"range\":[\"1-10\",\"1\",\"10\"],\"min\":1,\"max\":10,\"count\":6,\"decimal\":undefined,\"dmin\":undefined,\"dmax\":undefined,\"dcount\":undefined},\"items\":[{\"name\":0,\"path\":[\"data\",\"list\",0],\"type\":\"object\",\"template\":{},\"rule\":{},\"properties\":[]}]}]}```","Front-End\\Package\\工具包\\Monaco Editor.md":"#MonacoEditor>[MonacoEditor](https://github.com/microsoft/monaco-editor)是微软开发的一款开源在线代码编辑器。它是[VSCode](https://code.visualstudio.com/)的浏览器版本，随着近年VSCode大热，MonacoEditor也逐渐走红。目前虽未登上OnlineEditor领域的宝座，却也隐燃有超越几位老前辈之势。>>[闲谈MonacoEditor-基本使用-知乎(zhihu.com)](https://zhuanlan.zhihu.com/p/47746336)","Front-End\\Package\\工具包\\RxJS.md":"#RxJs>[概览|RxJS中文文档](https://cn.rx.js.org/manual/overview.html#-)","Front-End\\Package\\工具包\\自定义片段.md":"#自定义片段##1.获取文件后缀名使用场景：上传文件判断后缀名```js/***获取文件后缀名*@param{String}filename*/exportfunctiongetExt(filename){if(typeoffilename=='string'){//如果文件没有后缀名，返回nullif(!filename.includes('.')){returnnull}returnfilename.split('.').pop().toLowerCase()}else{thrownewError('filenamemustbeastringtype')}}```使用方式```jsgetExt('1.mp4')//->mp4```##2.复制内容到剪贴板```jsexportfunctioncopyToBoard(value){constelement=document.createElement('textarea')document.body.appendChild(element)element.value=valueelement.select()if(document.execCommand('copy')){document.execCommand('copy')document.body.removeChild(element)returntrue}document.body.removeChild(element)returnfalse}```使用方式:```js//如果复制成功返回truecopyToBoard('lalallala')```原理：1.创建一个textare元素并调用select()方法选中2.document.execCommand('copy')方法，拷贝当前选中内容到剪贴板。##3.休眠多少毫秒```js/***休眠xxxms*@param{Number}milliseconds*/exportfunctionsleep(ms){returnnewPromise((resolve)=>setTimeout(resolve,ms))}//使用方式constfetchData=async()=>{awaitsleep(1000)}```##4.生成随机字符串```js/***生成随机id*@param{*}length*@param{*}chars*/exportfunctionuuid(length=8,chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',){letresult=''for(leti=length;i>0;--i)result+=chars[Math.floor(Math.random()*chars.length)]returnresult}```使用方式```js//第一个参数指定位数，第二个字符串指定字符，都是可选参数，如果都不传，默认生成8位uuid()```使用场景：用于前端生成随机的ID,毕竟现在的Vue和React都需要绑定key##5.简单的深拷贝```js/***深拷贝*@export*@param{*}obj*@returns*/exportfunctiondeepCopy(obj){if(typeofobj!='object'){returnobj}if(obj==null){returnobj}returnJSON.parse(JSON.stringify(obj))}```缺陷：只拷贝对象、数组以及对象数组，对于大部分场景已经足够```jsconstperson={name:'xiaoming',child:{name:'Jack'}}deepCopy(person)//newperson```##6.数组去重```js/***数组去重*@param{*}arr*/exportfunctionuniqueArray(arr){if(!Array.isArray(arr)){thrownewError('Thefirstparametermustbeanarray')}if(arr.length==1){returnarr}//若不支持set,可以使用arr.filter((item,i)=>arr.indexOf(item)===i)return[...newSet(arr)]}```原理是利用Set中不能出现重复元素的特性```jsuniqueArray([1,1,1,1,1])//[1]```##7.对象转化为FormData对象```js/***对象转化为formdata*@param{Object}object*/exportfunctiongetFormData(object){constformData=newFormData()Object.keys(object).forEach((key)=>{constvalue=object[key]if(Array.isArray(value)){value.forEach((subValue,i)=>formData.append(key+`[${i}]`,subValue))}else{formData.append(key,object[key])}})returnformData}```使用场景：上传文件时我们要新建一个FormData对象，然后有多少个参数就append多少次，使用该函数可以简化逻辑使用方式：```jsletreq={file:xxx,userId:1,phone:'15198763636',//...}fetch(getFormData(req))```##8.保留到小数点以后n位```js//保留小数点以后几位，默认2位exportfunctioncutNumber(number,no=2){if(typeofnumber!='number'){number=Number(number)}returnNumber(number.toFixed(no))}```使用场景：JS的浮点数超长，有时候页面显示时需要保留2位小数","Front-End\\Package\\文件\\excel\\index.md":"#[exceljs-Node和浏览器里实现Excel的解析和生成](https://www.npmjs.com/package/exceljs?activeTab=readme)##读取文件```tsxconst{Workbook}=require('exceljs')asyncfunctionmain(){constworkbook=newWorkbook()constworkbook2=awaitworkbook.xlsx.readFile('./data.xlsx')workbook2.eachSheet((sheet,index1)=>{console.log('工作表'+index1)sheet.eachRow((row,index2)=>{constrowData=[]row.eachCell((cell,index3)=>{rowData.push(cell.value)})console.log('行'+index2,rowData)})})}main()```##生成文件```tsxconst{Workbook}=require('exceljs')asyncfunctionmain(){constworkbook=newWorkbook()constworksheet=workbook.addWorksheet('guang111')worksheet.columns=[{header:'ID',key:'id',width:20},{header:'姓名',key:'name',width:30},{header:'出生日期',key:'birthday',width:30},{header:'手机号',key:'phone',width:50},]constdata=[{id:1,name:'光光',birthday:newDate('1994-07-07'),phone:'13255555555',},{id:2,name:'东东',birthday:newDate('1994-04-14'),phone:'13222222222',},{id:3,name:'小刚',birthday:newDate('1995-08-08'),phone:'13211111111',},]worksheet.addRows(data)workbook.xlsx.writeFile('./data2.xlsx')}main()```","Front-End\\Package\\模板引擎\\ejs.md":"#EJS##特性>-快速编译与绘制输出>-简洁的模板标签：<%%>>-自定义分割符（例如：用<??>替换<%%>）>-引入模板片段>-同时支持服务器端和浏览器JS环境>-JavaScript中间结果静态缓存>-模板静态缓存>-兼容[Express](http://expressjs.com/)视图系统##入门###安装```bashnpminstallejs```###用法将模板字符串和一些数据作为参数传递给EJS，Duang，HTML出来了。```javascriptletejs=require('ejs'),people=['geddy','neil','alex'],html=ejs.render('<%=people.join(\",\");%>',{people:people})```###浏览器支持从这里下载[最新的浏览器版本](https://github.com/mde/ejs/releases/latest)，然后引入页面即可。```markup<scriptsrc=\"ejs.js\"></script><script>letpeople=['geddy','neil','alex'],html=ejs.render('<%=people.join(\",\");%>',{people:people});</script>```##文档###实例```markup<%if(user){%><h2><%=user.name%></h2><%}%>```###用法```javascriptlettemplate=ejs.compile(str,options)template(data)//=>输出渲染后的HTML字符串ejs.render(str,data,options)//=>输出渲染后的HTML字符串ejs.renderFile(filename,data,options,function(err,str){//str=>输出渲染后的HTML字符串})```###参数-`cache`缓存编译后的函数，需要指定`filename`-`filename`被`cache`参数用做键值，同时也用于include语句-`context`函数执行时的上下文环境-`compileDebug`当值为`false`时不编译调试语句-`client`返回独立的编译后的函数-`delimiter`放在角括号中的字符，用于标记标签的开与闭-`debug`将生成的函数体输出-`_with`是否使用`with(){}`结构。如果值为`false`，所有局部数据将存储在`locals`对象上。-`localsName`如果不使用`with`，localsName将作为存储局部变量的对象的名称。默认名称是`locals`-`rmWhitespace`删除所有可安全删除的空白字符，包括开始与结尾处的空格。对于所有标签来说，它提供了一个更安全版本的`-%>`标签（在一行的中间并不会剔除标签后面的换行符)。-`escape`为`<%=`结构设置对应的转义（escape）函数。它被用于输出结果以及在生成的客户端函数中通过`.toString()`输出。(默认转义XML)。-`outputFunctionName`设置为代表函数名的字符串（例如`'echo'`或`'print'`）时，将输出脚本标签之间应该输出的内容。-`async`当值为`true`时，EJS将使用异步函数进行渲染。（依赖于JS运行环境对async/await是否支持）###标签含义-`<%`'脚本'标签，用于流程控制，无输出。-`<%_`删除其前面的空格符-`<%=`输出数据到模板（输出是转义HTML标签）-`<%-`输出非转义的数据到模板-`<%#`注释标签，不执行、不输出内容-`<%%`输出字符串'<%'-`%>`一般结束标签-`-%>`删除紧随其后的换行符-`_%>`将结束标签后面的空格符删除###包含（include）通过`include`指令将相对于模板路径中的模板片段包含进来。(需要提供'filename'参数。)例如，如果存在\"./views/users.ejs\"和\"./views/user/show.ejs\"两个模板文件，你可以通过`<%-include('user/show');%>`代码包含后者。你可能需要能够输出原始内容的标签(`<%-`)用于include指令，避免对输出的HTML代码做转义处理。```markup<ul><%users.forEach(function(user){%><%-include('user/show',{user:user});%><%});%></ul>```###自定义分隔符可针对单个模板或全局使用自定义分隔符：```javascriptletejs=require('ejs'),users=['geddy','neil','alex']//单个模板文件ejs.render('<?=users.join(\"|\");?>',{users:users},{delimiter:'?'})//=>'geddy|neil|alex'//全局ejs.delimiter='$'ejs.render('<$=users.join(\"|\");$>',{users:users})//=>'geddy|neil|alex'```###缓存EJS附带了一个基本的进程内缓存，用于缓在渲染模板过程中所生成的临时JavaScript函数。通过Node的`lru-cache`库可以很容易地加入LRU缓存：```javascriptletejs=require('ejs'),LRU=require('lru-cache')ejs.cache=LRU(100)//具有100条内容限制的LRU缓存```如果要清除EJS缓存，调用`ejs.clearCache`即可。如果你正在使用的是LRU缓存并且需要设置不同的限额，则只需要将`ejs.cache`重置为一个新的LRU实例即可。###自定义文件加载器默认的文件加载器是`fs.readFileSync`，如果你想要的自定义它,设置`ejs.fileLoader`即可。```javascriptletejs=require('ejs')letmyFileLoader=function(filePath){return'myFileLoader:'+fs.readFileSync(filePath)}ejs.fileLoader=myFileLoad```使用此功能，您可以在读取模板之前对其进行预处理。###布局（Layouts）EJS并未对块（blocks）提供专门的支持，但是可以通过包含页眉和页脚来实现布局，如下所示：```javascript<%-include('header');-%><h1>Title</h1><p>Mypage</p><%-include('footer');-%>```###客户端支持从[latestrelease](https://github.com/mde/ejs/releases/latest)链接下载`./ejs.js`或`./ejs.min.js`文件。或者，你可以clone这个仓库并通过执行`jakebuild`自己编译（或者执行`$(npmbin)/jakebuild`，如果jake不是安装在全局环境的话）。在页面中包含上面的任意一个文件，然后`ejs`就全局可用了####示例```javascript<divid=\"output\"></div><scriptsrc=\"ejs.min.js\"></script><script>letpeople=['geddy','neil','alex'],html=ejs.render('<%=people.join(\",\");%>',{people:people});//WithjQuery:$('#output').html(html);//VanillaJS:document.getElementById('output').innerHTML=html;</script>```####注意事项大多数情况下，EJS将会按照我们的预期运行;但是,仍然需要注意：1.显然,如果你没有文件系统的访问权限,`ejs.renderFile`将无法正常工作。2.相同的原因,除非为include设置一个回调函数，否则include无法正常工作。如下所示：```javascriptletstr=\"Hello<%=include('file',{person:'John'});%>\",fn=ejs.compile(str,{client:true})fn(data,null,function(path,d){//includecallback//path->'file'//d->{person:'John'}//Putyourcodehere//Returnthecontentsoffileasastring})//returnsrenderedstring```###在Express中使用EJS```javascriptletexpress=require('express')letapp=express()app.set('viewengine','ejs')//配置选项app.set('viewoptions',{delimiter:'?'})app.get('/',(req,res)=>{res.render('index',{foo:'FOO'})})app.listen(4000,()=>console.log('Exampleapplisteningonport4000!'))```####自定义渲染功能```jsletejsOptions={delimiter:'?'}app.engine('ejs',(path,data,cb)=>{ejs.renderFile(path,data,ejsOptions,cb)})```####应用程序局部变量设置的任何属性都将混合到传递到视图引擎的呈现调用的对象中，并且名称匹配已知选择属性的属性将作为选择传递给EJS：`app.locals``data````app.locals.delimiter='?'```这允许您在一个位置设置EJS选项，但无法用于不安全的选项，如。`root`####使用数据传递选择调用中具有名称匹配已知选择属性的数据对象中的任何属性都将作为选择传递给EJS：`render````jsapp.get('/',(req,res)=>{res.render('index',{foo:'FOO',delimiter:'?'})})```此方法意味着您必须在每个渲染调用中传递EJS选项，并且不能使用不安全的选项，如。`root````jsapp.get('/',function(request,response){response.render('index.ejs',{list:'lists'})})```","Front-End\\Package\\模板引擎\\Pug.md":"#Pug>-安装`npminstallpug`>-全局安装pug命令行工具`npmisstallpug-cli-g`>-执行编译`index.pug`:`pugindex.pug`(默认是压缩版)>-`pugindex.pug-P`:标准版的html>-`pugindex.pug-oa`将index.html输入到a目录下>-批量编译:`pug文件夹名`:会编译当前文件夹下全部pug文件>-概要:`pug.compile()`会把Pug代码编译成一个js函数,该函数可以传入数据(局部变量,locals);>-传入响应的数据,会返回数据渲染的HTML字符串>-[pug官方文档](https://www.pugjs.cn/api/express.html)```js//template.pugp#{name}的Pug代码!//js代码constpug=require('pug');//编译这份代码constcompiledFunction=pug.compileFile('template.pug');//渲染一组数据console.log(compiledFunction({name:'李莉'}));//\"<p>李莉的Pug代码！</p>\"//渲染另外一组数据console.log(compiledFunction({name:'张伟'}));//\"<p>张伟的Pug代码！</p>\"//编译并使用一组数据渲染template.pugconsole.log(pug.renderFile('template.pug',{name:'Timothy'}));//\"<p>Timothy的Pug代码！</p>\"```##基础语法###属性Attribute|Pug代码|html|描述||--------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|---------------------||a(href='baidu.com')百度|`<ahref=\"baidu.com\">百度</a>`|||a(class='button'href='baidu.com')百度|`<aclass=\"button\"href=\"baidu.com\">百度</a>`|||a(class='button',href='baidu.com')百度|`<aclass=\"button\"href=\"baidu.com\">百度</a>`|可以加入,号作为分隔符||a(style={color:'red'})|`<astyle=\"color:red;\"></a>`|||-varauthenticated=true<br/>body(class=authenticated?'authed':'anon')|`<bodyclass=\"authed\"></body>`|||input(<br/>type='checkbox'<br/>name='agreement'<br/>checked<br/>)|`<inputtype=\"checkbox\"name=\"agreement\"checked=\"checked\"/>`|多行属性||div(class='div-class',(click)='play()')<br/>div(class='div-class''(click)'='play()')|`<divclass=\"div-class\"(click)=\"play()\"></div>`<br/>`<divclass=\"div-class\"(click)=\"play()\"></div>`|特殊字符||div(escaped=\"<code>\">)<br>div(unescaped!=\"<code>\")|`<divescaped=\"&lt;code&gt;\"></div>`<br>`<divunescaped=\"<code>\"></div>`|转义属性优先使用!=|###类和ID```puga.button.content=\"\\n\"a#main-link#content``````html<aclass=\"button\"></a><divclass=\"content\"></div><aid=\"main\"></a><divid=\"content\"></div>```###结构语法####树状```pugulliItemAliItemBliItemC``````html<ul><li>ItemA</li><li>ItemB</li><li>ItemC</li></ul>```####内联>-pug:`a:img`>-html:`<a><img/></a>`####自闭合```jsimginputimg/input/``````html<img/><input/><img/><input/>```###标签####DOCTYPE|PUG|HTML||-----------------------------------------------------|----------------------------------------------------------||doctypehtml|`<!DOCTYPEhtml>`||doctypehtmlPUBLIC\"-//W3C//DTDXHTMLBasic1.1//EN\"|`<!DOCTYPEHTMLPUBLIC\"-//W3C//DTDXHTMLBasic1.1//EN\">`|####标签嵌入>-写法`#[标签名(标签属性)标签内容]````pugp.这是一个很长很长而且还很无聊的段落，还没有结束，是的，非常非常地长。突然出现了一个#[strong充满力量感的单词]，这确实让人难以#[em忽视]。``````html<p>这是一个很长很长而且还很无聊的段落，还没有结束，是的，非常非常地长。突然出现了一个<strong>充满力量感的单词</strong>，这确实让人难以<em>忽视</em>。</p>```###内容####管道文本>-每行前面添加`|`字符```pug|纯文本当然也可以包括<strong>HTML</strong>内容。p|但它必须单独起一行。``````html纯文本当然也可以包括<strong>HTML</strong>内容。<p>但它必须单独起一行。</p>```####标签内文本>-一个空格>-```pug>p纯文本当然也可以包括<strong>HTML</strong>内容。>```>-```html><p>>纯文本当然也可以包括><strong>HTML</strong>>内容。></p>>```####嵌入大文本>-标签后接一个`.`>-日常嵌入脚本或样式```pugscript.console.log('usingPug')``````html<script>console.log('usingPug')</script>```###注释####单行注释```pug//注释```####不输出注释```pug//-不输出的代码```####块注释```pugbody//块状注释```####条件注释```pug<!--[ifIE8]><htmllang=\"en\"class=\"lt-ie9\"><![endif]--><!--[ifgtIE8]><!--><htmllang=\"en\"><!--<![endif]-->``````html<!--[ifIE8]><htmllang=\"en\"class=\"lt-ie9\"><![endif]--><!--[ifgtIE8]><!--><htmllang=\"en\"><!--<![endif]--></html>```##逻辑语法```pug-for(varx=0;x<3:x++)liitem``````html<li>item</li><li>item</li><li>item</li>```###变量###内容变量```pug-vartitle=\"OnDogs:Man'sBestFriend\";-varauthor=\"enlore\";-vartheGreat=\"<span>转义!</span>\";-varmsg=\"notmyinsidevoice\";-varurl='pug-test.html';-varbtnType='info'-varbtnSize='lg'button(type='button'class='btnbtn-'+btnType+'btn-'+btnSize)='\\n'button(type='button'class=`btnbtn-${btnType}btn-${btnSize}`)//模板字符串a(href='/'+url)链接pThisis#{msg.toUpperCase()}h1=titlep#{author}笔下源于真情的创作。p这是安全的：#{theGreat}div#foo(data-bar=\"foo\")&attributes({'data-foo':'bar'})//<divid=\"foo\"data-bar=\"foo\"data-foo=\"bar\"></div>```###条件####if-else```pug-varuser={description:'foobarbaz'}-varauthorised=false#userifuser.descriptionh2.green描述p.description=user.descriptionelseifauthorisedh2.blue描述p.description.用户没有添加描述。不写点什么吗……elseh2.red描述p.description用户没有描述``````html<divid=\"user\"><h2class=\"green\">描述</h2><pclass=\"description\">foobarbaz</p></div>```####switch```pug-varfriends=10casefriendswhen0pbreakwhen1p您有一个朋友defaultp您有#{friends}个朋友```###循环>-目前支持each和while####each```puguleachval,indexin[1,2,3,4,5]li=val+':'+indexuleachval,indexin{1:'一',2:'二',3:'三'}li=index+':'+val-varvalues=[];uleachvalinvalues.length?values:['没有内容']li=val//当values为空时,就会执行else-varvalues=[];uleachvalinvaluesli=valelseli没有内容```####while```pug-varn=0;ulwhilen<4li=n++```###混入mixin>-`+link(class='btn')`等价于`+link()(class=\"btn')````//-定义mixinlist(name)ulli=namelifoolibarlibaz//-使用+list+listp这是文章+list('grh')//生成两个ul列表```##文件包含>-include```pug//-index.pugdoctypehtmlhtmlheadstyleincludestyle.cssbodyh1我的网站p欢迎来到我这简陋得不能再简陋的网站。scriptincludescript.js```##文件继承>-block,extendslayout.pug```pughtmlheadmeta(charset=\"UTF-8\")title我的站点-#{title}blockscriptsscript(src='/jquery.js')bodyblockcontentblockfoot#footerp一些页脚的内容```pet.pug```pugp=petName```page-a.pug```pugextendslayout.pugblockscriptsscript(src='/jquery.js')script(src='/pets.js')blockcontenth1=title-varpets=['猫','狗']eachpetNameinpetsincludepet.pug```###继承拓展>-prepend在前面添加head>-append在后面添加footer>-block关键词可以省略page-b.pug```pugextendslayout.pugblockprependheadscript(src='/vendor/three.js')blockappendfooterscript(src='/game.js')```##模板index.pug```pugdoctypehtmlhtmlheadmeta(charset=\"UTF-8\")title=documentTitleeachvalinsrcStyleslink(href=baseStyle+'/'+val)bodyheader.hdnav.hd-navbar.m-navbar.m-navbar_primary.hd-navbar-tel联系方式:#{tel}ul.hd-navbar-naveachvalinmainNavItemli.Hnn-item.m-btn.m-btn_infoa(href=\"#\")=valsection.mainh1.main-title我的文档p.main-content.这是一个很长很长而且还很无聊的段落，还没有结束，是的，非常非常地长。突然出现了一个#[strong充满力量感的单词]，这确实让人难以#[em忽视]。footer.ftpCopyright(c)小火柴的蓝色理想eachvalinsrcScriptsscript(src=baseScript+'/'+val)``````json//-data.json{\"documentTitle\":\"测试文档\",\"tel\":\"400-888-8888\",\"mainNavItem\":[\"登录\",\"注册\",\"关于\",\"帮助\"],\"baseStyle\":\"style\",\"srcStyles\":[\"bootstrap.css\",\"main.css\"],\"baseScript\":\"/js\",\"srcScripts\":[\"jquery.js\",\"app.js\"]}```执行`pugindex.pug-P-w-Odata.json`","Front-End\\Package\\测试\\jest\\index.md":"#JEST>Jest是Facebook开源的一套JavaScript测试框架，它集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具。>>官方简介：一个令人愉快的javascript测试框架##使用```shellnpminit-ynpmadd--devjest#全局安装npmi-gjest```","Front-End\\Package\\测试\\jest\\js.md":"#helloworld(jest)>编写以下两个js文件，控制台输入命令jest--no-cache--verbose(全局安装)，或者npxjest--no-cache--verbose（项目依赖安装），jest会搜索项目下所有测试脚本并执行输出测试结果。```js//hello.jsmodule.exports=function(){return'helloworld'}//hello.test.jsconsthello=require('../hello')it('should',()=>{expect(hello()).toBe('helloworld')})```#基础测试知识##jest文件和目录命名规范>待测试文件:hello.js测试脚本文件取名：hello.test.jsorhello.spec.js测试目录:testsor**tests**##测试函数```jstest('测试用列描述信息',()=>{})//orit('测试用例描述信息',()=>{})```##断言函数测试即运行结果是否与我们预期结果一致断言函数用来验证结果是否正确.```jsexpect(运行结果).toBe(期望的结果)//常见断言方法expect({a:1}).toBe({a:1})//判断两个对象是否相等expect(1).not.toBe(2)//判断不等expect({a:1,foo:{b:2}}).toEqual({a:1,foo:{b:2}})expect(n).toBeNull()//判断是否为nullexpect(n).toBeUndefined()//判断是否为undefinedexpect(n).toBeDefined()//判断结果与toBeUndefined相反expect(n).toBeTruthy()//判断结果为trueexpect(n).toBeFalsy()//判断结果为falseexpect(value).toBeGreaterThan(3)//大于3expect(value).toBeGreaterThanOrEqual(3.5)//大于等于3.5expect(value).toBeLessThan(5)//小于5expect(value).toBeLessThanOrEqual(4.5)//小于等于4.5expect(value).toBeCloseTo(0.3)//浮点数判断相等expect('Christoph').toMatch(/stop/)//正则表达式判断expect(['one','two']).toContain('one')//不解释```##分组函数```jsdescribe('关于每个功能或某个组件的单元测试',()=>{//不同用例的单元测试})```##常见命令```js{\"nocache\":\"jest--no-cache\",//清除缓存\"watch\":\"jest--watchAll\",//实时监听\"coverage\":\"jest--coverage\",//生成覆盖测试文档\"verbose\":\"npxjest--verbose\"//显示测试描述}```##基础测试###对象等值测试```jsdescribe('对象测试',()=>{it('是否同一个对象',()=>{constfoo={a:1}expect(foo).toBe(foo)})it('对象值是否相等',()=>{expect({a:1,foo:{b:2}}).toEqual({a:1,foo:{b:2}})})test('对象赋值',()=>{constdata={one:1}data['two']=2expect(data).toEqual({one:1,two:2})})})```###异步测试>异步测试脚本执行完，单元测试就结束了，如果需要延时才能断言的结果，单元测试函数需要设置done形参，在定时回调函数中调用，显示的通过单元测试已完成。```jsdescribe('异步操作测试',()=>{functionfoo(callback){console.log('foo...')setTimeout(()=>{callback&&callback()},1000)}it('异步测试',(done)=>{functionbar(){console.log('bar..')done()}foo(bar)})})```###定时器测试（异步测试）及断言>基于jest提供的两个方法jest.useFakeTimers和jest.runAllTimers可以更优雅的对延时功能的测试。```jsdescribe('定时器相关测试',()=>{//开启定时函数模拟jest.useFakeTimers()functionfoo(callback){console.log('foo...')setTimeout(()=>{callback&&callback()},1000)}it('断言异步测试',()=>{//创建mock函数，用于断言函数被执行或是执行次数的判断constcallback=jest.fn()foo(callback)expect(callback).not.toBeCalled()//快进，使所有定时器回调jest.runAllTimers()expect(callback).toBeCalled()})})```###Dom测试>实现dom渲染测试，以及点击事件等交互功能测试。```jsdescribe('Dom测试',()=>{it('测试按钮是否被渲染',()=>{document.body.innerHTML=`<div><buttonid='btn'>小按钮</button></div>`console.log(document.getElementById('btn'),document.getElementById('btn').toString(),)expect(document.getElementById('btn')).not.toBeNull()expect(document.getElementById('btn').toString()).toBe('[objectHTMLButtonElement]',)})it('测试点击事件',()=>{constonclick=jest.fn()document.body.innerHTML=`<div><buttonid='btn'>小按钮</button></div>`constbtn=document.getElementById('btn')expect(onclick).not.toBeCalled()btn.onclick=onclickbtn.click()expect(onclick).toBeCalled()expect(onclick).toHaveBeenCalledTimes(1)btn.click()btn.click()expect(onclick).toHaveBeenCalledTimes(3)})})```##Vue测试###5.1安装unit-jest>如果你创建的项目没有安装unit-jest依赖包，可以通过vueadd@vue/unit-jest命令添加。否则通过脚手架手动模式创建一个包含unit-jest的项目。###基础知识>mount和shallowMount的区别-shallowMount只挂载指定组件，不挂载子组件-mount挂载所有组件>Vue的渲染机制默认情况下Vue会异步地批量执行更新(在下一轮tick)，以避免不必要的DOM重绘或者是观察者计算>异步测试需要在nextTick()之后执行###helloJestVue>vue组件渲染测试```jsit('挂载countBtn组件',()=>{constwraper=shallowMount(CountBtn)constbtn=wraper.find('button')expect(wraper.html()).toBe(`<button>点击次数0</button>`)})```###事件测试>vue组件点击事件测试```jsit('测试countBtn组件点击',(done)=>{constwraper=shallowMount(CountBtn)constbtn=wraper.find('button')expect(wraper.html()).toBe(`<button>点击次数0</button>`)btn.trigger('click')setTimeout(()=>{expect(wraper.html()).toBe(`<button>点击次数1</button>`)done()},1000)})it('优雅的测试点击事件',async()=>{constwraper=shallowMount(CountBtn)constbtn=wraper.find('button')expect(wraper.html()).toBe(`<button>点击次数0</button>`)btn.trigger('click')awaitwraper.vm.$nextTick()expect(wraper.html()).toBe(`<button>点击次数1</button>`)})```###axios异步请示测试>模拟异步请示，测试渲染结果是否一致```vue<!--User.vue--><template><table><trv-for=\"iteminlist\":key=\"item.id\"><td>{{item.id}}</td><td>{{item.name}}</td><td>{{item.age}}</td></tr></table></template><script>exportdefault{data(){return{list:[],}},created(){this.$http.get('/user').then(({data})=>{this.list=data})},}</script>``````js//User.spec.jsimport{mount}from'@vue/test-utils'importUserfrom'@/components/User'it('测试用户组件',async()=>{constwrapper=mount(User,{mocks:{$http:{get:(url)=>Promise.resolve({data:[{id:1,name:'xxxx',age:18},{id:2,name:'yyyy',age:19},],}),},},})console.log(wrapper.html())//渲染前expect(wrapper.html()).toBe('<table></table>')awaitwrapper.vm.$nextTick()//渲染后//console.log(wrapper.html())//console.log(wrapper.find('tr'))expect(wrapper.findAll('tr').length).toBe(2)expect(wrapper.findAll('td').at(2).html()).toBe('<td>18</td>')})```","Front-End\\Package\\测试\\jest\\ts.md":"#ts-jest##安装```shellnpmi-Djesttypescriptts-jest@types/jest```","Front-End\\Package\\虚拟列表\\react-window.md":"#[react-window]()>[源码](https://github.com/bvaughn/react-window)>[api](https://react-window.vercel.app/#/examples/list/fixed-size)1、不用全部加载出所有的DOM节点。默认只渲染可视区域及可视区域外的一个节点，此属性可自定义设置。2、可用于处理大型数据列表。当使用在大型数据列表中，可避免因为数据的更新而导致大量的重新渲染。##FixedSizeList（固定尺寸的列表）```jsimport{FixedSizeList}from'react-window'/***每个列表项的组件*@paramindex：列表项的下标；style：列表项的样式（此参数必须传入列表项的组件中，否则会出现滚动到下方出现空白的情况）**/constRow=({index,style})=><divstyle={style}>Row{index}</div>constExample=()=>(<FixedSizeListheight={150}//列表可视区域的高度itemCount={1000}//列表数据长度itemSize={35}//列表行高width={300}//列表可视区域的宽度>{Row}</FixedSizeList>)```##VariableSizeList（可变尺寸列表）```jsximport{VariableSizeList}from'react-window';constrowHeights=newArray(1000).fill(true).map(()=>25+Math.round(Math.random()*50));constgetItemSize=index=>rowHeights[index];//此处采用随机数作为每个列表项的高度/***每个列表项的组件*@paramindex：列表项的下标；style：列表项的样式（此参数必须传入列表项的组件中，否则会出现滚动到下方出现空白的情况）**/constRow=({index,style})=>(<divstyle={style}>Row{index}</div>);constExample=()=>(<VariableSizeListheight={150}//列表可视区域的高度itemCount={1000}//列表数据长度itemSize={getItemSize}//设置列表项的高度layout=\"vertical\"//（vertical/horizontal）默认为vertical，此为设置列表的方向width={300}>{Row}<VariableSizeList>);```##结合`react-virtualized-auto-sizer`使列表自适应当前页面的宽高>使用AutoSizer可是列表宽高为当前父组件的100%import{FixedSizeList}from\"react-window\";importAutoSizerfrom\"react-virtualized-auto-sizer\";constExample=()=>(<AutoSizer>{({height,width})=>(<FixedSizeListclassName=\"List\"height={height}itemCount={1000}itemSize={35}width={width}>{Row}</FixedSizeList>)}</AutoSizer>);##常见问题>在使用VariableSizeList会遇到列表项样式缓存没有被清除导致行高一直和第一次可视区域里展示的一样。可使用组件的属性`resetAfterIndex(index:number,shouldForceUpdate:boolean=true):void`来清除样式。```jsxclassExampleextendsComponent{constructor(props){super(props)this.myRef=React.createRef()}......render(){......<VariableSizeListclassName='friends-list'height={66}itemCount={100}itemSize={64}itemSize={getItemSize}ref={this.myRef}width={260}>{Row}</VariableSizeList>......<buttononClick={()=>{this.myRef.current.resetAfterIndex(0,false)}}>清除样式</button>......}}```","Front-End\\TEMP.md":"#file-type```txt*.3gppaudio/3gpp,video/3gpp*.ac3audio/ac3*.asfallpication/vnd.ms-asf*.auaudio/basic*.csstext/css*.csvtext/csv*.docapplication/msword*.dotapplication/msword*.dtdapplication/xml-dtd*.dwgimage/vnd.dwg*.dxfimage/vnd.dxf*.gifimage/gif*.htmtext/html*.htmltext/html*.jp2image/jp2*.jpeimage/jpeg*.jpegimage/jpeg*.jpgimage/jpeg*.jstext/javascript,application/javascript*.jsonapplication/json*.mp2audio/mpeg,video/mpeg*.mp3audio/mpeg*.mp4audio/mp4,video/mp4*.mpegvideo/mpeg*.mpgvideo/mpeg*.mppapplication/vnd.ms-project*.oggapplication/ogg,audio/ogg*.pdfapplication/pdf*.pngimage/png*.potapplication/vnd.ms-powerpoint*.ppsapplication/vnd.ms-powerpoint*.pptapplication/vnd.ms-powerpoint*.rtfapplication/rtf,text/rtf*.svfimage/vnd.svf*.tifimage/tiff*.tiffimage/tiff*.txttext/plain*.wdbapplication/vnd.ms-works*.wpsapplication/vnd.ms-works*.xhtmlapplication/xhtml+xml*.xlcapplication/vnd.ms-excel*.xlmapplication/vnd.ms-excel*.xlsapplication/vnd.ms-excel*.xltapplication/vnd.ms-excel*.xlwapplication/vnd.ms-excel*.xmltext/xml,application/xml*.zipapplication/zip,application/x-zip-compressed*.xlsxapplication/vnd.openxmlformats-officedocument.spreadsheetml.sheet```","Front-End\\UI\\antd\\antd2.md":"#antd2>[AntDesign-一套企业级UI设计语言和React组件库](https://2x.ant.design/components/pagination-cn/)##Pagination分页>采用分页的形式分隔长列表，每次只加载一个页面##Select###添加搜索过滤功能>`showSearchoptionFilterProp=\"children\"````jsx<SelectshowSearchoptionFilterProp=\"children\">{options.map((item,index)=><Optionkey={index}value={item.id}{item.name}</Option>)}</Select>```##DatePicker日期选择框>defaultValue:是moment对象","Front-End\\UI\\antd\\antd4.md":"#antd4##Form>initialValue:和antd2的使用差别,使用function组件,只会挂载第一次初始化的值,如果通过mobx管理的数据,不会挂载修改后的数据,只会挂载第一次的数据,可以通过useForm,form.setFielsValue(valueObj)后重置数据","Front-End\\UI\\elemnt-UI.md":"#element-UI","Front-End\\UI\\Swiper.md":"#Swiper>[轮播图幻灯片js插件](https://www.swiper.com.cn/)","Front-End\\代码混淆\\index.md":"#代码混淆##javascript-obfuscator<https://www.npmjs.com/package/javascript-obfuscator><https://juejin.cn/post/7349936384512884771?searchId=20250304174938E8D574B78FBAE2AD3D8F>##Terser<https://terser.nodejs.cn/docs/api-reference/>##uglify-js<https://www.npmjs.com/package/uglify-js>","Front-End\\代码片段\\获取鼠标选中内容.md":"##获取鼠标选中内容```js//监听双击事件document.addEventListener('dblclick',doubleClick,true)//监听释放鼠标按钮事件document.addEventListener('mouseup',mouseUp,true)//双击处理函数functiondoubleClick(){vartext=''if(window.getSelection){text=window.getSelection().toString()}elseif(document.selection&&document.selection.type!='Control'){text=document.selection.createRange().text}if(''!=text){console.log(text)}}//释放鼠标处理函数functionmouseUp(){vartext=''if(window.getSelection){text=window.getSelection().toString()}elseif(document.selection&&document.selection.type!='Control'){text=document.selection.createRange().text}if(''!=text){console.log(text)}}```","Front-End\\其他\\代码混淆.md":"#[javascript-obfuscator](https://www.npmjs.com/package/javascript-obfuscator)","Front-End\\其他\\伦敦CSS-2020.md":"#伦敦CSS2020>还只是一个提案，离到TR阶段还需要很长的时间>><https://www.motionblurjs.com/>>>```html><head>><scriptsrc=\"https://www.motionblurjs.com/blur.js\"></script>></head>>```##Web动效##动态模糊（MotionBlur）>CSS>>-animation是新增了motion-rendering和motion-shutter-angle>-向引擎请求动态模糊:motion-rendering:inherit|initial|auto|none|blur值>-类似于相机的快门，指的是快门角度，用来控制模糊量或模糊强度>-motion-shutter-angle可受任意角度值inherit|initial|auto=180deg|`<ahref=\"https://codepen.io/airen/pen/oNxQoLw\">`0deg,...,720deg]```css.animated-layer{/*GPU加速动画*/animation:rotate0.5slinearinfinite;/*向引擎请求动态模糊*motion-rendering可以接受inherit|initial|auto|none|blur值*/motion-rendering:blur;/*类似于相机的快门，指的是快门角度，用来控制模糊量或模糊强度*motion-shutter-angle可受任意角度值inherit|initial|auto=180deg|<ahref=\"https://codepen.io/airen/pen/oNxQoLw\">0deg,...,720deg]*/motion-shutter-angle:180deg;}@keyframesrotate{to{transform:rotate(1turn);}}```来看一个简单的[示例](https://codepen.io/airen/pen/oNxQoLw)：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54fd731e901c41c1b028d0acea6e8778~tplv-k3u1fbpfcp-watermark.image)从效果上看似乎没看到动态模糊的效果。这里还是用文档中提供的一个带有动效的图向大家展示动态模糊的效果：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acb11f2cab5f4c14acdf61cc6bf44a70~tplv-k3u1fbpfcp-watermark.image)虽然说，motion-rendering和motion-shutter-angle还只是一个提案，离到TR阶段还需要很长的时间，但对于某些场景（动画场景），可以使用CSS的filter来模拟，比如[下面这个效果](https://codepen.io/ka4tik/pen/aFstu)：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63261a3356548cb9b478803ccbd751f~tplv-k3u1fbpfcp-watermark.image)代码很简单：```css.blur{animation:blur250ms;}@keyframesblur{0%{-webkit-filter:blur(0px);}50%{-webkit-filter:blur(5px);}100%{-webkit-filter:blur(0px);}}```另外，现在提供的motion-rendering和motion-shutter-angle还只是一个提议，在Github中讨论的评论中，也有建议将这两个属性换成：```filter:motion-blur(5px)motion-squash(2px)//或transform-filter:motion-blur(180deg)//或transition-filter:motion-blur(180deg)```也就是说，上面提供的CSS实现动态模糊的属性不是完全定下来的，随着后面的发展，CSS中实现动态模糊的属性，一切皆有可能。再来看看SVG世界中，相对于CSS世界而言，SVG中要实现动态模拟效果要更容易一些，可以使用SVG中的滤镜来模拟动态模糊效果：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f36203f542d4d4eb135555fc0590fda~tplv-k3u1fbpfcp-watermark.image)上图来自于@LucasBebber的[《MotionBlurEffectwithSVG](https://tympanus.net/codrops/2015/04/08/motion-blur-effect-svg/)》教程。如果你对SVG中的滤镜相关的知识感兴趣的话，可以阅读：\\*[SVG1.1:FilterEffects](https://www.w3.org/TR/SVG11/filters.html)-[SVGFilters101](https://tympanus.net/codrops/2019/01/15/svg-filters-101/)有意思的是，@MichelleBarker在Codepen写了一个[Demo](https://codepen.io/michellebarker/full/povdXRW)，这个Demo是用CSS的box-shadow模拟出有[动态模拟的效果](https://codepen.io/michellebarker/pen/povdXRW)：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f4df78a44734000bd8da729426a3f70~tplv-k3u1fbpfcp-watermark.image)如果你真的想在项目中让自己的动画效果具有动态模糊效果（让动效看上去更真一点），而又担心CSS或SVG相关特性未得到主流浏览器支持而不敢使用，那么我在这里向大家推荐一个JavaScript库：[MotionBlurJS](https://www.motionblurjs.com/)：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f4df78a44734000bd8da729426a3f70~tplv-k3u1fbpfcp-watermark.image)来看使用MotionBlurJS实现的动态模糊效果：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3f8d8cfa9546c4952317763c178280~tplv-k3u1fbpfcp-watermark.image)##@scroll-timelineWeb开发者时常会碰到使用滚动来触发某些元素的动画效果，比如说，页面滚动条滚动到某个位置，标题固定在顶部；页面顶部展示你页面进度（滚动指示器）；还是一些我们所说的[视差滚动](https://www.cnblogs.com/coco1s/p/9453938.html)效果等。以往实现这些效果，大都借助JavaScript来实现，可以通过DOM事件查看滚动位置，并根据该位置更改元素的样式。如果可以的话，最好使用IntersectionObserver。有关于这方面的介绍可以阅读：-[TrustisGood,ObservationisBetter—IntersectionObserverv2](https://developers.google.com/web/updates/2019/02/intersectionobserver-v2)-[Howtodoscroll-linkedanimationstherightway](https://blog.logrocket.com/how-to-do-scroll-linked-animations/)不过，现在有一个关于这方面的CSS草案，即[Scroll-linkedAnimations](https://drafts.csswg.org/scroll-animations-1/#scroll-driven-animations)。也就是说，在未来，我们可以直接使用CSS的[@scroll-timeline](https://drafts.csswg.org/scroll-animations-1/#scroll-timeline-at-rule)属性来实现前面提到的一些动画效果。```@scroll-timeline=@scroll-timeline<timeline-name>{<declaration-list>}```![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3f8d8cfa9546c4952317763c178280~tplv-k3u1fbpfcp-watermark.image)```css@media(prefers-reduced-motion:no-preference){div.circle{animation-duration:1s;animation-timing-function:linear;animation-timeline:collision-timeline;}#left-circle{animation-name:left-circle;}#right-circle{animation-name:right-circle;}#union-circle{animation-name:union-circle;animation-fill-mode:forwards;animation-timeline:union-timeline;}@scroll-timelinecollision-timeline{source:selector(#container);orientation:block;start:200px;end:300px;}@scroll-timelineunion-timeline{source:selector(#container);orientation:block;start:250px;end:300px;}@keyframesleft-circle{to{transform:translate(300px);}}@keyframesright-circle{to{transform:translate(350px);}}@keyframesunion-circle{to{opacity:1;}}}```如果是使用JavaScript的话，可以像下面这样：```jsif(window.matchMedia('(prefers-reduced-motion:no-preference)').matches){constscrollableElement=document.querySelector('#container')constcollisionTimeline=newScrollTimeline({source:scrollableElement,start:CSS.px(200),end:CSS.px(300),})constleft=leftCircle.animate({transform:'translate(300px)'},1000)left.timeline=collisionTimelineconstright=leftCircle.animate({transform:'translate(350px)'},1000)right.timeline=collisionTimelineconstunion=unionCircle.animate({opacity:1},{duration:1000,fill:'forwards'},)union.timeline=newScrollTimeline({source:scrollableElement,start:CSS.px(250),end:CSS.px(300),})}```[再来看一个滚动计时器的效果](https://codepen.io/airen/pen/yJGJEJ)：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3f8d8cfa9546c4952317763c178280~tplv-k3u1fbpfcp-watermark.image)上面的示例，我们是使用渐变来模拟的一个效果，但有了@scroll-timeline我们就可以像下面这样来实现：```css@media(prefers-reduced-motion:no-preference){@scroll-timelineprogress-timeline{source:selector(#body);start:0;end:100%;}@keyframesprogress{to{width:100%;}}#progress{width:0px;height:30px;background:red;animation:1slinearforwardsprogressprogress-timeline;}}```如果使用WebAnimationAPI的话，可以像下面这样：```if(window.matchMedia('(prefers-reduced-motion:no-preference)').matches){varanimation=div.animate({width:'100%'},{duration:1000,fill:\"forwards\"});animation.timeline=newScrollTimeline({start:0,end:CSS.percent(100)});}```@argyleink在他分享的PPT中也提供了一个简单的[示例](https://codepen.io/argyleink/pen/XWdNYaY),滚动页面的时候，你会发现两个数字之间的/符会不断的旋转：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3f8d8cfa9546c4952317763c178280~tplv-k3u1fbpfcp-watermark.image)上面的示例效果是基于WebAnimationAPI来实现@scroll-timeline的效果，但是目前还需要其对应的[Polyfill](https://github.com/flackr/scroll-timeline)。```jsimport'https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js'constcounter=document.querySelector('main')constslashes=document.querySelectorAll('.slash')slashes.forEach(slash=>{slash.animate({transform:<ahref=\"https://drafts.csswg.org/scroll-animations-1/\">'rotateZ(0)','rotateZ(4turn)']},{duration:1000,fill:'both',timeline:newScrollTimeline({scrollSource:counter,fill:'both',}),})})```有关于@scroll-timeline更详细的介绍可以查阅[Scroll-linkedAnimations([drafts.csswg.org/scroll-anim…](https://drafts.csswg.org/scroll-animations-1/)，另外，该规范目前还只是一个草案，在未来有可能还会有所变动。)#Web排版先看布局上将会有的一些新特性：##subgridCSSGrid布局是Web布局模式中唯一一种二维布局，也是我自己最认可的布局模式（至少到目前为止还没有发现比Grid更强大的）。如果你从未接触过Grid布局的话，你可以把他想象成最初的table布局，因为他们俩之间有很多概念都非常的相似。随着Web布局技术不断的更新以及浏览器不断的发展，现在使用Grid布局的越来越多，特别是今年以来，Grid和Flexbox布局的占比越来越近：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f9c53519ab643ddb6b72112de6ae6b2~tplv-k3u1fbpfcp-watermark.image)上面的数据是来自于MDN，更详细的可以阅读[MDNBrowserCompatibilityReport2020](https://mdn-web-dna.s3-us-west-2.amazonaws.com/MDN-Browser-Compatibility-Report-2020.pdf)暂时把你拉回到90年代，那个时候Web的布局主要以table布局为主，在使用table布局的时候也时常会发现表格嵌套表格：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bcdc9d56c94d2083bc71a8bddaca59~tplv-k3u1fbpfcp-watermark.image?imageslim)在Grid布局也是相似的，也会碰到网格嵌套网格。```css<!--HTML--><divclass=\"grid\"><divclass=\"item\"><divclass=\"subitem\"></div></div></div>/*CSS*/.grid{display:grid;grid-template-columns:repeat(9,1fr);grid-template-rows:repeat(4,minmax(100px,auto));}.item{grid-column:2/7;grid-row:2/4;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,80px);}.subitem{grid-column:2/4;grid-row:1/4;}```![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bcdc9d56c94d2083bc71a8bddaca59~tplv-k3u1fbpfcp-watermark.image?imageslim)网格嵌套在网格中，各自的网格轨道是相互独立的，不过也会引起子网格中元素对齐会存在一些问题。不过在CSSGridLayoutModuleLevel2([drafts.csswg.org/css-grid-2](https://drafts.csswg.org/css-grid-2))模块中新增了[subgrid](https://drafts.csswg.org/css-grid-2/#subgrids)属性（Firefox71开始就支持该属性）。有了subgrid之后，在嵌套网格的时候，我们就可以在grid-template-columns和grid-template-rows设置subgrid。这样一来，上面示例的代码我们就可以修改成：```.grid{display:grid;grid-template-columns:repeat(9,1fr);grid-template-rows:repeat(4,minmax(100px,auto));}.item{grid-column:2/7;grid-rows:2/4;display:grid;grid-template-columns:subgrid;grid-template-rows:subgrid;}.subitem{grid-column:3/6;grid-row:1/4;}```这样一来，子网格就会继承其父网格的网格轨道，反过来，在使用任何类型的自动调整（比如，auto、min-content、max-content等）时也会影响其维度（尺寸）。在我们平时的一些UI布局中，subgrid就可以用得上了：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6558ff205c84075ab7ecacd4a800799~tplv-k3u1fbpfcp-watermark.image)我们一起来看一个[subgrid的具体实例](https://codepen.io/antonjb/pen/rNNgxWV)。注意，请使用Firefox71+查看上面的Demo，看到的效果如下：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb2629e03c44e57932ed63807a0c189~tplv-k3u1fbpfcp-watermark.image)subgrid和grid一样，是一套复杂的体系，如果要说清楚subgrid的话，可能会要多文章文章才能讲清楚。如果你对subgrid感兴趣的话，还可以阅读下面这几篇文章：-[CSSGridLayoutModuleLevel2:subgrid](https://drafts.csswg.org/css-grid-2/#subgrids)-[Hellosubgrid!](https://noti.st/rachelandrew/3sescR/hello-subgrid)-[CSSGridLevel2:HereComesSubgrid](https://www.smashingmagazine.com/2018/07/css-grid-2/)-[MDN:Subgrid](https://developer.mozilla.org/en-US/docs/Web/CSS/CSSGridlayout/Subgrid)-[Irregular-shapedLinkswithSubgrid](https://css-irl.info/irregular-shaped-links-with-subgrid/)##可用于双屏幕和可折叠屏幕的媒体查询条件和环境变量随着技术不断的发展，我们所面对的终端个性化越来越强，比如现在市场上已有或将有的双屏幕和可折叠屏幕设备：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1d4ab1d63ca46c6a36c7a64f0e0ba8f~tplv-k3u1fbpfcp-watermark.image?imageslim)作为Web开发者，我们终究有一天需要面对这些终端的适配处理。到目前为止，CSS世界具备处理方面适配的能力，即使用screen-spanning媒体查询条件和env(fold-left)、env(fold-top)、env(fold-height)及env(fold-width)环境变量：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87dff1ed59894c16b581a1c50c7b744f~tplv-k3u1fbpfcp-watermark.image)有了这些特性，我们就可以很轻易的实现像下图这样的布局效果：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c513fe738b6f4b8a8347e9c156354896~tplv-k3u1fbpfcp-watermark.image)如果你对这方面的知识感兴趣的话，可以阅读下面几篇文章，这几篇文章也是全网介绍双屏幕和可折叠屏幕最详细的教程：-[聊聊安卓折叠屏给交互设计和开发带来的变化](https://www.atatech.org/articles/140055)-[可折叠Web可能会给我们带来的变化](https://www.atatech.org/articles/177539)-可用于双屏幕和折叠屏的[WebAPI](https://www.atatech.org/articles/181271)##瀑布流布局瀑布流布局（MasonryLayout）也是Web布局中的典型布局之一：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac48d670d664274afa46df2a1c20adf~tplv-k3u1fbpfcp-watermark.image)虽然能使用CSS的多列布局、Flexbox布局和Grid布局等模拟出瀑布流布局效果，但更多的同学还是更喜欢使用一些JavaScript库来实现瀑布流布局，比如[Masoonry](https://masonry.desandro.com/)。为了能让原生的CSS直接实现瀑布流布局效果，早在2017年社区中就有人提出[用原生的CSS实现瀑布流布局效果](https://github.com/w3c/csswg-drafts/issues/945)，不幸的是，直到现在也还只是一个实验性的属性，而且仅在FirefoxNightly浏览器中支持。```css.masonry{display:grid;gap:20px;grid:masonry/repeat(auto-fill,minmax(250px,1fr));}```比如这个[Demo](https://codepen.io/rachelandrew/pen/qBOpjPx)。为了能在FirefoxNightly浏览器能正常的查看上面Demo的效果，你需要确保开启了相应的功能。如果没有的话，请在FirefoxNightly浏览器地址栏中输入about:config，然后搜索layout.css.grid-template-masonry-value.enabled，并将其设置为true：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b855fb62b04c91945591547095db14~tplv-k3u1fbpfcp-watermark.image)然后重启浏览器，查看Demo，你看到的效果将会是像下面这样：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5159d44b95467ca95888ae770a4e1b~tplv-k3u1fbpfcp-watermark.image)##gap“Gap”从字面上来解释的话可以有“间隙，间隔”之意。那么在Web的布局中总是避免不了处理块与块以及行与行之间的间距。![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba53dbdc976f4facbe9520c32e96781c~tplv-k3u1fbpfcp-watermark.image)而在CSS的世界中，用来控制元素之间的间距的间距，一般会使用盒模型中的外距，即margin属性，但是往往很多时候，使用margin来控制元素之间间距并不能很好的满足设计师的诉求。比如说，元素只和元素之间有间距，但和它的父容器之间没有任何的间距。针对于这样的场景，使用gap属性会比使用margin要容易控制的多。![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ee3e4a15e8415abfdb6db12794c4f5~tplv-k3u1fbpfcp-watermark.image)注意，上图来自于[《Next-generationwebstyling》](https://web.dev/next-gen-css-2019/)一文。CSS的gap属性自身最大的特点就是：gap是相对于流的，这意味着它会根据内容流的方向动态变化。比如说书写模式的改变，gap也会自动改变。早期在CSS中，gap分很多种，在不同的容器格式中，叫法不同，比如在多列布局[（Multi-columnContainers）](https://www.w3.org/TR/css3-multicol/#multi-column-container)中对应的是column-gap：```cssbody{column-gap:35px;}```![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/388af9c9f5204a8185f8247a8e64628a~tplv-k3u1fbpfcp-watermark.image)但在网格容器[（GridContainers）](https://www.w3.org/TR/css-grid-1/#grid-container)又被称为grid-row-gap和grid-column-gap。除此之外，它还可以被运用于Flexbox容器[（FlexboxContainers）](https://www.w3.org/TR/css-flexbox-1/#flex-container)，只不过早前，在Flexbox中没有类似flex-row-gap和flex-column-gap这样的属性。需要注意的是，在Flexbox模块中是没有gap属性，但这并不影响我们在Flexbox布局中使用gap属性，这是因为gap统一纳入到了[CSSBoxAlignmentModuleLevel3](https://www.w3.org/TR/css-align-3/#gaps)模块。而且gap是row-gap和column-gap的简写属性：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5c66a53a0614135977125f45cda1090~tplv-k3u1fbpfcp-watermark.image)我们现在可以在多列布局，Flexbox布局和网格布局中像下面这样使用gap：```css//多列布局.multi__column{gap:5ch;}//Flexbox布局.flexbox{display:flex;gap:20px;}//Grid布局.grid{display:grid;gap:10vh20%;}```从上面示例代码中我们可以发现，gap是row-gap和column-gap的简写属性，而且gap可以接受一个值也可以接受两个值，当gap只有一个值时，表示row-gap和column-gap的值相同；当gap有两个值时，其中第一个值是row-gap，第二个值是column-gap。```css.gap{gap:10px;}//等同于.gap{row-gap:10px;column-gap:10px;}.gap{gap:20px30px;}//等同于.gap{row-gap:20px;column-gap:30px;}```特别声明一点，虽然CSS新增了gap属性（row-gap、column-gap），但Grid中早期的grid-row-gap和grid-column-gap属性同样可用。##aspect-ratioaspect-ratio是[CSSBoxSizingModuleLevel4](https://www.w3.org/TR/css-sizing-4/#aspect-ratio)模块中的一个用来计算元素盒子宽高比的属性。在这个属性还没有之前，在CSS中都是通过其他一些方法来[模拟宽高比的效果](https://www.atatech.org/articles/81457)。比如：```css.aspectration{position:relative;/*因为容器所有子元素需要绝对定位*/height:0;/*容器高度是由padding来控制，盒模型原理告诉你一切*/width:100%;}.aspectration<ahref=\"https://codepen.io/rachelandrew/pen/WNrRZaV\">data-ratio=\"16:9\"]{padding-top:56.25%;}.aspectration[data-ratio='4:3']{padding-top:75%;}```如果浏览器支持了aspect-ratio的话，可以像下面这样使用：```cssdiv{aspect-ratio:1/1;}```比如[[@rachelandrew在Codepen提供的一个示例](https://codepen.io/rachelandrew/pen/WNrRZaV)，我在该示例的基础上稍作调整了一下([codepen.io/airen/pen/v…](https://codepen.io/airen/pen/vYGvqmZ)：)![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1293e1b702b0442ab31a08add1e9195d~tplv-k3u1fbpfcp-watermark.image)##:target`和`:target-within:target和:target-within都是[SelectorsLevel4](https://www.w3.org/TR/selectors-4)[模块中的两个伪元素](https://www.w3.org/TR/selectors-4/#the-target-within-pseudo)。可能很多同学对:target更熟悉一些，甚至用:target伪元素的特性制作了[Tab](https://www.sitepoint.com/css3-tabs-using-target-selector/)、[Accordion](https://www.w3cplus.com/blog/160.html)和[Modal](https://www.cssscript.com/simple-modal-box-using-css-and-target-pseudo-class/)等UI交互效果。比如下面这个手风琴的效果就是用:[target伪元素制作](https://codepen.io/airen/pen/PxYxap)的：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54165209b29449db083c28498c50c01~tplv-k3u1fbpfcp-watermark.image)单的来看看:target和:target-within的作用。在某些文档语言中，文档的URL可以通过URL的片段进一步指向文档中的特定元素。以这种方式指向的元素是文档的目标元素。其中片段标识符是URL中紧跟#的部分，例如#top或#fontnote1。你可能已经使用它们创建页面内导航，比如大家常见的“跳转链接”。有了:target伪类，我们可以突出显示与该片段对应的文档部分，而且无需JavaScript也可以做到这一点。比如下面这个简单的[示例](https://codepen.io/airen/pen/BaKvjGj)：```css<!--HTML--><h3>TableofContents</h3><ol><li><ahref=\"#p1\">Jumptothefirstparagraph!</a></li><li><ahref=\"#p2\">Jumptothesecondparagraph!</a></li><li><ahref=\"#nowhere\">Thislinkgoesnowhere,becausethetargetdoesn'texist.</a></li></ol><h3>MyFunArticle</h3><pid=\"p1\">Youcantarget<i>thisparagraph</i>usingaURLfragment.Clickonthelinkabovetotryout!</p><pid=\"p2\">Thisis<i>anotherparagraph</i>,alsoaccessiblefromthelinksabove.Isn'tthatdelightful?</p>/*CSS*/p:target{background-color:gold;}/*在目标元素中增加一个伪元素*/p:target::before{font:70%sans-serif;content:'►';color:limegreen;margin-right:0.25em;}/*在目标元素中使用italic样式*/p:targeti{color:red;}```点击示例中的链接，你可以看到像下图的效果：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f8aff714e440c5990771376f64cf9c~tplv-k3u1fbpfcp-watermark.image)而:target-within伪类应用于:target伪类所应用的元素，以及在平面树（FlatTree）的后代（包括非元素节点，比如文本节点）与匹配:target-within的条件相匹配的元素。article:target-within{background-color:hsl(var(--surfaceHSL)/10%);}其实在选择器Level4模块中还新增了很多其他的伪类选择器，如果你对这方面新增的选择器感兴趣的话，可以听一听@AdamArgyle和@AnaTudor一起办的[CSSPodcast](https://thecsspodcast.libsyn.com/)，其中第十四期就是专门聊CSS的[伪类选择器](https://thecsspodcast.libsyn.com/014-pseudo-elements)的。##CSS逻辑属性如果你阅读过[《Web中向左向右》](https://www.atatech.org/articles/159175)一文或者有接触过CSS书写模式特性，你会发现以前我们熟悉的物理属性在不同的语言环境之下很难满足布局的需求，比如英语和阿拉伯语，日语和蒙语等，我们设置的margin-left有可能不是margin-left，width也有可能不是width。![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11b538fc559240c0bc6ca299bd36ca7d~tplv-k3u1fbpfcp-watermark.image)这个时候，CSS逻辑属性就显得尤其重要。换句话说，逻辑属性的出现，我们以往熟悉的盒模型也将带来很大的变化：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2b001945236486290f4b8388d0bcfa2~tplv-k3u1fbpfcp-watermark.image)下图是我们熟悉的物理属性和逻辑属性的对应关应：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6214095ce083444f80ca531be7ebba4e~tplv-k3u1fbpfcp-watermark.image)对于[块轴（blockaxis）](https://drafts.csswg.org/css-writing-modes-4/#block-axis)和[内联轴（inlineaxis）](https://drafts.csswg.org/css-writing-modes-4/#inline-axis)区别，同样用一张图来描述这两者吧：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/410d29a360da4db3b8c62225bee23803~tplv-k3u1fbpfcp-watermark.image?imageslim)块轴和内联轴和CSS的书写模式writing-mode以及direction和HTML的dir有关系。换句话说：-块轴：主要定义网站文档（元素块）流，CSS的书写模式writing-mode会影响块轴的方向-内联轴：主要定义网站的文本流方向，也就是文本的阅读方式，CSS的direction或HTML的dir会影响内联轴的方向![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8be6830d9c284c67aa44397f291f1a14~tplv-k3u1fbpfcp-watermark.image)有关于writing-mode、direction和dir对Web排版的影响相关的详细介绍可以阅读[《Web中向左向右》](https://www.atatech.org/articles/159175)一文。##min()max()和clamp()min()、max()和clamp()三个函数称为“比较函数”。早在[《聊聊min()，max()和clamp()函数》](https://www.w3cplus.com/css/min-max-clamp-function.html)一文中对其做过详细的介绍。这里不做详细介绍，仅和三张图来分别展示他们的功能。我们可以使用min()设置最大值：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5cd1c0b78bb4bb78883f90cf4159127~tplv-k3u1fbpfcp-watermark.image)max()和min()相反，返回的是最大值。使用max()设置一个最小值：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35b11d99dda8497e9fe3a4a50ce38553~tplv-k3u1fbpfcp-watermark.image)clamp()函数和min()以及max()不同，它返回的是一个区间值。clamp()函数接受三个参数，即clamp(MIN,VAL,MAX)，其中MIN表示最小值，VAL表示首选值，MAX表示最大值。它们之间：-如果VAL在MIN和MAX之间，则使用VAL作为函数的返回值；-如果VAL大于MAX，则使用MAX作为函数的返回值；-如果VAL小于MIN，则使用MIN作为函数的返回值这里有一个关于clamp()的[示例](https://www.atatech.org/articles/'https://codepen.io/airen/pen/pojVpJv)，尝试着拖动浏览器视窗的大小，你可以看到类似下图这样的效果：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c8ea1dc711e4af4bc6b366f3677994a~tplv-k3u1fbpfcp-watermark.image)我们再来看几个和文本相关的特性：##leading-trim和text-edge一直以来，在Web的排版中行高（line-height）总是令Web开发者感到困惑和头痛，主要是因为line-height在CSS中是一个非常复杂的体系。他的计算总是会涉及到很多因素：@iamvdo的[《DeepdiveCSS:fontmetrics,line-heightandvertical-align》](https://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align)一文对这方面做过深入的阐述！在还原UI时，文本的行高总是让我们计算元素块之间的间距带来一定的麻烦：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc437f49aa142c0a9cc33d39b947582~tplv-k3u1fbpfcp-watermark.image)为了解决这方面的烦恼，[CSSInlineLayoutModuleLevel3](https://www.w3.org/TR/css-inline-3)新增了一个[leading-trim](https://www.w3.org/TR/css-inline-3/#leading-trim)和[text-edge](https://www.w3.org/TR/css-inline-3/#text-edges)属性。可以让我们删除每一种字体中的额外间距，以便我们可以更好的计算相邻块元素之间的间距。![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b1b4f2b6bf449eacf6ad481b122db8~tplv-k3u1fbpfcp-watermark.image)```cssh1{leading-trim:both;text-edge:capalphabetic;}```上面的示例首先使用text-edge来告诉浏览器想要的文本边缘是cap高度和字母基线（alphabeticbaseline）。然后用leading-trim对文本两边进行修剪。注意，leading-trim只影响文本框，它不会切断其中的文字。示例中的两行简单的CSS创建了一个包含文本的干净的文本框（不受line-height相关的特性影响）。这有助于实现更精确的间距，并创建更好的视觉层次结构。CSS的text-edge和leading-trim分别可接受的值：```csstext-edge:leading|<ahref=\"https://matthiasott.com/notes/the-thing-with-leading-in-css?ref=heydesigner\">text|cap|ex|ideographic|ideographic-ink][text|alphabetic|ideographic|ideographic-ink]?leading-trim:normal|start|end|both```如果你对leading-trim特性感兴趣的话，除了阅读规范之外，还可以阅读下面几篇文章：-[[TheThingWithLeadinginCSC\\]](https://matthiasott.com/notes/the-thing-with-leading-in-css?ref=heydesigner)-[Leading-Trim:TheFutureofDigitalTypesetting](https://medium.com/microsoft-design/leading-trim-the-future-of-digital-typesetting-d082d84b202)-[Rethinkingline-sizingandleading-trim](https://github.com/w3c/csswg-drafts/issues/5168)##::grammar-error和::spelling-error::grammar-error和::spelling-error是两个非常有意思的伪元素选择器。从字面说我们可以知道，Grammarerror指的是语法错误，Spellingerror指的是拼写错误。其实这两种现象在我们平时书写文本的时候经常可见，可能会由于手误，将某个单词或标点符号用错，甚至语法上的错误。针对于这种现象，我们总是希望有一定的提示信息来提示我们，比如颜色上的差异，添加一些下划线等等：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/278eeff5d6244f309347a59ddfb2e6af~tplv-k3u1fbpfcp-watermark.image)在[CSSPseudo-ElementsModuleLevel4](https://drafts.csswg.org/css-pseudo)的[高亮伪元素](https://drafts.csswg.org/css-pseudo/#highlight-pseudos)中我们可以看到这两个伪元素的身影：-::grammar-error：浏览器为语法错误的文本段添加样式-::spelling-error：浏览器为拼写错误的文本段添加样式在CSS中并不是所有属性都能运用于这两个伪元素，到目前为止，只有color、background-color、cursor、text-emphasis-color、text-shadow、outline、text-decoration、fill-color、stroke-color和stroke-width可以用于这两个伪元素。```css:root::spelling-error{text-decoration-line:spelling-error;}:root::grammar-error{text-decoration-line:grammar-error;}<ahref=\"https://drafts.csswg.org/css-values-4\">spellcheck]::spelling-error{text-decoration:wavyunderlinevar(--neon-red);}[grammarcheck]::grammar-error{text-decoration:wavyunderlinevar(--neon-blue);}```##新增相对单位：cap、lh、rlh、vi和vb[CSS中单位和值([drafts.csswg.org/css-values-…](https://drafts.csswg.org/css-values-4))中单位有：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb570e4de16e46e9bd744e11ff6542eb~tplv-k3u1fbpfcp-watermark.image)但在相对[单位](https://drafts.csswg.org/css-values-4/#relative-lengths)中并没有提到cap、lh、rlh、vi和vb这几个相对单位。![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dcf3c24296a4dbb978f62ab4b6c28e8~tplv-k3u1fbpfcp-watermark.image)从上表的描述来看，其中cap、lh、rlh的计算都和元素的字体以及行高等有关系。我用下图来描述一个字体的CapHeight，LineHeight等：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b79650b8ef4cbda29ccebefcf8cef2~tplv-k3u1fbpfcp-watermark.image)#Web性能##contain和content-visibility这两个属性是属于CSS容器模块的，其最大的特点应该是可以帮助Web开发者提高Web页面的性能：当容器的内容发生变化时，浏览器考虑到其他元素可能也会发生变化，于是就会去检查页面中所有的元素。一直以来浏览器都是这么做的，大家都习以为常了。但从另一方面来说，开发者很清楚当前修改的元素是否独立、是否影响其他元素。因此如果开发者能把这个信息通过CSS告诉浏览器，那么浏览器就不需要再去考虑其他元素了，这就是非常完美的事情。而CSS容器模块中的contain属性就为我们提供了这种能力。们来看@ManuelRegoCasasnovas在[《AnintroductiontoCSSContainment》](https://blogs.igalia.com/mrego/2019/01/11/an-introduction-to-css-containment/?ref=heydesigner)文章中提供的一个[示例](https://blogs.igalia.com/mrego/files/2019/01/css-contain-example.html)：假设一个页面有很多个元素，在这个示例中，我们有10000个这样的元素：```<divclass=\"item\"><div>Loremipsum...</div></div>```使用JavaScript的textContent这个API来动态更改div.item>div的内容：```jsconstNUM_ITEMS=10000constNUM_REPETITIONS=10functionlog(text){letlog=document.getElementById('log')log.textContent+=text}functionchangeTargetContent(){log('Change\"targetInner\"content...')//Forcelayout.document.body.offsetLeftletstart=window.performance.now()lettargetInner=document.getElementById('targetInner')targetInner.textContent=targetInner.textContent=='HelloWorld!'?'BYE':'HelloWorld!'//Forcelayout.document.body.offsetLeftletend=window.performance.now()lettime=window.performance.now()-startlog('Time(ms):'+time+'\\n')returntime}functionsetup(){for(leti=0;i<NUM_ITEMS;i++){letitem=document.createElement('div')item.classList.add('item')letinner=document.createElement('div')inner.style.backgroundColor='#'+Math.random().toString(16).slice(-6)inner.textContent='Loremipsum...'item.appendChild(inner)wrapper.appendChild(item)}}```如果不使用contain，即使更改是在单个元素上，浏览器在布局上的渲染也会花费大量的时间，因为它会遍历整个DOM树（在本例中，DOM树很大，因为它有10000个DOM元素）：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19cec39c8af44304a01e7bc442155f9e~tplv-k3u1fbpfcp-watermark.image)在本例中，div的大小是固定的，我们在内部div中更改的内容不会溢出它。因此，我们可以将contain:strict应用到项目上，这样当项目内部发生变化时，浏览器就不需要访问其他节点，它可以停止检查该元素上的内容，并避免到外部去。![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2584344468f47439c3ecef01fe00814~tplv-k3u1fbpfcp-watermark.image)CSS容器模块中的content-visibility属性会显著影响第一次下载和第一次渲染的速度。此外，你可以立即与新渲染的内容交互，而无需等待内容的其余部分加载。该属性强制用户代理跳过不在屏幕上的标记和绘制元素。实际上，它的工作方式类似于延迟加载，只是不加载资源，而是渲染资源。简单地说，CSS的content-visibility属性可跳过不在屏幕上的内容渲染，包括布局（Layout）和渲染（Paint），直到真正需要布局渲染的时候为止。所以利用它可以使用初始用户加载速度更快，还能与屏幕上的内容进行更快的交互。![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01765bad264b49d2949d5c8ff05b7a7a~tplv-k3u1fbpfcp-watermark.image)上图来自于@UnaKravets和@VladimirLevin的《content-visibility:thenewCSSpropertythatboostsyourrenderingperformance([web.dev/content-vis…](https://web.dev/content-visibility/)》一文。从图中我们可以获知，使用content-visibility):auto属性可使分块的内容区域的初始加载性能提高7倍。有关于这方面的介绍，还可以阅读：-[CSSContainmentinChrome52](https://developers.google.com/web/updates/2016/06/css-containment)-[HelpingBrowsersOptimizeWithTheCSSContainProperty](https://www.smashingmagazine.com/2019/12/browsers-containment-css-contain-property/)-[AnintroductiontoCSSContainment](https://blogs.igalia.com/mrego/2019/01/11/an-introduction-to-css-containment)-[Let’sTakeaDeepDiveIntotheCSSContainProperty](https://css-tricks.com/lets-take-a-deep-dive-into-the-css-contain-property/)-[CSSContainment](([developer.mozilla.org/zh-CN/docs/…](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Containment))-[content-visibility:thenewCSSpropertythatboostsyourrenderingperformance](https://web.dev/content-visibility/)-[Shortnoteoncontent-visibility:hidden](https://html5accessibility.com/stuff/2020/08/25/short-note-on-content-visibility-hidden/)-[Usingcontent-visibility:hidden](https://www.w3.org/TR/css-contain-2/#using-cv-hidden)-[Usingcontent-visibility:auto](https://www.w3.org/TR/css-contain-2/#using-cv-auto)##数据服务数据服务指的是DataSaver。啥意思呢？不做解释，直接用一段代码来描述：```css@media(prefers-reduced-data:reduce){header{background-image:url(/grunge.avif);}}```我想大家对于@media(prefers-reduced-data:reduce)应该不会陌生吧。是的，它就是我们所说的CSS媒体查询。只不过稍有不同的是，这个媒体查询是根据用户在设备上的设置喜好来做条件判断。比如上面示例代码，当用户在设备上开启了“LowDataMode”（低数据模式），会加载grunge.avif图像，可以帮助iPhone上的应用程序减少网络数据的使用：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00676b3813724664bb85d1a7bb9a75ca~tplv-k3u1fbpfcp-watermark.image)到目前为止，CSS媒体查询提供了多个媒体特性，可以以用户在设备上的喜好设置做为判断，比如iOS13+开始，[iPhone提供的DarkMode模式（prefers-color-scheme）](https://www.atatech.org/articles/153525)：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2764327f5de4e3b88911a54e0de5876~tplv-k3u1fbpfcp-watermark.image)比如，使用prefers-reduced-motion媒体查询用于检测用户的系统是否被开启了动画减弱功能：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/296c3e7cf4924b359ac39170b9036fbc~tplv-k3u1fbpfcp-watermark.image)上面提到的这些媒体查询条件都是在CSSMediaQueriesLevel5([www.w3.org/TR/mediaque…](https://www.w3.org/TR/mediaqueries-5/))模块中新增的。除了上面提到的之外，还有一些我们平时很少见的媒体查询条件，比如：```css@media(hover:hoveer){}@media(hover:none)and(pointer:coarse){}@media(hover:none)and(pointer:fine){}@mediaprintand(min-resolution:300dpi){}@media(scan:interlace){}@media(update){}@media(environment-blending:additive){}@media(color){}```##变量字体变量字体是一个非常有意思的CSS特性，它也常被称为“可变字体”，先给大家展示一个[Demo](https://codepen.io/airen/pen/yLNpQQW)：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e86397ef899e478e95e9aeee40458cc5~tplv-k3u1fbpfcp-watermark.image)变量字体的目标是让网站性能更好，同时给用户提供了更多选择和扩展。变量字体是类似矢量图形，允许为各种字体轴定义不同的值。变量字体设计中一般有五个注册轴，包括字体、字宽、斜体和光学尺寸。每个注册轴都有一个对应的四个字母的标记，可以映射到现有的CSS属性：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/195ba4a12cc2421bb3ee59e28e116dca~tplv-k3u1fbpfcp-watermark.image)除了注册轴之外，字体设计器还可以包含自定义轴。自定义轴让可变字体变得更具创造性，因为不限制自定义轴的范围、定义或数量。与注册轴类似，自定义轴具有相应的四个字母标记。但是，自定义轴的字母标记必须是大写的。例如，你定义了一个注册轴是grade，其对应的字母标记是GRAD。比如上面示例效果对应的代码：```css.text{font-weight:800;font-style:italic;font-variation-settings:'SSTR'183,'INLN'648,'TSHR'460,'TRSB'312,'TWRM'638,'SINL'557,'TOIL'333,'TINL'526,'WORM'523;transition:font-variation-settings0.28sease;}.text:hover{font-weight:400;font-style:normal;font-variation-settings:'SSTR'283,'INLN'248,'TSHR'160,'TRSB'112,'TWRM'338,'SINL'257,'TOIL'133,'TINL'426,'WORM'223;}```在Firefox浏览器中，我们还可以通过开发者工具中“字体”选项提供的相关可变字体注册轴的值调整：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2543d829b0f34dae9fe57a58e9b9ebca~tplv-k3u1fbpfcp-watermark.image)调整完之后，可以获得新代码：```cssp{font-size:60px;line-height:37px;letter-spacing:0.113em;font-variation-settings:'SSTR'450,'INLN'741,'TSHR'292,'TRSB'497,'TWRM'173,'SINL'557,'TOIL'728,'TINL'526,'WORM'523,'TFLR'362,'TRND'516,'SWRM'536,'TSLB'509;font-weight:491;}```对应效果如下：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dd014614fe948fab8560ba9ae5c8587~tplv-k3u1fbpfcp-watermark.image)#Web可访问性##:focus-visible和:focus-within一直以来我很容易把:focus-within和:focus-visible混淆。其实:focus-within和:focus-visible都是CSS选择器[Level4中用户操作类伪类选择器](https://www.w3.org/TR/selectors-4/#useraction-pseudos)。早前在[《初探CSS选择器Level4》](https://www.w3cplus.com/css/css-selectors-level-4.html)中聊过:focus-within，但没有聊过:focus-visible。另外，在[《CSS:focus-within》](https://www.w3cplus.com/css/focus-within.html)教程中就提到过，:focus-within能非常方便处理获取焦点状态。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。:focus-within伪类选择器的行为本质上是一种父选择器行为，子元素的状态会影响父元素的样式。由于这种“父选择器”行为需要借助用户的行为触发，属于“后渲染”，不会与现有的渲染机制相互冲突。![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5449da8502064eb9823f008db4adcfbd~tplv-k3u1fbpfcp-watermark.image)如果上面的介绍让你感到困惑的话，可以看下面这个[Demo](https://codepen.io/ericwbailey/pen/KQOpRM)。你会发现，当的后代元素得到焦点时，会有一个放大的效果：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1593c1a20da14e7a8cc258c245b2f045~tplv-k3u1fbpfcp-watermark.image)实现上图的效果代码非常的简单：```cssform:focus-within{box-shadow:0px0.2em2.5em#c4c4c4;transform:scale(1.025);}```对于:focus-visible伪类来说，当元素匹配:focus伪类并且客户端(UA)的启发式引擎决定焦点应当可见时就会生效。这个选择器可以有效地根据用户的输入方式(鼠标vs键盘)展示不同形式的焦点。简单点说，按键盘tab键和鼠标点击得到的焦点效果不同。比如：```css/*链接得到焦点时的样式*/a:focus{}/**1\\.如果链接有焦点，但是浏览器通常不会显示默认的焦点样式，会覆盖上面的焦点样式*2\\.不是按键盘`tab`键让链接得到的焦点，比如说鼠标点击链接*/a:focus:not(:focus-visible){}/*按键盘tab键让链接得到焦点的样式*/a:focus-visible{}```[来看一个具体的案例](https://codepen.io/airen/pen/GRZPPVR)。这个示例中分别用鼠标点击链链和按键盘tab键让链接得到焦点，它的样式是不一样的：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2598e55ccf5248fcbd154f2104e6e28a~tplv-k3u1fbpfcp-watermark.image)#Web美化##ColorLevel4和Level5[CSSColorLevel4](https://www.w3.org/TR/css-color-4)和[Level5](https://www.w3.org/TR/css-color-5)两个模块主要是为我们推出了一些颜色使用的新属性，比如：-<hwb()>：HWB(白色-白色-黑色的缩写)是另一种指定颜色的方法，类似于HSL，它描述了一开始的色调，然后是一定程度的白色和黑色混合到基本色调-<lab()>和<lch()>：Lab是由一个亮度通道和两个颜色通道组成的。在Lab颜色空间中，每个颜色用L(亮度)、a(从绿色到红色的分量)和b(从蓝色到黄色的分量)三个数字表示。而Lch分别表示了颜色的亮度、饱和度和色调-<gray()>：灰色是完全去饱和的颜色，gray()函数表示法简化了对这组常见颜色的指定，因此只需要一个数值参数，用来指定颜色的灰度-<color()>：该函数允许在特定的颜色空间中指定颜色-<device-cmyk()>：该函数是以CMYK(青色、品红、黄色和黑色)组合，在该设备上生成特定的颜色-：根据用户操作系统来匹配颜色-color-mix()：该函数接受两个规范，并在给定的颜色空间中以指定的数量返回它们混合的结果-color-contrast()：该函数首先使用一种颜色(通常是背景色)，然后使用两种或两种以上颜色的列表，它从该列表中选择亮度对比度最高的颜色到单一颜色-color-adjust()：该函数接受一个规范，并通过指定的转换函数在给定的颜色空间中返回调整该颜色的结果颜色扩展：根据现有的颜色(在这称为“原始颜色”)在函数的目标颜色空间中生成颜色，它是<rgb()>、<rgba()>、<hsl()>、<hsla()>、<hwb()>、<lab()>和<lch()>的扩展颜色对于Web开发者来说，最大的感受是语法规则有较大的变化：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89701d59c2614bd9a541ec99c25794bf~tplv-k3u1fbpfcp-watermark.image)来看两个示例：```//ColorLevel4.colour{--fn-notation:hsl(2rad50%50%/80%);--neon-pink:color(display-p3101);--gray:lch(50%00);--fallback:color(lab252525,display-p3101,#ccc);}//ColorLevel5.colour{--pink:color-mix(red,white);--halfpink:color(var(--pink)/50%);--halfred:rgb(from#f00/50%);--darkred:hsl(fromredhscalc(l*.25));}```这里再特意提一下display-p3颜色，我们可以配合CSS的媒体查询@media(dynamic-range:high)一起使用：```@media(dynamic-range:high){.neon-red{--neon-glow:color(display-p3100);}.neon-pink{--neon-glow:color(display-p3101);}.neon-purple{--neon-glow:color(display-p3001);}.neon-blue{--neon-glow:color(display-p3011);}.neon-green{--neon-glow:color(display-p3010);}.neon-yellow{--neon-glow:color(display-p3110);}.neon-white{--neon-glow:color(display-p3111);}}```注意，Display-P3颜色空间颜色要比sRGB颜色空间中的颜色更鲜艳：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e35a157b2ec4ca4aa0e3fb5f45ec4ca~tplv-k3u1fbpfcp-watermark.image)也可以说，Display-P3是sRGB的一个超集，大约要大35%：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7facc99fcacd4175bd29210dbbadbcd7~tplv-k3u1fbpfcp-watermark.image)Safari97预览版本可以查看到display-p3的效果：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac858ab58de04d29968e517b7a3ae325~tplv-k3u1fbpfcp-watermark.image)同样的，在color()函数中使用display-p3指定颜色空间时，也可以和sRGB颜色空间相互转换，如下图所示：![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4a590cd6ac049e18648280836dffb00~tplv-k3u1fbpfcp-watermark.image)下面是@AdamArgyle在Codepen提供的一个有关于[display-p3的示例](https://codepen.io/argyleink/pen/MWymQGj)：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b1f6532e1ba48b790ed8a25f9962f1e~tplv-k3u1fbpfcp-watermark.image)##::marker::marker也是CSS的伪元素，现在被纳入到CSSListsModuleLevel3规范中。在该规范中涵盖了列表和计算数器相关的属性，比如我们熟悉的list-style-type、list-style-position、list-style、list-item、counter-increment、counter-reset、counter()和counters()等属性。在CSS中display设置list-item值之后就会生成一个Markers标记以及控制标记位置和样式的几个属性，而且还定义了计数器（计数器是一种特殊的数值对象），而且该计数器通常用于生成标记（Markers）的默认内容。一时之间，估计大家对于Markers标记并不熟悉，但对于一个列表所涉及到的相关属性应该较为熟悉，对于一个CSSList，它可以涵盖了下图所涉及到的相关属性：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db4275d10de5461c908691dd4a76be5e~tplv-k3u1fbpfcp-watermark.image)事实上，CSS的::marker和伪元素::before（或::after）类似，也可以通过content和attr()一起来控制Marker标记的效果。需要记住，生成个性化Marker标记内容需要做到几下几点：非列表项li元素需要显式的设置display:list-item（内联列表项需要使用display:inlinelist-item）需要显式设置list-style-type为none使用content添加内容（也可以通过attr()配合data-\\*来添加内容）比如下面这个小示例：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fadd1aeb08749cbbe54a14912b8bd02~tplv-k3u1fbpfcp-watermark.image)另外，::marker还没有得到浏览器支持之前，一般都是使用CSS的计数器来实现一些带有个性化的有顺序列表，比如下面这样的效果：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5902e78ed3f9412bb977229e54572324~tplv-k3u1fbpfcp-watermark.image)是不是很有意思，有关于::marker伪元素更详细的介绍，还可以阅读：[《CustombulletswithCSS::marker》](https://web.dev/css-marker-pseudo-element/)一文。##text-emphasis先上张图：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f894714b58e446baaa5d86138b847d35~tplv-k3u1fbpfcp-watermark.image)上图的效果就是使用CSS的text-emphasis实现的。在以往我们要给文本添加一些装饰效果，除了加粗（font-weight）、倾斜（font-style）、阴影（text-shadow），文本上面或下面添加线条（text-decoration）等之外也没有别的了（当然，还可以使用其他的CSS实现一些特殊效果）。但要实现上图的效果还是有一定难度的。不过text-emphasis的出现，这一切变得要简单地多。text-emphasis是属于CSSTextDecorationModule规范中的一个特性，在[Level3](https://www.w3.org/TR/css-text-decor-3/#emphasis-marks)中和text-emphasis有关的属性还有text-emphasis-style和text-emphasis-color，而且text-emphasis是这两个属性的简写属性。另外还有一个用来指定标记符位置的属性text-emphasis-position：```.emphasis{text-emphasis:trianglerebeccapurple;text-emphasis-position:under;}```![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8ccd0f5617a4f96a05c71aa42d037b5~tplv-k3u1fbpfcp-watermark.image)在Level4的规范中还新增了[text-emphasis-skip属性](https://www.w3.org/TR/css-text-decor-4/#text-emphasis-skip)。[具体的效果如下：](https://codepen.io/airen/pen/yLOZpzO)![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538851f309cd43cc8bdd65d27b10ab97~tplv-k3u1fbpfcp-watermark.image)##color-schemecolor-scheme属性来自于[CSSColorAdjustmentModuleLevel1](https://drafts.csswg.org/css-color-adjust/#color-scheme-prop)。如果你在自己的项目中实现过[iOS的DarkMode的效果](https://www.atatech.org/articles/153525)，你肯定使用过CSS的媒体查询prefers-color-scheme。```css:root{--color:#fff;--color-bg:#000;}@media(prefers-color-scheme:dark){--color:#000;--color-bg:#fff;}body{color:var(--color);background-color:var(--color-bg);}```虽然说，这可以让用户根据自己喜好来选择自己喜欢的皮肤，但这并不能覆盖所有的。这个时候可以使用color-scheme属性来做一定的补充。该属性允许用户通过用户代理控制自动调整色彩模式，比如暗色模式，对比度调整或特定所需的配色方案。这些值与用户的首选项进行协商，从而产生影响用户界面（UI）内容的所选颜色方案，例如表单控制和滚动条的默认颜色，以及CSS系统颜色的使用值。![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d242673ae94a6bba57a48893317a56~tplv-k3u1fbpfcp-watermark.image)color-scheme有两种用法，先来看第一种:```:root{color-scheme:darklight;}```在:root元素上，使用color-scheme颜色方案进行渲染，会影响画布的表面颜色（即全局背景颜色），color属性的初始值和系统颜色的使用值，还应该影响视窗滚动条颜色。另外一种使用方式是在标签上：```<metaname=\"color-scheme\"content=\"darklight\"/>```要遵守color-schemeCSS属性，需要先下载CSS（如果它是通过引用的）并进行解析。为了帮助用户代理立即用所需的颜色方案渲染页面背景，还可以在元素中提供一个颜色方案值。由于meta标记和CSS属性(如果应用到:root)最终都会导致相同的行为，所以我更建议通过meta标记指定颜色方案，这样浏览器可以更快地采用首选方案。最后给大家提供[@tomayac](https://twitter.com/tomayac)提供的一个关于[color-scheme的Demo](https://color-scheme-demo.glitch.me/)，下图是dark和light下相应的效果：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bce8135058a545688d0131dcac558da5~tplv-k3u1fbpfcp-watermark.image)这里仅仅是简单的说了一下color-scheme属性，如果想深入的了解还是需要阅读一些相关的教程：[CSSColorAdjustmentModuleLevel1:color-scheme](https://drafts.csswg.org/css-color-adjust/#color-scheme-prop)[Improveddarkmodedefaultstylingwiththecolor-schemeCSSpropertyandthecorrespondingmetatag](https://web.dev/color-scheme/)[Don’tForgetthecolor-schemeProperty](https://blog.jim-nielsen.com/2020/color-scheme-property/)#其他##&>和@nest很多同学应该使用过像Sass、LESS之类的CSS处理器，这些处理器中有一个特大的特性就是选择器的嵌套，比如Sass中：```css.parent{&>.child{color:red;}}.child{.parent&{color:blue;}}```编译之后的CSS：```css.parent>.child{color:red;}.parent.child{color:blue;}```以往只能在CSS处理器中使用这样的特性，但将来在CSS中也可以使用这方面的特性，因为现在CSS中新增了一个嵌套模块，即[CSSNestingModule](https://drafts.csswg.org/css-nesting-1)。有点类似于CSS自定义属性（变量）特性一样，最早也是出现在CSS处理器中，现在原生CSS也支持了这方面的特性。也就是说，在不久的将来（如果在你的工程构建中配置了[postcss-preset-env](https://preset-env.cssdb.org/)，现在就可以使用）：```cssarticle,section{&p{color:blue;}}```相当于：```css:is(article,section)p{color:blue;}```也就是：```cssarticlep,sectionp{color:blue;}```还可以是&>结合起来使用：```cssarticle,section{&>p{color:blue;}}```相当于：```cssarticle>p,section>p{color:blue;}```再来看另外几种有效的嵌套方式：```css.foo{color:blue;&>.bar{color:red;}}/*等同于*/.foo{color:blue;}.foo>.bar{color:red;}.foo{color:blue;&.bar{color:red;}}/*等同于*/.foo{color:blue;}.foo.bar{color:red;}.foo,.bar{color:blue;&+.baz,&.qux{color:red;}}/*等同于*/.foo,.bar{color:blue;}:is(.foo,.bar)+.baz,:is(.foo,.bar).qux{color:red;}```但是下面这几种写法将是无效的：```css/*无效，因为没有嵌套选择器*/.foo{color:red;.bar{color:blue;}}/*无效，因为&不在第一个复合选择器中*/.foo{color:red;.bar&{color:blue;}}/*无效，因为列表中的第二个选择器不包含嵌套选择器*/.foo{color:red;&.bar,.baz{color:blue;}}```还可以结合@nest使用。下面这几种嵌套方式都是有效的：```css.foo{color:red;@nest&>.bar{color:blue;}}/*等同于*/.foo{color:red;}.foo>.bar{color:blue;}.foo{color:red;@nest.parent&{color:blue;}}/*等同于*/.foo{color:red;}.parent.foo{color:blue;}.foo{color:red;@nest:not(&){color:blue;}}/*等同于*/.foo{color:red;}:not(.foo){color:blue;}```但像下面这样嵌套则是无效的：```css/*无效，因为没有嵌套选择器*/.foo{color:red;@nest.bar{color:blue;}}/*无效，因为不是列表中的所有选择器都包含嵌套选择器*/.foo{color:red;@nest&.bar,.baz{color:blue;}}```注意，如果使用@nest时记得要和&结合在一起使用才有效。##@property在CSSHoudini中，最令人兴奋的是给CSS自定义属性和值的API。这个API通过赋予CSS自定义属性（通常也称为CSS变量）语义意义（由语法定义）甚至回退值来增强CSS自定义属性。简单地说，可以使用CSSHoudini的CSS自定义属性和值的CSS.registerProperty()来注册一个自定义属性：```cssCSS.registerProperty({name:'--colorPrimary',syntax:'<color>',initialValue:'magenta',inherits:false});```这样一来就可以使用已注册好的--colorPrimary自定义属性：```css.card{background-color:var(--colorPrimary);/*magenta*/}.highlight-card{--colorPrimary:yellow;background-color:var(--colorPrimary);/*yellow*/}.another-card{--colorPrimary:23;background-color:var(--colorPrimary);/*magenta*/}```现在或者将来，我们可以直接使用CSS的@property来注册一个自定义属性：```css@property--gradient-start{syntax:'<color>';initial-value:white;inherits:false;}```在CSS中就可以直接像下面这样使用：```css.el{--gradient-start:white;background:linear-gradient(var(--gradient-start),black);transition:--gradient-start1s;}.el:hover{--gradient-start:red;}```比如下面这个[示例](https://codepen.io/airen/pen/poyqBGe)（请使用Chrome85+查看）：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b510aab114fb4247ae1206f30347d13a~tplv-k3u1fbpfcp-watermark.image)在CSS的世界中，还有另外一套规范是和CSS自定义属性有关的，那就是[CSSCustomPropertiesforCascadingVariablesModuleLevel1](https://www.w3.org/TR/css-variables-1/)。使用--在选择器块中声明自定义属性，然后使用var()函数引用已声明的自定义属性，将其当作CSS属性的值：```css:root{--color:#f09;}body{color:var(--color);}```到目前为止，CSS自定义属性（也有同学称为CSS变量）已经得到了主流浏览器的使用，而且在一些大型Web应用中可以看到其身影。另外CSS自定义属性被运用的场景也很多，比如说@AdamArgyle就用CSS自定义属性模拟了[一套缓动函数](https://codepen.io/argyleink/full/BajvPLz)，我们可以用于CSSAnimation中：```css:root{--ease-in-quad:cubic-bezier(0.55,0.085,0.68,0.53);--ease-in-cubic:cubic-bezier(0.55,0.055,0.675,0.19);--ease-in-quart:cubic-bezier(0.895,0.03,0.685,0.22);--ease-in-quint:cubic-bezier(0.755,0.05,0.855,0.06);--ease-in-expo:cubic-bezier(0.95,0.05,0.795,0.035);--ease-in-circ:cubic-bezier(0.6,0.04,0.98,0.335);--ease-out-quad:cubic-bezier(0.25,0.46,0.45,0.94);--ease-out-cubic:cubic-bezier(0.215,0.61,0.355,1);--ease-out-quart:cubic-bezier(0.165,0.84,0.44,1);--ease-out-quint:cubic-bezier(0.23,1,0.32,1);--ease-out-expo:cubic-bezier(0.19,1,0.22,1);--ease-out-circ:cubic-bezier(0.075,0.82,0.165,1);--ease-in-out-quad:cubic-bezier(0.455,0.03,0.515,0.955);--ease-in-out-cubic:cubic-bezier(0.645,0.045,0.355,1);--ease-in-out-quart:cubic-bezier(0.77,0,0.175,1);--ease-in-out-quint:cubic-bezier(0.86,0,0.07,1);--ease-in-out-expo:cubic-bezier(1,0,0,1);--ease-in-out-circ:cubic-bezier(0.785,0.135,0.15,0.86);--easing:var(--ease-in-quad);}.animation__target{animation:ani5svar(--easing)alternateinfinite;}//JavaScriptconsthandlerElement=document.getElementById(\"easing\");handlerElement.addEventListener(\"change\",function(e){document.documentElement.style.setProperty(\"--easing\",e.target.value);});```[点击这里查看效果](https://codepen.io/airen/pen/ExPryme)：![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9fea68f071e46f28f8bce7469a45a25~tplv-k3u1fbpfcp-watermark.image)##::cue`和`::cue(selector)::cue和::cue(selector)对我而言是一个全新的东西，这两个伪元素是[WebVTT:TheWebVideoTextTracksFormat](https://w3c.github.io/webvtt/#the-cue-pseudo-element)模块中的。::cue和::cue(selector)两个伪元素最大的差别是后者带参数的伪元素。具体的作用：-::cue伪元素（不带参数）匹配元素构造的任何WebVTT节点对象列表，但与背景符号对应的属性必须应用于WebVTT线索背景框，而不是WebVTT节点对象列表-::cue(selector)是带有参数的伪元素，必须有一个由CSS选择器组成的参数。它匹配元素构造的WebVTT内部节点对象，该元素也匹配给定的CSS选择器在CSS中只有部分属性可以运用于::cue和::cue(selector)两个伪元素，比如color、opacity、visibility、text-decoration、text-shadow、background、outline、font、line-height、white-space、text-combine-upright和ruby-position等。```::cue{color:white;background-color:hsl(00%0%/90%);}```说实话，没有完全阅读WebVTT:[TheWebVideoTextTracksFormat](https://w3c.github.io/webvtt)模块所有内容，对其并不完全了解。这里只是做一个抛砖引玉的作用，如果你的工作内容和WebVTT相关，那应该对你会有一定的作用；如果你对这方面感兴趣的话，可以深挖这方面的知识。","Front-End\\其他\\待整理代码.md":"16.::before和:after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用（1）、冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（2）、::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。🍀注意：:before和:after这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before::after。38.有哪几种隐藏元素的方法？visibility:hidden;这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；opacity:0;``CSS3属性，设置0可以使一个元素完全透明；position:absolute;设置一个很大的left负值定位，使元素定位在可见区域之外；display:none;元素会变得不可见，并且不会再占用文档的空间；transform:scale(0);将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；<divhidden=\"hidden\">HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态；height:0;将元素高度设为0，并消除边框；filter:blur(0);CSS3属性，括号内的数值越大，图像高斯模糊的程度越大，到达一定程度可使图像消失（此处感谢小伙伴支持）；39.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？li排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔。解决办法：在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px;设置float：left；41.🤭全屏滚动的原理是什么？用到了CSS的哪些属性？全屏滚动有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%。也可以理解为超出隐藏部分，滚动时显示。可能用到的CSS属：overflow:hidden;transform:translate(100%,100%);display:none;❤️拓展：也可以利用全屏视觉滚动差，使用background-attachment:fixed;来实现全屏效果。（这里是细心的小伙伴提出的另一个idea🤨）18.html转图片需要安装插件dom-to-imagenpminstalldom-to-imageimportdomtoimagefrom'dom-to-image';downLoadPhoto(){constnode=document.getElementById('table')//对应的html标签iddomtoimage.toPng(node).then((dataUrl)=>{constimg=newImage()img.src=dataUrl//将获取到的base64下载下来constimgUrl=img.srcif(window.navigator.msSaveOrOpenBlob){constbstr=atob[imgUrl.split(','](1))letn=bstr.lengthconstu8arr=newUint8Array(n)while(n--){u8arr[n]=bstr.charCodeAt(n)}constblob=newBlob([u8arr])window.navigator.msSaveOrOpenBlob(blob,'chart-download'+'.'+'png')}else{//这里就按照chrome等新版浏览器来处理consta=document.createElement('a')a.href=imgUrla.setAttribute('download','chart-download')a.click()}})}19.字符串转base与base64转字符串//加密functionbase64EncodeUnicode(str){returnbtoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,function(match,p1){returnString.fromCharCode('0x'+p1);}));}//解密functionbase64DecodeUnicode(str){returndecodeURIComponent(atob(str).split('').map(function(c){return'%'+('00'+c.charCodeAt(0).toString(16)).slice(-2);}).join(''));}20.图片添加水印constsetWatermark=({url='',textAlign='center',textBaseline='middle',font=\"20pxMicrosoftYahei\",fillStyle='rgba(184,184,184,0.8)',content='水印',cb=null,textX=100,textY=30}={})=>{constimg=newImage()img.src=urlimg.crossOrigin='anonymous'img.onload=function(){constcanvas=document.createElement('canvas')//斜式水印处理const\\_w=img.widthconst_h=img.heightconstclientWidth=document.body.clientWidthconstproportion=\\_h/\\_wcanvas.width=_wcanvas.height=_hconstctx=canvas.getContext('2d')ctx.drawImage(img,0,0,clientWidth,clientWidth*proportion)ctx.textAlign=textAlignctx.textBaseline=textBaselinectx.font=fontctx.fillStyle=fillStyle//ctx.fillText(content,_w-textX,_h-textY)//右下角水印//斜式水印ctx.rotate((-15*Math.PI)/180)for(leti=0;i<5;i++){for(letj=0;j<7;j++){ctx.fillText(content,i*(clientWidth/5),j*(clientWidth*proportion/5))}}constbase64Url=canvas.toDataURL()cb&&cb(base64Url)}}//用法setWatermark({url:'xxxx',content:'测试水印',cb:(base64Url)=>{console.log(base64Url)}})21.获取hh:mm:ss时间consttimeFormat=date=>date.toTimeString().slice(0,8)timeFormat(newDate())22.移动端获取软键盘高度//ios软键盘弹起后可以修改固定底部的元素bottom的值visualViewport.addEventListener('resize',()=>{letkeyboardHeight=document.body.clientHeight-visualViewport.height})一、日期处理1.去除字符串中的HTML该方法用于去除字符串中的HTML元素：conststripHtml=html=>(newDOMParser().parseFromString(html,'text/html')).body.textContent||'';","Front-End\\其他\\获取网站favicon.icon.md":"#[`获取网站favicon.icon`](/)##方法一直接在网站网址后面加favicon.ico例如：<https://www.baidu.com/favicon.ico>（有一些网站可能会直接跳转到网站页面，并不会显示图标文件）##方法二F12或者右键查看网页源代码，然后再网页头部找到,链接指向即为favicon.ico的地址例如：有道翻译网站的图标获取`<linkrel=\"shortcuticon\"href=\"http://shared.ydstatic.com/images/favicon.ico\"type=\"image/x-icon\">`但一些网站（例如方法一中的百度的ico文件）是指向静态资源目录，无法获取到##方法三也是我比较推荐的方法<http://www.google.com/s2/favicons?domain=网站地址>例如获取百度的：<http://www.google.com/s2/favicons?domain=www.baidu.com>","Front-End\\包管理器\\cnpm.md":"#cnpm##问题###cnpm:无法加载文件C:\\Users\\AppData\\Roaming\\npm\\cnpm.ps1，因为在此系统上禁止运行脚本>提示信息：系统禁止运行脚本。这时我们需要更改系统的执行策略，使得脚本能够在我们的系统上执行。>过程如下：>>1.以`管理员身份`运行`WindowsPowerShell`>2.输入命令`set-ExecutionPolicyRemoteSigned`更改执行策略。>3.输入`Y`,执行更改策略。>4.部分电脑要`重启电脑`才可以生效","Front-End\\包管理器\\npm\\error\\npm publish 时提示需要升级TLS 1.2的解决方案.md":"#npmpublish时提示需要升级TLS1.2的解决方案从2021年10月4日开始，所有与npm网站和npm注册表的连接（包括软件包安装）必须使用TLS1.2或更高版本。很多朋友在发布npm包时可能会遇到提示：```shellnpmnoticeBeginningOctober4,2021,allconnectionstothenpmregistry-includingforpackageinstallation-mustuseTLS1.2orhigher.Youarecurrentlyusingplaintexthttptoconnect.PleasevisittheGitHubblogformoreinformation:<https://github.blog/2021-08-23-npm-registry-deprecating-tls-1-0-tls-1-1/>npmERR!codeE426```这时候可以首先将npm镜像地址设为https的地址：`npmconfigsetregistry<https://registry.npmjs.org>`然后再尝试发布，如果还是报错，可以运行以下命令支持TLS1.2：`npminstall-g<https://tls-test.npmjs.com/tls-test-1.0.0.tgz>`运行完会收到提示：```shellHello!Thetls-testpackagewassuccessfullydownloadedandinstalled.Congratulations!YourpackagemanagerappearstosupportTLS1.2.```如果收到错误提示，可以升级node到包含npm7以上的版本以支持TLS1.2，升级完检查下npm版本，如果没到7.0可以按照提示升级到7.0以上。","Front-End\\包管理器\\npm\\npm-cli.md":"#npmCLI##目录-本地模式：npm将包安装到当前项目目录，默认为当前工作目录。-软件包安装到`./node_modules`，并将bin安装到`./node_modules/.bin`-全局模式：npm将包安装到安装前缀到`$npm_config_prefix/lib/node_modules`和`$npm_config_prefix/bin`##Hooks-`prepublish`:在publish该包之前执行。(在包目录下执行npminstall时也会执行)-`postpublish`:在该包publish之后执行-`preinstall`:在该包被install之前执行-`postinstall`:在该包被install之后执行-`preuninstall`:在该包被uninstall之前执行-`postuninstall`:在该包被uninstall之后执行-`preversion`:在修改该包的version之前执行-`postversion`:在修改该包的version之后执行-`pretest`,`posttest`:在该包内执行test时执行，其中pretest先于posttest-`prestop`,`poststop`:在该包内执行stop时执行，其中prestop先于poststop-`prestart`,`poststart`:在该包内执行start时执行，其中prestart先于poststart-`prerestart`,`postrestart`:在该包内执行`restart`脚本时执行，其中prerestart先于postrestart。注意:如果没有在scripts里显示指定restart脚本，则会自动调用stop，然后再start-上面这些Hooks都是npm预定义好的，也就是说，当你执行npminstall时，如果你在scripts里定义了preinstall和postinstall，那它们分别会在npminstall之前/后自动执行","Front-End\\包管理器\\npm\\npm包.md":"#npm包##react>代码高亮<https://github.com/react-syntax-highlighter/react-syntax-highlighter>>>-组件拖拽<https://react-dnd.github.io/react-dnd/docs/api/drag-source>>-组件拖拽<https://github.com/atlassian/react-beautiful-dnd#readme>>-[React源码技术揭秘](https://react.iamkasong.com/preparation/source.html#拉取源码)>-react-quill[react-quill的使用\\_Alonepatients的博客](https://blog.csdn.net/weixin_45551411/article/details/104791466)##npm包-<https://www.npmjs.com/package/qs>-[node打包可执行文件工具——Pkg](https://www.cnblogs.com/mordom/archive/2018/01/23/8337337.html)-prisma-<http://createjs.cc/>-<https://github.com/jaywcjlove/onlinenetwork>-<https://www.npmjs.com/package/mitt>-<https://www.npmjs.com/package/validator>-<https://www.npmjs.com/package/yup>-<https://www.npmjs.com/package/date-fns>-<https://www.npmjs.com/package/jsonwebtoken>-<https://ramda.cn/>-<https://www.npmjs.com/package/winston>-<https://github.com/junqiuzhang/react-virtualize>-<https://github.com/junqiuzhang/easy-drag>##包管理器管理、读取和打包JavaScript库的工具。-[npm](https://www.npmjs.com/)：npm是JavaScript的包管理器。-[Bower](https://github.com/bower/bower)：一个web应用的包管理器。-[component](https://github.com/componentjs/component)：能构建更好web应用的客户端包管理器。-[spm](https://github.com/spmjs/spm)：全新的静态包管理器。-[jam](https://github.com/caolan/jam)：一个专注于浏览器端的包管理器,兼容RequireJS。-[jspm](https://github.com/jspm/jspm-cli)：流畅的浏览器包管理器。-[Ender](https://github.com/ender-js/Ender)：没有库文件的程序库。-[volo](https://github.com/volojs/volo)：以项目模板、添加依赖项与自动化生成的方式创建前端项目。-[Duo](https://github.com/duojs/duo)：融合了Component、Browserify和Go的最佳思想，快速无痛开发组织前端代码的下一代包管理器。-[yarn](https://yarnpkg.com/lang/en/)：高效、稳定、安全的依赖管理器。-[pnpm](https://pnpm.js.org/)：效率高、磁盘利用率高的包管理器rnmnvm:node版本管理器","Front-End\\包管理器\\npm\\npm发布失败.md":"##npm发布失败,并要`npmadduser`,运行后会跳转到`cnpm`登录页-查看淘宝镜像`npmgetregistry`-如果不是<https://registry.npmjs.org/>-重新设置```shellnpmconfigsetregistry<https://registry.npmjs.org/>```然后再切回原本自己的镜像```shellnpmconfigsetregistryhttps://registry.npmmirror.com/```","Front-End\\包管理器\\npm\\npm指令说明.md":"#npm##常用npm命令1.`npm-v`：查看npm版本。2.`npminit`：初始化后会出现一个`package.json`配置文件。可以在后面加上`-y`，快速跳过问答式界面。3.`npminstall`：会根据项目中的`package.json`文件自动下载项目所需的全部依赖。4.`npminstall包名--save-dev`(`npminstall包名-D`)：安装的包只用于开发环境，不用于生产环境，会出现在`package.json`文件中的`devDependencies`属性中。5.`npminstall包名--save`(`npminstall包名-S`)：安装的包需要发布到生产环境的，会出现在package.json文件中的`dependencies`属性中。6.`npmlist`：查看当前目录下已安装的node包。7.`npmlist-g`：查看全局已经安装过的node包。8.`npm--help`：查看npm帮助命令。9.`npmupdate包名`：更新指定包。10.`npmuninstall包名`：卸载指定包。11.`npmconfiglist`：查看配置信息。12.`npm指定命令--help`：查看指定命令的帮助。13.`npminfo指定包名`：查看远程npm上指定包的所有版本信息。14.`npmconfigsetregistryhttps://registry.npm.taobao.org`：修改包下载源，此例修改为了淘宝镜像。15.`npmroot`：查看当前包的安装路径。16.`npmroot-g`：查看全局的包的安装路径。17.`npmls包名`：查看本地安装的指定包及版本信息，没有显示empty。18.`npmls包名-g`：查看全局安装的指定包及版本信息，没有显示empty。##Config`npmconfigls-l`:查看一组npm内部的配置参数，如果没有指定其他参数，则为默认值。-`-a`:`--all`-`--enjoy-by`:`--before`-`-c`:`--call`-`--desc`:`--description`-`-f`:`--force`-`-g`:`--global`-`-L`:`--location`-`-d`:`--loglevelinfo`-`-s`:`--loglevelsilent`-`--silent`:`--loglevelsilent`-`--ddd`:`--loglevelsilly`-`--dd`:`--loglevelverbose`-`--verbose`:`--loglevelverbose`-`-q`:`--loglevelwarn`-`--quiet`:`--loglevelwarn`-`-l`:`--long`-`-m`:`--message`-`--local`:`--no-global`-`-n`:`--no-yes`-`--no`:`--no-yes`-`-p`:`--parseable`-`--porcelain`:`--parseable`-`-C`:`--prefix`-`--readonly`:`--read-only`-`--reg`:`--registry`-`-S`:`--save`-`-B`:`--save-bundle`-`-D`:`--save-dev`-`-E`:`--save-exact`-`-O`:`--save-optional`-`-P`:`--save-prod`-`-?`:`--usage`-`-h`:`--usage`-`-H`:`--usage`-`--help`:`--usage`-`-v`:`--version`-`-w`:`--workspace`-`--ws`:`--workspaces`-`-y`:`--yes`##更新安装包###手动更新修改`package.json`中依赖包版本，执行`npminstall--force`###使用第三方插件`npminstall-gnpm-check-updates``ncu`//查看可更新包`ncu`-u//更新package.json`npminstall`//升级到最新版本###更新指定包`npm-ginstall<name>````shell安装但不写入package.json；npminstallxxx安装并写入package.json的\"dependencies\"中npminstallxxx–S安装并写入package.json的\"devDependencies\"中npminstallxxx–D全局安装npminstallxxx-g安装指定版本npminstallxxx@1.2.0更新先检查更新npmoutdated执行以上命令，可以看到所有可以更新的模块。我们需要先更新package.json文件：安装\"npm-check-updates\"模块npminstall-gnpm-check-updates检查可更新的模块ncunpm-check-updates以上两条命令都可检查可更新模块。接下来更新package.json的依赖包到最新版本：ncu-u以上命令执行，更新全部模块。但在实际开发中不建议一次全部更新，可以根据实际需要，更新指定的模块，并且可以根据作用范围在后面加上-D、-S或-gnpmupdatexxx注意：指定更新需要提前修改package.json中的版本号。为了保险起见，package.json更新后，可删除整个node_modules目录并重新初始化项目。npminstall删除删除指定模块；npmuninstallxxx删除全局模块npmuninstall-gxxx```","Front-End\\包管理器\\npm\\yarn.md":"---title:yarndate:2020-10-3114:02:19tags:-yarn-tool---#yarn**安装Yarn**>npminstall-gyarn**安装CYarn**>npminstall-gcyarn或者使用cnpm源：>npminstall-gcyarn–registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org/)**1、初始化一个新的项目**>yarninit=》**npminit****2、添加一个依赖包**>`yarnadd[package]=》**npminstall[package]--save**yarnadd[package]@[version]yarnadd[package]@[tag]yarnadd[package]--dev=》npminstall[package]--save-devyarnglobaladd[package]=》npminstall[package]--global`**3、更新一个依赖包**>`yarnupgrade[package]=》npmupdate--saveyarnupgrade[package]@[version]yarnupgrade[package]@[tag]`**4、删除一个依赖包**>`yarnremove[package]=》npmuninstall[package]--save`**5、安装所有的依赖包**>yarnoryarninstall=》**npminstall****6、运行脚本**>yarnrun=》**npmrun****7、package缓存**>yarncachels列出每个缓存的包>yarncacheclean清除本地缓存**8、yarn配置文件**>yarnconfiglist列出所有配置项>yarnconfiggetxxx显示某项配置的值>yarnconfigsetxxxxxx修改配置>yarnconfigdeletexxx删除配置更改路径配置（换成淘宝镜像）>`yarnconfigsetregistry[https://registry.npm.taobao.org](https://registry.npm.taobao.org/)`**9、显示包信息**>`yarninfoReact````powershellnpminit----yarninitnpminstall----yarnaddnpminstallxxx@1.1.1-g----yarnglobaladdxxx@1.1.1npminstallxxx@1.1.1--save----yarnaddxxx@1.1.1npminstallxxx@1.1.1--save-dev----yarnaddxxx@1.1.1--devnpmuninstallxxx--save(-dev)----yarnremovexxxnpmrunxxx----yarnrunxxxx```","Front-End\\包管理器\\npm\\制作NPM包\\index.md":"#NPM包制作##前置工作>1.先去<https://www.npmjs.com/signup>注册一个用户>2.在本地登录好自己的账号`npmlogin`###登录失败>指向源出错```shellnpmlogin--registry=https://registry.npmjs.org/```###开始>1.创建项目>2.创建``package.json`:`npminit`>3.开始编辑您的组件###发布>1.发布`npmpublish`>2.然后就可以到官网搜索发布的包###添加链接访问功能```json{\"unpkg\":\"dist/bundle.js\",\"jsdelivr\":\"dist/bundle.js\"}```###npm上传白名单>在``package.json`添加代码```js\"files\":[\"src\",\"demo\",\"index.js\",]```###npm上传黑名单>在项目根目录下添加`.npmignore`文件:定义即使在白名单中,也会被忽略>>和`gitignore`文件写法类似```js/demo```###npm包删除和弃用>-撤销发布的包(24小时内):`npmunpublish`>-弃用特定版本以及版本范围:`npmdeprecate<pkg>[@version]<message>`###发布问题>-必须要有``package.json`,而且里面的`version`要有改变>-手动更改版本号:>>```bash>//version:1.1.1>npmversionpatch//第三位+1>npmversionminor//第二位+1>npmversionmajor//第一位+1>```###使用>-`npminstall[包名]`","Front-End\\包管理器\\npm\\制作NPM包\\ts.md":"#使用TS制作NPM包##前置工作>-`npminit`初始化一个`package.json`文件```json#package.json{\"name\":\"ts-hi\",\"version\":\"0.0.1\",\"description\":\"createnpmpackagewithtypescript\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo\\\"Error:notestspecified\\\"&&exit1\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/youthcity/ts-hi.git\"},\"keywords\":[\"typescript\"],\"author\":\"youthcity\",\"license\":\"ISC\",\"bugs\":{\"url\":\"https://github.com/youthcity/ts-hi/issues\"},\"homepage\":\"https://github.com/youthcity/ts-hi#readme\"}```##配置==Typescript==>-安装`Typescript`>>-方法一:`npmitypescript-D`>-方法二:`yarnaddtypescript-D`>>-配置`tsconfig.json`>>-方法一:直接自己创建改文件>-方法二:>-全局安装`typescript`包:`npmitypescript-g`>-命令行创建`tsc--init````json{\"compilerOptions\":{\"target\":\"es5\",\"module\":\"commonjs\",\"declaration\":true,\"outDir\":\"./dist\",\"strict\":true}}```##开始制作>1.创建`lib`文件夹>2.创建`index.ts````tsx#非常简单的加法函数exportfunctionadd(a:number,b:number):number{returna+b;}```##修改==package.json==```json{\"name\":\"ts-hi\",\"version\":\"0.0.1\",\"description\":\"createnpmpackagewithtypescript\",\"main\":\"index.js\",\"scripts\":{\"build\":\"tsc\"#增加ts编译命令},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/youthcity/ts-hi.git\"},\"keywords\":[\"typescript\"],\"author\":\"youthcity\",\"license\":\"ISC\",\"bugs\":{\"url\":\"https://github.com/youthcity/ts-hi/issues\"},\"homepage\":\"https://github.com/youthcity/ts-hi#readme\",\"devDependencies\":{\"typescript\":\"^3.0.3\"}}```>然后运行命令编译:`npmrunbuild`![image-20210603112139825](.assets/image-20210603112139825-1622690502121.png)##编写测试>安装测试框架和断言库>>-`npmimocha-D`>-`npmichai-D`>>创建测试文件目录和文件>>-`mkdirtest`>-`touchtest/test.js````js'usestrict'constexpect=require('chai').expectconstadd=require('../dist/index').adddescribe('ts-hifunctiontest',()=>{it('shouldreturn2',()=>{constresult=add(1,1)expect(result).to.equal(2)})})```###添加测试脚本```js\"scripts\":{\"build\":\"tsc\",\"test\":\"mocha--reporterspec\"},```>运行测试脚本`npmruntest`##提交和推送```shelltouch.gitignore//创建.gitignore文件，并添加node_modules/避免将node_modules添加到版本控制中gitadd.gitcommit-m“Initialrelease”gittagv0.1.0#修改一下package.json中的版本号为0.1.0gitpushoriginmaster--tags```###添加提交忽略文件>创建`.npmignore`文件```shell#忽略liblib/```##发布>1.在`https://www.npmjs.com/`注册或登录账号>2.`npmadduser`>3.`Username:[name]`>4.`Password:[pwd]`>5.`Email:(thisISpublic)[填写邮箱]`>6.发布包:`npmpublish`(已经登录了账号的,可直接执行这一步)","Front-End\\包管理器\\npm\\制作NPM包\\发包问题.md":"#发包问题#`npmERR!needauthThiscommandrequiresyoutobeloggedinto<https://registry.npm.taobao.org/>npmERR!needauthYouneedtoauthorizethismachineusing'npmadduser'``npmsetregistry<https://registry.npmjs.org>`","Front-End\\包管理器\\npm\\制作NPM包\\开发相关.md":"#开发相关##基本快捷方式-安装—常规：npminstall，简写：npmi。-测试—常规：npmtest，简写：npmt。-帮助—常规：npm--help，简写：npm-h。-全局标志—常规：--global，简写：-g。-保存为开发依赖-常规：-save-dev，简写：-D。-npminit默认值-常规：npminit--yes或npminit--force，简写：npminit-y或npminit-f-我们知道使用-save或-S来保存包，但现在这是个已经是默认值。要安装一个包而不保存它，可以使用——no-save标志。###不太常见的快捷键-安装包信息将加入到`optionalDependencies`（可选阶段的依赖）-常规：`--save-optional`，简写：-O。-精确安装指定模块版本-常规：`--save-optional`，简写：-O。-如果需要在本地保存一个npm包，或者通过单个文件下载选择一组可用的包，可以使用`--save-bundle`或-B将它们捆绑在一起，并使用npmpack获得捆绑包##设置默认npminit属性```shnpmconfigsetinit.author.name\"ruihuag\"npmconfigsetinit.author.email\"ruihuag@qq.com\"npmconfigsetinit.author.url\"guanruihua.github.io\"npmconfigsetinit.license\"MIT\"#查看配置文件信息npmconfigedit#编辑全局npmconfigedit-g```##让脚本跨平台兼容-`cross-env`:实现跨平台兼容性的最无缝的方法##并行运行脚本可以使用&&来依次运行两个或多个进程。但是并行运行脚本呢?为此，我们可以从各种npm包中进行选择。concurrent和npm-run-all是最流行的解决方案。首先通过npmi-Dconcurrently安装开发依赖。然后按照以下格式将其添加到脚本中：```json{\"start\":\"concurrently\\\"command1arg\\\"\\\"command2arg\\\"\"}```##在不同的目录中运行脚本-在不同的文件夹中拥有一个包含多个package.json文件的应用程序。从根目录访问这些脚本会很方便，而不是每次要运行脚本时导航到不同的文件夹，有两种方法可以执行此操作。-第一种是手动cd并运行对应的命令：`cdfolder&&npmstart&&cd..`-但还有一个更优雅的解决方案，即使用--prefix标志指定路径:`npmstart--prefixpath/to/your/folder`-下面是一个工作应用程序中此解决方案的示例，我们希望在前端(在客户机目录中)和后端(在服务器目录中)运行npmstart。`\"start\":\"concurrently\\\"(npmstart--prefixclient)\\\"\\\"(npmstart--prefixserver)\\\"\"`##延迟运行脚本直到端口准备就绪通常，在开发全堆栈应用程序期间，咱们可能希望同时启动服务器和客户端。wait-on节点模块提供了一种方便的方法来确保进程只在某些进程就绪时发生:在我们的例子中，我们有一个特定的端口。例如，这是我在使用React前端的Electron项目中使用的dev脚本。同时使用，脚本并行加载表示层和Electron窗口。但是，使用wait-on，只有在`<http://localhost:3000>`启动好，才会打开Electron窗口。`\"dev\":\"concurrently\\\"cross-envBROWSER=nonenpmrunstart\\\"\\\"wait-onhttp://localhost:3000&&electron.\\\"\"``React`默认情况下会打开一个浏览器窗口，但对于`Electron`开发来说，这是不必要的。咱们可以通过传递环境变量`BROWSER=none`来禁用此行为。##控制应用程序版本```sh#1.0.0npmversionpatch#1.0.1npmversionminor#1.1.0npmversionmajor#2.0.0```##自动设置和打开你的github库-如果package.json文件中有“repository”，则可以通过输入npmrepo在默认浏览器中打开它。-如果你的项目已经连接到远程存储库，并且已经在命令行上安装了git，那您可以使用这个命令找到你的连接存储库`gitconfig--getremote.origin.url`-更好的是，如果你按照上面的提示并安装了json模块，可以使用下面的脚本自动将正确的存储库添加到package.json`json-I-fpackage.json-e\"this.repository=\\\"$(gitconfig--getremote.origin.url)\\\"\"`##自定义npminit脚本-让我们更进一步，使用我们自己的npminit脚本，它接受GitHub存储库URL并自动推送我们的第一个提交。在本技巧中，我们将讨论如何创建自定义npminit脚本。在下一个(也是最后一个)技巧中，我们将合并git。可以通过重定向到主目录中的.npm-init.js文件来编辑npminit脚本。（在Windows上，通常是c/Users/<用户名>，在Mac上，它是/Users/<用户名>）。-先在我们的主目录中创建一个.nmm-init.js文件。为了确保npminit被指向正确的文件，可以运行:`npmconfigsetinit-module~\\.npm-init.js`在集成git之前，这里有一个简单的.npm-init.js文件，它模拟了默认npminit的问题```jsmodule.exports={name:prompt('packagename',basename||package.name),version:prompt('version','0.0.0'),decription:prompt('description',''),main:prompt('entrypoint','index.js'),repository:prompt('gitrepository',''),keywords:prompt(function(s){returns.split(/\\s+/)}),author:prompt('author','JoeBloggs<ruihuag@qq.com>(guanruihua.github.io)',),license:prompt('license','ISC'),}```每个问题都遵循`nameInPackage`模式:`prompt('nameInPrompt','defaultValue')`。要在缺省情况下设置值而不带问题，只需删除prompt方法。如果要返回默认设置，只需删除`.npm-init.js`##使用自定义npminit脚本将你的第一个Commit提交到GitHub为了将git命令合并到`.npm-init.js`文件中，需要一种方法来控制命令行。为此，可以使用`child_process`模块。在文件的顶部引入它，因为我们只需要`execSync`函数，所以可以使用析构赋值语法自己获取它：`const{execSync}=require('child_process');`我还创建了一个helper函数，它将函数的结果打印到控制台：```jsfunctionrun(func){console.log(execSync(func).toString())}```最后，我们将提示输入GitHub存储库URL，如果提供，我们将生README.md文件，并启动我们的第一次提交。```jsrepository:prompt('githubrepositoryurl','',function(url){if(url){run('touchREADME.md')run('gitinit')run('gitaddREADME.md')run('gitcommit-m\"firstcommit\"')run(`gitremoteaddorigin${url}`)run('gitpush-uoriginmaster')}returnurl})```总的来说，`.npm-init.js`文件大概如下：```jsconst{execSync}=require('child_process')functionrun(func){console.log(execSync(func).toString())}module.exports={name:prompt('packagename',basename||package.name),version:prompt('version','0.0.1'),description:prompt('description',''),main:prompt('entrypoint','index.js'),keywords:prompt(function(s){returns.split(/\\s+/)}),author:prompt('author','ruihuag<ruihuag@qq.com>(guanruihua.github.io)'),license:prompt('license','ISC'),repository:prompt('githubrepositoryurl','',function(url){if(url){run('touchREADME.md')run('gitinit')run('gitaddREADME.md')run('gitcommit-m\"firstcommit\"')run(`gitremoteaddorigin${url}`)run('gitpush-uoriginmaster')}returnurl}),}```package.json文件：```json{\"name\":\"Customnpminit\",\"version\":\"0.0.0\",\"decription\":\"Atestproject,todemonstrateacustomnpminitscript.\",\"main\":\"index.js\",\"keywords\":[],\"author\":\"ruihuag<ruihuag@qq.com>(guanruihua.github.io)\",\"license\":\"ISC\",\"repository\":{\"type\":\"git\",\"url\":\"git+<https://github.com/JoeBloggs/custom.git>\"},\"bugs\":{\"url\":\"https://github.com/JoeBloggs/custom/issues\"},\"homepage\":\"https://github.com/JoeBloggs/custom#readme\"}```","Front-End\\包管理器\\npm\\命令\\version.md":"#version##查看包历史版本```shell#查看包全部包历史版本npmv[package-name]versions#查看包最新版本npmv[package-name]version```##version-`npmversion[<newversion>|major|minor|patch|premajor|preminor|prepatch|prerelease|from-git]`-版本控制-major：主版本号（大版本）(3.1.0-->4.0.0)-premajor：预备主版本(1.1.0-0变为2.0.0-0)-minor：次版本号（小更新）(2.0.1变为2.1.0)-preminor:预备次版本(1.0.2-0变为1.1.0-0)-patch：补丁号（补丁）(2.0.0-0变为2.0.0/2.0.0变为2.0.1)-prepatch：预备补丁版本(1.0.1-1变为1.0.2-0)-prerelease：预发布版本```shellnpmversionpatch//1.0.1表示小的bug修复npmversionminor//1.1.0表示新增一些小功能npmversionmajor//2.0.0表示大的版本或大升级npmversionpreminor//1.1.0-0后面多了个0，表示预发布```##`npmversino````shellnpmversion{npm:'6.14.10',ares:'1.18.1',brotli:'1.0.9',cldr:'40.0',icu:'70.1',llhttp:'6.0.4',modules:'93',napi:'8',nghttp2:'1.45.1',nghttp3:'0.1.0-DEV',ngtcp2:'0.1.0-DEV',node:'16.14.0',openssl:'1.1.1m+quic',tz:'2021a3',unicode:'14.0',uv:'1.43.0',v8:'9.4.146.24-node.20',zlib:'1.2.11'}```","Front-End\\包管理器\\npm\\命令\\命令.md":"#命令##收藏包>`npmstar[package-name]`>用于收藏包```shell#收藏包npmstar[package-name]#取消收藏npmunstar[package-name]#查看收藏列表npmstars```##查看包文档```shell#此命令会尝试猜测包文档URL的可能位置，一般没有自定义的话，就会打开包的github地址。npmdocs[package-name]#ornpmhome[package-name].#打开当前项目文档npmdocs/home```>若不接受参数,默认打开`package.json`汇总的`homepage`配置##查看包仓库>打开`package.json`配置的`repository`的url```shell#此命令尝试猜测包的存储库URL的可能位置npmrepo[package-name]```##给包提issues>打开`package.json`配置的`bugs`的url```shellnpmbugs[package-name]```##查看包信息>包括作者信息等```shellnpmv[package-name]#ornpmview[package-name]npminfo[package-name]npmshow[package-name]```##查看当前项目哪些包过时```shellnpmoutdated```##查看本地全局环境有哪些包过时```shellnpmoutdated-g--depth=0```##审计项目中所有包的安全漏洞```shellnpmaudit#这个命令依赖package-lock.json文件,所以如果你用的是yarn需要使用下面的命令yarnauditpnpmaudit```##给出问题的严重性```shellnpmtokenlist```##检测镜像延迟```shellnpmping```##检测node和npm问题```shellnpmdoctor```","Front-End\\包管理器\\npm\\快速删除文件.md":"#快速删除文件>安装`npminstallrimraf-g`>>删除`rimraf[文件名]`","Front-End\\包管理器\\npm\\运行其他目录script.md":"#[`运行其他目录script`]()>运行指定目录的`package.json`脚本```bashnpmstart--prefixpath/to/your/app```","Front-End\\包管理器\\nrm.md":"#nrm##安装```shellnpminstall-gnrm```##命令###查看可选源```shellnrmls*npm----https://registry.npmjs.org/cnpm---http://r.cnpmjs.org/taobao-http://registry.npm.taobao.org/eu-----http://registry.npmjs.eu/au-----http://registry.npmjs.org.au/sl-----http://npm.strongloop.com/nj-----https://registry.nodejitsu.com/```###切换```shellnrmusetaobao```###添加源```shellnrmadd<registry>nrmaddregistryhttp://registry.npm.frp.trmap.cn/```###删除源```shellnrmdel<registry>```###测试源的响应时间```shellnrmtestnpm```","Front-End\\包管理器\\package\\author.md":"#author>项目作者>表示该项目包的作者##字符串```json{\"author\":\"ruihuag\",//or\"author\":\"ruihuag<ruihuag@qq.com>(https://guanruihua.github.io)\"}```##对象形式```json{\"author\":{\"name\":\"CUGGZ\",\"email\":\"xxxxx@xx.com\",\"url\":\"https://juejin.cn/user/3544481220801815\"}}```","Front-End\\包管理器\\package\\bugs.md":"#bugs>项目`bugs`反馈地址,通常`githubissue`页面的链接```json{\"bugs\":\"https://github.com/vuejs/core/issues\"}```","Front-End\\包管理器\\package\\contributors.md":"#contributors>表示该项目包的贡献者，和author不同的是，该字段是一个数组，包含所有的贡献者，它同样有两种写法：```json{\"contributors\":[\"ruihuag0<ruihuag@qq.com>(https://guanruihua.github.io)\",\"ruihuag1<ruihuag@qq.com>(https://guanruihua.github.io)\"],//or\"contributors\":[{\"name\":\"ruihuag0\",\"email\":\"ruihuag@qq.com\",\"url\":\"https://guanruihua.github.io\"},{\"name\":\"ruihuag1\",\"email\":\"ruihuag@qq.com\",\"url\":\"https://guanruihua.github.io\"}]}```","Front-End\\包管理器\\package\\description.md":"#description>1.项目描述>2.展示在npm官网```json{\"description\":\"ReactisaJavaScriptlibraryforbuildinguserinterfaces.\"}```","Front-End\\包管理器\\package\\homepage.md":"#homepage>项目官网/文档首页>通常是项目`github`链接```json{\"homepage\":\"https://reactjs.org/\"}```","Front-End\\包管理器\\package\\index.md":"#package.json##初始化>配置`npminit`的默认字段```shellnpmconfigsetinit.author.name\"ruihuag\"npmconfigsetinit.author.email\"2116047353@qq.com\"npmconfigsetinit.author.url\"https://github.com/guanruihua\"npmconfigsetinit.license\"MIT\"```>查看配置文件信息:`npmconfigedit`>查看全局配置文件信息:`npmconfig--globaledit`","Front-End\\包管理器\\package\\keywords.md":"#keywords>项目关键词```json//Antd组件库{\"keywords\":[\"ant\",\"component\",\"components\",\"design\",\"framework\",\"frontend\",\"react\",\"react-component\",\"ui\"]}```keywords字段是一个字符串数组，表示这个项目包的关键词。和description一样，都是用来增加项目包的曝光率的。下面是eslint包的描述和关键词：![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ade17781b5104432a6f13eec9a4411ad~tplv-k3u1fbpfcp-watermark.awebp)","Front-End\\包管理器\\package\\license.md":"#license>-项目的开源许可证>-指定项目的版权拥有人可以使用开源许可证来限制源码的使用、复制、修改和再发布等行为>-常见的开源许可证有BSD、MIT、Apache等![](./.assets/license-2022-11-12-14-10-42.png)```json{\"license\":\"MIT\"}```","Front-End\\包管理器\\package\\name.md":"#name>1.项目的名称>2.如果是第三方包的话，其他人可以通过该名称使用`npminstall[name]`进行安装给name字段命名时，需要注意以下几点：-名称的长度必须小于或等于214个字符，不能以“.”和“\\_”开头，不能包含大写字母（这是因为当软件包在npm上发布时，会基于此属性获得自己的URL，所以不能包含非URL安全字符（non-url-safe））；-名称可以作为参数被传入`require(\"\")`，用来导入模块，所以应当尽可能的简短、语义化；-名称不能和其他模块的名称重复，可以使用`npmview`命令查询模块明是否重复，如果不重复就会提示404：![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a19278d60f5a4edbaab907273a7e3a90~tplv-k3u1fbpfcp-watermark.awebp)如果npm包上有对应的包，则会显示包的详细信息：![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/143f24d9f95c4c1e97b90fabe4171536~tplv-k3u1fbpfcp-watermark.awebp)实际上，我们平时开发的很多项目并不会发布在npm上，所以这个名称是否标准可能就不是那么重要，它不会影响项目的正常运行。如果需要发布在npm上，name字段一定要符合要求。","Front-End\\包管理器\\package\\repository.md":"#repository>项目的仓库控制地址以及版本控制信息```json{\"repository\":\"https://github.com/facebook/react.git\",//or\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/facebook/react.git\",\"directory\":\"packages/react\"}}```","Front-End\\包管理器\\package\\version.md":"#version>版本管理>与`name`构成项目唯一标识符>版本管理标准[semver](https://semver.org/)![](./.assets/version-2022-11-12-13-36-07.png)1.主版本号`Major`，通常在涉及重大功能更新，产生了破坏性变更时会更新此版本号2.次版本号`Minor`，在引入了新功能，但未产生破坏性变更，依然向下兼容时会更新此版本号3.修订号`Patch`，在修复了一些问题，也未产生破坏性变更时会更新此版本号4.`Pre-release`和`Metadata`来描述项目的测试版本-如果某个版本的改动较大，并且不稳定，可能如法满足预期的兼容性需求，就需要发布先行版本，先行版本通过会加在版本号的后面，通过“-”号连接以点分隔的标识符和版本编译信息：内部版本（alpha）、公测版本（beta）和候选版本（rc，即releasecandiate）##查看版本可以通过以下命令来查看npm包的版本信息，以react为例：```javascript//查看最新版本npmviewreactversion//查看所有版本npmviewreactversions```当执行第二条命令时，结果如下：![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691978ac852647c18af70b3208ed32c3~tplv-k3u1fbpfcp-watermark.awebp)##package文件-node项目中使用到的相关依赖和依赖的版本号-在package.json的依赖中，版本号使用的是semver版本表示法，即“主版本.次版本.补丁版本”的格式，版本号的递增规则如下：-主版本号，一些不兼容的breakingchange-次版本号，能向下兼容，在不影响低版本的使用下可以新增和弃用一些api，但要确保向下兼容-补丁版本号，一些向下兼容的修正，一般都是对于一些缺陷的修复当发布新版本的时候，可不能随心所欲地增加数字，一定要遵循上述的规则，这是作为一个合格的项目所必备的基本条件。同时，npm也设置了一些规则，用于在运行np`mupdate的时候，为package.json中的依赖更新到尽可能新的版本号，你一定不陌生-`～`:只更新修订号，用于静默获取一些包中对于bug修复的最新版本-`^`:只执行不更新最左边非零数字版本号的更新。例如^0.1.0，可以更新到0.1.10.1.2等，但不会更新到0.2.0或更高版本；而1.0.0可以更新到1.0.1或1.1.0等，但不会更新到2.0.0或更高版本-`>`:只接受高于指定版本的任何版本-`≥`:只接受高于或等于指定版本的任何版本-`<`:只接受低于指定版本的任何版本-`≤`:只接受低于或等于指定版本的任何版本-`=`:接受确切版本-`-`:接受一定范围的版本，如：`2.1.0-2.6.2`-`||`:组合集合，如：`<2.1||>2.6`-`latest`:使用可用的最新版本-无符号，等同于`=`##packagelock文件-在npm5版本中，引入了package-lock.json文件-其它的包管理工具也有其对应的lock文件，如yarn的yarn.lock、pnpm的pnpm-lock.yaml-package-lock.json文件相比package.json文件-不仅可以跟踪项目中使用到的npm包-还能跟踪每个npm包的确切版本-以确保产品可以拥有完整且相同的node_modules树，产品的表现形式一致-正如上述关于package.json依赖工作的描述，package.json一直都存在着一个比较尴尬的问题，即在运行npmupdate或者npminstall的时候，会尽可能地安装最新的依赖，如果虽然补丁版本和次版本不应该引入重大的更改，但并不是所有的开源项目的作者都是遵守semver规则（我相信有些人可能都还不知道这东东），免不了的，还是有可能会产生bug。那如果在服务器的ci服务器，每次都是先npminstall安装依赖再执行打包构建的时候，不就有可能会产生问题了吗？这里就不得不先提一下npmci这个命令了，npmci跟npminstall不同。看到ci，也应该能想到持续集成中的这个ci。没错啦，这个就是专门用于CI/CD中的安装依赖操作。npmci相比npminstall命令，有几个特点：npm版本要≥v5.7.1-不会更改package.json、package-lock.json文件-执行的之前如果存在node_modules，会先将之删除-优先依赖于package-lock.json或npm-shrinkwrap.json文件安装依赖-如果在以上两个文件中的依赖在package.json中找不到，就抛错退出执行这些特性确保了相同的lock文件能拥有相同的依赖环境，避免在构建的时候出现与开发时环境不一致的情况。","Front-End\\包管理器\\package\\依赖配置\\bundleDependencies.md":"#[`bundleDependencies`]()>打包依赖。它的值是一个数组，在发布包时，bundleDependencies里面的依赖都会被一起打包>比如指定react和react-dom为打包依赖：```json{\"bundleDependencies\":[\"react\",\"react-dom\"]}```>在执行npmpack打包生成tgz压缩包中，将出现`node_modules`并包含react和react-dom。>>需要注意的是，这个字段数组中的值必须是在`dependencies`，`devDependencies`两个里面声明过的依赖才行。>>普通依赖通常从npmregistry安装，但当你想用一个不在npmregistry里的包，或者一个被修改过的第三方包时，打包依赖会比普通依赖更好用","Front-End\\包管理器\\package\\依赖配置\\dependencies.md":"#[`dependencies`]()CUGGZ>-运行依赖，也就是项目生产环境下需要用到的依赖。比如react，vue，状态管理库以及组件库等>-使用`npminstallxxx`或则`npminstallxxx--save`时，会被自动插入到该字段中```json{\"dependencies\":{\"react\":\"^18.2.0\",\"react-dom\":\"^18.2.0\"}}```","Front-End\\包管理器\\package\\依赖配置\\devDependencies.md":"#[`devDependencies`]()>-开发依赖，项目开发环境需要用到而运行时不需要的依赖，用于辅助开发，通常包括项目工程化工具比如`webpack`，`vite`，`eslint`等。>-使用`npminstallxxx-D`或者`npminstallxxx--save-dev`时，会被自动插入到该字段中。```json{\"devDependencies\":{\"webpack\":\"^5.69.0\"}}```","Front-End\\包管理器\\package\\依赖配置\\index.md":"#依赖配置>项目依赖其他包,在`package.json`里配置这些信息","Front-End\\包管理器\\package\\依赖配置\\optionalDependencies.md":"#[`optionalDependencies`]()>-可选依赖，顾名思义，表示依赖是可选的，它不会阻塞主功能的使用，安装或者引入失败也无妨>-这类依赖如果安装失败，那么npm的整个安装过程也是成功的>-比如我们使用`colors`这个包来对`console.log`打印的信息进行着色来增强和区分提示，但它并不是必需的,所以可以将其加入到`optionalDependencies`，并且在运行时处理引入失败的逻辑使用`npminstallxxx-O`或者`npminstallxxx--save-optional`时，依赖会被自动插入到该字段中```json{\"optionalDependencies\":{\"colors\":\"^1.4.0\"}}```","Front-End\\包管理器\\package\\依赖配置\\overrides.md":"#[`overrides`]()>overrides可以重写项目依赖的依赖，及其依赖树下某个依赖的版本号，进行包的替换。比如某个依赖A，由于一些原因它依赖的包foo@1.0.0需要替换，我们可以使用overrides修改foo的版本号：```json{\"overrides\":{\"foo\":\"1.1.0-patch\"}}```当然这样会更改整个依赖树里的foo，我们可以只对A下的foo进行版本号重写：```json{\"overrides\":{\"A\":{\"foo\":\"1.1.0-patch\"}}}```>`overrides`支持任意深度的嵌套。>>如果在yarn里也想复写依赖版本号，需要使用resolution字段，而在pnpm里复写版本号需要使用pnpm.`overrides`字段。","Front-End\\包管理器\\package\\依赖配置\\peerDependencies.md":"#[`peerDependencies`]()>-同伴依赖，一种特殊的依赖，不会被自动安装，通常用于表示与另一个包的依赖与兼容性关系来警示使用者>-比如我们安装A，A的正常使用依赖B@2.x版本，那么B@2.x就应该被列在A的peerDependencies下，表示“如果你使用我，那么你也需要安装B，并且至少是2.x版本”比如React组件库AntDesign，它的package.json里peerDependencies为```json{\"peerDependencies\":{\"react\":\">=16.9.0\",\"react-dom\":\">=16.9.0\"}}```表示如果你使用AntDesign，那么你的项目也应该安装react和react-dom，并且版本需要大于等于16.9.0。","Front-End\\包管理器\\package\\依赖配置\\peerDependenciesMeta.md":"#[`peerDependenciesMeta`]()>同伴依赖也可以使用`peerDependenciesMeta`将其指定为可选的```json{\"peerDependencies\":{\"colors\":\"^1.4.0\"},\"peerDependenciesMeta\":{\"colors\":{\"optional\":true}}}```","Front-End\\包管理器\\package\\发布配置\\index.md":"#发布配置>项目发布配置","Front-End\\包管理器\\package\\发布配置\\preferGlobal.md":"#preferGlobal>表示当用户不把该模块安装为全局模块时，如果设置为true就会显示警告。它并不会真正的防止用户进行局部的安装，只是对用户进行提示，防止产生误解：```json{\"preferGlobal\":true}```","Front-End\\包管理器\\package\\发布配置\\private.md":"#[`private`]()>如果是私有项目，不希望发布到公共npm仓库上，可以将private设为true```json{\"private\":true}```","Front-End\\包管理器\\package\\发布配置\\publishConfig.md":"#[`publishConfig`]()>publishConfig就是npm包发布时使用的配置。比如在安装依赖时指定了registry为taobao镜像源，但发布时希望在公网发布，就可以指定publishConfig.registry。```json{\"publishConfig\":{\"registry\":\"https://registry.npmjs.org/\"}}```","Front-End\\包管理器\\package\\文件配置\\files.md":"#files-项目在进行`npm`发布时，可以通过`files`指定需要跟随一起发布的内容来控制`npm`包的大小，避免安装时间太长-发布时默认会包括`package.json`，`license`，`README`和`main`字段里指定的文件。忽略`node_modules`，`lockfile`等文件-在此基础上，我们可以指定更多需要一起发布的内容。可以是单独的文件，整个文件夹，或者使用通配符匹配到的文件-一般情况下，`files`里会指定构建出来的产物以及类型文件，而`src`，`test`等目录下的文件不需要跟随发布```json{\"files\":[\"filename.js\",\"directory/\",\"glob/*.{js,json}\"]}```","Front-End\\包管理器\\package\\文件配置\\index.md":"#文件配置>包含项目所包含的文件,以及入口配置文件等信息","Front-End\\包管理器\\package\\文件配置\\type.md":"#type-在node支持ES模块后，要求ES模块采用.mjs后缀文件名-只要遇到.mjs文件，就认为它是ES模块-如果不想修改文件后缀，就可以在`package.json`文件中，指定`type`字段为`module````js\"type\":\"module\"```复制代码这样所有.js后缀的文件，node都会用ES模块解释。```js//使用ES模块规范nodeindex.js```如果还要使用CommonJS模块规范，那么需要将CommonJS脚本的后缀名都改成.cjs，不过两种模块规范最好不要混用，会产生异常报错。","Front-End\\包管理器\\package\\文件配置\\workspaces.md":"#workspaces>项目的工作区配置，用于在本地的根目录下管理多个子项目>可以自动地在`npminstall`时将`workspaces`下面的包，软链到根目录的`node_modules`中，不用手动执行`npmlink`操作>>workspaces字段接收一个数组，数组里可以是文件夹名称或者通配符。比如：```json{\"workspaces\":[\"workspace-a\"]}```表示在workspace-a目录下还有一个项目，它也有自己的package.json。`package.json`workspace-a└──package.json>通常子项目都会平铺管理在packages目录下，所以根目录下workspaces通常配置为：```json{\"workspaces\":[\"packages/*\"]}```","Front-End\\包管理器\\package\\文件配置\\入口文件.md":"#入口文件```json{\"main\":\"./index.js\",\"browser\":\"./browser/index.js\",\"module\":\"./index.mjs\"}```##main-项目发布时，默认会包括`package.json`，`license`，`README`和`main`字段里指定的文件，因为main字段里-指定的是项目的入口文件，在browser和Node环境中都可以使用-如果不设置main字段，那么入口文件就是根目录下的`index.js`-比如packageA的main字段指定为`index.js````json{\"main\":\"./index.js\"}```>引入packageA时，实际上引入的就是node_modules/packageA/index.js。>这是早期只有CommonJS模块规范时，指定项目入口的唯一属性。##browser>-`main`字段里指定的入口文件在browser和Node环境中都可以使用>-如果只想在web端使用，不允许在server端使用，可以通过browser字段指定入口```json{\"browser\":\"./browser/index.js\"}```##module>同样，项目也可以指定ES模块的入口文件，这就是module字段的作用```json{\"module\":\"./index.mjs\"}```##webpack构建项目比如`webpack`构建项目时默认的`target`为`web`，也就是`Web`构建。它的`resolve.mainFeilds`字段默认为`['browser','module','main']````jsmodule.exports={resolve:{//此时会按照browser->module->main的顺序来查找入口文件。mainFields:['browser','module','main'],},}```##exports>node在14.13支持在package.json里定义exports字段，拥有了条件导出的功能。>exports字段可以配置不同环境对应的模块入口文件，并且当它存在时，它的优先级最高。比如使用require和import字段根据模块规范分别定义入口：```json{\"exports\":{\"require\":\"./index.js\",\"import\":\"./index.mjs\"}}```>这样的配置在使用import'xxx'和require('xxx')时会从不同的入口引入文件，exports也支持使用browser和node字段定义browser和Node环境中的入口。>上方的写法其实等同于：```json{\"exports\":{\".\":{\"require\":\"./index.js\",\"import\":\"./index.mjs\"}}}```为什么要加一个层级，把require和import放在\".\"下面呢？因为exports除了支持配置包的默认导出，还支持配置包的子路径。比如一些第三方UI包需要引入对应的样式文件才能正常使用。`importpackageA/dist/css/index.css`;我们可以使用exports来封装文件路径：```json{\"exports\":{\"./style\":\"./dist/css/index.css'}}```用户引入时只需：`importpackageA/style;`除了对导出的文件路径进行封装，exports还限制了使用者不可以访问未在\"exports\"中定义的任何其他路径。-比如发布的`dist`文件里有一些内部模块`dist/internal/module`，被用户单独引入使用的话可能会导致主模块不可用。为了限制外部的使用，我们可以不在exports定义这些模块的路径，这样外部引入packageA/`dist/internal/module`模块的话就会报错结合上面入口文件配置的知识，再来看看下方vite官网推荐的第三方库入口文件的定义![](./.assets/入口文件-2022-11-12-17-39-33.png)","Front-End\\包管理器\\package\\第三方配置\\babel.md":"#babel>用来指定Babel的编译配置，代码如下：```javascript\"babel\":{\"presets\":[\"@babel/preset-env\"],\"plugins\":[...]}```","Front-End\\包管理器\\package\\第三方配置\\browserslist.md":"#[`browserslist`]()>-设置项目的浏览器兼容情况>-`babel`和`autoprefixer`等工具会使用该配置对代码进行转换。当然你也可以使用`.browserslistrc`单文件配置```json{\"browserslist\":[\">1%\",\"last2versions\"]}``````json{\"browserslist\":{\"production\":[\">0.2%\",\"notdead\",\"notop_miniall\"],\"development\":[\"last1chromeversion\",\"last1firefoxversion\",\"last1safariversion\"]}}```","Front-End\\包管理器\\package\\第三方配置\\CDN服务.md":"#[`CDN服务`]()>可以让npm上的文件都开启CDN服务##unpkg>访问unpkg.com/vue会重定向到`unpkg.com/vue@3.2.37/…3.2.27`是Vue的最新版本```json{\"unpkg\":\"dist/vue.global.js\"}```##jsdelivr>[jsDelivr-Afree,fast,andreliableCDNforopensource](https://www.jsdelivr.com/)>访问`cdn.jsdelivr.net/npm/vue`实际上获取到的是jsdelivr字段里配置的文件地址```json{\"jsdelivr\":\"dist/vue.global.js\"}```","Front-End\\包管理器\\package\\第三方配置\\eslintConfig.md":"#eslintConfig>eslint的配置可以写在单独的配置文件`.eslintrc.json`中，也可以写在package.json文件的eslintConfig配置项中```json{\"eslintConfig\":{\"root\":true,\"env\":{\"node\":true},\"extends\":[\"plugin:vue/essential\",\"eslint:recommended\"],\"rules\":{},\"parserOptions\":{\"parser\":\"babel-eslint\"}}}```","Front-End\\包管理器\\package\\第三方配置\\index.md":"#第三方配置>一些第三方库或应用在进行某些内部处理时会依赖这些字段，使用它们时需要安装对应的第三方库","Front-End\\包管理器\\package\\第三方配置\\lint-staged.md":"#[`lint-staged`]()>`lint-staged`是用于对git的暂存区的文件进行操作的工具，比如可以在代码提交前执行lint校验，类型检查，图片优化等操作```json{\"lint-staged\":{\"src/**/*.{js,jsx,ts,tsx}\":[\"eslint--fix\",\"gitadd-A\"]}}```>`lint-staged`通常配合`husky`这样的`git-hooks`工具一起使用>`git-hooks`用来定义一个钩子，这些钩子方法会在git工作流程中比如`pre-commit`，`commit-msg`时触发，可以把`lint-staged`放到这些钩子方法中","Front-End\\包管理器\\package\\第三方配置\\sideEffects.md":"#[`sideEffects`]()-显示设置某些模块具有副作用，用于webpack的tree-shaking优化-比如在项目中整体引入AntDesign组件库的css文件`import'antd/dist/antd.css';//or'antd/dist/antd.less'`-如果AntDesign的package.json里不设置sideEffects，那么webpack构建打包时会认为这段代码只是引入了但并没有使用，可以tree-shaking剔除掉，最终导致产物缺少样式-所以AntDesign在package.json里设置了如下的sideEffects，来告知webpack，这些文件具有副作用，引入后不能被删除```json{\"sideEffects\":[\"dist/*\",\"es/**/style/*\",\"lib/**/style/*\",\"*.less\"]}```","Front-End\\包管理器\\package\\第三方配置\\types&typings.md":"#[`types&typings`]()>指定`Typescript`的类型定义的入口文件```json{\"types\":\"./index.d.ts\",//or\"typeings\":\"./index.d.ts\"}```","Front-End\\包管理器\\package\\系统配置\\cpu.md":"#[`cpu`]()>指定项目只能在特定的CPU体系上运行```json{\"cpu\":[\"x64\",\"ia32\"]}```","Front-End\\包管理器\\package\\系统配置\\engines.md":"#[`engines`]()一些项目由于兼容性问题会对node或者包管理器有特定的版本号要求，比如：```json{\"engines\":{\"node\":\">=14<16\",\"pnpm\":\">7\"}}```>要求node版本大于等于14且小于16，同时pnpm版本号需要大于7","Front-End\\包管理器\\package\\系统配置\\index.md":"#系统配置>-和项目关联的系统配置，比如node版本或操作系统兼容性之类>-这些要求只会起到提示警告的作用，即使用户的环境不符合要求，也不影响安装依赖包","Front-End\\包管理器\\package\\系统配置\\os.md":"#[`os`]()在linux上能正常运行的项目可能在windows上会出现异常，使用os字段可以指定项目对操作系统的兼容性要求。```json{\"os\":[\"darwin\",\"linux\"]}```","Front-End\\包管理器\\package\\脚本配置\\config.md":"#config>config用于设置scripts里的脚本在运行时的参数。比如设置port为3001：```json{\"config\":{\"port\":\"3001\"}}```>在执行脚本时，我们可以通过npm_package_config_port这个变量访问到3001。```jsconsole.log(process.env.npm_package_config_port)//3001```","Front-End\\包管理器\\package\\脚本配置\\script.md":"#Script>脚本##列出可运行脚本>`npmi-gntl`>到对应的目录下运行`npmrun`##并行运行脚本>`&&`符号依次运行多个脚本>`并行运行脚本`:[concurrently](https://www.npmjs.com/package/concurrently)```json{\"start\":\"concurrently\\\"command1arg\\\"\\\"command2arg\\\"\"}```###延迟运行脚本直到端口准备就绪```json\"dev\":\"concurrently\\\"cross-envBROWSER=nonenpmrunstart\\\"\\\"wait-onhttp://localhost:3000&&electron.\\\"\"```>`wait-on`:只有在`http://localhost:3000`启动好,才打开electron窗口>React默认情况下会打开一个浏览器窗口，但对于Electron开发来说，这是不必要的。咱们可以通过传递环境变量BROWSER=none来禁用此行为##不同目录运行脚本```shell#手动打开到对应目录cdfolder&&npmstart&&cd..#使用prefixnpmstart--prefixpath/to/your/folder``````json{\"start\":\"concurrently\\\"(npmstart--prefixclient)\\\"\\\"(npmstart--prefixserver)\\\"\"}```##脚本跨平台>`cross-env`>`npmi-Dcross-env````json{\"scripts\":{\"build\":\"cross-envNODE_ENV=productionwebpack--configbuild/webpack.config.js\"}}```","Front-End\\包管理器\\pnpm install 失败.md":"#[`pnpminstall失败`](/)运行`pnpminstall`,安装依赖失败##配置.npmrc文件```js@types:registry=https//registry.npmjs.org/```","Front-End\\包管理器\\pnpm+monorepo.md":"#[`pnpm+monorepo`](/)##容器(root)安装模块```shellpnpmadd<package-name>-w```##运行子模块命令```shellpnpmrun--filterpackage1start```##在子模块安装包```shellpnpmadd<module-name>-W--filter<package-name>`#egpnpmaddlodash-W--filterpackage1```##卸载子模块的包```shellpnpmremove<module-name>--filter<package-name>#egpnpmremovelodash--filterpackage1```","Front-End\\包管理器\\使用script命令触发bat命令.md":"#[`使用script命令触发bat命令`]()>-路径写法和node脚本不一致>-要正常可以通过路径可以触发的```jsonc{...\"script\":{...//根目录下的bat\"one\":\"one.bat\",//放在script文件夹\"two\":\".\\\\script\\\\one.bat\",...}...}```","Front-End\\可视化\\canvas\\canvas.md":"#canvas>[CanvasAPI](https://www.canvasapi.cn/CanvasRenderingContext2D/arc#&introduction)>[Canvas-WebAPI接口参考|MDN(mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API)>>-用于绘制图像,通常用javascript绘制##canvas基本使用###canvas表示使用```html<canvaswidth=\"300\"height=\"150\">不支持canvas标签会显示该内容</canvas>```###canvas方法检查支持性```jsvarcanvas=document.getElementById('target')if(canvas.getContext){varctx=canvas.getContext('2d')}else{console.log('该浏览器版本过低,请更换')}```##样式添加```jsfillStyle=colorstrokeStyle=color//color可以为颜色值、渐变对象(并非样式！！！！)lineWidth=value线宽lineCap=type（butt、round、square）线条末端样式依次是方形、圆形&突出、方形&突出```![canvas8](https://user-gold-cdn.xitu.io/2018/11/26/1674efc200a1fb4e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)```lineJoin=type（round、bevel、miter）线条交汇处样式依次是圆形、平角、三角形```![canvas9](https://user-gold-cdn.xitu.io/2018/11/26/1674efc203135b97?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)```ctx.setLineDash([实际长度,间隙长度])//虚线setLineDash接受数组ctx.lineDashOffet//设置偏移量```###渐变```vargradient=ctx.createLinearGradient(x1,y1,x2,y2);//线性渐变vargradient=ctx.createRadialGradient(x1,y1,r1,x2,y2,r2);//径向渐变gradient.addColorStop(position,color)//position:相对位置0~1color:该位置下的颜色```###透明度```ctx.globalAlpha=value(0~1)```##文本```fillText(text,x,y,[,maxWidth])在(x,y)位置绘制text文本最大宽度为maxWidth(可选)strokeText(text,x,y,[,maxWidth])在(x,y)位置绘制text文本边框最大宽度为maxWidth(可选)font=valueeg:\"100pxsans-serif\"```##绘制图片```drawImage(image,x,y,width,height)image为图片对象、从(x,y)处放置宽高分别为widthheight的图片drawImage(image,sx,sy,swidth,sheight,dx,dy,dwidth,dheight)切片前四个是定义图像源的切片位置和大小后四个是定期切片的目标显示位置大小```##动作```translate(x,y)将canvas原点的移动到(x,y)（save&restore保存初始状态！！！）rotate(angle)顺时针方向旋转坐标轴angle弧度scale(x,y)将图形横向缩放x倍、纵向缩放y倍（x、y大于1是放大小于1为缩放！！！）```##全局合成操作globalCompositeOperation=type;source-over<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc2202ba9d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas11\"style=\"zoom:50%;\"/>source-in<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc231836ca4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas12\"style=\"zoom:50%;\"/>source-out<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc230f9efee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas13\"style=\"zoom:50%;\"/>source-atop<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc22fd95ad9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas14\"style=\"zoom:50%;\"/>destination-over<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc24023b46d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas15\"style=\"zoom:50%;\"/>destination-in<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc24bb0268a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas16\"style=\"zoom:50%;\"/>destination-out<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc257a9972a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas17\"style=\"zoom:50%;\"/>destination-atop<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc257bf9efd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas18\"style=\"zoom:50%;\"/>xor<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc27398ea8a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas19\"style=\"zoom:50%;\"/>copy<imgsrc=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc272df1d1e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"alt=\"canvas20\"style=\"zoom:50%;\"/>##裁剪```clip//只显示裁剪区域内部区域(使用save&restore存储canvas状态！！！)```##动画```clearRect()清空画布save&restore保存恢复canvas状态```##定时执行-setInterval()-setTimeout()-requestAnimationFrame()","Front-End\\可视化\\canvas\\Demo\\canvas转图片下载.md":"#Canvas转图片并下载>临时保存,后面再记录```html<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"/><metahttp-equiv=\"X-UA-Compatible\"content=\"IE=edge\"/><metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\"/><linkrel=\"stylesheet\"href=\"https://cdn.jsdelivr.net/npm/rh-static@0.0.1/css/test-body.css\"/><title>index</title></head><style></style><body><canvasid=\"canvas\"></canvas><buttonclass=\"button-balanced\"id=\"save\"onclick=\"btnClick()\">save</button><br/><ahref=\"\"download=\"canvas_love.png\"id=\"save_href\"><imgsrc=\"\"id=\"save_img\"/></a><scriptsrc=\"https://cdn.jsdelivr.net/npm/rh-static@0.0.1/js/addWindowSize.js\"defer></script><script>varc=document.getElementById('canvas')functiondrawLove(canvas){letctx=canvas.getContext('2d')ctx.beginPath()ctx.fillStyle='#E992B9'ctx.moveTo(75,40)ctx.bezierCurveTo(75,37,70,25,50,25)ctx.bezierCurveTo(20,25,20,62.5,20,62.5)ctx.bezierCurveTo(20,80,40,102,75,120)ctx.bezierCurveTo(110,102,130,80,130,62.5)ctx.bezierCurveTo(130,62.5,130,25,100,25)ctx.bezierCurveTo(85,25,75,37,75,40)ctx.fill()}drawLove(c)functiondownLoad(url){varoA=document.createElement('a')oA.download=''//设置下载的文件名，默认是'下载'oA.href=urldocument.body.appendChild(oA)oA.click()oA.remove()//下载之后把创建的元素删除}varbutSave=document.getElementById('save')functionbtnClick(){varsvaeHref=document.getElementById('save_href')/**传入对应想要保存的图片格式的mime类型*常见：image/png，image/gif,image/jpg,image/jpeg*/varimg=document.getElementById('save_img')vartempSrc=canvas.toDataURL('image/png')console.log(tempSrc)svaeHref.href=tempSrcimg.src=tempSrc//location.href=tempSrcdownLoad(tempSrc)}</script></body></html>```","Front-End\\可视化\\canvas\\图片\\createImageData.md":"#createImageData>创建一个全新的空的ImageData对象。该对象中的所有像素信息都是透明黑```jscontext.createImageData(width,height)context.createImageData(imagedata)```返回值是ImageData对象，包含width，height和data这3个只读属性。参数具体含义如下：>`width{Number}`ImageData对象包含的width值。如果ImageData对象转换成图像，则此width也是最终图像呈现的宽度>`height{Number}`ImageData对象包含的height值。如果ImageData对象转换成图像，则此height也是最终图像呈现的高度>`imagedata{Object}`一个存在的ImageData对象，只会使用该ImageData对象中的width和height值，包含的像素信息会全部转换为透明黑```html<canvasid=\"canvas\"></canvas>``````js//绘制在Canvas上varcontext=canvas.getContext('2d')varimagedata=context.createImageData(300,150)//给对应坐标位置的数据设置色值为绿色for(varx=1;x<=300;x+=5){for(vary=1;y<=150;y+=5){varindex=4*((y-1)*300+(x-1))//变为绿色，色值依次是0,128,0,256imagedata.data[index]=0imagedata.data[index+1]=128imagedata.data[index+2]=0imagedata.data[index+3]=256}}//再重绘context.putImageData(imagedata,0,0)```![](/.assets/img/2022-02-15-11-09-10.png)>直接使用createImageData()方法创建一个图像，例如，所有位置是5的倍数的地方我们塞入一个绿色颜色值，这样可以得到一个点阵图效果","Front-End\\可视化\\canvas\\图片\\drawImage.md":"#drawImage```jscontext.drawImage(image,dx,dy)context.drawImage(image,dx,dy,dWidth,dHeight)context.drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)```>`image{Object}`:绘制在Canvas上的元素，可以是各类Canvas图片资源（见CanvasImageSource），如`<img>`图片，SVG图像，Canvas元素本身等>`dx{Number}`:在Canvas画布上规划一片区域用来放置图片，dx就是这片区域的左上角横坐标>`dy{Number}`:在Canvas画布上规划一片区域用来放置图片，dy就是这片区域的左上角纵坐标>`dWidth{Number}`:在Canvas画布上规划一片区域用来放置图片，dWidth就是这片区域的宽度>`dHeight{Number}`:在Canvas画布上规划一片区域用来放置图片，dHeight就是这片区域的高度>`sx{Number}`:表示图片元素绘制在Canvas画布上起始横坐标>`sy{Number}`:表示图片元素绘制在Canvas画布上起始纵坐标>`sWidth{Number}`:表示图片元素从坐标点开始算，多大的宽度内容绘制Canvas画布上>`sHeight{Number}`:表示图片元素从坐标点开始算，多大的高度内容绘制Canvas画布上`context.drawImage(image,0,0,300,150);`![](/.assets/img/2022-02-15-14-17-29.png)>原图:500\\*333,这样子设置会被压扁了些","Front-End\\可视化\\canvas\\图片\\index.md":"#图片##getImageData>`CanvasRenderingContext2D.getImageData()`返回一个`ImageData`对象，其中包含Canvas画布部分或完整的像素点信息>对图像进行像素级处理>`getImageData()`方法可能会出现CORS跨域报错`context.getImageData(sx,sy,sWidth,sHeight)`|参数|作用||:--------------|:---------------------------------||`sxNumbe`|需要返回的图像数据区域的起始横坐标||`syNumber`|需要返回的图像数据区域的起始纵坐标||`sWidthNumber`|需要返回的图像数据区域的宽度||`sHeightNumber`|需要返回的图像数据区域的高度|```html<canvasid=\"canvas\"width=\"250\"height=\"167\"></canvas>``````jsvarimg=newImage()img.onload=function(){varcontext=canvas.getContext('2d')//图片绘制context.drawImage(this,0,0,250,167)//然后获取中间100*100区域数据varimageData=context.getImageData(75,34,100,100)varlength=imageData.data.lengthfor(varindex=0;index<length;index+=4){varr=imageData.data[index]varg=imageData.data[index+1]varb=imageData.data[index+2]//计算灰度vargray=r*0.299+g*0.587+b*0.114imageData.data[index]=grayimageData.data[index+1]=grayimageData.data[index+2]=gray}//更新新数据context.putImageData(imageData,75,34)}img.src='./1.jpg'```![](./.assets/index-2022-03-29-15-49-12.png)","Front-End\\可视化\\canvas\\图片\\putImageData.md":"#putImageData>-将ImageData对象的数据绘制到位图上>-若提供举行,则仅绘制矩形的像素>-不受画布变换矩阵影响```jscontext.putImageData(imagedata,dx,dy)context.putImageData(imagedata,dx,dy,dirtyX,dirtyY,dirtyWidth,dirtyHeight)```|参数|类型|作用||:------------------|:-----|:--------------------------------------------------||imagedata|Object|包含图像像素信息的ImageData对象||dx|Number|目标Canvas中被图像数据替换的起点横坐标||dy|Number|目标Canvas中被图像数据替换的起点纵坐标||dirtyX（可选）|Number|图像数据渲染区域的左上角横坐标。默认值是0||dirtyY（可选）|Number|图像数据渲染区域的左上角纵坐标。默认值是0||dirtyWidth（可选）|Number|图像数据渲染区域的宽度。默认值是imagedata图像的宽度||dirtyHeight（可选）|Number|图像数据渲染区域的高度。默认值是imagedata图像的高度|>3类参数：>>-第1类:`imagedata`，就是用来替换当前已有的Canvas画布上的ImageData数据对象。>-第2类:`dx`，`dy`，这两个参数是作用在Canvas画布上的。imagedata你可以看成是一个即将贴在Canvas画布上“图片膏药”，究竟贴在什么位置呢？dx，dy参数就是告诉这个膏药，你的左上角位置就是这里。>-第3类:`dirtyX`,`dirtY`,`dirtyWidth`,`dirtyHeight`,表示矩形的坐标喝尺寸,这些参数是作用在`imageData`上,`imageData`所有数据都参与替换,同过这几个参数设置,让其中部分数据用来替换>>需要注意的是，其坐标系并没有发生任何变化。从效果表现上看，可以看成是脏矩形外面的像素被当做透明像素处理了。```html<imgid=\"image1\"src=\"./1.jpg\"alt=\"目标图片\"/><imgid=\"image2\"src=\"./1.jpg\"alt=\"数据源图片\"/><canvasid=\"canvas\"width=\"300\"height=\"200\"></canvas>``````js//尺寸varwidth=300,height=200//目标Canvas上下文varcontext=canvas.getContext('2d')//目标Canvas绘制context.drawImage(image1,0,0,width,height)//获取覆盖图数据vardirtyCanvas=document.createElement('canvas')vardirtyContext=dirtyCanvas.getContext('2d')//设置屏幕外Canvas尺寸dirtyCanvas.width=widthdirtyCanvas.height=height//绘制替换图dirtyContext.drawImage(image2,0,0,width,height)//此时可以得到imagedata数据varimagedata=dirtyContext.getImageData(0,0,width,height)//然后中间100*100区域替换目标Canvascontext.putImageData(imagedata,0,0,100,50,100,100)```","Front-End\\可视化\\canvas\\圆\\index.md":"#圆##圆弧&正圆###arc>`context.arc(x,y,radius,startAngle,endAngle[,anticlockwise]);`>>`x{Number}`:圆弧对应的圆心横坐标>`y{Number}`:圆弧对应的圆心纵坐标>`radius{Number}`:圆弧的半径大小。>`startAngle{Number}`:圆弧开始的角度，单位是弧度。>`endAngle{Number}`:圆弧结束的角度，单位是弧度。>`anticlockwise（可选）{Boolean}`:弧度的开始到结束的绘制是按照顺时针来算，还是按时逆时针来算。如何设置为`true`，则表示按照逆时针方向从`startAngle`绘制到`endAngle`。```js//顺时针绘制0到1/4弧度圆弧context.beginPath()context.arc(150,75,50,0,Math.PI/2)context.stroke()```![](/.assets/img/2022-02-15-10-04-26.png)###arcTo>-正圆圆弧,给路径添加圆弧>-根据两个控制点(x1,y1)和(x2,y2)以及半径绘制弧线同时连接两个控制点>`context.arcTo(x1,y1,x2,y2,radius);`>>`x1{Number}`:第1个控制点的横坐标>`y1{Number}`:第1个控制点的纵坐标>`x2{Number}`:第2个控制点的横坐标>`y2{Number}`:第2个控制点的纵坐标>`radius{Number}`:圆弧的半径大小```jscontext.beginPath()context.moveTo(50,50)context.arcTo(150,100,200,40,40)context.lineTo(200,40)context.stroke()```![](/.assets/img/2022-02-15-10-11-03.png)##椭圆>绘制椭圆>不支持IE浏览器,Edge13+支持>`context.ellipse(x,y,radiusX,radiusY,rotation,startAngle,endAngle,anticlockwise);`>`x{Number}`:椭圆弧对应的圆心横坐标>`y{Number}`:椭圆弧对应的圆心纵坐标>`radiusX{Number}`:椭圆弧的长轴半径大小>`radiusY{Number}`:椭圆弧的短轴半径大小>`rotation{Number}`:椭圆弧的旋转角度，单位是弧度>`startAngle{Number}`:圆弧开始的角度，角度从横轴开始算，单位是弧度>`endAngle{Number}`:圆弧结束的角度，单位是弧度>`anticlockwise（可选）{Boolean}`:弧度的开始到结束的绘制是按照顺时针来算，还是按时逆时针来算。如何设置为true，则表示按照逆时针方向从startAngle绘制到endAngle```js//绘制椭圆context.ellipse(150,75,80,40,Math.PI/4,0,2*Math.PI)context.stroke()```![](/.assets/img/2022-02-15-14-35-03.png)","Front-End\\可视化\\canvas\\基础Api\\index.md":"#基础Api##图案对象>创建图案对象,指定平铺方式,用来作为图案的类型>`context.createPattern(image,repetition)`>`returnCanvasPattern`>`imageObject`>>用来平铺的CanvasImageSource图像。可以是下面的类型：>>-HTMLImageElement，也就是`<img>`元素。>-HTMLVideoElement，也就是`<video>`元素，例如捕获摄像头视频产生的图像信息。>-HTMLCanvasElement>-CanvasRenderingContext2D>-ImageBitmap>-ImageData>-Blob>>`repetition``{String}`>图案的平铺方式，可以是下面的值：>>-`repeat`，水平和垂直平铺。当repetition属性值为空字符串''或者null，也会按照'repeat'进行渲染>-`repeat-x`，仅水平平铺>-`repeat-y`，仅垂直平铺>-`no-repeat`，不平铺```html<canvasid=\"canvas\"width=\"250\"height=\"167\"></canvas>``````js//先绘制图片varimg=newImage()img.onload=function(){//我们创建一个Canvas元素varcanvasCreated=document.createElement('canvas')canvasCreated.width=50canvasCreated.height=34canvasCreated.getContext('2d').drawImage(this,0,0,50,34)//页面上需要呈现最终纹理的Canvas上下文varcontext=canvas.getContext('2d')//创建纹理并填充，顺便测试null是否渲染为'repeat'varpattern=context.createPattern(canvasCreated,null)context.fillStyle=patterncontext.fillRect(0,0,250,167)}img.src='./1.jpg'```![](/.assets/img/2022-02-15-11-23-51.png)>图片缩小，并作为纹理显示。我们直接把`<img>`元素作为纹理图案是无法控制其尺寸的，我们可以将`<img>`元素绘制在大小可控的Canvas元素上，然后把这个Canvas元素作为图案进行平铺即可##剪裁>先绘制剪裁路径,执行`clip()`方法,在绘制内容,就在这个剪裁路径中呈现```jscontext.clip()context.clip(fillRule)context.clip(path,fillRule)```>`fillRule{String}`:填充规则。用来确定一个点实在路径内还是路径外。可选值包括：>>-`nonzero`：非零规则(默认)>-`evenodd`：奇偶规则。>>`pathObject`:指Path2D对象。```jsletcontext=canvas.getContext('2d')//需要图片先加载完毕letimg=newImage()img.onload=function(){//剪裁路径是三角形context.beginPath()context.moveTo(20,20)context.lineTo(200,80)context.lineTo(110,150)//剪裁context.clip()//填充图片context.drawImage(img,0,0,250,167)}img.src='./1.jpg'```![](/.assets/img/2022-02-15-10-50-54.png)>利用剪裁实现一个图案填充效果。实现图案填充，标准用法是创建一个Pattern对象，然后作为fillStyle进行路径填充。这里，我们还可以使用clip()剪裁实现，这样就不用new一个Pattern对象了。例如，实现一个三角形，里面是人物照片图案。##清除画布>`context.clearRect(x,y,width,height)`>`x{Number}`:矩形左上角x坐标>`y{Number}`:矩形左上角y坐标>`width{Number}`:被清除的矩形区域的高度>`height{Number}`:被清除的矩形区域的宽度度```js//先绘制图片varimg=newImage()img.onload=function(){context.drawImage(img,0,0,250,167)//中间开个方形的洞context.clearRect(50,50,100,66)}img.src='./1.jpg'```![](/.assets/img/2022-02-15-10-41-05.png)>先把一张图片绘制在Canvas画布上，然后再把中间一块矩形区域的像素信息清除##渐变###渐变对象>创建渐变对象>`context.createLinearGradient(x0,y0,x1,y1);`>`x0{Number}`:渐变起始点横坐标>`y0{Number}`:渐变起始点纵坐标>`x1{Number}`:渐变结束点横坐标>`y1{Number}`:渐变结束点纵坐标>线性渐变效果比较好脑补，就是从坐标点[x0,y0]到坐标点[x1,y1]的位置画一条线，然后整个渐变色带与与这条线垂直```jsvarcontext=canvas.getContext('2d')//创建渐变vargradient=context.createLinearGradient(0,0,300,0)gradient.addColorStop(0,'red')gradient.addColorStop(1,'green')//设置填充样式为渐变context.fillStyle=gradient//左上角和右下角分别填充2个矩形context.fillRect(10,10,160,60)context.fillRect(120,80,160,60)```![](/.assets/img/2022-02-15-11-15-04.png)###径向渐变>创建径向渐变>不同于CSS3的径向渐变,Canvas中径向渐变的起始点由两个圆环坐标构成>`context.createRadialGradient(x0,y0,r0,x1,y1,r1)`>`returnCanvasPattern对象`>`x0{Number}`:起始圆的横坐标>`y0{Number}`:起始圆的纵坐标>`r0{Number}`:起始圆的半径>`x1{Number}`:结束圆的横坐标>`y1{Number}`:结束圆的纵坐标>`r1{Number}`:结束圆的半径####标准径向渐变>看似标准两色径向渐变的实现并不是理所当然，反而是需要一些技巧，技巧就是我们的起始圆半径设置为0，化作一个点。例如实现一个红绿渐变```html<canvaswidth=\"240\"height=\"120\"></canvas>``````jsvarcontext=canvas.getContext('2d')//创建一个起始圆半径为0的径向渐变对象vargradient=context.createRadialGradient(120,60,0,120,60,60)//设置起止颜色gradient.addColorStop(0,'red')gradient.addColorStop(1,'green')//矩形填充context.fillStyle=gradientcontext.fillRect(0,0,240,120)```![](/.assets/img/2022-02-15-11-32-48.png)####色带分隔明显的色环>同心五环效果```html<canvaswidth=\"150\"height=\"150\"></canvas>``````jsvarcontext=canvas.getContext('2d')//创建一个起始圆半径为0的径向渐变对象vargradient=context.createRadialGradient(75,75,0,75,75,75)//设置起止颜色gradient.addColorStop(0,'red')gradient.addColorStop(0.2,'red')gradient.addColorStop(0.2,'orange')gradient.addColorStop(0.4,'orange')gradient.addColorStop(0.4,'yellow')gradient.addColorStop(0.6,'yellow')gradient.addColorStop(0.6,'green')gradient.addColorStop(0.8,'green')gradient.addColorStop(0.8,'purple')gradient.addColorStop(1,'purple')gradient.addColorStop(1,'transparent')//矩形填充context.fillStyle=gradientcontext.fillRect(0,0,150,150)```![](/.assets/img/2022-02-15-11-36-09.png)>不同浏览器还是有差异的，Chrome浏览器下的锯齿比较明显>实际上，如果起始渐变圆的半径如果不是0，则在Firefox浏览器下，第5环会无法呈现，且也会出现明显锯齿，这个案例可参见CanvasGradient.addColorStop##状态保存&恢复```jssave()//状态存储restore()//恢复上一次状态```","Front-End\\可视化\\canvas\\基础Api\\isPointInPath.md":"#isPointInPath>`CanvasRenderingContext2D.isPointInPath()`用来检测某个点是否在当前路径中```jscontext.isPointInPath(x,y)context.isPointInPath(x,y,fillRule)//下面语法IE不支持context.isPointInPath(path,x,y)context.isPointInPath(path,x,y,fillRule)```>此方法返回Boolean值。|参数|作用||-------------------|--------------------------------------------------------------------------------------------------------------------------||`x{Number}`|用来检测的点的横坐标||`y{Number}`|用来检测的点的纵坐标||`fillRule{String}`|填充规则。用来确定一个点实在路径内还是路径外。<br/>可选值包括：<br>`nonzero`：非零规则(default)<br>`evenodd`：奇偶规则。||`path{Object}`|指Path2D对象。|```js//画一个圆context.arc(120,120,80,0,Math.PI*2)context.stroke()//用来测试的点坐标们vararrPoints=[{x:50,y:50,},(point2={x:150,y:150,}),(point3={x:120,y:40,}),]arrPoints.forEach(function(point){//检测点是否在路径内point.isPointInPath=context.isPointInPath(point.x,point.y)})arrPoints.forEach(function(point){//标记这几个点context.fillStyle='red'context.beginPath()context.arc(point.x,point.y,3,0,Math.PI*2)context.fill()//检测结果以文本方式绘制context.font='14pxarial'context.fillText(point.isPointInPath,point.x+5,point.y)})```![](./.assets/isPointInPath-2022-03-29-16-21-20.png)>在路径范围内和正好压在路径上，返回值都是true，在路径外返回值是false","Front-End\\可视化\\canvas\\基础Api\\isPointInStroke.md":"#isPointInStroke>检测是否在描边上```jscontext.isPointInStroke(x,y)context.isPointInStroke(path,x,y)```>此方法返回Boolean值。|参数|类型|作用||:-----|:-------|:-------------------||`x`|`Number`|用来检测的点的横坐标||`y`|`Number`|用来检测的点的纵坐标||`path`|`Object`|指Path2D对象|```js//画一个圆context.arc(120,120,80,0,Math.PI*2)context.lineWidth=5context.stroke()//用来测试的点坐标们vararrPoints=[{x:40,y:40,},(point2={x:120,y:180,}),(point3={x:120,y:38,}),]arrPoints.forEach(function(point){//检测点是否在路径内point.isPointInStroke=context.isPointInStroke(point.x,point.y)})arrPoints.forEach(function(point){//标记这几个点context.fillStyle='red'context.beginPath()context.arc(point.x,point.y,3,0,Math.PI*2)context.fill()//检测结果以文本方式绘制context.font='14pxarial'context.fillText(point.isPointInStroke,point.x+5,point.y)})```![](./.assets/isPointInStroke-2022-03-29-16-29-43.png)>只有检测点在描边路径上，才返回true，在描边路径外和描边路径内部都返回false","Front-End\\可视化\\canvas\\基础Api\\rotate.md":"#rotate##旋转`context.rotate(angle)````js//旋转45度context.rotate((45*Math.PI)/180)//字体填充context.font='20pxSTHeiti,SimHei'context.fillText('旋转，跳跃，我闭着眼',60,-40,188)//重置当前的变换矩阵为初始态context.setTransform(1,0,0,1,0,0)```![](./.assets/rotate-2022-03-29-17-36-28.png)","Front-End\\可视化\\canvas\\基础Api\\scale.md":"#scale缩放>-不会影响之前绘制好的>-影响之后的绘制>-默认缩放中心(0,0)##`context.scale(x,y)`|参数|类型|作用||:---|:-------|:-------------------------------------------------------------||`x`|`Number`|Canvas坐标系水平缩放的比例。支持小数，如果值是-1，表示水平翻转||`y`|`Number`|Canvas坐标系垂直缩放的比例。支持小数，如果值是-1，表示垂直翻转|```js//显示绘制个正方形用来对比context.fillRect(10,10,10,10)//缩放context.scale(10,3)//再次绘制context.fillRect(10,10,10,10)//恢复坐标系context.setTransform(1,0,0,1,0,0)```![](./.assets/scale-2022-03-29-17-40-58.png)","Front-End\\可视化\\canvas\\基础Api\\setTransform.md":"#setTransform>设置矩阵变换当前>此方法和transform()方法的区别在于，后者不会完全重置已有的变换，而是累加`context.setTransform(a,b,c,d,e,f)`参数|类型|作用|:----|:----|:----|`a`|`Number`|水平缩放`b`|`Number`|水平斜切`c`|`Number`|垂直斜切`d`|`Number`|垂直缩放`e`|`Number`|水平位移`f`|`Number`|垂直位移![](./.assets/setTransform-2022-03-29-17-48-14.png)```jscontext.setTransform(1,0,1,1,0,0)context.fillRect(10,20,100,100)```![](./.assets/setTransform-2022-03-29-17-50-49.png)","Front-End\\可视化\\canvas\\基础Api\\stroke_.md":"#stroke\\_##stroke>对路径进行描边```jscontext.stroke()context.stroke(path)```参数`pathObject`:指Path2D对象(IE浏览器不支持)```jscontext.moveTo(50,50)context.lineTo(250,100)//描边context.stroke()```![](./.assets/index-2022-04-01-16-07-27.png)##strokeRect>矩形描边```jscontext.strokeRect(x,y,width,height)```|参数|类型|作用||:-----|:-----|:---------------||x|Number|矩形的起点横坐标||y|Number|矩形的起点纵坐标||width|Number|矩形的宽度||height|Number|矩形的高度|```js//像素宽矩形描边context.lineWidth=2context.strokeRect(75,25,150,100)```![](./.assets/stroke_-2022-04-01-16-11-44.png)##strokeText>文字描边,居中描边```jscontext.strokeText(text,x,y[,maxWidth]);```|参数|类型|参数||:-------|:--------------------------|:----------------------------------------------------||text|String用来描边的文本信息。||x|Number|描边文本的起点横坐标。||y|Number|描边文本的起点纵坐标。||maxWidth|（可选）Number|填充文本最大宽度(超过最大宽度,通过压缩每个文本宽度)|```js//文字描边context.font='50pxSTHeiti,SimHei'context.strokeText('文字描边',50,90)```![](./.assets/stroke_-2022-04-01-16-17-12.png)","Front-End\\可视化\\canvas\\基础Api\\transform.md":"#transform>对当前坐标进行进一步变换,实现缩放,旋转,拉伸或位移效果>与`setTransform`区别在于,`setTransform`会重置已有的变换,`transform`是累加```jscontext.transform(a,b,c,d,e,f)```|参数|类型|作用||:---|:-------|:-------||`a`|`Number`|水平缩放||`b`|`Number`|水平斜切||`c`|`Number`|垂直斜切||`d`|`Number`|垂直缩放||`e`|`Number`|水平位移||`f`|`Number`|垂直位移|![](./.assets/setTransform-2022-03-29-17-48-14.png)```jscontext.transform(1,0,1,1,0,0)context.fillRect(10,20,100,100)```![](./.assets/setTransform-2022-03-29-17-50-49.png)","Front-End\\可视化\\canvas\\基础Api\\translate.md":"#translate>对Canvas坐标进行整体位移,实际开发中常用来改变其他变换的方法的变换中心点`context.translate(x,y);`|参数|类型|作用||:---|:-----|:-------------------||x|Number|坐标系水平位移的距离||y|Number|坐标系垂直位移的距离|```html<canvasid=\"canvas\"width=\"300\"height=\"200\"></canvas>``````jsvarimg=newImage()img.onload=function(){varcontext=canvas.getContext('2d')//坐标位移context.translate(150,100)//旋转45度context.rotate((45*Math.PI)/180)//再位移回来context.translate(-150,-100)//此时绘制图片就是中心旋转了context.drawImage(this,0,0,300,200)//坐标系还原context.setTransform(1,0,0,1,0,0)}img.src='./1.jpg'```![](./.assets/translate-2022-04-01-16-30-05.png)","Front-End\\可视化\\canvas\\属性\\canvas.md":"#属性|属性名|描述||:------------------------------|:-----------------------------------------------------------------------------------------------||`canvas(readOnly)`|可以反向放回当前上下文`Canvas`||`fillStyle(default#000)`|填充各种图形样式(支持`color色值`,`渐变填充`,`pattern:填充纹理(contextPattern.createPattern())`)||`font(default10pxsans-serif)`|设置字体||`globalAlpha`|设置画布的全局透明度||`globalCompositeOperation`|设置Canvas图形的混合模式||`lineCap`|设置线条端点的样式(`buzz[default]`,`round圆弧`,`square:多出一个方框,宽度和线一直,长为线宽一半`)||`lineDashOffset`|指定虚线绘制的偏移距离||`lineJoin`|线条转角样式(`miter(尖头)`,`round(圆头)`,`bevel(平头)`)||`lineWidth`|线宽||`miterLimit`|限制尖角长度范围||`shadowBlur`|阴影的模糊程度||`shadowColor`|阴影颜色||`shadowOffsetX`|阴影水皮偏移||`shadowOffsetY`|阴影垂直偏移||`strokeStyle`|描边样式||`textAlign`|文本水平对齐方式||`textBaseline`|文本对齐基线|","Front-End\\可视化\\canvas\\文字\\index.md":"#文字##fillText填充文字>`CanvasRenderingContext2D.fillText()`:用来填充文字，是Canvas绘制文本的主力方法>>`context.fillText(text,x,y[,maxWidth])`>`text{String}`:用来填充的文本信息。>`x{Number}`:填充文本的起点横坐标。>`y{Number}`:填充文本的起点纵坐标。>`maxWidth（可选）{Number}`:文本最大宽度(不是换行,超过该长度会压缩文本宽度)```jscontext.font='24pxSTheiti,SimHei'context.fillText('CanvasAPI中文网',24,66)```![](./.assets/index-2022-03-29-14-54-54.png)##measureText文字宽度>`CanvasRenderingContext2D.measureText()`可以用来测量文本的一些数据，返回`TextMetrics`对象，包含字符宽度等信息。###`context.measureText(text)`>返回值是TextMetrics对象>`text{String}`被测量的文本```js//设置字体字号context.font='24pxSTHeiTi,SimHei'//文本信息对象就有了vartextZh=context.measureText('帅')vartextEn=context.measureText('handsome')//文字绘制context.fillText('帅',60,50)context.fillText('handsome',60,90)//显示宽度context.font='12pxArial'context.fillStyle='red'context.fillText('宽'+textZh.width,62+textZh.width,40)context.fillText('宽'+textEn.width,62+textEn.width,80)```![](./.assets/index-2022-03-29-16-45-12.png)","Front-End\\可视化\\canvas\\矩形\\index.md":"#矩形##矩形填充>默认黑色>`context.fillRect(x,y,width,height);`-`x{Number}`:填充矩形的起点横坐标-`y{Number}`:填充矩形的起点纵坐标-`width{Number}`:填充矩形的宽度-`height{Number}`:填充矩形的高度```jsfillRect(x,y,width,height)//填充以(x,y)为起点宽高分别为width、height的矩形默认为黑色strokeRect(x,y,width,height)//绘制一个空心以(x,y)为起点宽高分别为width、height的矩形clearRect(x,y,width,height)//清除以(x,y)为起点宽高分别为width、height的矩形为透明```","Front-End\\可视化\\canvas\\矩形\\rect.md":"#rect>`CanvasRenderingContext2D.rect()`绘制矩形路径>`rect()`绘制出来的仅仅是路径，和`arc()`、`ellipse()`方法是一样的。需要你需要填充，还需要执行`fill()`方法，如果要描边，还需要执行`stroke()`方法。实际上，对于矩形，填充和描边有现成的方法，这个是为矩形独有的，为`fillRect()`和`strokeRect()````jscontext.rect(x,y,width,height)```|参数|类型|作用||:-------|:-------|:-------------------||`x`|`Number`|矩形路径的起点横坐标||`y`|`Number`|矩形路径的起点纵坐标||`width`|`Number`|矩形的宽度||`height`|`Number`|矩形的高度|```js//矩形context.rect(100,25,100,100)context.stroke()```![](./.assets/rect-2022-03-29-17-29-25.png)","Front-End\\可视化\\canvas\\线\\曲线.md":"#曲线##一次贝塞尔曲线>-没有控制点>-就是一条直线##二次贝塞尔曲线quadraticCurveTo>-一个控制点```jsquadraticCurveTo(cpx,cpy,x,y)//(cp1x,cp1y)控制点(x,y)结束点```|参数|类型|作用||:----|:-------|:-------------||`cpx`|`Number`|控制点的横坐标||`cpy`|`Number`|控制点的纵坐标||`x`|`Number`|结束点的横坐标||`y`|`Number`|结束点的纵坐标|```js//开始绘制context.beginPath()context.moveTo(50,50)context.quadraticCurveTo(100,100,250,100)context.stroke()```![](./.assets/曲线-2022-03-29-17-23-46.png)##三次贝塞尔曲线bezierCurveTo>-两个控制点>-绘制:正圆,椭圆,曲线图像>`context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)`>`(cp1x,cp1y)`:控制点1>`(cp2x,cp2y)`:控制点2>`(x,y)`:结束点```jscontext.beginPath()context.moveTo(50,50)context.bezierCurveTo(100,100,200,40,250,100)context.stroke()```![](/.assets/img/2022-02-15-10-30-35.png)>灰色是起始点，红色是两个控制点>其中有1个白点的是第1个控制点，有2个白点的是第2个控制点，绿色是结束点","Front-End\\可视化\\canvas\\线\\线.md":"#线##获取虚线样式getLineDash>`CanvasRenderingContext2D.getLineDash()`用来获取当前虚线的样式```jscontext.beginPath()context.moveTo(10,60)context.lineTo(230,60)context.setLineDash([5])context.stroke()//将getLineDash()结果绘制在画布上vardash=context.getLineDash()//绘制文本context.font='16pxarial'context.fillText(dash,10,48)//控制台输出console.log(dash)```![](./.assets/线-2022-03-29-16-09-48.png)##设置虚线样式setLineDash>`CanvasRenderingContext2D.setLineDash()`:设置虚线样式###`ctx.setLineDash(segments)``segmentsArray`:数值列表数组。例如[5,5]，表示虚线的实线和透明部分长度是5像素和5像素。如果此参数值适合空数组[]，则表示实线，常用来重置虚线设置。```jscontext.beginPath()context.setLineDash([5,10,15,30])context.moveTo(20,70)context.lineTo(280,70)context.stroke()```![](./.assets/线-2022-03-29-17-44-55.png)","Front-End\\可视化\\canvas\\路径\\index.md":"#路径##beginPath新路径>`beginPath`>`type:()=>void`>新的路径,和之前的路径分开```js//开始路径context.beginPath()context.strokeStyle='blue'context.moveTo(60,20)context.lineTo(220,20)context.stroke()//开始路径againcontext.beginPath()context.strokeStyle='green'context.moveTo(60,20)context.lineTo(160,120)context.stroke()```![](/.assets/img/2022-02-15-10-18-29.png)>执行两次`beginPath()`##closePath闭合路径>`closePath()`>`type:()=>void`>关闭该路径将绘制指令重新转移到上下文```js//绘制三角context.beginPath()context.moveTo(10,10)context.lineTo(140,70)context.lineTo(70,140)//不执行闭合，直接描边context.stroke()//绘制另外一个三角context.beginPath()context.moveTo(160,10)context.lineTo(290,70)context.lineTo(220,140)//执行闭合，然后描边context.closePath()context.stroke()```![](/.assets/img/2022-02-15-10-55-38.png)>左侧图形没有执行`closePath()`，右侧执行了`closePath()`##fill路径填充>路径填充,包含非零规则,奇偶规则```jscontext.fill()context.fill(fillRule)context.fill(path,fillRule)```>`fillRule{String}`:填充规则。用来确定一个点实在路径内还是路径外。可选值包括：>>-`nonzero`：非零规则，此乃默认规则>-`evenodd`：奇偶规则>>`path{Object}`:指Path2D对象```html<canvaswidth=\"300\"height=\"300\"data-rule=\"nonzero\"></canvas><canvaswidth=\"300\"height=\"300\"data-rule=\"evenodd\"></canvas>``````js//2个三角的点坐标vararrPoints=[[60,60],[240,100],[160,280],[60,60],[150,20],[260,260],]varcanvases=document.querySelectorAll('canvas')//遍历;[].slice.call(canvases).forEach(function(canvas,index){varrule=canvas.getAttribute('data-rule')varcontext=canvas.getContext('2d')//开始绘制context.beginPath()context.moveTo(arrPoints[0][0],arrPoints[0][1])context.lineTo(arrPoints[1][0],arrPoints[1][1])context.lineTo(arrPoints[2][0],arrPoints[2][1])context.lineTo(arrPoints[3][0],arrPoints[3][1])context.lineTo(arrPoints[4][0],arrPoints[4][1])context.lineTo(arrPoints[5][0],arrPoints[5][1])context.closePath()context.fillStyle='#0e65c5'context.fill(rule)})```![](/.assets/img/2022-02-15-14-44-30.png)##lineTo连接>绘制直线连接最后的子路径点喝lineTo()指定点`context.lineTo(x,y)`|参数|类型|作用||:---|:-------|:-----------------------||`x`|`Number`|绘制的直线的落点的横坐标||`y`|`Number`|绘制的直线的落点的纵坐标|```jscontext.beginPath()context.moveTo(50,20)context.bezierCurveTo(100,100,200,40,250,120)context.lineTo(50,120)context.stroke()```![](./.assets/线-2022-03-29-16-41-16.png)##moveTo绘制点移动###`context.moveTo(x,y);`|参数|类型|作用||:---|:-------|:-----------||`x`|`Number`|落点的横坐标||`y`|`Number`|落点的纵坐标|```jscontext.beginPath()context.moveTo(50,20)context.lineTo(200,100)context.stroke()```![](./.assets/index-2022-03-29-16-53-29.png)##drawFocusIfNeeded路径高亮>路径处于focus状态>兼容性差>增强可访问性>日常使用:>>-用来增强高亮复杂路径>-点选删除元素>-复制移动工具类应用场景```jscontext.drawFocusIfNeeded(element)context.drawFocusIfNeeded(path,element)```>`element{Object}`用来检测当前是否处于focus状态的元素。此元素需要原本就是可聚焦的元素，例如按钮或者链接或者输入框等。然后，还需要放置在`<canvas>`标签中才有用>`path{Object}`指Path2D对象```html<canvasid=\"canvas\"width=\"240\"height=\"120\"><buttonid=\"button1\">按钮1</button><buttonid=\"button2\">按钮2</button></canvas>``````js//两个按钮元素varbutton1=document.getElementById('button1')varbutton2=document.getElementById('button2')//canvas元素和上下文varcanvas=document.querySelector('#canvas')varcontext=canvas.getContext('2d')vardraw=function(){context.clearRect(0,0,240,120)//设置字体样式context.font='16pxSTHeiti,SimHei'context.textAlign='center'context.textBaseline='middle'//绘制两个圆和文字context.beginPath()context.arc(60,60,50,0,Math.PI*2)context.fillStyle='red'context.fill()context.fillStyle='white'context.fillText('按钮1',60,60)context.drawFocusIfNeeded(button1)context.beginPath()context.arc(180,60,50,0,Math.PI*2)context.fillStyle='green'context.fill()context.fillStyle='white'context.fillText('按钮2',180,60)context.drawFocusIfNeeded(button2)}draw()//点击canvas元素canvas.addEventListener('click',function(event){//通过点击位置判断点击是哪个圈圈varx=event.clientX-canvas.getBoundingClientRect().leftvary=event.clientY-canvas.getBoundingClientRect().top//距离两个圈圈圆心的距离vardistance1=Math.sqrt((60-x)*(60-x)+(60-y)*(60-y))vardistance2=Math.sqrt((180-x)*(180-x)+(60-y)*(60-y))//根据距离和半径大小判断是否在圈内if(distance1<=50){button1.focus()draw()}elseif(distance2<50){button2.focus()draw()}})```![](/.assets/img/2022-02-15-11-41-32.png)```jsbeginPath()//新建一条路径一旦创建成功绘制命令将转移到新建的路径上moveTo(x,y)//移动画笔到(x,y)点开始后面的绘制工作closePath()//关闭该路径将绘制指令重新转移到上下文stroke()//将绘制的路径进行描边fill()//将绘制的封闭区域进行填充```","Front-End\\可视化\\cesium.md":"#Cesium>[官网](https://cesium.com/platform/cesiumjs/)>3d可视化","Front-End\\可视化\\D3.md":"#D3>[d3-brush|D3js:Data-DrivenDocuments](https://d3js.org.cn/document/d3-brush/#api-reference)>>[D3.js-AxisAPI\\_学习D3JS|WIKI教程(iowiki.com)](https://iowiki.com/d3js/d3js_axis_api.html)>>-操作真实DOM的框架,和JQuery类似>-实现效果类似echart或highChart[d3-scale-chromatic|D3js:Data-DrivenDocuments](https://d3js.org.cn/document/d3-scale-chromatic/#api-reference)[React+D3.js之图表制作——柱状图-知乎(zhihu.com)](https://zhuanlan.zhihu.com/p/85862899)[柱状图-CodeSandbox](https://codesandbox.io/embed/zhuzhuangtu-ukfzt)[d3/d3:BringdatatolifewithSVG,CanvasandHTML.(github.com)](https://github.com/d3/d3)","Front-End\\可视化\\echart\\echart.md":"#[`EChart`](https://echarts.apache.org/zh/index.html)##地图>-[yanivam/react-svg-worldmap:Asimple,compactandfreeReactSVGworldmap.](https://github.com/yanivam/react-svg-worldmap)>-[react、echarts和地图的结合](https://www.jianshu.com/p/29b346e282ac)","Front-End\\可视化\\echart\\error\\Echarts版本v5弃用的normal和api.style.md":"#[`Echarts版本v5弃用的normal和api.style`](/)-警告:`[ECharts]DEPRECATED:'normal'hierarchyinitemStylehasbeenremovedsince4.0.AllstylepropertiesareconfiguredinitemStyledirectlynow.````jsseries:[{type:'custom',renderItem:(params,api)=>{return{type:'rect',style:api.style(),}},data,},]```该为```jsseries:[{type:'custom',renderItem:(params,api)=>{return{type:'rect',style:{fill:api.visual('color'),},}},data,},]```","Front-End\\可视化\\echart\\error\\图表刷新.md":"#图表刷新问题##数据切换时,原数据还在图表上```jschart.setOption(option,notMerge,lazyUpdate)```1.notMerge:默认值false1.false:合并2.true:组件删除重新渲染##resize```jschart.resize()window.addEventListener('resize',()=>{chart.resize()})document.addEventListener('fullscreenchange',()=>{chart.resize()})document.addEventListener('webkitfullscreenchange',()=>{chart.resize()})document.addEventListener('mozfullscreenchange',()=>{chart.resize()})document.addEventListener('msfullscreenchange',()=>{chart.resize()})```","Front-End\\可视化\\echart\\error\\多条折线数据错乱.md":"#[`多条折线数据错乱`]()```js{series:[{name:\"异常\",type:\"line\",stack:\"Total\",//把这个stack去掉或者设置不同数值data:this.abnormalList,itemStyle:{borderColor:\"#f0f075\",color:\"#ffffff\",borderWidth:2.5,},lineStyle:{color:\"#f0f075\",width:2.5,},},//...}```","Front-End\\可视化\\FabricJS.md":"#FabricJS<https://juejin.cn/post/7336743827827015731?searchId=20250317103505D1000297F4879ACB037C><https://github.com/ikuaitu/vue-fabric-editor>","Front-End\\可视化\\GSAP.md":"#GSAP<https://jamessawyer.github.io/awesome-gsap/blogs/react/getting-start-with-gsap-and-react.html>","Front-End\\可视化\\HighEchart.md":"#HighEChart>[HighchartsAPI文档|Highcharts](https://api.highcharts.com.cn/highcharts)>[demo](https://jshare.com.cn/highcharts/hhhh7r)###react使用###package.js```json{\"dependencies\":{\"highcharts-drilldown\":\"^0.1.7\",\"react-highcharts\":\"^11.5.0\"}}```###react文件>`grouped-categories.js`:坐标轴分组>>`https://blacklabel.github.io/grouped_categories/grouped-categories.js````jsimportReactfrom'react'importHighchartsfrom'highcharts'importReactHighchartsfrom'react-highcharts'importGroupedfrom'../../assets/js/grouped-categories'Grouped(Highcharts)//启用第三方包//定义配置文件constconfig={chart:{renderTo:\"container\",type:\"column\"},title:{useHTML:true,x:-10,y:8,text:'<spanclass=\"chart-title\">Groupedcategories</span>'},series:[{data:[4,14,18,5,6,5,14,15,18]}],xAxis:{categories:[{name:\"Fruit\",categories:[\"Apple\",\"Banana\",\"Orange\"]},{name:\"Vegetable\",categories:[\"Carrot\",\"Potato\",\"Tomato\"]},{name:\"Fish\",categories:[\"Cod\",\"Salmon\",\"Tuna\"]}]}}//渲染出来<ReactHighchartsconfig={config}></ReactHighcharts>```##配置###去掉highcharts的logo```jscredits:{enabled:false//不显示LOGO},```###改变柱状图宽度```jsplotOptions:{series:{pointPadding:0,//数据点之间的距离值groupPadding:0,//分组之间的距离值borderWidth:0,shadow:false,pointWidth:5//柱子之间的距离值}}//统一柱状图的颜色color:'#ffc77f',```###改变y轴的刻度```jsonyAxis:{tickPositions:[0,50000,100000,150000,200000,250000,300000]//指定竖轴坐标点的值},```###改变背景颜色,改变环形图文字颜色```jsonchart:{plotBackgroundColor:null,plotBorderWidth:null,backgroundColor:'#fff',//改变背景颜色plotShadow:false,spacing:[100,0,40,0]},title:{floating:true,text:'前十大投资人',style:{color:\"#000\"//改变环形图文字颜色}},```###去掉图例```jslegend:{enabled:false}```###highcharts改变y轴刻度的单位```jsonlabels:{formatter:function(){returnthis.value+\"%\";}}```###提示框的背景色```jsontooltip:{backgroundColor:'#ff6600',pointFormat:'平台交易:<b>{point.y:.1f}万元</b><br>交易笔数：<b>{point.y:.1f}万笔</b>',animation:true},```###重新绘制```json$(\"#container1\").highcharts().reflow();```###雷达图刻度```jsonplotOptions:{line:{dataLabels:{enabled:true//开启数据标签},enableMouseTracking:false//关闭鼠标跟踪，对应的提示框、点击事件会失效}},```##第三方包###grouped-categories.js```js/*globalHighchartsmodulewindow:true*/;(function(factory){if(typeofmodule==='object'&&module.exports){module.exports=factory}else{factory(Highcharts)}})(function(HC){'usestrict'/***GroupedCategoriesv1.1.6(2020-06-19)**(c)2012-2020BlackLabel**License:CreativeCommonsAttribution(CC)*//*jshintexpr:true,boss:true*/varUNDEFINED=void0,mathRound=Math.round,mathMin=Math.min,mathMax=Math.max,merge=HC.merge,pick=HC.pick,each=HC.each,//cacheprototypesaxisProto=HC.Axis.prototype,tickProto=HC.Tick.prototype,//cacheoriginalmethodsprotoAxisInit=axisProto.init,protoAxisRender=axisProto.render,protoAxisSetCategories=axisProto.setCategories,protoTickGetLabelSize=tickProto.getLabelSize,protoTickAddLabel=tickProto.addLabel,protoTickDestroy=tickProto.destroy,protoTickRender=tickProto.renderfunctiondeepClone(thing){returnJSON.parse(JSON.stringify(thing))}functionCategory(obj,parent){this.userOptions=deepClone(obj)this.name=obj.name||objthis.parent=parentreturnthis}Category.prototype.toString=function(){varparts=[],cat=thiswhile(cat){parts.push(cat.name)cat=cat.parent}returnparts.join(',')}//returnssumofanarrayfunctionsum(arr){varl=arr.length,x=0while(l--){x+=arr[l]}returnx}//AddscategoryleaftoarrayfunctionaddLeaf(out,cat,parent){out.unshift(newCategory(cat,parent))while(parent){parent.leaves=parent.leaves?parent.leaves+1:1parent=parent.parent}}//BuildsreversecategorytreefunctionbuildTree(cats,out,options,parent,depth){varlen=cats.length,catdepth=depth?depth:0options.depth=options.depth?options.depth:0while(len--){cat=cats[len]if(cat.categories){if(parent){cat.parent=parent}buildTree(cat.categories,out,options,cat,depth+1)}else{addLeaf(out,cat,parent)}}options.depth=mathMax(options.depth,depth)}//PushespartofgridtopathfunctionaddGridPart(path,d,width){//BasedoncrispLinefromHC(#65)if(d[0]===d[2]){d[0]=d[2]=mathRound(d[0])-(width%2)/2}if(d[1]===d[3]){d[1]=d[3]=mathRound(d[1])+(width%2)/2}path.push('M',d[0],d[1],'L',d[2],d[3])}//ReturnstickpositionfunctiontickPosition(tick,pos){returntick.getPosition(tick.axis.horiz,pos,tick.axis.tickmarkOffset)}functionwalk(arr,key,fn){varl=arr.length,childrenwhile(l--){children=arr[l][key]if(children){walk(children,key,fn)}fn(arr[l])}}////Axisprototype//axisProto.init=function(chart,options){//defaultbehaviourprotoAxisInit.call(this,chart,options)if(typeofoptions==='object'&&options.categories){this.setupGroups(options)}}//setuprequiredaxisoptionsaxisProto.setupGroups=function(options){varcategories=deepClone(options.categories),reverseTree=[],stats={},labelOptions=this.options.labels,userAttr=labelOptions.groupedOptions,css=labelOptions.style//buildcategoriestreebuildTree(categories,reverseTree,stats)//setaxispropertiesthis.categoriesTree=categoriesthis.categories=reverseTreethis.isGrouped=stats.depth!==0this.labelsDepth=stats.depththis.labelsSizes=[]this.labelsGridPath=[]this.tickLength=options.tickLength||this.tickLength||null//#66:tickWidthforxaxisdefaultsto1,foryto0this.tickWidth=pick(options.tickWidth,this.isXAxis?1:0)this.directionFactor=[-1,1,1,-1][this.side]this.options.lineWidth=pick(options.lineWidth,1)//#85:alignlabelsverticallythis.groupFontHeights=[]for(vari=0;i<=stats.depth;i++){varhasOptions=userAttr&&userAttr[i-1],mergedCSS=hasOptions&&userAttr[i-1].style?merge(css,userAttr[i-1].style):cssthis.groupFontHeights[i]=Math.round(this.chart.renderer.fontMetrics(mergedCSS?mergedCSS.fontSize:0).b*0.3,)}}axisProto.render=function(){//cleargridpathif(this.isGrouped){this.labelsGridPath=[]}//cacheoriginalticklengthif(this.originalTickLength===UNDEFINED){this.originalTickLength=this.options.tickLength}//usedefaulttickLengthfornot-groupedaxis//andgenerategridongroupedaxes,//usetinynumbertoforcehighchartstohidetickthis.options.tickLength=this.isGrouped?0.001:this.originalTickLengthprotoAxisRender.call(this)if(!this.isGrouped){if(this.labelsGrid){this.labelsGrid.attr({visibility:'hidden',})}returnfalse}varaxis=this,options=axis.options,top=axis.top,left=axis.left,right=left+axis.width,bottom=top+axis.height,visible=axis.hasVisibleSeries||axis.hasData,depth=axis.labelsDepth,grid=axis.labelsGrid,horiz=axis.horiz,d=axis.labelsGridPath,i=options.drawHorizontalBorders===false?depth+1:0,offset=axis.opposite?(horiz?top:right):horiz?bottom:left,tickWidth=axis.tickWidth,partif(axis.userTickLength){depth-=1}//rendergridpathforthefirsttimeif(!grid){grid=axis.labelsGrid=axis.chart.renderer.path().attr({//#58:usetickWidth/tickColorinsteadoflineWidth/lineColor:strokeWidth:tickWidth,//<4.0.3'stroke-width':tickWidth,//4.0.3+#30stroke:options.tickColor||'',//forstyledmode(tickColor===undefined)}).add(axis.axisGroup)//forstyledmode-addclassif(!options.tickColor){grid.addClass('highcharts-tick')}}//gothrougheverylevelanddrawhorizontalgridlinewhile(i<=depth){offset+=axis.groupSize(i)part=horiz?[left,offset,right,offset]:[offset,top,offset,bottom]addGridPart(d,part,tickWidth)i++}//drawgridpathgrid.attr({d:d,visibility:visible?'visible':'hidden',})axis.labelGroup.attr({visibility:visible?'visible':'hidden',})walk(axis.categoriesTree,'categories',function(group){vartick=group.tickif(!tick){returnfalse}if(tick.startAt+tick.leaves-1<axis.min||tick.startAt>axis.max){tick.label.hide()tick.destroyed=0}else{tick.label.attr({visibility:visible?'visible':'hidden',})}returntrue})returntrue}axisProto.setCategories=function(newCategories,doRedraw){if(this.categories){this.cleanGroups()}this.setupGroups({categories:newCategories,})this.categories=this.userOptions.categories=newCategoriesprotoAxisSetCategories.call(this,this.categories,doRedraw)}//cleansoldcategoriesaxisProto.cleanGroups=function(){varticks=this.ticks,nfor(ninticks){if(ticks[n].parent){deleteticks[n].parent}}walk(this.categoriesTree,'categories',function(group){vartick=group.tickif(!tick){returnfalse}tick.label.destroy()each(tick,function(v,i){deletetick[i]})deletegroup.tickreturntrue})this.labelsGrid=null}//keepssizeofeachcategorieslevelaxisProto.groupSize=function(level,position){varpositions=this.labelsSizes,direction=this.directionFactor,groupedOptions=this.options.labels.groupedOptions?this.options.labels.groupedOptions[level-1]:false,userXY=0if(groupedOptions){if(direction===-1){userXY=groupedOptions.x?groupedOptions.x:0}else{userXY=groupedOptions.y?groupedOptions.y:0}}if(position!==UNDEFINED){positions[level]=mathMax(positions[level]||0,position+10+Math.abs(userXY),)}if(level===true){returnsum(positions)*direction}elseif(positions[level]){returnpositions[level]*direction}return0}////Tickprototype////OverridemethodsprototypestickProto.addLabel=function(){vartick=this,axis=tick.axis,categoryprotoTickAddLabel.call(tick)if(!axis.categories||!(category=axis.categories[tick.pos])){returnfalse}//setlabeltext-butappliedafterformatter#46if(tick.label){tick.label.attr('text',tick.axis.labelFormatter.call({axis:axis,chart:axis.chart,isFirst:tick.isFirst,isLast:tick.isLast,value:category.name,pos:tick.pos,}),)}//createelementsforparentcategoriesif(axis.isGrouped&&axis.options.labels.enabled){tick.addGroupedLabels(category)}returntrue}//renderancestorlabeltickProto.addGroupedLabels=function(category){vartick=this,axis=this.axis,chart=axis.chart,options=axis.options.labels,useHTML=options.useHTML,css=options.style,userAttr=options.groupedOptions,attr={align:'center',rotation:options.rotation,x:0,y:0,},size=axis.horiz?'height':'width',depth=0,labelwhile(tick){if(depth>0&&!category.tick){//renderlabelelementthis.value=category.namevarname=options.formatter?options.formatter.call(this,category):category.name,hasOptions=userAttr&&userAttr[depth-1],mergedAttrs=hasOptions?merge(attr,userAttr[depth-1]):attr,mergedCSS=hasOptions&&userAttr[depth-1].style?merge(css,userAttr[depth-1].style):css//#63:styleispassedinCSSandnotasanattributedeletemergedAttrs.stylelabel=chart.renderer.text(name,0,0,useHTML).attr(mergedAttrs).css(mergedCSS).add(axis.labelGroup)//tickpropertiestick.startAt=this.postick.childCount=category.categories.lengthtick.leaves=category.leavestick.visible=this.childCounttick.label=labeltick.labelOffsets={x:mergedAttrs.x,y:mergedAttrs.y,}//linktickwithcategorycategory.tick=tick}//setlevelsize,#93if(tick&&tick.label){axis.groupSize(depth,tick.label.getBBox()[size])}//gouptotheparentcategorycategory=category.parentif(category){tick=tick.parent=category.tick||{}}else{tick=null}depth++}}//setlabelsposition&rendercategoriesgridtickProto.render=function(index,old,opacity){protoTickRender.call(this,index,old,opacity)vartreeCat=this.axis.categories[this.pos]if(!this.axis.isGrouped||!treeCat||this.pos>this.axis.max){return}vartick=this,group=tick,axis=tick.axis,tickPos=tick.pos,isFirst=tick.isFirst,max=axis.max,min=axis.min,horiz=axis.horiz,grid=axis.labelsGridPath,size=axis.groupSize(0),tickWidth=axis.tickWidth,xy=tickPosition(tick,tickPos),start=horiz?xy.y:xy.x,baseLine=axis.chart.renderer.fontMetrics(axis.options.labels.style?axis.options.labels.style.fontSize:0,).b,depth=1,reverseCrisp=(horiz&&xy.x===axis.pos+axis.len)||(!horiz&&xy.y===axis.pos)?-1:0,//adjustgridlinesforedgesgridAttrs,lvlSize,minPos,maxPos,attrs,bBox//rendergridfor\"normal\"categories(first-level),renderleftgridlineonlyforthefirstcategoryif(isFirst){gridAttrs=horiz?[axis.left,xy.y,axis.left,xy.y+axis.groupSize(true)]:axis.isXAxis?[xy.x,axis.top,xy.x+axis.groupSize(true),axis.top]:[xy.x,axis.top+axis.len,xy.x+axis.groupSize(true),axis.top+axis.len,]addGridPart(grid,gridAttrs,tickWidth)}if(horiz&&axis.left<xy.x){addGridPart(grid,[xy.x-reverseCrisp,xy.y,xy.x-reverseCrisp,xy.y+size],tickWidth,)}elseif(!horiz&&axis.top<=xy.y){addGridPart(grid,[xy.x,xy.y+reverseCrisp,xy.x+size,xy.y+reverseCrisp],tickWidth,)}size=start+sizefunctionfixOffset(tCat){varret=0if(isFirst){ret=tCat.parent.categories.indexOf(tCat.name)ret=ret<0?0:retreturnret}returnret}while(group.parent){group=group.parentvarfix=fixOffset(treeCat),userX=group.labelOffsets.x,userY=group.labelOffsets.yminPos=tickPosition(tick,mathMax(group.startAt-1,min-1))maxPos=tickPosition(tick,mathMin(group.startAt+group.leaves-1-fix,max),)bBox=group.label.getBBox(true)lvlSize=axis.groupSize(depth)//checkifontheedgetoadjustreverseCrisp=(horiz&&maxPos.x===axis.pos+axis.len)||(!horiz&&maxPos.y===axis.pos)?-1:0attrs=horiz?{x:(minPos.x+maxPos.x)/2+userX,y:size+axis.groupFontHeights[depth]+lvlSize/2+userY/2,}:{x:size+lvlSize/2+userX,y:(minPos.y+maxPos.y-bBox.height)/2+baseLine+userY,}if(!isNaN(attrs.x)&&!isNaN(attrs.y)){group.label.attr(attrs)if(grid){if(horiz&&axis.left<maxPos.x){addGridPart(grid,[maxPos.x-reverseCrisp,size,maxPos.x-reverseCrisp,size+lvlSize,],tickWidth,)}elseif(!horiz&&axis.top<=maxPos.y){addGridPart(grid,[size,maxPos.y+reverseCrisp,size+lvlSize,maxPos.y+reverseCrisp,],tickWidth,)}}}size+=lvlSizedepth++}}tickProto.destroy=function(){vargroup=this.parentwhile(group){group.destroyed=group.destroyed?group.destroyed+1:1group=group.parent}protoTickDestroy.call(this)}//returnsizeofthelabel(heightforhorizontal,widthforverticalaxes)tickProto.getLabelSize=function(){if(this.axis.isGrouped===true){//#72,getBBoxmightneedrecalculatingwhenchartistallvarsize=protoTickGetLabelSize.call(this)+10,topLabelSize=this.axis.labelsSizes[0]if(topLabelSize<size){this.axis.labelsSizes[0]=size}returnsum(this.axis.labelsSizes)}returnprotoTickGetLabelSize.call(this)}//Sincedatasortingisnotsupportedbytheplugin,//overridereplaceMovedLabelmethod,#146.HC.wrap(HC.Tick.prototype,'replaceMovedLabel',function(proceed){if(!this.axis.isGrouped){proceed.apply(this,Array.prototype.slice.call(arguments,1))}})})```","Front-End\\可视化\\index.md":"#工具库-[Recharts](https://recharts.org/zh-CN/examples)-[AGCharts](https://ag-grid.com/charts/react/quick-start/)","Front-End\\可视化\\threejs\\API\\PerspectiveCamera.md":"#透视相机（PerspectiveCamera）这一摄像机使用[perspectiveprojection](<https://en.wikipedia.org/wiki/Perspective_(graphical)>)（透视投影）来进行投影。这一投影模式被用来模拟人眼所看到的景象，它是3D场景的渲染中使用得最普遍的投影模式。##代码示例```jsconstcamera=newTHREE.PerspectiveCamera(45,width/height,1,1000)scene.add(camera)```##例子[animation/skinning/blending](https://threejs.org/examples/#webgl_animation_skinning_blending)[animation/skinning/blending](https://threejs.org/examples/#webgl_animation_skinning_morph)[effects/stereo](https://threejs.org/examples/#webgl_effects_stereo)[interactive/cubes](https://threejs.org/examples/#webgl_interactive_cubes)[loader/collada/skinning](https://threejs.org/examples/#webgl_loader_collada_skinning)##构造器###PerspectiveCamera(fov:Number,aspect:Number,near:Number,far:Number)>-fov—摄像机视锥体垂直视野角度>-aspect—摄像机视锥体长宽比>-near—摄像机视锥体近端面>-far—摄像机视锥体远端面这些参数一起定义了摄像机的[viewingfrustum](https://en.wikipedia.org/wiki/Viewing_frustum)（视锥体）。##属性>共有属性请参见其基类Camera>请注意，在大多数属性发生改变之后，你将需要调用.updateProjectionMatrix来使得这些改变生效。###.aspect:Float>摄像机视锥体的长宽比，通常是使用画布的宽/画布的高。默认值是**1**（正方形画布）。###.far:Float>摄像机的远端面，默认值是**2000**。>>该值必须大于nearplane（摄像机视锥体近端面）的值。###.filmGauge:Float>胶片尺寸，其默认值为35（毫米）。这个参数不会影响摄像机的投影矩阵，除非.filmOffset被设置为了一个非零的值。###.filmOffset:Float>水平偏离中心偏移量，和.filmGauge单位相同。默认值为**0**。###.focus:Float>用于立体视觉和景深效果的物体的距离。这个参数不会影响摄像机的投影矩阵，除非使用了StereoCamera。默认值是**10**。###.fov:Float>摄像机视锥体垂直视野角度，从视图的底部到顶部，以角度来表示。默认值是**50**。###.near:Float>摄像机的近端面，默认值是**0.1**。>>其有效值范围是0到当前摄像机farplane（远端面）的值之间。请注意，和OrthographicCamera不同，**0**对于PerspectiveCamera的近端面来说*不是*一个有效值。###.view:Object>Frustumwindowspecificationornull.这个值使用.setViewOffset方法来进行设置，使用.clearViewOffset方法来进行清除。###.zoom:number>获取或者设置摄像机的缩放倍数，其默认值为**1**。##方法>共有方法请参见其基类Camera。###.clearViewOffset():undefined>清除任何由.setViewOffset设置的偏移量。###.getEffectiveFOV():Float>结合.zoom（缩放倍数），以角度返回当前垂直视野角度。###.getFilmHeight():Float>返回当前胶片上图像的高，如果.aspect小于或等于1（肖像格式、纵向构图），则结果等于.filmGauge。###.getFilmWidth():Float>返回当前胶片上图像的宽，如果.aspect大于或等于1（景观格式、横向构图），则结果等于.filmGauge。###.getFocalLength():Float>返回当前.fov（视野角度）相对于.filmGauge（胶片尺寸）的焦距。###.setFocalLength(focalLength:Float):undefined>通过相对于当前.filmGauge的焦距，设置FOV。>>默认情况下，焦距是为35mm（全画幅）摄像机而指定的。###.setViewOffset(fullWidth:Float,fullHeight:Float,x:Float,y:Float,width:Float,height:Float):undefinedfullWidth—多视图的全宽设置fullHeight—多视图的全高设置x—副摄像机的水平偏移y—副摄像机的垂直偏移width—副摄像机的宽度height—副摄像机的高度在较大的viewingfrustum（视锥体）中设置偏移量，对于多窗口或者多显示器的设置是很有用的。例如，如果你有一个3x2的显示器阵列，每个显示器分辨率都是1920x1080，且这些显示器排列成像这样的网格：```txt+---+---+---+|A|B|C|+---+---+---+|D|E|F|+---+---+---+```那对于每个显示器，你可以这样来设置、调用：```jsconstw=1920consth=1080constfullWidth=w*3constfullHeight=h*2//Acamera.setViewOffset(fullWidth,fullHeight,w*0,h*0,w,h)//Bcamera.setViewOffset(fullWidth,fullHeight,w*1,h*0,w,h)//Ccamera.setViewOffset(fullWidth,fullHeight,w*2,h*0,w,h)//Dcamera.setViewOffset(fullWidth,fullHeight,w*0,h*1,w,h)//Ecamera.setViewOffset(fullWidth,fullHeight,w*1,h*1,w,h)//Fcamera.setViewOffset(fullWidth,fullHeight,w*2,h*1,w,h)```请注意，显示器的不必具有相同的大小，或者不必在网格中。###.updateProjectionMatrix():undefined更新摄像机投影矩阵。在任何参数被改变以后必须被调用。###.toJSON(meta:Object):Objectmeta--包含有元数据的对象，例如对象后代中的纹理或图像将摄像机转换为three.js[JSONObject/Sceneformat](https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4)（three.jsJSON物体/场景格式）。##源代码[src/cameras/PerspectiveCamera.js](https://github.com/mrdoob/three.js/blob/master/src/cameras/PerspectiveCamera.js)","Front-End\\可视化\\threejs\\API\\WebGLRenderer.md":"#WebGLRendererWebGLRender用[WebGL](https://en.wikipedia.org/wiki/WebGL)渲染出你精心制作的场景。##构造器###WebGLRenderer(parameters:Object)parameters-(可选)该对象的属性定义了渲染器的行为。也可以完全不传参数。在所有情况下，当缺少参数时，它将采用合理的默认值。以下是合法参数：>-canvas-一个供渲染器绘制其输出的[canvas](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)它和下面的domElement属性对应。如果没有传这个参数，会创建一个新canvas>-context-可用于将渲染器附加到已有的渲染环境([RenderingContext](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext))中。默认值是null>-precision-着色器精度.可以是**\"highp\"**,**\"mediump\"**或者**\"lowp\"**.如果设备支持，默认为**\"highp\"**.点击[here](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices)查看\"应该避免的事\">-alpha-canvas是否包含alpha(透明度)。默认为**false**>-premultipliedAlpha-renderer是否假设颜色有[premultipliedalpha](https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#Premultiplied_alpha).默认为**true**>-antialias-是否执行抗锯齿。默认为**false**.>-stencil-绘图缓存是否有一个至少8位的模板缓存([stencilbuffer](https://en.wikipedia.org/wiki/Stencil_buffer))。默认为**true**>-preserveDrawingBuffer-是否保留缓直到手动清除或被覆盖。默认**false**.>-powerPreference-提示用户代理怎样的配置更适用于当前WebGL环境。可能是**\"high-performance\"**,**\"low-power\"**或**\"default\"**。默认是**\"default\"**.详见[WebGLspec](https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12)>-failIfMajorPerformanceCaveat-whethertherenderercreationwillfailuponlowperfomanceisdetected.Defaultis**false**.See[WebGLspec](https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12)fordetails.>-depth-绘图缓存是否有一个至少6位的深度缓存([depthbuffer](https://en.wikipedia.org/wiki/Z-buffering))。默认是**true**.>-logarithmicDepthBuffer-是否使用对数深度缓存。如果要在单个场景中处理巨大的比例差异，就有必要使用。Notethatthissettingusesgl_FragDepthifavailablewhichdisablesthe[EarlyFragmentTest](https://www.khronos.org/opengl/wiki/Early_Fragment_Test)optimizationandcancauseadecreaseinperformance.默认是**false**。示例：camera/logarithmicdepthbuffer##属性###.autoClear:Boolean>定义渲染器是否在渲染每一帧之前自动清除其输出。###.autoClearColor:Boolean>如果autoClear为true,定义renderer是否清除颜色缓存。默认是**true**###.autoClearDepth:Boolean>如果autoClear是true,定义renderer是否清除深度缓存。默认是**true**###.autoClearStencil:Boolean>如果autoClear是true,定义renderer是否清除模板缓存.默认是**true**###.debug.checkShaderErrors:Boolean>如果checkShaderErrors为true，定义是否检查材质着色器程序编译和链接过程中的错误。禁用此检查生产以获得性能增益可能很有用。强烈建议在开发期间保持启用这些检查。如果着色器没有编译和链接-它将无法工作，并且相关材料将不会呈现。默认是**true**###.capabilities:Object>一个包含当前渲染环境([RenderingContext](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext))的功能细节的对象。>>-floatFragmentTextures:环境是否支持[OES_texture_float](https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float)扩展>-floatVertexTextures:如果floatFragmentTextures和vertexTextures都是true，则此值为**true**>-getMaxAnisotropy():返回最大可用各向异性。>-getMaxPrecision():返回顶点着色器和片元着色器的最大可用精度。>-isWebGL2:**true**ifthecontextinuseisaWebGL2RenderingContextobject.>-logarithmicDepthBuffer:如果logarithmicDepthBuffer在构造器中被设为true且环境支持[EXT_frag_depth](https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth)扩展，则此值为**true**>-maxAttributes:**gl.MAX_VERTEX_ATTRIBS**的值>-maxCubemapSize:**gl.MAX_CUBE_MAP_TEXTURE_SIZE**的值，着色器可使用的立方体贴图纹理的最大宽度\\*高度>-maxFragmentUniforms:**gl.MAX_FRAGMENT_UNIFORM_VECTORS**的值，片元着色器可使用的全局变量(uniforms)数量>-maxTextureSize:**gl.MAX_TEXTURE_SIZE**的值，着色器可使用纹理的最大宽度\\*高度>-maxTextures:\\*gl.MAX_TEXTURE_IMAGE_UNITS的值，着色器可使用的纹理数量>-maxVaryings:**gl.MAX_VARYING_VECTORS**的值，着色器可使用矢量的数量>-maxVertexTextures:**gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS**的值，顶点着色器可使用的纹理数量。>-maxVertexUniforms:**gl.MAX_VERTEX_UNIFORM_VECTORS**的值，顶点着色器可使用的全局变量(uniforms)数量>-precision:渲染器当前使用的着色器的精度>-vertexTextures:如果.maxVertexTextures:Integer大于0，此值为**true**(即可以使用顶点纹理)###.clippingPlanes:Array>用户自定义的剪裁平面，在世界空间中被指定为THREE.Plane对象。这些平面全局使用。空间中与该平面点积为负的点将被切掉。默认值是`[]`###.domElement:DOMElement>一个[canvas](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)，渲染器在其上绘制输出。>渲染器的构造函数会自动创建(如果没有传入canvas参数);你需要做的仅仅是像下面这样将它加页面里去:>`document.body.appendChild(renderer.domElement);`###.extensions:Object.extensions.get方法的包装,用于检查是否支持各种WebGL扩展###.outputEncoding:number定义渲染器的输出编码。默认为THREE.LinearEncoding如果渲染目标已经使用.setRenderTarget、之后将直接使用renderTarget.texture.encoding查看textureconstants页面以获取其他格式细节###.info:Object一个对象，包含有关图形板内存和渲染过程的一系列统计信息。这些信息可用于调试或仅仅满足下好奇心。改对象包含以下字段:-memory:-geometries-textures-render:-calls-triangles-points-lines-frame-programsBydefaultthesedataareresetateachrendercallbutwhenhavingmultiplerenderpassesperframe(e.g.whenusingpostprocessing)itcanbepreferredtoresetwithacustompattern.First,set**autoReset**to**false**.`renderer.info.autoReset=false;`Call**reset()**wheneveryouhavefinishedtorenderasingleframe.`renderer.info.reset();`###.localClippingEnabled:Boolean定义渲染器是否考虑对象级剪切平面。默认为**false**.###.physicallyCorrectLights:Boolean是否使用物理上正确的光照模式。默认是**false**。示例：[lights/physical](https://threejs.org/examples/#webgl_lights_physical)###.properties:Object渲染器内部使用，以跟踪各种子对象属性。###.renderLists:WebGLRenderLists在内部用于处理场景渲染对象的排序。###.shadowMap:WebGLShadowMap如果使用，它包含阴影贴图的引用。###.shadowMap.enabled:Boolean如果设置开启，允许在场景中使用阴影贴图。默认是**false**。###.shadowMap.autoUpdate:Boolean启用场景中的阴影自动更新。默认是**true**如果不需要动态光照/阴影,则可以在实例化渲染器时将之设为false###.shadowMap.needsUpdate:Boolean当被设为**true**,场景中的阴影贴图会在下次**render**调用时刷新。默认是**false**如果你已经禁用了阴影贴图的自动更新(**shadowMap.autoUpdate=false**),那么想要在下一次渲染时更新阴影的话就需要将此值设为**true**###.shadowMap.type:Integer定义阴影贴图类型(未过滤,关闭部分过滤,关闭部分双线性过滤)可选值有THREE.BasicShadowMap,THREE.PCFShadowMap(默认),THREE.PCFSoftShadowMap和THREE.VSMShadowMap。详见Rendererconstants###.sortObjects:Boolean定义渲染器是否应对对象进行排序。默认是**true**.说明:排序用于尝试正确渲染出具有一定透明度的对象。根据定义，排序可能不总是有用。根据应用的需求，可能需要关闭排序并使其他方法来处理透明度的渲染，例如，手动确定每个对象的显然顺序。###.state:Object包含设置WebGLRenderer.context状态的各种属性的函数。###.toneMapping:Constant默认是NoToneMapping。查看Rendererconstants以获取其它备选项###.toneMappingExposure:Number色调映射的曝光级别。默认是**1**###.xr:WebXRManagerProvidesaccesstotheWebXRrelatedinterfaceoftherenderer.##方法###.clear(color:Boolean,depth:Boolean,stencil:Boolean):undefined告诉渲染器清除颜色、深度或模板缓存.此方法将颜色缓存初始化为当前颜色。参数们默认都是**true**###.clearColor():undefined清除颜色缓存。相当于调用.clear(true,false,false)###.clearDepth():undefined清除深度缓存。相当于调用.clear(false,true,false)###.clearStencil():undefined清除模板缓存。相当于调用.clear(false,false,true)###.clearTarget(renderTarget:WebGLRenderTarget,color:Boolean,depth:Boolean,stencil:Boolean):undefinedrenderTarget--需要被清除的renderTargetcolor--如果设置,颜色会被清除depth--如果设置,深度缓存会被清除stencil--如果设置,模板缓存会被清除该方法清楚了一个rendertarget。为此它会激活此endertarget###.compile(scene:Object3D,camera:Camera):undefined使用相机编译场景中的所有材质。这对于在首次渲染之前预编译着色器很有用。###.copyFramebufferToTexture(position:Vector2,texture:FramebufferTexture,level:Number):undefined将当前WebGLFramebuffer中的像素复制到2D纹理中。可访问[WebGLRenderingContext.copyTexImage2D](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/copyTexImage2D).###.copyTextureToTexture(position:Vector2,srcTexture:Texture,dstTexture:Texture,level:Number):undefined将纹理的所有像素复制到一个已有的从给定位置开始的纹理中。可访问[WebGLRenderingContext.texSubImage2D](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texSubImage2D).###.dispose():undefined处理当前的渲染环境###.extensions.get(extensionName:String):Object用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息。该方法检查以下扩展：\\-**WEBGL_depth_texture**\\-**EXT_texture_filter_anisotropic**\\-**WEBGL_compressed_texture_s3tc**\\-**WEBGL_compressed_texture_pvrtc**\\-**WEBGL_compressed_texture_etc1**###.forceContextLoss():undefined模拟WebGL环境的丢失。需要支持[WEBGL_lose_context](https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context)扩展才能用。###.forceContextRestore():undefined模拟WebGL环境的恢复。需要支持[WEBGL_lose_context](https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context)扩展才能用。###.getClearAlpha():Float返回一个表示当前alpha值的float，范围0到1###.getClearColor(target:Color):Color返回一个表示当前颜色值的THREE.Color实例###.getContext():WebGLRenderingContext返回当前WebGL环境###.getContextAttributes():WebGLContextAttributes返回一个对象，这个对象中存有在WebGL环境在创建的时候所设置的属性###.getActiveCubeFace():IntegerReturnsthecurrentactivecubeface.###.getActiveMipmapLevel():IntegerReturnsthecurrentactivemipmaplevel.###.getRenderTarget():RenderTarget如果当前存在RenderTarget，则返回该值；否则返回**null**。###.getCurrentViewport():RenderTarget返回当前视口###.getDrawingBufferSize():Object返回一个包含渲染器绘图缓存宽度和高度(单位像素)的对象。###.getPixelRatio():number返回当前使用设备像素比###.getSize():Object返回包含渲染器输出canvas的宽度和高度(单位像素)的对象。###.initTexture(texture:Texture):undefinedInitializesthegiventexture.Usefulforpreloadingatextureratherthanwaitinguntilfirstrender(whichcancausenoticeablelagsduetodecodeandGPUuploadoverhead).###.resetGLState():undefined将GL状态重置为默认值。WebGL环境丢失时会内部调用###.readRenderTargetPixels(renderTarget:WebGLRenderTarget,x:Float,y:Float,width:Float,height:Float,buffer:TypedArray,activeCubeFaceIndex:Integer):undefinedbuffer-Uint8Arrayistheonlydestinationtypesupportedinallcases,othertypesarerenderTargetandplatformdependent.See[WebGLspec](https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12)fordetails.将enderTarget中的像素数据读取到传入的缓冲区中。这是[WebGLRenderingContext.readPixels](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels)()的包装器示例：[interactive/cubes/gpu](https://threejs.org/examples/#webgl_interactive_cubes_gpu)ForreadingoutaWebGLCubeRenderTargetusetheoptionalparameteractiveCubeFaceIndextodeterminewhichfaceshouldberead.###.render(scene:Object3D,camera:Camera):undefined用相机(camera)渲染一个场景(scene)或是其它类型的object。渲染一般是在canvas上完成的，或者是renderTarget(如果有指定)如果forceClear值是**true**，那么颜色、深度及模板缓存将会在渲染之前清除，即使渲染器的autoClear属性值是false即便forceClear设为true,也可以通过将autoClearColor、autoClearStencil或autoClearDepth属性的值设为false来阻止对应缓存被清除。###.resetState():undefinedCanbeusedtoresettheinternalWebGLstate.ThismethodismostlyrelevantforapplicationswhichshareasingleWebGLcontextacrossmultipleWebGLlibraries.###.setAnimationLoop(callback:Function):undefinedcallback—每个可用帧都会调用的函数。如果传入‘null’,所有正在进行的动画都会停止。可用来代替[requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)的内置函数.对于WebXR项目，必须使用此函数。###.setClearAlpha(alpha:Float):undefined设置alpha。合法参数是一个**0.0**到**1.0**之间的浮点数###.setClearColor(color:Color,alpha:Float):undefined设置颜色及其透明度###.setPixelRatio(value:number):undefined设置设备像素比。通常用于避免HiDPI设备上绘图模糊###.setRenderTarget(renderTarget:WebGLRenderTarget,activeCubeFace:Integer,activeMipmapLevel:Integer):undefinedrenderTarget--需要被激活的renderTarget(可选)。若此参数为空，则将canvas设置成活跃rendertarget。activeCubeFace--Specifiestheactivecubeside(PX0,NX1,PY2,NY3,PZ4,NZ5)ofWebGLCubeRenderTarget(optional).activeMipmapLevel--Specifiestheactivemipmaplevel(optional).该方法设置活跃rendertarget。###.setScissor(x:Integer,y:Integer,width:Integer,height:Integer):undefined将剪裁区域设为(x,y)到(x+width,y+height)Setsthescissorareafrom###.setScissorTest(boolean:Boolean):undefined启用或禁用剪裁检测.若启用，则只有在所定义的裁剪区域内的像素才会受之后的渲染器影响。###.setSize(width:Integer,height:Integer,updateStyle:Boolean):undefined将输出canvas的大小调整为(width,height)并考虑设备像素比，且将视口从(0,0)开始调整到适合大小将updateStyle设置为false以阻止对canvas的样式做任何改变。###.setViewport(x:Integer,y:Integer,width:Integer,height:Integer):undefined将视口大小设置为(x,y)到(x+width,y+height).##源码[src/renderers/WebGLRenderer.js](https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js)","Front-End\\可视化\\threejs\\API\\几何体\\BoxGeometry.md":"#立方缓冲几何体（BoxGeometry）BoxGeometry是四边形的原始几何类，它通常使用构造函数所提供的“width”、“height”、“depth”参数来创建立方体或者不规则四边形。<iframeid=\"scene\"src=\"https://threejs.org/docs/scenes/geometry-browser.html#BoxGeometry\"style=\"width:880px;height:420px;border:0px;color:rgb(187,187,187);font-family:Inter,sans-serif;font-size:18px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial;\"></iframe>##代码示例```jsconstgeometry=newTHREE.BoxGeometry(1,1,1)constmaterial=newTHREE.MeshBasicMaterial({color:0x00ff00})constcube=newTHREE.Mesh(geometry,material)scene.add(cube)```##构造器###BoxGeometry(width:Float,height:Float,depth:Float,widthSegments:Integer,heightSegments:Integer,depthSegments:Integer)>-width—X轴上面的宽度，默认值为1。>-height—Y轴上面的高度，默认值为1。>-depth—Z轴上面的深度，默认值为1。>-widthSegments—（可选）宽度的分段数，默认值是1。>-heightSegments—（可选）高度的分段数，默认值是1。>-depthSegments—（可选）深度的分段数，默认值是1。##属性共有属性请参见其基类BufferGeometry。###.parameters:Object一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。使用上面的示例代码来作为基础：```jsgeometry.parameters//outputsanobject{width:1,height:1,depth:1,widthSegments:undefined,heightSegments:undefined}cube.geometry.parameters//asabovecube.geometry.parameters.width//===1cube.geometry.parameters.widthSegments//===undefined.```##方法(Methods)共有方法请参见其基类BufferGeometry。##源代码[src/geometries/BoxGeometry.js](https://github.com/mrdoob/three.js/blob/master/src/geometries/BoxGeometry.js)![img](https://threejs.org/files/ic_mode_edit_black_24dp.svg)","Front-End\\可视化\\threejs\\API\\几何体\\CircleGeometry.md":"#圆形缓冲几何体（CircleGeometry）CircleGeometry是欧式几何的一个简单形状，它由围绕着一个中心点的三角分段的数量所构造，由给定的半径来延展。同时它也可以用于创建规则多边形，其分段数量取决于该规则多边形的边数。<iframeid=\"scene\"src=\"https://threejs.org/docs/scenes/geometry-browser.html#CircleGeometry\"style=\"width:880px;height:420px;border:0px;color:rgb(187,187,187);font-family:Inter,sans-serif;font-size:18px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial;\"></iframe>##代码示例```jsconstgeometry=newTHREE.CircleGeometry(5,32)constmaterial=newTHREE.MeshBasicMaterial({color:0xffff00})constcircle=newTHREE.Mesh(geometry,material)scene.add(circle)```##构造器###CircleGeometry(radius:Float,segments:Integer,thetaStart:Float,thetaLength:Float)radius—圆形的半径，默认值为1segments—分段（三角面）的数量，最小值为3，默认值为8。thetaStart—第一个分段的起始角度，默认为0。（threeo'clockposition）thetaLength—圆形扇区的中心角，通常被称为“θ”（西塔）。默认值是2\\*Pi，这使其成为一个完整的圆。##属性共有属性请参见其基类BufferGeometry。###.parameters:Object一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。##方法(Methods)共有方法请参见其基类BufferGeometry。##源代码[src/geometries/CircleGeometry.js](https://github.com/mrdoob/three.js/blob/master/src/geometries/CircleGeometry.js)","Front-End\\可视化\\threejs\\API\\几何体\\DodecahedronGeometry.md":"#十二面缓冲几何体（DodecahedronGeometry）一个用于创建十二面几何体的类。<iframeid=\"scene\"src=\"https://threejs.org/docs/scenes/geometry-browser.html#DodecahedronGeometry\"style=\"width:880px;height:420px;border:0px;color:rgb(187,187,187);font-family:Inter,sans-serif;font-size:18px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial;\"></iframe>##构造器###DodecahedronGeometry(radius:Float,detail:Integer)radius—十二面体的半径，默认值为1。detail—默认值为0。将这个值设为一个大于0的数将会为它增加一些顶点，使其不再是一个十二面体。##属性共有属性请参见其基类PolyhedronGeometry。###.parameters:Object一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。##方法(Methods)共有方法请参见其基类PolyhedronGeometry。##源代码[src/geometries/DodecahedronGeometry.js](https://github.com/mrdoob/three.js/blob/master/src/geometries/DodecahedronGeometry.js)","Front-End\\可视化\\threejs\\API\\材质\\LineBasicMaterial.md":"#基础线条材质（LineBasicMaterial）一种用于绘制线框样式几何体的材质。##代码示例```jsconstmaterial=newTHREE.LineBasicMaterial({color:0xffffff,linewidth:1,linecap:'round',//ignoredbyWebGLRendererlinejoin:'round',//ignoredbyWebGLRenderer})```##例子[WebGL/buffergeometry/drawrange](https://threejs.org/examples/#webgl_buffergeometry_drawrange)[WebGL/buffergeometry/lines](https://threejs.org/examples/#webgl_buffergeometry_lines)[WebGL/buffergeometry/lines/indexed](https://threejs.org/examples/#webgl_buffergeometry_lines_indexed)[WebGL/decals](https://threejs.org/examples/#webgl_decals)[WebGL/geometry/nurbs](https://threejs.org/examples/#webgl_geometry_nurbs)[WebGL/geometry/shapes](https://threejs.org/examples/#webgl_geometry_shapes)[WebGL/geometry/spline/editor](https://threejs.org/examples/#webgl_geometry_spline_editor)[WebGL/interactive/buffergeometry](https://threejs.org/examples/#webgl_interactive_buffergeometry)[WebGL/interactive/voxelpainter](https://threejs.org/examples/#webgl_interactive_voxelpainter)[WebGL/lines/colors](https://threejs.org/examples/#webgl_lines_colors)[WebGL/lines/dashed](https://threejs.org/examples/#webgl_lines_dashed)[WebGL/lines/sphere](https://threejs.org/examples/#webgl_lines_sphere)[WebGL/materials](https://threejs.org/examples/#webgl_materials)[physics/ammo/rope](https://threejs.org/examples/#physics_ammo_rope)##构造函数(Constructor)###LineBasicMaterial(parameters:Object)parameters-(可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。属性color例外，其可以作为十六进制字符串传递，默认情况下为**0xffffff**（白色），内部调用Color.set(color)。##属性(Properties)共有属性请参见其基类Material。###.color:Color材质的颜色(Color)，默认值为白色(0xffffff)。###.linewidth:Float控制线宽。默认值为**1**。由于[OpenGLCoreProfile](https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf)与大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。###.linecap:String定义线两端的样式。可选值为'butt','round'和'square'。默认值为'round'。该属性对应[2DCanvaslineCap](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap)属性，并且会被WebGL渲染器忽略。###.linejoin:String定义线连接节点的样式。可选值为'round','bevel'和'miter'。默认值为'round'。该属性对应[2DCanvaslineJoin](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineJoin)属性，并且会被WebGL渲染器忽略。##方法(Methods)共有方法请参见其基类Material。##源码(Source)[src/materials/LineBasicMaterial.js](https://github.com/mrdoob/three.js/blob/master/src/materials/LineBasicMaterial.js)","Front-End\\可视化\\threejs\\API\\材质\\LineDashedMaterial.md":"#虚线材质(LineDashedMaterial)一种用于绘制虚线样式几何体的材质。##代码示例```jsconstmaterial=newTHREE.LineDashedMaterial({color:0xffffff,linewidth:1,scale:1,dashSize:3,gapSize:1,})```##例子[WebGL/lines/dashed](https://threejs.org/examples/#webgl_lines_dashed)##构造函数(Constructor)###LineDashedMaterial(parameters:Object)parameters-(可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从LineBasicMaterial继承的任何属性)。##属性(Properties)共有属性请参见其基类LineBasicMaterial。###.dashSize:number虚线的大小，是指破折号和间隙之和。默认值为**3**。###.gapSize:number间隙的大小，默认值为**1**。###.scale:number线条中虚线部分的占比。默认值为**1**。##方法(Methods)共有方法请参见其基类LineBasicMaterial。##源码(Source)[src/materials/LineDashedMaterial.js](https://github.com/mrdoob/three.js/blob/master/src/materials/LineDashedMaterial.js)","Front-End\\可视化\\threejs\\API\\材质\\MeshMatcapMaterial.md":"#MeshMatcapMaterialMeshMatcapMaterial由一个材质捕捉（MatCap，或光照球（LitSphere））纹理所定义，其编码了材质的颜色与明暗。由于mapcap图像文件编码了烘焙过的光照，因此MeshMatcapMaterial不对灯光作出反应。它将会投射阴影到一个接受阴影的物体上(andshadowclippingworks)，但不会产生自身阴影或是接受阴影。<iframeid=\"scene\"src=\"https://threejs.org/docs/scenes/material-browser.html#MeshMatcapMaterial\"style=\"width:880px;height:420px;border:0px;color:rgb(187,187,187);font-family:Inter,sans-serif;font-size:18px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial;\"></iframe>##构造函数(Constructor)###MeshMatcapMaterial(parameters:Object)parameters-(可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。属性color例外，其可以作为十六进制字符串传递，默认情况下为**0xffffff**（白色），内部调用Color.set(color)。##属性(Properties)共有属性请参见其基类Material。###.alphaMap:Texturealpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。默认值为null。仅使用纹理的颜色，忽略alpha通道（如果存在）。对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB565格式中为绿色提供了额外的精度。Luminance-only以及luminance/alpha纹理也仍然有效。###.bumpMap:Texture用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。###.bumpScale:Float凹凸贴图会对材质产生多大影响。典型范围是0-1。默认值为1。###.color:Color材质的颜色(Color)，默认值为白色(0xffffff)。###.displacementMap:Texture位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象，以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。###.displacementScale:Float位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。###.displacementBias:Float位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为0。###.flatShading:Boolean定义材质是否使用平面着色进行渲染。默认值为false。###.map:Texture颜色贴图。默认为null。纹理贴图颜色由漫反射颜色.color调节。###.matcap:Texturematcap贴图，默认为null。###.normalMap:Texture用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。Incasethematerialhasanormalmapauthoredusingthelefthandedconvention,theycomponentofnormalScaleshouldbenegatedtocompensateforthedifferenthandedness.###.normalMapType:Integer法线贴图的类型。选项为THREE.TangentSpaceNormalMap（默认）和THREE.ObjectSpaceNormalMap。###.normalScale:Vector2法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）。##方法(Methods)共有方法请参见其基类Material。##源码(Source)[src/materials/MeshMatcapMaterial.js](https://github.com/mrdoob/three.js/blob/master/src/materials/MeshMatcapMaterial.js)","Front-End\\可视化\\threejs\\API\\渲染器\\CSS3DRenderer.md":"#CSS3D渲染器（CSS3DRenderer）CSS3DRenderer用于通过CSS3的[transform](https://www.w3schools.com/cssref/css3_pr_transform.asp)属性，将层级的3D变换应用到DOM元素上。如果你希望不借助基于canvas的渲染来在你的网站上应用3D变换，那么这一渲染器十分有趣。同时，它也可以将DOM元素与WebGL的内容相结合。然而，这一渲染器也有一些十分重要的限制：-它不可能使用**three.js**中的材质系统。-同时也不可能使用几何体。因此，CSS3DRenderer仅仅关注普通的DOM元素，这些元素被包含到了特殊的对象中（**CSS3DObject**或者**CSS3DSprite**），然后被加入到场景图中。##例子[molecules](https://threejs.org/examples/#css3d_molecules)[orthographiccamera](https://threejs.org/examples/#css3d_orthographic)[periodictable](https://threejs.org/examples/#css3d_periodictable)[sprites](https://threejs.org/examples/#css3d_sprites)##构造函数###CSS3DRenderer()##方法###.getSize():Object返回一个包含有渲染器宽和高的对象。###.render(scene:Scene,camera:PerspectiveCamera):undefined使用perspectivecamera渲染scene。###.setSize(width:Number,height:Number):undefined将渲染器尺寸重新调整为(width,height)。##源代码[examples/jsm/renderers/CSS3DRenderer.js](https://github.com/mrdoob/three.js/blob/master/examples/jsm/renderers/CSS3DRenderer.js)","Front-End\\可视化\\threejs\\three.md":"#threejs>[three.js](https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene)","Front-End\\可视化\\threejs\\threejs.md":"#Three><https://threejs.org/docs/>##React使用```jsimportReactfrom'react'import*asTHREEfrom'three'classIndexextendsReact.Component{mdom:any=React.createRef()componentDidMount(){constscene=newTHREE.Scene()constcamera=newTHREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,1000)constrenderer=newTHREE.WebGLRenderer()renderer.setSize(window.innerWidth-100,window.innerHeight-100)this.mdom.current.appendChild(renderer.domElement)//document.body.appendChild(renderer.domElement)constgeometry=newTHREE.BoxGeometry()constmaterial=newTHREE.MeshBasicMaterial({color:0x00ff00})constcube=newTHREE.Mesh(geometry,material)scene.add(cube)camera.position.z=5functionanimate(){requestAnimationFrame(animate)cube.rotation.x+=0.01cube.rotation.y+=0.01renderer.render(scene,camera)}animate()}render():React.ReactNode{//return<></>return<divref={this.mdom}id='WebGL-output'></div>}}exportdefaultIndex```","Front-End\\工具库\\工具库.md":"#[`工具库`](/)##@logicflow/core-流程图编辑器框架![](./.assets/工具库-2024-07-31-15-06-21.png)![](./.assets/工具库-2024-07-31-15-07-01.png)##NProgress-进度条-展示页面加载的进度/路由跳转的进度##tesseract.js-识别图片文字##sharp-图像格式转换-将常见格式的大型图像转换为较小的、网络友好的JPEG、PNG、WebP、GIF和不同维度的AVIF图像##Fastify-服务器框架-[介绍](https://zhuanlan.zhihu.com/p/684317580)##[react-image-crop](https://www.npmjs.com/package/react-image-crop)-上传图片剪辑-[codesandbox(inlinepreview)](https://codesandbox.io/p/sandbox/react-image-crop-demo-with-react-hooks-y831o?file=%2Fsrc%2FcanvasPreview.ts%3A1%2C28-1%2C44)-[react-image-crop](https://www.npmjs.com/package/react-image-crop)","Front-End\\微前端\\Garfish.md":"#Carfish<https://www.garfishjs.org/guide>","Front-End\\微前端\\icestark.md":"#icestark<https://micro-frontends.ice.work/docs/guide>","Front-End\\微前端\\qiankun\\index.md":"#qiankun<https://github.com/umijs/qiankun/discussions/1378>","Front-End\\拓展\\CORS.md":"#CORS>**CORS**（Cross-OriginResourceSharing，跨域资源共享）是一个系统，它由一系列传输的[HTTP头](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_header)组成，这些HTTP头决定浏览器是否阻止前端JavaScript代码获取跨域请求的响应。>>[同源安全策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)默认阻止“跨域”获取资源。但是CORS给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源##[Access-Control-Allow-Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)>指示请求的资源能共享给哪些域。>>`Headertype`:`Responseheader`>>`Access-Control-Allow-Origin:*`//允许所有资源都可以访问您的资源,>`Access-Control-Allow-Origin:https://developer.mozilla.org`//允许<https://developer.mozilla.org>访问您的资源##[Access-Control-Allow-Credentials](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)>指示当请求的凭证标记为true时，是否响应该请求。>>响应头表示是否可以将对请求的响应暴露给页面,返回true可以,其他值均不可以;>>`Headertype`:`Responseheader`>>Credentials可以是cookies,authorizationheaders或TLSclientcertificates。>>当作为对预检请求的响应的一部分时，这能表示是否真正的请求可以使用credentials。>>注意简单的`GET`请求没有预检，所以若一个对资源的请求带了credentials，如果这个响应头没有随资源返回，响应就会被浏览器忽视，不会返回到web内容。允许credentials:```Access-Control-Allow-Credentials:true```使用带credentials的[XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)：```varxhr=newXMLHttpRequest();xhr.open('GET','http://example.com/',true);xhr.withCredentials=true;xhr.send(null);```CopytoClipboard使用带credentials的[Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)：```jsfetch(url,{credentials:'include',})```##[Access-Control-Allow-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers)>用在对预请求的响应中，指示实际的请求中可以使用哪些HTTP头。>>响应首部**`Access-Control-Allow-Headers`**用于[preflightrequest](https://developer.mozilla.org/zh-CN/docs/Glossary/Preflight_request)（预检请求）中，列出了将会在正式请求的[Access-Control-Request-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers)字段中出现的首部信息。>>简单首部，如[simpleheaders](https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header)、[Accept](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)、[Accept-Language](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language)、[Content-Language](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language)、[Content-Type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)（只限于解析后的值为`application/x-www-form-urlencoded、multipart/form-data`或`text/plain三种MIME类型（不包括参数）），它们始终是被支持的，不需要在这个首部特意列出。`>>```xml>Access-Control-Allow-Headers:<header-name>[,<header-name>]*>Access-Control-Allow-Headers:*>```>>`<header-name>`:可支持的请求首部名字。请求头会列出所有支持的首部列表，用逗号隔开。##[Access-Control-Allow-Methods](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods)>指定对预请求的响应中，哪些HTTP方法允许访问请求的资源。>>`Access-Control-Allow-Methods:<method>,<method>,...`>>`Access-Control-Allow-Methods:POST,GET,OPTIONS`>>`<method>`:GET,POST,HEAD,PUT,DELETE,CONNECT,OPTIONS,TRACE,PATCH##[Access-Control-Expose-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers)>指示哪些HTTP头的名称能在响应中列出>>`Access-Control-Expose-Headers:<header-name>,<header-name>,...`>>默认情况七种`simpleresponseheaders`>>-[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)>-[Content-Language](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language)>-[Content-Length](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length)>-[Content-Type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)>-[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)>-[Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)>-[Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma)##[Access-Control-Max-Age](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age)>指示预请求的结果能被缓存多久。(即[Access-Control-Allow-Methods](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods)和[Access-Control-Allow-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers)提供的信息）可以被缓存多久。)>>`Access-Control-Max-Age:<delta-seconds>`>>`<delta-seconds>`>>-返回结果可以被缓存的最长时间（秒）。>在Firefox中，[上限是24小时](https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131)（即86400秒）。>在Chromiumv76之前，[上限是10分钟](https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e)（即600秒)。>从Chromiumv76开始，[上限是2小时](https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=31&rcl=49e7c0b4886cac1f3d09dc046bd528c9c811a0fa)（即7200秒)。>Chromium同时规定了一个默认值5秒。>如果值为**-1**，表示禁用缓存，则每次请求前都需要使用OPTIONS预检请求。##[Access-Control-Request-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers)>用于发起一个预请求，告知服务器正式请求会使用那些HTTP头。>>`Access-Control-Request-Headers:<header-name>,<header-name>,...`>>`Access-Control-Request-Headers:X-PINGOTHER,Content-Type`##[Access-Control-Request-Method](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method)>用于发起一个预请求，告知服务器正式请求会使用哪一种[HTTP请求方法](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)。>>`Access-Control-Request-Method:<method>`>>`Access-Control-Request-Method:POST`##[Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin)>指示获取资源的请求是从什么域发起的>>`Origin:\"\"`>>`Origin:<scheme>\"://\"<host>[\":\"<port>]`>>`Origin:https://developer.mozilla.org`>>-`<scheme>`:请求所使用的的协议,通常是HTTP协议或他的安全版本HTTPS协议>-`<host>`:服务器的域名或IP地址>-`<port>`:(可选)服务器正在监听的TCP端口号,缺省为服务的默认蹲坑(HTTP请求而言,默认端口为80)##[Vary-HTTP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary)>`Headertype`:`Responseheader`>>`Vary:*`:所有请求都被视为唯一并且非缓存>>-使用`Cache-Control:no-store`:实现更加使用>>`Vary:<header-name>,<header-name>...`:都好分隔的一系列http头部名称,用户确定缓存是否可用>>动态服务:>>-`Vary:User-Agent`:可以防止客户端使用了桌面端的缓存##Responseheader响应头>响应头(Responseheader):定义为被用于http响应中并且和相应信息主题无关的那一类HTTPheader```xml200OKAccess-Control-Allow-Origin:*Connection:Keep-AliveContent-Encoding:gzipContent-Type:text/html;charset=utf-8Date:Mon,18Jul201616:06:00GMTEtag:\"c561c68d0ba92bbeb8b0f612a9199f722e3a621a\"Keep-Alive:timeout=5,max=997Last-Modified:Mon,18Jul201602:36:04GMTServer:ApacheSet-Cookie:mykey=myvalue;expires=Mon,17-Jul-201716:06:00GMT;Max-Age=31449600;Path=/;secureTransfer-Encoding:chunkedVary:Cookie,Accept-EncodingX-Backend-Server:developer2.webapp.scl3.mozilla.comX-Cache-Info:notcacheable;metadatatoolargeX-kuma-revision:1085259x-frame-options:DENY```###Age>`Age:<delta-seconds>`:表示对象在缓存代理服务器中存储的时长(单位秒)[delta-seconds非负整数]###Location>`Headertype`:`Responseheader`>>`Location`首部指定的是需要将页面重新定向至的地址。一般在响应码为3xx的响应中才会有意义。>>发送新请求，获取Location指向的新页面所采用的方法与初始请求使用的方法以及重定向的类型相关：>>-[303](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303)(SeeAlso)始终引致请求使用[GET](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)方法，而，而[307](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307)(TemporaryRedirect)和[308](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/308)(SeeAlso)始终引致请求使用[GET](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)方法，而，而[307](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307)(TemporaryRedirect)和[308](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/308)(PermanentRedirect)则不转变初始请求中的所使用的方法；>-[301](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301)(PermanentRedirect)和[302](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302)(Found)在大多数情况下不会转变初始请求中的方法，不过一些比较早的用户代理可能会引发方法的变更（所以你基本上不知道这一点）。>>状态码为上述之一的所有响应都会带有一个Location首部。>>除了重定向响应之外，状态码为[201](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/201)(Created)的消息也会带有Location首部。它指向的是新创建的资源的地址。>>[Location](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location)与`Content-Location`是不同的，前者（[Location](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location)）指定的是一个重定向请求的目的地址（或者新创建的文件的URL），而后者（`Content-Location`）指向的是经过内容协商后的资源的直接地址，不需要进行进一步的内容协商。Location对应的是响应，而Content-Location对应的是要返回的实体。```Location:<url>Location:/index.html-url:相对地址（相对于要访问的URL）或绝对地址。```###Server>`Headertype`:`Responseheader`>>Server:首部包含请求的源头服务器所用到的软件相关信息>>-尽量避免使用过长或者过于信息的描述作为Server的值,太长容易泄漏服务器的内部实现细节,容易被通过已知安全漏洞攻击,不安全>>`Server:<product>`>>`Server:Apache/2.4.1(Unix)`>>`<product>`:处理请求的软件或产品或组件产品的名称##禁止修改的消息首部>禁止修改的消息首部:不能再代码中修改的HTTP协议消息首部>>用户代理对这些消息首部保留全部控制权,应用程序无法设置它们>>`User-Agent`:以及从列表冲移除禁止修改消息首部包括Proxy-和Sec-开头的消息首部,以及```xmlAccept-CharsetAccept-EncodingAccess-Control-Request-HeadersAccess-Control-Request-MethodConnectionContent-LengthCookieCookie2DateDNTExpectHostKeep-AliveOriginProxy-Sec-RefererTETrailerTransfer-EncodingUpgradeVia```","Front-End\\拓展\\css-in-js\\特点.md":"#`css-in-js`>`css-in-js`作为一个理念较新的开发思路，拥有如下几个明显的优缺点。优点：>无全局样式冲突。就像js文件天然支持模块化的好处一样，原生css因为没有模块化能力，天然容易导致全局样式污染，如果不是特意用BEM方式命名，想要避免冲突就只能借助`css-in-js`了。（css-modules也一样能做到）>与js代码合在一起。天然融合进js代码方便模块化管理，使css可以与某个局部模块绑定。（css-modules也一样能做到，只是必须单独拆一个样式文件）>能将js变量应用到样式上。虽然css变量也能解决这个问题，但不如`css-in-js`那么直观，inline-style也能解决这个问题，但会产生大量重复的局部样式，且这个优势`css-modules`做不到。>缺点：>`css-in-js`运行时解析的实现版本增加了运行时性能压力，尤其在`React18`调度机制模式下，存在无法解决的性能问题（运行时插入样式会导致React渲染暂停，浏览器解析一遍样式，渲染再继续，然后浏览器又解析一遍样式）。>增加了包体积。相比原生或者css-modules方案来说，增加了运行时框架代码8kb左右。>让ReactDevTools结构变得复杂，因为`css-in-js`会包裹额外的React组件层用来实现样式插入。>除了上述缺点外，`css-in-js`还有三点深度使用后才能察觉的坑：多个不同（甚至是相同）版本的`css-in-js`库同时加载时可能导致错误。笔者用styled-components就遇到了类似问题，甚至语法会产生不兼容的情况，虽然这些问题都可以被解决，但花费的额外时间需要计算一样，相比`css-in-js`得到的收益是否值得。样式插入优先级无法自定义，这就导致产生样式覆盖时，业务对样式覆盖的优先级无法产生稳定的预期。class优先级由header定义顺序决定，而非className的字符顺序决定，而header定义顺序又由资源加载与`css-in-js`插入执行时机决定，导致业务几乎不可能有稳定的样式覆盖顺序。这里产生的问题就是业务代码不断增多的!important定义。不同React版本的SSR，`css-in-js`需要适配不同的实现，这对框架作者不太友好。除了性能问题以外，其他问题都可以忍，但偏偏在性能问题上，`css-in-js`遇到了无解的场景。无解的性能问题第一条缺点提到的运行时解析，是`css-in-js`方案永远跨不过去的困境，即便对于编译时`css-in-js`方案来说，也免不了在渲染时做额外的逻辑执行拖慢渲染速度：```jsfunctionApp(){return<divcss={{color:'red'}}/>//就是这种代码导致了性能问题}```原因是当React重渲染组件时，需要重新解析样式定义，并序列化className，当渲染非常频繁时会导致明显的性能瓶颈，而解决方法是把样式定义抽出来，但这样就损失了第三个优点，即无法读取js变量了：```jsconstmyCss=css({backgroundColor:'blue',width:100,height:100,})```不得不的说React的渲染机制实在是太有问题了，如果换成`SolidJS`这个问题就好办了，因为运行时的样式代码仅会运行一次，组件重渲染也不会导致这段解析代码被重复执行，此时`css-in-js`在样式变化时再做一次精确样式更新，性能问题就可以被解决了。-换成`cssmodules`>`css-modules`同时支持优点一和二，而优点三可以通过一些特定语法糖绕过：通过:import:export伪类做css变量的导入导出，用`webpack-loader`实现js中引用css变量，用cssvariable实现css引用js变量。>所以当性能问题是绕不过去的话题，而css-modules在性能最优的情况下，有一些曲线方案可以同时支持`css-in-js`的优点，也就能理解为什么作者要弃用`css-in-js`了。-包体积真的变大了吗>原文谈到的`css-in-js`增加了8~16kb其实是在强行堆缺点了，除非你的项目只有一行css定义。如果我们只考虑传输时的包体积与HTML中样式定义数量，而忽略运行时产生的性能负担，那么`css-in-js`在大型项目无疑是最优的。>原因就是`css-in-js`样式是按需插入的，没有渲染的组件就不会插入样式。甚至渲染了的组件也不一定会插入样式，因为`css-in-js`可以对包含相同样式定义的场景做className合并，类似于webpack打包时，可以把不同模块公共代码抽到一个chunk里。-编译时`css-in-js`方案是出路吗>理论上是出路，但限制了`css-in-js`的灵活性。从vanilla-extract等编译时`css-in-js`框架来看，确实解决了运行时`css-in-js`性能问题，但带来了更多语法限制，比如必须预先定义样式再使用：```jsximport{style}from'@vanilla-extract/css'constmyStyle=style({display:'flex',paddingTop:'3px',})constApp=()=><divclassName={myStyle}/>```编译时`css-in-js`想要做到通用性，只能提供一个className，这样就不受任何框架和环境的限制了，但这样也限制了声明语法的灵活性，显然不可以用内连方式定义样式。而且这种编译时的方案本质上和css-modules是一样的，背后都是定义了一些静态样式名，只是说这些样式问题以.sass定义还是.ts定义，如果用.ts定义，配合编译工具可以使代码原生import的更加舒服。所以使用了编译时`css-in-js`方案，本质上还是抛弃了运行时`css-in-js`，投向了变种的css-modules阵营。##总结>`css-in-js`本身方向是对的，即把css与js融合，但太过灵活的运行时`css-in-js`方案遇到了几乎不可解的性能问题，编译时的`css-in-js`方案可能是更好的出路。>`css-in-js`这个名字本身就表示它拥有injs的灵活性，而编译时`css-in-js`方案本质因为是css-module，所以不可避免拥有一些比较奇怪的限制，如果js里的代码不能像真的js一样灵活，可能还不如回到.scss或者.less的后缀更好理解一些。","Front-End\\拓展\\js垃圾回收机制.md":"#js垃圾回收机制```mermaidgraphLRA(JS垃圾回收机制)-->B(内存泄漏理解)A-->C(垃圾回收机制)A-->D(内存泄漏识别)```##内存泄漏>-程序的运行需要内存，当程序提出要求，操作系统就会供给内存。>-对于不再用到的内存，没有及时释放，就叫做内存泄漏。>-对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。##垃圾回收机制>JavaScript具有垃圾收集器，垃圾收集器会按照固定的时间间隔周期性的执行。>>-最常见的垃圾回收方式有两种：标记清除,引用计数###标记清除>原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。去掉环境中的变量以及被环境中的变量引用的变量的标记。再被加上标记的会被视为准备删除的变量。垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。###引用计数>原理：跟踪记录每个值被引用的次数。声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1。当引用次数变成0时，说明没办法访问这个值了。当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。（注意：当循环引用的时候就会释放不掉内存。）##观察内存泄漏>如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。可以浏览器查看内存占用。通过命令行，命令行可以使用Nodeprocess.memoryUsage提供的方法。process.memoryUsage返回一个对象，包含了Node进程的内存占用信息。（判断内存泄漏，以heapUsed字段为准。）四、总结内存没有释放或释放及时会造成内存泄漏。垃圾回收机制的常用方式是标记清除和引用计数。查看内存泄漏可以通过浏览器和命令行的方式。","Front-End\\拓展\\优化\\css 通配符.md":"#[`*通配符`](/)```css*{margin:0px;padding:0px;}```-上面的代码虽然能实现所有标签的样式初始化,但是通配符选择器匹配页面上的每一个元素。在大型或结构复杂的网页中，这可能意味着成百上千甚至上万个元素。-浏览器的CSS引擎在处理这样的选择器时，需要遍历整个DOM树，对每个元素进行检查和匹配，这无疑增加了计算负担，可能导致页面渲染变慢，尤其是初次加载时。-可以使用以下代码替代```csshtml,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;}/*HTML5display-roleresetforolderbrowsers*/article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block;}body{line-height:1;}ol,ul{list-style:none;}blockquote,q{quotes:none;}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none;}table{border-collapse:collapse;border-spacing:0;}```","Front-End\\拓展\\优化\\index.md":"#优化##文档碎片-`DocumentFragment`是一个非常有用的DOM接口，它被用于创建一个轻量级的文档对象，它的独特之处在于它不会被渲染到页面中，但可以包含各种DOM节点。这种方法可以用于优化DOM操作，因为它可以减少页面上的回流和重绘次数。```jsletcontent=document.createDocumentFragment()constlist_item=document.querySelector('.list')for(leti=0;i<10000;i++){letli=document.createElement('li')li.innerHTML='我是小丽'content.appendChild(li)}container.appendChild(content)```-同样避免了dom节点的频繁操作，而且在语义结构上更加的丰富和完善##减少回流操作-回流是指浏览器为了重新渲染部分或全部文档而重新计算元素的位置和尺寸的过程。在回流过程中，浏览器会根据各种样式属性（如宽高、边距、填充、边框等）重新计算元素的位置和大小，然后绘制到屏幕上。(这是比较消耗时间的)-触发回流操作-DOM元素的添加、删除或修改：任何对DOM结构的改变都会导致回流。-样式计算：修改元素的样式属性（如宽高、边距、填充等）可能导致回流。-尺寸调整：调整浏览器窗口大小或添加/删除滚动条也会触发回流。-获取某些属性：读取某些属性（如offsetWidth、offsetHeight、scrollTop等）时，浏览器可能需要回流来确保返回最新的值。```jsfor(leti=0;i<10000;i++){document.querySelector('.list').innerHTML+=`<li>我是小丽</li>`}```-`document.querySelector('.list')`应当提出到循环外面用变量保存，不然每次都需要重新进行选择-减少操作原生dom的次数，不能像循环中一样每次循环操作一次。争取一次性操作完成，可以像下面这样```jsconstlist_item=document.querySelector('.list')letstr=''for(leti=0;i<10000;i++){str+=`<li>我是小丽</li>`}list_item.innerHTML=str```##避免直接使用标签选择器```html<ulclass=\"list\"><liclass=\"list-item\"></li></ul>ul*10>li*10//这里代表着10个ul里面每个都拥有10个li标签```-优先使用class选择器使用,减少标签选择性使用","Front-End\\拓展\\内存.md":"#内存##内存泄露和和内存溢出内存溢出-是一种程序运行出现的错误-但程序运行所需内存超过计算机剩余内存时,程序崩溃,并报出内存溢出的错误内存泄露-指内存被占用且没有及时释放-内存泄露越多,计算机剩余的内存就越小,此时越容易发生内存溢出-常见的内存泄露情况-意外的全局变量-未及时清理计时器或回调函数-闭包```jsfunctionx(){a=10//或者this.a=10;//或者window.a=10;}x()//产生了一个意外的全局变量``````jsvarintervald=setInterval(function(){console.log('----');},1000);//清除计时器clearInterval(intervalId);-----------------------------------------varelement=document.getElementById('button');functiononClick(event){element.innerHtml='text';}element.addEventListener('click',onClick);element.removeEventListener('click',onClick);element.parentNode.removeChild(element);``````jsfunctiona(){varx=10functionb(){returnx}returnb}varf=a()f()//将内部函数对象设置为垃圾对象f=null```","Front-End\\拓展\\前后端交互\\ajax.md":"#ajax>-全称`AsynchronousJavaScriptandXML`>-主要实现`获取促进->处理数据->展示数据````jsfunctionajaxRequest(){//实例化一个XMLHttpRequest对象varxhr=newXMLHttpRequest()//open()规定请求的类型、url、是否异步xhr.open('GET','https://www.w3cschool.cn/statics/demosource/ajax_info.txt',true,)xhr.send()//send()发送请求，必须结合open一起使用xhr.onreadystatechange=function(){//监测服务器响应的状态if(xhr.readyState===4&&xhr.status===200){//当readyState等于4且状态为200时，表示成功响应document.getElementById('view').innerHTML=xhr.responseText}}}```##ajax和flash的优缺点```AjaxAjax的优势：1.可搜索性2.开放性3.费用4.易用性5.易于开发。Ajax的劣势：1.它可能破坏浏览器的后退功能2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中，不过这些都有相关方法解决。FlashFlash的优势：1.多媒体处理2.兼容性3.矢量图形4.客户端资源调度Flash的劣势：1.二进制格式2.格式私有3.flash文件经常会很大，用户第一次使用的时候需要忍耐较长的等待时间4.性能问题```##优缺点优点：1.页面无刷新更新，用户的体验非常好；2.异步通信，响应更快3.可以将一些服务器工作转移到客户端，利用客户端资源来处理，减轻服务器和带宽的压力，节约空间和带宽租用成本；4.技术标准化，并被`浏览器广泛支持`，不需要下载插件或者小程序；5.Ajax可使因特网应用程序更小、更快、更友好。缺点：1.Ajax不支持浏览器back返回按钮；2.有安全问题，Ajax暴露了与服务器交互的细节；3.对搜索引擎不友好；4.破坏了程序的异常机制；5.不容易调试。##同源策略>**一个URL地址可以有以下几个组成部分：**`scheme`**://**`host`**:**`post`**/**`path`**?**`query`**#**`fragment`>>-**scheme**：通信协议，一般为http、https；>-**host**：域名；>-**post**：端口号，此项为可选项，http协议默认的端口号为80，https协议默认的端口号为443；>-**path**：路径，由\"/\"隔开的字符串；>-**query**：查询参数，此项为可选项；>-**fragment**：信息片段，用于指定网络资源中的某片断，此项为可选项；###同源>-URL地址动的协议,域名,端口都相同,不相同就会产生跨域>-只能和同源的后端接口进行数据交互###跨域处理>-JSONP技术>-服务端代理>-通过修改window.name实现跨域>-使用HTML5中新引进的window.postMessage方法来跨域传送数据##XMLHttpRequest>-Ajax技术核心就是`XMLHttpRequest`类,简称XHR,允许脚本`异步调用`HTTPAPI.>-浏览器在`XMLHttpRequest`类上定义了HTTPAPI,这个类每个实例都是独立的请求/响应对象,可指定对象上和方法允许指定细节和提取响应数据###创建实例```jsvarxhr=newXMLHttpRequest()//兼容IE7之前并不支持前者varxhr=newActiveXObject('Microsoft.XMLHTTP')//兼容性写法varxhr=window.XMLHttpRequest?newwindow.XMLHttpRequest():newActiveXObject('Microsoft.XMLHTTP')```##open()创建XMLHttpRequest对象之后，发起HTTP请求的`下一步`是调用XMLHttpRequest对象的`open`方法，指定HTTP请求的两个必需部分：**请求方法**和**URL****xhr.open(method,url,async)**-**method：**-第一个参数用于指定HTTP请求的方法，不区分大小写；-该参数可取的值包括：\"GET\"、\"POST\"、\"HEAD\"、\"PUT\"、\"OPTIONS\"、\"DELETE\"，其中，\"GET\"和\"POST\"是得到广泛支持的请求方法；-**url：**-第二个参数用于指定HTTP请求的URL地址，可以是**绝对URL**或**相对URL**；-绝对URL：需要满足\"同源策略\"（服务器明确允许跨域请求的情况除外）；-相对URL：即相对于文档的URL；-**async：**-第三个参数是可选的，可用`布尔值`指定脚本是否以异步的方式调用此次Ajax请求；-该参数默认为true，表示异步调用此次Ajax请求，不阻塞后续脚本的执行；**注意**：`open()`方法其实还可以有第四、第五个参数，分别是用于HTTP请求访问认证的`用户名和密码`，使用它们需要在服务器做相应的配置，较为少用。##setRequestHeader如果你的HTTP请求需要`设置请求头`，那么调用open方法之后的`下个步骤`就是设置它，使用的方法是：`setRequestHeader````js//在open方法之后设置请求头xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')```**xhr.setRequestHeader(name,value)**-**name**:请求头名称；-**value**:请求头的值。##send()使用XMLHttpRequest`发起HTTP请求`的`最后一步`是指定可选的请求主体、并向服务器发送它，使用的方法是：`send````jsvarxhr=newXMLHttpRequest()xhr.open('GET','/statics/demosource/demo_get_json.php')//由于GET请求,没有请求主体，所以在调用send方法时可以传递null或省略这个参数；xhr.send(null)varxhr=newXMLHttpRequest()xhr.open('POST','/statics/demosource/demo_post_json.php')//把msg作为请求主体发送xhr.send(msg)```1.POST请求通常都拥有请求主体，可在send方法中指定它；2.POST请求的请求主体，`应该匹配``setRequestHeader`方法所指定的\"Content-Type\"头。##获取响应>-一个完整的HTTP响应由`状态码、响应头和响应主体`组成，这三者都可以通过`XMLHttpRequest`对象提供的属性和方法获取。>-为了能够在HTTP响应准备就绪时得到通知，必须**监听**`XMLHttpRequest`对象上的`readystatechange`事件。但为了理解这个事件类型，需要先了解下`readyState`属性，因为该事件监听的是`readyState`属性值的改变。>-XMLHttpRequest`对象上的`readyState`属性在HTTP请求过程中，会`从0变到4```html<script>varoBtn=document.getElementById('btn')oBtn.onclick=function(){//兼容处理varxhr=window.XMLHttpRequest?newwindow.XMLHttpRequest():newActiveXObject('Microsoft.XMLHTTP')alert(xhr.readyState)//0xhr.onreadystatechange=function(){alert(xhr.readyState)}xhr.open('GET','/statics/demosource/demo_get_json.php')xhr.send()}</script>```###readyState属性`readyState`属性是一个整数，它的值代表了不同的HTTP请求状态。-0：初始值，表示请求未初始化，`open`方法尚未调用；-1：启动请求，open方法已经调用，但尚未调用send方法；-2：请求发送，已经调用send方法，但尚未接收到响应；-3：接收响应，已经接受到`部分响应`数据，主要是响应头；-4：HTTP响应完成，已经接收到全部响应数据，而且可以在客户端使用。每次`readyState`属性值的改变都会触发`readystatechange`事件，**但只有`readyState`属性值为4时才是我们所关心的状态**，因为只有这个状态才表示HTTP的响应准备就绪，可以真正意义上的结合服务器所响应的数据来实现我们的业务需求。###发送请求规范```html<body><buttonid=\"btn\">点我观察readyState属性的改变</button><divid=\"tip\"></div><script>varoBtn=document.getElementById('btn'),oTip=document.getElementById('tip')oBtn.onclick=function(){varxhr=window.XMLHttpRequest?newwindow.XMLHttpRequest():newActiveXObject('Microsoft.XMLHTTP')xhr.onreadystatechange=function(){if(xhr.readyState===4){oTip.innerText='HTTP响应完成'}}xhr.open('GET','/statics/demosource/demo_get_json.php')xhr.send()}</script></body>```**注意**：-`readyState`的属性值只代表此时的HTTP请求处于哪个阶段：是发送了请求还是未发送请求，是只接收到了响应头还是响应完成；-\"响应完成\"只代表HTTP请求结束，至于服务器的响应状态：是请求成功还是请求错误，又或者是服务器错误，需要通过`HTTP状态码`判断，它存储在`XMLhttpRequest`的`status`属性上；###status属性`status`属性会以数字的形式保存服务器响应的HTTP状态码，诸如使用最频繁的\"200\"表示请求成功，\"404\"表示URL不能匹配服务器上的任何资源。`HTTP状态码`是用来表示网页服务器响应状态的`3位`数字代码，所有状态码的第一个数字代表了响应的五种状态之一：-1xx：临时响应-2xx：成功-3xx：重定向-4xx：请求错误-5xx：服务器错误哪些HTTP状态码表示我们可以获取到HTTP响应数据呢？**2开头的状态码**与**304**。2开头的状态码都表示请求成功，而304是对客户端可读取缓存的一种响应，同样能获取到HTTP的响应数据。```html<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"/><title>Tryrun4</title><style>#btn{margin-top:7px;}</style></head><body><divid=\"tip\"></div><buttonid=\"btn\">点我发起Ajax请求</button><script>varoBtn=document.getElementById('btn'),oTip=document.getElementById('tip')oBtn.onclick=function(){varxhr=window.XMLHttpRequest?newwindow.XMLHttpRequest():newActiveXObject('Microsoft.XMLHTTP')xhr.onreadystatechange=function(){if(xhr.readyState===4)returnif((xhr.status>=200&&xhr.status<300)||xhr.status===304){oTip.innerText='HTTP请求成功'}}xhr.open('GET','/statics/demosource/demo_get_json.php')xhr.send()}</script></body></html>```###responseText属性`responseText`属性以字符串的形式存储了响应主体，即：服务器的响应数据。无论返回的数据类型是什么，响应主体的内容都会保存在`responseText`属性中；####响应html```jsvarxhr=newXMLHttpRequest()xhr.onreadystatechange=function(){if(xhr.readyState!==4)returnif((xhr.status>=200&&xhr.status<300)||xhr.status===304){//当响应成功，获取响应数据,将数据赋值给本地oView.innerHTML=xhr.responseText}}xhr.open('GET','/statics/demosource/demo_get.php')xhr.send()```响应json```jsvarxhr=newXMLHttpRequest()xhr.onreadystatechange=function(){if(xhr.readyState!==4)returnif((xhr.status>=200&&xhr.status<300)||xhr.status===304){//使用JSON.parse把响应数据转换为json数据varres=JSON.parse(xhr.responseText)//将响应数据中的data属性赋值给oTime做内容oTime.innerText=res.data}}xhr.open('GET','/statics/demosource/demo_get_json.php')xhr.send()```###查询HTTP响应头的方法在`XMLHttpRequest`对象上，可通过`getAllResponseHeaders`和`getResponseHeader`方法查询响应头信息。####getAllResponseHeaders-`getAllResponseHeaders`方法无参数，用于一次性返回可查询的全部响应头信息```jsvarxhr=newXMLHttpRequest()xhr.onreadystatechange=function(){if(xhr.readyState!==4)returnif((xhr.status>=200&&xhr.status<300)||xhr.status===304){//获取所有可查询的响应头信息oView.innerText=xhr.getAllResponseHeaders()}}xhr.open('GET','/statics/demosource/demo_get_json.php')xhr.send()```####getResponseHeader-`getResponseHeader`方法用于查询`单一`响应头信息，需要传入一个指定\"头名称\"的字符串作为参数：`getResponseHeader(headerName)````jsvarxhr=newXMLHttpRequest()xhr.onreadystatechange=function(){if(xhr.readyState!==4)returnif((xhr.status>=200&&xhr.status<300)||xhr.status===304){//查询\"Content-Type\"响应头信息alert(xhr.getResponseHeader('Content-Type'))}}xhr.open('GET','/statics/demosource/demo_get_json.php')xhr.send()```**注意**：由于`XMLHttpRequest`会自动处理cookie，将cookie从`getAllResponseHeaders`方法返回的响应头集合中过滤掉，并且如果给`getResponseHeader`方法传递\"Set-Cookie\"或\"Set-Cookie2\"，则返回null。###同步响应```jsvarxhr=newXMLHttpRequest()//指定open方法的第三个参数为falsexhr.open('GET','/statics/demosource/demo_get_json.php',false)//send方法的调用将阻塞后面代码的执行，直到此次HTTP请求完成xhr.send()//不再需要监听readystatechange事件if((xhr.status>=200&&xhr.status<300)||xhr.status===304){oTime.innerText=JSON.parse(xhr.response).date}else{//如果请求不成功，就报错thrownewError(xhr.status)}```###abort中止请求若HTTP请求的时间超出预期，可以调用`XMLHttpRequest`对象上的`abort`方法来中止HTTP请求。```jsvarxhr=newXMLHttpRequest()vartimer=null//用于存储定时器标识xhr.onreadystatechange=function(){if(xhr.readyState!==4)returnif((xhr.status>=200&&xhr.status<300)||xhr.status===304){clearTimeout(timer)//未超时则取消定时器}}xhr.open('GET','/statics/demosource/demo_get_json.php')xhr.send()//2秒后中止此次GET请求timer=setTimeout(function(){xhr.abort()},2000)```##GET请求GET请求一般用于信息`获取`，它`没有请求主体`，而是使用URL传递参数（即：传递数据给后台）。传递参数的方式：1.对所需发送的数据（具有名称和值）执行普通的URL编码，即：由一对对\"名称=值\"组成（称为：名/值对），每一对之间用\"&\"拼接，如\"name=value&name=value&...&name=value\"；2.由于名/值对会附加在URL地址后面，因此在这串字符参数的最前面需要添加个\"?\"，表示URL的查询参数开始。```html<body><divid=\"form\"><labelfor=\"country\">国家：<inputtype=\"text\"name=\"country\"id=\"country\"/></label><labelfor=\"city\">城市：<inputtype=\"text\"name=\"city\"id=\"city\"/></label></div><hr/><div>你查询的国家是：<spanid=\"ipt_country\"></span></div><div>你查询的城市是：<spanid=\"ipt_city\"></span></div><br/><buttontype=\"button\"id=\"search\">查询</button>（查询成功后会把你输入的值显示在上方）<script>varoSearch=document.getElementById('search'),oIpt_country=document.getElementById('ipt_country'),oIpt_city=document.getElementById('ipt_city')varurl='/statics/demosource/demo_get_json.php'oSearch.onclick=function(){varcountry=document.getElementById('country').value,city=document.getElementById('city').valuevarquery='country='+country+'&city='+cityvarqueryURL=url+'?'+query//发起get请求ajaxGet(queryURL)}functionajaxGet(url){varxhr=window.XMLHttpRequest?newwindow.XMLHttpRequest():newActiveXObject('Microsoft.XMLHTTP')xhr.onreadystatechange=function(){if(xhr.readyState===4){if((xhr.status>=200&&xhr.status<300)||xhr.status===304){varres=JSON.parse(xhr.responseText)oIpt_country.innerText=res.params.countryoIpt_city.innerText=res.params.city}}}xhr.open('GET',url)xhr.send()}</script></body>```###缓存问题对于GET请求，请求的结果会被浏览器缓存，特别是在IE浏览器下。这时，如果GET请求的URL不变，那么请求的结果就是浏览器的缓存（也就是上次GET请求的结果）。**解决办法**实时改变GET请求的URL，只要URL不同，就不会取到浏览器的缓存结果。在URL末尾`添加时间戳参数`。由于时间戳可以精确到毫秒，从而保证了每次发起GET请求的时间不同，达到实时改变请求URL的目的。```jsvarurl='/statics/demosource/demo_get_json.php'//在请求参数的最后附加时间戳参数tvarquery='user='+user+'&pwd='+pwd+'&t='+newDate().getTime()varqueryURL=url+'?'+query//ajax_get为自己封装的请求对象，不是固定用法ajax_get(queryURL)```###封装GET异步请求函数步骤：-实例化一个`XMLHttpRequest`对象，如果你正在使用IE7以下版本的浏览器，应该对它做兼容处理；-对`data`数据执行普通的URL编码，也可以使用预置代码中提供的`urlencodeData`工具函数完成这步操作；-调用`open()`方法，指定请求方式、请求地址、是否异步，注意请求地址需要是`url`与请求参数拼接的结果；-调用`send()`方法；-给`XMLHttpRequest`实例添加`readystatechange`事件处理程序：-最好在`open()`方法调用之前实现`readystatechange`事件，比较严谨；-在事件处理程序中判断HTTP请求状态，只有请求状态为\"完成\"时，才能保证响应内容完整；-根据HTTP状态码（即`status`属性值），执行对应的回调函数：-HTTP状态码在200与300之间（不包括300）、或为304都表示成功：使用`JSON.parse()`方法将`responseText`属性值解析为JavaScript对象，并作为`success`函数的实参传出；-HTTP状态码为其它值则表示请求失败：调用`error`函数，并将失败的HTTP状态码作为实参传出；-在运行结果区封装的`ajaxPost`,能否正常响应，常见的错误有：-成功请求的测试出现403：GET请求的URL地址不正确，可以检查一下是否在`url`与请求参数之间拼接了\"?\"。```html<script>functionajaxGet(url,data,success,error){//在下方开始你的代码varxhr=window.XMLHttpRequest?newwindow.XMLHttpRequest():newActiveXObject('Microsoft.XMLHTTP');data=urlencodeData(data)console.log(data);xhr.onreadystatechange=function(){if(xhr.readyState!==4)return;if(xhr.status>=200&&xhr.status<300||xhr.status===304){console.log(xhr.status);varres=JSON.parse(xhr.responseText)success(res);}else{varres=JSON.parse(xhr.responseText)console.log(res);error(res);}};url=url+'?'+data;xhr.open('GET',url,true);xhr.send(null);}</script><!--工具函数--><script>//用于对JavaScript对象执行普通的URL编码//编码后的格式为：\"名称=值&...&名称=值\"functionurlencodeData(data){if(!data)return;varpairs=[];for(varnameindata){if(!data.hasOwnProperty(name))continue;if(typeofdata[name]===\"function\")continue;varvalue=(data[name]===null||data[name]===undefined)?\"\":data[name].toString();pairs.push(encodeURIComponent(name)+\"=\"+encodeURIComponent(value));}returnpairs.join(\"&\");}</script><!--以下均是测试代码--><!--测试代码的css部分--><style>#request{text-align:center;}.request-result{padding:12px;border:1pxsolid#e8e8e8;border-radius:2px;box-shadow:01px3px1px#d9dfe9;}.request-btn{margin-top:12px;padding:7px;color:#fff;border-radius:7px;transition:all.2s;cursor:pointer;}.request-success{background-color:#1890ff;}.request-success:hover{background-color:#40a9ff;}.request-error{background-color:#d9363e;}.request-error:hover{background-color:#ff7875;}</style></head><body><!--测试代码的html部分--><divid=\"request\"><divclass=\"request-result\"><divclass=\"res-tip\">测试下你封装的异步GET请求能不能正常响</div><divclass=\"res-param\"></div></div><divclass=\"request-btnrequest-success\">成功请求的测试</div><divclass=\"request-btnrequest-error\">失败请求的测试</div></div><!--测试代码的js部分--><script>varoDivs=document.getElementsByTagName(\"div\");varoResult_tip=oDivs[2],oResult_param=oDivs[3],oSuccess=oDivs[4],oError=oDivs[5];varurl=\"/statics/demosource/demo_get_json.php\",badUrl=\"/statics/demosource/404.txt\";vardata={aa:null,from:\"南昌\",to:\"厦门\",time:\"今天\"};varsuccess=function(res){oResult_tip.innerText=\"请求成功\";oResult_param.innerHTML=\"<div><span>起点：</span><span>\"+res.params.from+\"</span></div><div><span>终点：</span><span>\"+res.params.to+\"</span></div><div><span>时间：</span><span>\"+res.params.time+\"</span></div>\";};varerror=function(res){oResult_tip.innerText=\"请求失败：\"+res;oResult_param.innerHTML=\"\";};oSuccess.onclick=function(){ajaxGet(url,data,success,error);};oError.onclick=function(){ajaxGet(badUrl,data,success,error);}</script></body>```##POST请求POST请求一般用于修改服务器上的资源，它需要发送一个请求主体，客户端传递给服务器的数据就包含在这个请求主体中。`\"Content-Type\"`请求头用于设置请求主体的编码格式。###表单编码的POST请求POST请求使用**表单编码**的方式来发送数据的关键步骤：1.对所需发送的数据（具有名称和值）执行普通的URL编码，即：像GET请求那样拼接为名/值对的形式；2.将`\"Content-Type\"`请求头的值设置为`\"application/x-www-form-urlencoded\"`。```js//获取用户输入的表单数据varcountry=document.getElementById('country').value,city=document.getElementById('city').value//将数据拼接为名/值对的形式varquery='country='+country+'&city='+cityvarxhr=newXMLHttpRequest()xhr.onreadystatechange=function(){//......省略事件处理程序}//指定POST请求xhr.open('POST','/statics/demosource/demo_post_json.php')//设置请求主体的编码方法xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')//发送请求主体（数据）xhr.send(query)```###JSON编码的POST请求JSON是一种轻量级的前后端`数据交换格式`，直接使用`JSON.stringify`原生API即可实现JSON编码，比表单编码的方式更加快捷。POST请求使用**JSON编码**的方式来发送数据的关键步骤：1.`\"Content-Type\"`请求头的值需要为`\"application/json\"`；2.对请求主体进行序列化，在JavaScript中可使用`JSON.stringify`完成这步操作。```js//获取用户输入的表单数据varcountry=document.getElementById('country').value,city=document.getElementById('city').value//将数据转换为JavaScript对象vardata={country:country,city:city,}varxhr=newXMLHttpRequest()xhr.onreadystatechange=function(){//......省略事件处理程序}//指定POST请求xhr.open('POST','/statics/demosource/demo_json_data.php')//设置请求主体的编码方法xhr.setRequestHeader('Content-Type','application/json')//编码请求主体并发送xhr.send(JSON.stringify(data))```##两种方式的比较**GET请求：**1.一般用于信息`获取`：通过发送一个请求来取得服务器上的资源；2.数据包含在URL地址中；3.数据量受URL的长度限制；4.不安全：浏览器的URL`可见`到，明文传输；5.GET请求`会被缓存`；6.GET没有请求主体，请求速度相对较快。**POST请求：**1.一般用于`修改`服务器上的资源：向指定资源提交数据，后端处理请求后往往会导致服务器建立新的资源或修改已有资源；2.数据包含在请求主体中；3.没有数据量限制，可在服务器的配置里进行限制；4.只能是比GET`安全`，实际上也是不安全的：可通过开发者工具或者抓包看到，明文传输；5.POST请求`不会缓存`；6.POST相对稳定、可靠：可发送包含未知字符的内容。**容易产生的误区**：HTTP协议里并没有限制GET和POST的长度，GET的最大长度限制是因为浏览器和Web服务器对URL的长度限制，不同的浏览器和Web服务器限制的最大长度不一样，它们所限制的是整个URL的长度，而不仅仅是查询参数的数据长度。##Ajax扩展###jQuery中的AjaxjQuery是一个JavaScript工具库，它封装了JavaScript常用的功能代码，包括我们刚刚学完的Ajax。**jQuery中，Ajax常见的请求方式有以下几种：**-`$.ajax(url,options)`-`$.get(url,data,callback,dataType)`-`$.post(url,data,callback,dataType)`-`$.getJSON(url,data,callback)`-`$.getScript(url,callback)`-jQuery元素`.load(url,data,callback)````js//使用jQuery发起ajax请求$.ajax('/statics/demosource/demo_get_json.php',{//请求类型type:'GET',//要发送的数据data:{country:country,city:city,},//数据格式dataType:'json',//请求成功后执行success:function(res){//res为响应成功返回的数据oIpt_country.innerText=res.params.countryoIpt_city.innerText=res.params.city},//请求失败后执行error:function(res){//这里的res为响应失败返回的数据alert('请求失败：'+res.status)},})```###Ajax的替代品：fetchFetchAPI是随ES6发展而出现的一个JavaScript原生接口，与Ajax一样允许开发者异步发起HTTP请求，但却以更加简单明了的调用方式、基于Promise的数据处理方式被称作是Ajax的替代品。```jsfetch('/statics/demosource/demo_json_data.php',{method:'POST',header:newHeaders({'Content-Type':'application/json'}),body:JSON.stringify(data),}).then(function(res){returnres.ok?res.json():Promise.reject(res)}).then(function(data){oIpt_country.innerText=data.countryoIpt_city.innerText=data.city}).catch(function(res){alert('请求失败：'+res.status)})```##JSONJSON=JavaScriptObjectNotation，意思是：JavaScript对象表示法，是一种轻量级的`数据交换格式`。###语法规则JSON的语法可以表示以下三种类型的值：-**简单值**：使用与JavaScript相同的语法，可以在JSON中表示`number`、`string`、`boolean`与`null`，但JSON不支持JavaScript中的特殊值`undefined`；-**对象**：对象作为一种复杂数据类型，表示的是一组无序的键值对，而每个键值对中的值可以是简单值，也可以是复杂数据类型的值；-**数组**：数组也是一种复杂数据类型，表示一组有序的值的列表，数组的值也可以是任意类型——简单值、对象或数组。###简单值```js//JSON表示数值77//JSON表示字符串;('JSONisaformatfordataexchange')```**注意**：JSON字符串与JavaScript字符串的最大区别在于，JSON字符串必须使用**双引号**，单引号会导致语法错误。###对象JSON中的对象与JavaScript对象字面量稍微有一些不同。JavaScript的对象字面量：```js{name:\"Alan\",age:21}```json表示```js{\"name\":\"Alax\",\"age\":21}```JSON对象的键（属性名）**必须**加**双引号**。JSON对象的属性值可以是简单值，也可以是复杂类型值```js{\"name\":\"Alan\",\"age\":21,\"child\":{\"name\":\"Tim\",\"age\":7}}```###数组JSON数组采用的就是JavaScript中的数组字面量形式。JavaScript中的数组字面量：```js;[21,'Alan',false]```json表示```js;[21,'Alan',false]```###**总结**1.对于JSON与JavaScript的关系，你现在可以这么理解：JSON是JavaScript对象的字符串表示法，它使用纯文本格式来表示一个JavaScript对象的信息，本质上是一个字符串；2.通常，我们会将对象和数组作为JSON数据结构的最外层形式，利用它们能够创造出各种各样的数据结构。当然，这不是强制规定的。##JavaScript内置的JSON对象ECMAScript5定义了一个原生的JSON对象，可把JavaScript对象序列化为JSON字符串，或把JSON字符串解析为原生的JavaScript值。**JSON对象的方法：**1.`JSON.stringify()`：用于序列化JavaScript对象，将其转换为JSON字符串；2.`JSON.parse()`：用于解析JSON字符串，将其转换为JavaScript值。**提示**：除了以上两个方法，JSON对象本身并没有其它作用，也不能被做为构造函数使用。###stringify方法`JSON.stringify()`方法用于将一个JavaScript值/对象转换为JSON字符串。```jsvarobj={name:'Alan',age:21,child:{name:'Tim',age:7,},}//序列化obj对象，转换为JSON格式的字符串varjson=JSON.stringify(obj)```###parse方法`JSON.parse()`方法用于将JSON数据解析为原生的JavaScript值。```jsvarjson='{\"name\":\"Alan\",\"age\":21,\"child\":{\"name\":\"Tim\",\"age\":7}}'//json数据本质上是字符串，无法直接访问某一属性console.log(json.name)//undefined//解析json，转换为原生的JavaScript对象varobj=JSON.parse(json)console.log(obj.name)//此时可以使用JavaScript方法访问某一属性```","Front-End\\拓展\\前后端交互\\axios.md":"#axios>相关:`axios-jsonp`,`axios-retry`>[axios中文文档|axios中文网|axios(axios-js.com)](http://www.axios-js.com/zh-cn/docs/)##配置headeraxios使用post发送数据时，默认是直接把json放到请求体中提交到后端的。也就是说，我们的Content-Type变成了application/json;charset=utf-8,这是axios默认的请求头content-type类型。但是实际我们后端要求的'Content-Type':'application/x-www-form-urlencoded'为多见，这就与我们不符合。所以很多同学会在这里犯错误，导致请求数据获取不到。明明自己的请求地址和参数都对了却得不到数据。我们现在来说说post请求常见的数据格式（content-type）1.Content-Type:application/json：请求体中的数据会以json字符串的形式发送到后端2.Content-Type:application/x-www-form-urlencoded：请求体中的数据会以普通表单形式（键值对）发送到后端3.Content-Type:multipart/form-data：它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。###application/x-www-form-urlencoded配置####a.【用URLSearchParams传递参数】代码简单，省事。需要注意的是：URLSearchParams不支持所有的浏览器，但是总体的支持情况还是OK的```jsletparam=newURLSearchParams()param.append('username','admin')param.append('pwd','admin')axios({method:'post',url:'/api/lockServer/search',data:param,})```####b.配置axios请求头中的content-type为指定类型`axios.defaults.headers.post['Content-Type']='application/x-www-form-urlencoded';`或者```js{headers:{'Content-Type':'application/x-www-form-urlencoded'}}```将参数转换为query参数,利用qs，引入qs，这个库是axios里面包含的，不需要再下载了。```jsimportQsfrom'qs'letdata={username:'cc',psd:'123456',}axios({headers:{'Content-Type':'application/x-www-form-urlencoded',},method:'post',url:'/api/lockServer/search',data:Qs.stringify(data),})```##**Content-Type:multipart/form-data**```jsletparams=newFormData()params.append('file',this.file)params.append('id',localStorage.getItem('userID'))params.append('userName',this.name)params.append('sex',this.sex)params.append('mobile',this.phone)params.append('email',this.email)params.append('qq',this.qq)params.append('weChat',this.WeChat)axios.post(URL,params,{headers:{'Content-Type':'multipart/form-data'}}).then((res)=>{if(res.data.code===0){this.$router.go(-1)}}).catch((error)=>{alert('更新用户数据失败'+error)})```##**Content-Type:application/json**>axios默认的请求数据类型，我们只需将参数序列化json字符串进行传递即可，无需多余的配置。##axios-retry>让axios支持重试```tsimportAxios,{AxiosRequestConfig}from'axios'importaxiosRetryfrom'axios-retry'constclient=Axios.create({//你的配置})//安装retry插件//当请求失败后，自动重新请求，只有3次失败后才真正失败axiosRetry(client,{retries:3})exportasyncfunctionrequest(url:string,config?:AxiosRequestConfig){constresponse=awaitclient.request({url,...config})constresult=response.data//你的业务判断逻辑returnresult}//只有3次失败后才真正失败constdata=request('http://example.com/test')```##axios-jsonp>支持jsonp的功能```tsimportAxios,{AxiosRequestConfig}from'axios'importjsonpAdapterfrom'axios-jsonp'constclient=Axios.create({//你的配置})exportasyncfunctionrequest(url:string,config?:AxiosRequestConfig){constresponse=awaitclient.request({url,...config})constresult=response.data//你的业务判断逻辑returnresult}exportfunctionjsonp(url:string,config?:AxiosRequestConfig){returnrequest(url,{...config,adapter:jsonpAdapter})}//你现在可以发送jsonp的请求了constdata=jsonp('http://example.com/test-jsonp')```","Front-End\\拓展\\前后端交互\\fetch.md":"#fetch>Fetch的核心在于对HTTP接口的抽象##fetch()方法的使用>`fetch(input?:Requset|string,init?:RequestInit):Promise<Response>````jsfetch(url,option).then(function(response){//处理HTTP响应},function(error){//处理网络错误},)```##fetch()参数>`fetch(input?:Requset|string,init?:RequestInit):Promise<Response>`>>-input参数:字符串,|包含获取资源的URL|一个Request对象>-option:(可选),一个配置对象>-method:请求方式[GET,POST]>-headers:请求的头信息,包含与请求关联的Headers对象>-body:请求的body信息,[注意:GET或HEAD方法的请求不得包含body信息]>-mode:请求模式,cors,no-cors或same-origin>-credentials:请求的credentidials,如omit,same-origin或include[为了在当前域名内自动发送cookie,必须提供这个选项]##常用Fetch请求###html```jsfetch('/index/fetchHtml').then((res)=>{returnres.text()}).then((result)=>{document.body.innerHTML+=result}).catch((err)=>{//errs})```###JSON```jsfetch('/api/user/a').then(res=>returnres.josn()).then(json=>console.log(json)).catch(err=>{//err})```###POSTForm```jsfunctionpostForm(){constform=document.querySelector('form')constname=encodeURL(document.getElementByName('name')[0].value)fetch(`/api/user/${name}`,{method:'POST',body:newFormData(form),})}```###POSTJSON```jsfetch('/api/user/a',{method:'POST',header:{'Content-Type':'application/json',},body:JSON.stringify({name:'a',age:23,}),})```##fetch中止>fetch自身没有提供中止请求的话方法,但是大部分浏览器有实现AbortController,可以通过AbortController中止fetch请求```jsconstcontroller=newAbortController()constsignal=controller.signalsetTimeout(()=>controller.abort(),5000)fetch('/api/user/CaiCai',{signal,//在option中加入signalmethod:'POST',//credentials:'include',headers:{'Content-Type':'application/json',},body:JSON.stringify({name:'CaiCai',age:'26',}),}).then((res)=>{returnres.json()}).then((result)=>{console.log(result)}).catch((err)=>{console.log(err)})```##兼容性![Snipaste_2020-12-14_16-00-39](https://gitee.com/grh-gitee/picgo/raw/master/Snipaste_2020-12-14_16-00-39.png)##缺点1.fetch不支持jsonp,使用到该功能需要单独实现JSONP2.fetch自身没有abort的方法,需要AbortController去处理中止,AbortController兼容性也不是很好3.fetch兼容性不是很好,不支持的浏览器可以使用`fetchpolyfill`","Front-End\\拓展\\前后端交互\\文件交互\\index.md":"#文件交互>[(31条消息)js实现通过url下载文本/图片/视频且不跳转新页面\\_zhangx-CSDN博客](https://blog.csdn.net/kezanxie3494/article/details/104433087)>>[(36条消息)前端实现文件下载功能的三种方式\\_hfhwfw161226的博客-CSDN博客](https://blog.csdn.net/hfhwfw161226/article/details/105700504)>>[文件上传，搞懂这8种场景就够了](https://juejin.cn/post/6980142557066067982)","Front-End\\拓展\\加密\\base64.md":"#base64>Base64编码普遍应用于需要通过被设计为处理文本数据的媒介上储存和传输二进制数据而需要编码该二进制数据的场景。这样是为了保证数据的完整并且不用在传输过程中修改这些数据。Base64也被一些应用（包括使用MIME的电子邮件）和在XML中储存复杂的数据时使用。>>由于BASE64是一种非常常用的编码方案，在开发中经常会使用到，所以当前浏览器标准API（atob、btoa）都支持进行BASE64操作，遗憾的是上面提到的标准API仅支持ASCII字符。所以使用范围受限。>>[(79条消息)img标签轻松显示base64格式的图片\\_Teheran的博客-CSDN博客](https://blog.csdn.net/Teheran/article/details/84569991)>>[(79条消息)使用JavaScript进行Base64编码与解码\\_FKNIGHT的博客-CSDN博客](https://blog.csdn.net/gulang03/article/details/88854858)>>[用JS进行Base64编码、解码-简书(jianshu.com)](https://www.jianshu.com/p/14437764eff3)>>[浅析data:image/png;base64的应用-Angel_Kitty-博客园(cnblogs.com)](https://www.cnblogs.com/ECJTUACM-873284962/p/9245474.html)","Front-End\\拓展\\同步和异步.md":"#同步和异步```jsfor(vari=0;i<4;i++){setTimeout(function(){console.log(i)},0)}//4444```>for循环是同步任务,会先执行完循环,此时i的值为4,4ms后`console.log(i)`被一次放入任务队列,此时如果执行栈中没有同步任务了,就从任务队列中一次取出任务,所以打印4个4输出1,2,3,4的解决方法>1.把var换成let>>-let不会变量提升,而且let有块级作用域>>2.使用立即执行函数>>```js>for(leti=0;i<4;i++){>;(function(i){>setTimeout(function(){>console.log(i)>},0)>})(i)>}>```>>3.加闭包>>```js>for(leti=0;i<4:i++){>vara=function(){>varj=i;>setTimeout(function(){>console.log(j)>},0)>}>a();>}>``````jssetTimeout(function(){console.log(1)});newPromise(function(resolve){console.log(2);for(vari=0;i<10000;i++){i==9999&&resolve();}}).then(function(){console.log(3)});console.log(4);执行结果：//2，4，3，1```>1.setTimeout异步,且是宏函数,放到宏函数队列中>2.newPromise是同步任务,直接执行,打印2,并执行for循环>3.promise.then是微任务,放到微任务队列中>4.console.log(4)是同步任务,直接执行,打印4>5.此时主线程执行完毕,开始检查微任务队列中,有promise.then,执行微任务,打印3;>6.微任务执行完毕,第一次循环结束;从宏任务队列中取出第一个宏任务到主线程执行,打印1>7.结果:2,4,3,1>>执行顺序:同步任务>微任务>异步任务```jsfunctionadd(x,y){console.log(1)setTimeout(function(){//timer1console.log(2)},1000)}add()setTimeout(function(){//timer2console.log(3)})newPromise(function(resolve){console.log(4)setTimeout(function(){//timer3console.log(5)},100)for(vari=0;i<100;i++){i==99&&resolve()}}).then(function(){setTimeout(function(){//timer4console.log(6)},0)console.log(7)})console.log(8)执行结果//1，4，8，7，3，6，5，2```>1.add()是同步任务,直接执行打印1>2.add()里面的setTimeout是异步任务且宏函数,记做timer1放到宏函数队列>3.add()下的setTimeout是异步任务且宏函数,记做timer2放到宏函数队列>4.newPromise是同步任务,直接执行,打印4>5.Promise里面的setTimeout是异步任务且为宏函数,记做timer3放到宏函数队列中>6.Promise里面的for是同步任务直接执行>7.Promise.then是微任务,放到微任务队列>8.console.log(8)是同步任务,直接执行,打印8>9.此时主线程任务执行完毕,检查任务队列中,有Promise.then,执行微任务,发现有setTimeout是异步函数,记做timer4放到宏函数队列;>10.微任务中的console.log(7)是同步任务,直接执行,打印7>11.微任务执行完毕,第一次循环结束>12.检查宏任务EventTable,里面有timer1,timer2,timer3,timer4,四个定时器宏任务,按照定时器延迟时间得到可以执行顺序,即EventQueue:timer2,timer4,timer3,timer1,取出排在第一个的timer2>13.取出timer2执行,console.log(3)同步任务,直接执行,打印3>14.没有微任务,第二次EventLoop结束>15.取出timer4执行,console.log(6)同步任务,直接执行,打印6>16.没有微任务,第三次EventLoop结束>17.取出timer3执行,执行console.log(5)同步任务,直接执行,打印5>18.没有微任务,第四次EventLoop结束>19.取出timer1执行,console.log(2)同步任务,直接执行,打印2>20.没有微任务,也没有宏任务,第五次EventLoop结束>先执行同步任务,再执行该任务的微任务,若有异步且为宏函数就放到宏函数队列>>执行完该同步任务,然后开始检查宏函数队列,然后按照对应的规则取出任务,执行重复该过程","Front-End\\拓展\\性能指标\\指标.md":"#[性能指标](https://web.dev/learn-core-web-vitals/)|指标名称|全称|描述||:-------|:-----------------------|:---------------------------------------------||`FP`|FirstPaint|浏览器第一次绘制时间，第一个像素时间||`TTI`|TimeToInteractive|页面渲染完毕，可以响应用户输入的时间||`FID`|FirstInputDelay|用户与页面输入框等控件第一次可交互的时间||`LCP`|LargestContentfulPaint|最大内容绘制时间||`FMP`|FirstMeaningfulPaint|首次有意义的绘制，页面主要内容出现在屏幕的时间||`FCP`|FirstContentfulPaint|浏览器第一次屏幕绘制内容时间||`CLS`|CumulativeLayoutShift|累计布局版式位移，页面抖动，屏闪|","Front-End\\拓展\\时区\\index.md":"#时区>注意`Date()`的默认时区问题,我这里采用统一指定为格林威治时间,然后通过偏移量来转换##基本使用###`Date`支持的格式```jsnewDate('4-21-201921:00:00EST'),newDate(\"2019/04/2121:00:00EDT\"),newDate(\"2019/04/219:00PMEDT\"),newDate('4/21/20199:00PMEST'),newDate('2019-04-21T21:00:00'),newDate(\"Apr21,20199:00:00\"),newDate(\"April21,20199:00:00\"),newDate(95,3,21),//两位数年份表示1900-1999年,newDate(),newDate(1453094034000),newDate('TueApr02201916:39:08'),newDate(2019,3,2,16,37,22),newDate(\"2019-04-2121:00:00EDT\"),newDate(\"2019-04-2121:00:00EDT\").toUTCString(),```##momnent>[文档|Moment.js中文网(momentjs.cn)](http://momentjs.cn/docs/#/parsing/now/)>>[MomentTimezone|Home(momentjs.com)](https://momentjs.com/timezone/)###Install&Use```shell//Installbowerinstallmoment-timezone--save#bowernpminstallmoment-timezone--save#npmyarnaddmoment-timezone#Yarn//Use<scriptsrc=\"moment.js\"></script><scriptsrc=\"moment-timezone-with-data.js\"></script>letmoment=require('moment-timezone');```###Webpack```js//webpack.config.jsconstMomentTimezoneDataPlugin=require('moment-timezone-data-webpack-plugin')constcurrentYear=newDate().getFullYear()module.exports={plugins:[//Toincludeonlyspecificzones,usethematchZonesoptionnewMomentTimezoneDataPlugin({matchZones:/^America/,}),//Tokeepallzonesbutlimitdatatospecificyears,usetheyearrangeoptionsnewMomentTimezoneDataPlugin({startYear:currentYear-5,endYear:currentYear+5,}),],}```###常用方法>常用方法:>>1.`moment([待转换的时间]).tz([指定时区]).format([时间格式])`>2.`moment.tz([待转换的时间],([指定时区]).format([时间格式])`>>注意点:>>1.`待转换的时间`:注意格式,不是全部时间格式都支持的>2.`指定时区`:注意和其他语言支持的指定时区格式不完全支持>3.`时间格式`:>1.`z`:时区```jssessionStorage.setItem('sysTimeZoneOffset','28800000')//服务器时区sessionStorage.setItem('refTimeZoneOffset','28800000')//指定的时区//将时间强行指定为格林威治时间,然后再转换为时间戳constf_formatToTimeStamp=(time)=>{if(time.match(/^\\d{4}(-|\\s)\\d{1,2}(-|\\s)\\d{1,2}(\\s)\\d{1,2}:\\d{1,2}/g)){time+='GMT'}elseif(time.match(/^\\d{4}(-|\\s)\\d{1,2}(-|\\s)\\d{1,2}$/g)){time+='00:00:00GMT'}elseif(time.match(/^\\d{8}$/g)){lettemp=time.split('')temp.splice(4,0,'-')temp.splice(7,0,'-')time=temp.join('')+'00:00:00GMT'}elseif(time.match(/^\\d{14}$/g)){lettemp=time.split('')temp.splice(4,0,'-')temp.splice(7,0,'-')temp.splice(10,0,'')temp.splice(13,0,':')temp.splice(16,0,':')time=temp.join('')+'GMT'}elseif(time.match(/^\\d{1,2}-\\d{1,2}-\\d{4}$/g)){time=time.split('-').reverse().join('-')+'00:00:00GMT'}elseif(time.match(/^\\d{10,}$/g)){returnString(time*1000).split('').map((item,index)=>index<13&&item).filter((i)=>i!==false).join('')}returnDate.parse(String(time))}//通过偏移量来指定转换前后的时区functionf_Timezone(time='',offset){lettimeStamp=f_formatToTimeStamp(String(time))//时间戳stringoffset=offset||Number(sessionStorage.getItem('refTimeZoneOffset'))-Number(sessionStorage.getItem('sysTimeZoneOffset'))||0returnmomentz(Number(timeStamp)+Number(offset)).tz('GMT')}functionf_TimezoneFormat(time='',offset,format='YYYY-MM-DDHH:mm:ss'){returnf_Timezone(time,offset).format(format)}functionf_gmtTime(time){return(Number(f_formatToTimeStamp(String(time)))+Number(newDate().getTimezoneOffset())*60*1000)}```##[时区缩写](https://www.cnblogs.com/tracy/archive/2010/07/16/1778566.html)```texEST:美国东部标准时间，GMT-5EDT:美国东部夏令时时间，GMT-4CST：美国中部标准时间，GMT-6CDT：美国中部夏令时时间，GMT-5PST:（美国）太平洋标准时间，GMT-8PDT:（美国）太平洋夏令时时间，GMT-7GMT:格林威治标准时间，即UTC时间CCT：北京时间（中国沿海时间），GMT+8```","Front-End\\拓展\\特殊备注.md":"#特殊备注-浏览的时候看见源码里居然手动写`/*#__PURE__*/`，一般这个是没人写，倒是经过polyfill转换之后，很多代码会自然带上这个标记-既然这玩意开始有点用处，就稍微总结一下。其实除了这个标记，还有`inline`,`noinline`之类的注释，这个就是给`terser`使用的##terser-我们知道terser是个很强大的压缩工具，而为啥react没写pure呢，因为react使用的是`googleclosure`压缩工具，是个自己整的java压缩工具，跟一般的压缩方式并不相同，是一种破坏性压缩，在书写代码时需要注意某种规定，否则压缩出来的代码无法正常运行。但terser的压缩是非破坏性的，所以压缩效果上自然比google那个差点，但不容易出问题（反正vue代码比react代码少太多了）-其中terser认可的行内注释一般有3种：-`/*@__INLINE__*/`-forcesafunctiontobeinlinedsomewhere.-`/*@__NOINLINE__*/`-Makessurethecalledfunctionisnotinlinedintothecallsite.-`/*@__PURE__*/`-Marksafunctioncallaspure.Thatmeans,itcansafelybedropped.-可以把@换成#。-`inline`表示内联，会强制把标记的函数里依赖的函数内敛在里面-而`noinline`则相反，不会把函数拆成内容内联进函数体内-最后的`pure`则是用的最多的。会告诉编辑器，如果没用到这玩意，可以放心删了","Front-End\\拓展\\编码规范\\代码规范.md":"#[`代码规范`]()[2021最新阿里代码规范（前端篇）](https://developer.aliyun.com/article/850913)[腾讯前端规范](https://tgideas.qq.com/doc/index.html)[京东前端规范](https://guide.aotu.io/index.html)[百度前端规范](https://github.com/ecomfe/spec/blob/master/javascript-style-guide.md)","Front-End\\拓展\\编码规范\\方法.md":"#方法||描述||:----|:---------------------------||`to*`|非破坏性修改,不修改原有数据|","Front-End\\拓展\\跨域\\jsonp.md":"#JOSNP>名称:`JSONwithPadding`>>同源策略解决的问题:跨域>>简述:非官方的协议,它允许在服务器集成`script`返回客户端,通过``javascirptcallback`的形式实现跨域访问>>同源策略:>>-同源是指,域名,协议,端口相同>-当一个浏览器打开两个`tab`页,分别打开两个页面,当一个页面执行脚本,只有检查是否同源才会被执行##原理>通过`<script>`标签并不会被同源策略所束缚,所以可以获取任何服务器上脚本并执行.>>JSONP实现模式`javascriptCallBack`的形式.","Front-End\\拓展\\闭包.md":"#闭包>我的理解:**闭包就是能够读取其他函数内部变量的函数**>>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把**闭包简单理解成\"定义在一个函数内部的函数\"**。>>**闭包就是将函数内部和函数外部连接起来的一座桥梁。**-js垃圾回收机制：js中的变量和函数不再使用后，会被自动js垃圾回收机制回收。-形成闭包的条件：有函数/作用域的嵌套；内部函数引用外部函数的变量/参数。-闭包的结果：内部函数的使用外部函数的那些变量和参数仍然会保存，使用`return`返回了此内部函数，上面的变量和参数不会被回收。-闭包的原因：返回的函数并非孤立的函数，而是连同周围的环境（AO）打了一个包，成了一个封闭的环境包，共同返回出来---->闭包。-我们在返回函数的时候，并不是单纯的返回了一个函数，我们把该函数连同他的AO链一起返回了。-函数的作用域，取决于声明时而不取决于调用时。-变量存储`function(){}`、`{}`、`[]`存储的是一个地址。###闭包实现:每一秒输出一个数字-问题:```jsfor(leti=0;i<5;i++){//在此处写代码实现每一秒输出一个数字}```-解决:使用闭包```jsfor(leti=0;i<5;i++){;((function(i){settimeout(()=>{console.log(i)})}),(i+1)*1000)(i)}```##给滚动事件添加deBounce(防抖)>在操作结束后的一段时间内执行一次#闭包```js/****************我是分割线********************/exportdefalutComponentDemoextendsReact.PureComponent{constructor(props){super(props);this.debounce=this.debounce.bind(this);this.scrollHandler=this.scrollHandler.bind(this);}debounce(func,time){lettimer=null;returnfunction(){clearTimeOut(timer);timer=settimeout(()=>{func();})}}scrollHandler(){/**函数处理**/}componentDidMount(){window.addEventListern('scroll',this.debounce(()=>this.scrollHandler()),300);}/**@desc通常来说,添加了监听事件,就要移除滚动,如果是单页面就不需要移除,页面销毁后,监听事件也会被移除*/componentWillUnmoun(){window.removeEventListern('scroll',this.sdebounce(()=>this.scrollHandler(),300))}}```","Front-End\\拖拽\\index.md":"#[`拖拽`](/)-[移动！可拖动！可调整大小！可伸缩！旋转！可变形！可捏！可分组！可捕捉！(moveable)](https://github.com/daybrush/moveable?tab=readme-ov-file)","Front-End\\拖拽\\react-beautiful-dnd.md":"#[React-beautiful-dnd]()##[源码](https://github.dev/atlassian/react-beautiful-dnd)##Examples<https://codesandbox.io/examples/package/react-beautiful-dnd-grid>","Front-End\\拖拽\\react-dnd.md":"#[react-dnd](https://react-dnd.github.io/react-dnd/examples/sortable/cancel-on-drop-outside)##[ReactDND-在鼠标移动时获取拖动元素的坐标](https://cloud.tencent.com/developer/ask/sof/854392)##[MultiBackend](https://github.com/louisbrunner/dnd-multi-backend/tree/main/packages/react-dnd-multi-backend#migrating-from-2xx)<https://github.com/LouisBrunner/dnd-multi-backend/tree/main/packages/react-dnd-multi-backend>##demo<https://github.dev/pinkqq/react-antd/blob/main/src/pages/dndPro/index.js><https://codesandbox.io/s/6v7l7z68jk?file=/src/components/DragItem.js:3388-3398><https://github.com/LouisBrunner/dnd-multi-backend/tree/main/packages/react-dnd-multi-backend/examples><https://codesandbox.io/s/github/react-dnd/react-dnd/tree/gh-pages/examples_ts/03-nesting/drag-sources?from-embed=&file=/src/TargetBox.tsx>","Front-End\\浏览器\\Date.md":"#[`Date`]()>[苹果端Date异常](https://stackoverflow.com/questions/4310953/invalid-date-in-safari)","Front-End\\浏览器\\favicon.md":"#favicon>[Favicon&AppIconGenerator(favicon-generator.org)](https://www.favicon-generator.org/)","Front-End\\浏览器\\meta.md":"#Meta>[MetaTags](https://metatags.io/)编辑生成用于社交网络等站点的元标签，并预览效果","Front-End\\浏览器\\seo.md":"#SEO##1.使用HTTPS谷歌曾发公告表示，使用安全加密协议（HTTPS），是搜索引擎排名的一项参考因素。所以，在域名相同情况下，HTTPS站点比HTTP站点，能获得更好的排名。在网络渠道分发或合作上，有优势。比如微信、QQ等渠道平台，链接是否是HTTPS协议，是第一道关卡，必须满足才行。一个网站，如果不设置HTTPS，基本可以判断该网站的流量完全依赖搜索引擎。导致的问题是，网站无法最大价值化，流量来源局限性大，网站盈利几率大打折扣。另外，还有以下好处：-有利于保护搜索快照，增加快照被篡改的难度-增加被仿站镜像的难度-增加被抄袭文章内容的难度-防止被轻易篡改页面内容-用户体验感更好，不会被提示为不安全网站##2.确保页面快速加载从2010年起，谷歌一直把页面速度作为排名因素（将网速列为网页搜索排名因素）。如果网站加载缓慢，会损害站点的搜索排名。推荐使用PageSpeedInsights对站点进行全方位的体检，以满足搜索引擎的要求。以下是我的电子手册网站的体检结果：##3.设置好有流量潜力的关键词关键词是SEO中非常重要的一部分。高频命中用户搜索的单词和短语，可以让站点提升排名，带来更多目标流量。技术上的实现，是在head中，加入keywords：```html<head><metaname=\"keywords\"content=\"快速排序,quicksort\"data-rh=\"true\"/></head>```##4、使用简明扼要的URL使用精确的目标关键词作为URL是一个不错的方法。看链接就可以知道是相关内容这样，对用户体验友好，增加点击率。##5、编写一个引人注目的标题和描述为什么要写好标题和描述，一个重要的原因是：它会显示在搜索结果中：这样，用户可以从搜索结果的页面中，可以快速获知页面内容。从而吸引潜在用户，点击当前页面进行浏览。技术上的实现如下:```html<head><title>快速排序|前端面试手册</title><metaname=\"description\"content=\"使用快速排序，对数组进行排序\"data-rh=\"true\"/><metaproperty=\"og:title\"content=\"快速排序|前端面试手册\"data-rh=\"true\"/><metaproperty=\"og:description\"content=\"使用快速排序，对数组进行排序\"data-rh=\"true\"/></head>```##6、加入内链内链指的是：从你的网站的一个页面指向另外一个页面。一般来说，页面从内部和外部，获得的链接越多，则页面的搜索排名，会更高。这也可以说明，很多博客类网站，会在外链设置`rel=\"nofollow\"`的原因：避免页面的权重被外链分散。##7、获取更多的外链外链是谷歌算法的基础，并且是最重要的排名要素之一。谷歌认为，其他知名的网站都链接到该页面，则表明该页面的内容是高质量的。外链的好处：-提升网站的权重-增加网站的信任度-吸引爬虫抓取网站-提升网站页面收录情况-提升关键词排名-给网站带来流量","Front-End\\浏览器\\URL.md":"#URL##获取URL?后的参数```js/***获取url后的id文章id*/functiongetUrlData(){varurl=window.location.search//url中?之后的部分url=url.substring(1)//去掉?vardataObj={}if(url.indexOf('&')>-1){url=url.split('&')for(vari=0;i<url.length;i++){vararr=url[i].split('=')dataObj[arr[0]]=arr[1]}}else{url=url.split('=')dataObj[url[0]]=url[1]}/***获取urlid的值*/if(dataObj.id){returndataObj.id}else{return'没有这个属性'}}console.log(getUrlData())```","Front-End\\浏览器\\User Agent Stylesheet.md":"#UserAgentStylesheet>-Gecko(Firefox):>https://searchfox.org/mozilla-central/source/layout/style/res/html.css>-Chromium(Chrome):>https://chromium.googlesource.com/chromium/src/third_party/+/master/blink/renderer/core/html/resources/html.css>-WebKit(Safari):>https://trac.webkit.org/browser/trunk/Source/WebCore/css/html.css","Front-End\\浏览器\\Web Api\\getModifierState.md":"#[`getModifierState`](/)-获取按下的按键##提示用户大写锁定已开启```jsconstinputElement=document.querySelector('#your-input-element')inputElement.addEventListener('keydown',function(event){if(event.getModifierState('CapsLock')){console.log('大写锁定是打开的')}else{console.log('大写锁定是关闭的')}})```##自定义键盘快捷操作```jsdocument.addEventListener('keydown',function(event){if(event.getModifierState('Shift')&&event.getModifierState('Alt')&&event.key==='Z'){//执行自定义操作}})```##检测数字锁定```jsdocument.addEventListener('keydown',function(event){if(event.getModifierState('NumLock')){console.log('NumLockisactive');}})```##检测滚动锁定```jsdocument.addEventListener('keydown',function(event){if(event.getModifierState('ScrollLock')){console.log('ScrollLockisactive')}})```##检测其他特殊修饰键```jsdocument.addEventListener('keydown',function(event){if(event.getModifierState('AltGraph')){console.log('AltGraphisactive')}if(event.getModifierState('OS')){console.log('OSkey(WindowskeyorCommandkey)isactive')}})```","Front-End\\浏览器\\Web Api\\localStorage.md":"#LocalStorage>-长度:>-10M的字节数>-5M，单位就是字符串的长度，而不是字符数。>-localStorage存储的键和值始终采用UTF-16DOMString格式，每个字符使用两个字节。与对象一样，整数键将自动转换为字符串。>-每个字符使用两个字节，是有前提条件的，就是码点小于`0xFFFF`(65535)，大于这个码点的是四个字节。-特点:1.存储到浏览器的会话中,localStorage的数据可以长期保存2.localStorage的键值对是以字符串的形式存储3.localStorage目前是支持IE8以上的浏览器4.解决了cookie存储空间不足的问题cookie最大4klocalStorage最大为5M5.特定于页面的协议-添加&&修改```js/**key存在时,则是修改key对应的value*/localStorage.setItem('test','thisisatest')```-读取```localStorage.getItem('test');```-删除```localStorage.removeItem('test');```-删除全部localStorage```localStorage.clear();```","Front-End\\浏览器\\Web Api\\location.md":"#Location##属性###ancestorOrigins>[Location](https://developer.mozilla.org/zh-CN/docs/Web/API/Location)接口的**`ancestorOrigins`**只读属性是一个静态的[DOMStringList](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMStringList)，倒序排列了此[Location](https://developer.mozilla.org/zh-CN/docs/Web/API/Location)接口的**`ancestorOrigins`**只读属性是一个静态的[`DOMStringList`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMStringList)，倒序排列了此[Location](https://developer.mozilla.org/zh-CN/docs/Web/API/Location)对象所属文档先前所有浏览上下文的来源。>>你可以在脚本中使用`location.ancestorOrigins`来检测你的网页是否被你不希望的对象嵌入了。你也可以使用它让网页在被特定站点嵌入时做出不同的表现。```jsconstancestors=location.ancestorOrigins```###hash>Location接口的hash属性返回一个USVString，其中会包含URL标识中的'#'和后面URL片段标识符。>>这里fragment不会经过百分比编码（URL编码）。如果URL中没有fragment，该属性会包含一个空字符串，\"\"```js//string=object.hash;//object.hash=string;<aid=\"myAnchor\"href=\"/en-US/docs/Location.href#Examples\">Examples</a><script>varanchor=document.getElementById(\"myAnchor\");console.log(anchor.hash);//返回'#Examples'</script>```###host>Location接口的host属性是包含了主机的一段USVString，其中包含：主机名，如果URL的端口号是非空的，还会跟上一个':'，最后是URL的端口号。```js//string=object.host;//object.host=string;varanchor=document.createElement('a')anchor.href='https://developer.mozilla.org/en-US/Location.host'anchor.host=='developer.mozilla.org'anchor.href='https://developer.mozilla.org:443/en-US/Location.host'anchor.host=='developer.mozilla.org'//这里host中没有包含端口号，因为443是https协议的默认端口号anchor.href='https://developer.mozilla.org:4097/en-US/Location.host'anchor.host=='developer.mozilla.org:4097'```###hostname>Location的hostname属性是包含了域名的一段USVString。```js//string=object.hostname;//object.hostname=string;//在文档流中声明了一个元素：<aid=\"myAnchor\"href=\"https://developer.mozilla.org/en-US/docs/Location.hostname\">varanchor=document.getElementById('myAnchor')varresult=anchor.hostname//Returns:'developer.mozilla.org'```###href>Location接口的href属性是一个字符串化转换器(stringifier),返回一个包含了完整URL的USVString值,且允许href的更新.```js//string=object.href;//object.href=string;//假设文档中包含标签：<aid=\"myAnchor\"href=\"https://developer.mozilla.org/en-US/Location/href\">varanchor=document.getElementById('myAnchor')varresult=anchor.href//返回:'https://developer.mozilla.org/en-US/Location/href'```###origin>Theoriginread-onlypropertyoftheLocationinterfaceisaUSVStringcontainingtheUnicodeserializationoftheoriginoftherepresentedURL.>>-forURLusingthehttporhttps,theschemefollowedby'://',followedbythedomain,followedby':',followedbytheport(thedefaultport,80and443respectively,ifexplicitlyspecified);>-forURLusingfile:scheme,thevalueisbrowserdependant;>-forURLusingtheblob:scheme,theoriginoftheURLfollowingblob:.E.g\"blob:<https://mozilla.org>\"willhave\"https://mozilla.org\".>-Note:ThisfeatureisavailableinWebWorkers```js//string=object.origin;//CopytoClipboard//Onthispage,returnstheoriginvarresult=window.location.origin//Returns:'https://developer.mozilla.org'```###password>Deprecated:Thisfeatureisnolongerrecommended.Thoughsomebrowsersmightstillsupportit,itmayhavealreadybeenremovedfromtherelevantwebstandards,maybeintheprocessofbeingdropped,ormayonlybekeptforcompatibilitypurposes.Avoidusingit,andupdateexistingcodeifpossible;seethecompatibilitytableatthebottomofthispagetoguideyourdecision.Beawarethatthisfeaturemayceasetoworkatanytime.>>ThepasswordpropertyoftheLocationinterfaceisaUSVStringcontainingthepasswordspecifiedbeforethedomainname.>>Ifitissetwithoutfirstsettingtheusernameproperty,itsilentlyfails.```js//string=object.password;//object.password=string;//Let's<aid=\"myAnchor\"href=\"https://anonymous:flabada@developer.mozilla.org/en-US/docs/location.username\">beinthedocumentvaranchor=document.getElementByID('myAnchor')varresult=anchor.password//Returns:'flabada'```###pathname>ThepathnamepropertyoftheLocationinterfaceisaUSVStringcontainingthepathoftheURLforthelocation,whichwillbetheemptystringifthereisnopath.```js//string=object.pathname;//object.pathname=string;//Let'san<aid=\"myAnchor\"href=\"/en-US/docs/Location.pathname\">elementbeinthedocumentvaranchor=document.getElementById('myAnchor')varresult=anchor.pathname//Returns:'/en-US/docs/Location.pathname'```###port>TheportpropertyoftheLocationinterfaceisaUSVStringcontainingtheportnumberoftheURL.IftheURLdoesnotcontainanexplicitportnumber,itwillbesetto''.```js//string=object.port;//object.port=string;//Let'san<aid=\"myAnchor\"href=\"https://developer.mozilla.org:443/en-US/docs/Location.port\">elementbeinthedocumentvaranchor=document.getElementByID('myAnchor')varresult=anchor.port//Returns:'443'```###protocol>TheprotocolpropertyoftheLocationinterfaceisaUSVStringrepresentingtheprotocolschemeoftheURL,includingthefinal':'.```js//string=object.protocol;//object.protocol=string;//Let'san<aid=\"myAnchor\"href=\"https://developer.mozilla.org/en-US/Location.protocol\">elementbeinthedocumentvaranchor=document.getElementById('myAnchor')varresult=anchor.protocol//Returns:'https:'```###search>ThesearchpropertyoftheLocationinterfaceisasearchstring,alsocalledaquerystring;thatis,aUSVStringcontaininga'?'followedbytheparametersoftheURL.>>ModernbrowsersprovideURLSearchParamsandURL.searchParamstomakeiteasytoparseouttheparametersfromthequerystring.```jsstring=object.searchobject.search=string//Letan<aid=\"myAnchor\"href=\"/en-US/docs/Location.search?q=123\">elementbeinthedocumentvaranchor=document.getElementById('myAnchor')varqueryString=anchor.search//Returns:'?q=123'//Furtherparsing:letparams=newURLSearchParams(queryString)letq=parseInt(params.get('q'))//isthenumber123```###username>Deprecated:Thisfeatureisnolongerrecommended.Thoughsomebrowsersmightstillsupportit,itmayhavealreadybeenremovedfromtherelevantwebstandards,maybeintheprocessofbeingdropped,ormayonlybekeptforcompatibilitypurposes.Avoidusingit,andupdateexistingcodeifpossible;seethecompatibilitytableatthebottomofthispagetoguideyourdecision.Beawarethatthisfeaturemayceasetoworkatanytime.>>TheusernamepropertyoftheLocationinterfaceisaUSVStringcontainingtheusernamespecifiedbeforethedomainname.```jsstring=object.usernameobject.username=string//Let's<aid=\"myAnchor\"href=\"https://anonymous:flabada@developer.mozilla.org/en-US/docs/Location.username\">beinthedocumentvaranchor=document.getElementByID('myAnchor')varresult=anchor.username//Returns:'anonymous'```##方法###location.assign()>Location.assign()方法会触发窗口加载并显示指定的URL的内容。>如果由于安全原因无法执行跳转，那么会抛出一个SECURITY_ERROR类型的DOMException。当调用此方法的脚本来源和页面的Location对象中定义的来源隶属于不同域的时候，就会抛出上述错误。>如果传入了一个无效的URL，则会抛出一个SYNTAX_ERROR类型的DOMException。```jslocation.assign(url)//跳转到Location.reload()这篇文章document.location.assign('https://developer.mozilla.org/zh-CN/docs/Web/API/Location/reload',)```###Location.reload()>Location.reload()方法用来刷新当前页面。该方法只有一个参数，当值为true时，将强制浏览器从服务器加载页面资源，当值为false或者未传参时，浏览器则可能从缓存中读取页面。>该方法在跨域调用（执行该方法的脚本文件的域和Location对象所在页面的跨不同）时，将会抛出DOMException异常。```jsobject.reload(forcedReload)//无缓存刷新页面（但页面引用的资源还是可能使用缓存，//大多数浏览器可以通过设置在打开开发者工具时禁用缓存实现无缓存需求）window.location.reload(true)//forcedReload可选//该参数要求为布尔(en-US)类型，当取值为true时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为false或不传该参数时，浏览器则可能会从缓存中读取当前页面。```###Location.replace()>Location.replace()方法以给定的URL来替换当前的资源。与assign()方法不同的是，调用replace()方法后，`当前页面不会保存到会话历史`中（sessionHistory），这样，用户点击回退按钮时，将不会再跳转到该页面。>因违反安全规则导致的赋值失败，浏览器将会抛出类型为SECURITY_ERROR的DOMException异常。当调用该方法的脚本所属的源与拥有Location对象所属源不同时，通常情况会发生这种异常,此时通常该脚本是存在不同的域下。>如果URL无效，浏览器也会抛出SYNTAX_ERROR类型的DOMException异常。```JS//object.replace(url);//参数//url//DOMString类型，指定所导航到的页面的URL地址。//示例//NavigatetotheLocation.reloadarticlebyreplacingthispagewindow.location.replace('https://developer.mozilla.org/en-US/docs/Web/API/Location/reload');```###Location:toString()>toString()Location接口的stringifier方法返回包含整个URL的USVString}。它是Location.href的只读版本。```js//string=object.toString();//例子//Let'simaginean<aid=\"myAnchor\"href=\"https://developer.mozilla.org/en-US/docs/Location/toString\">elementisinthedocumentvaranchor=document.getElementById('myAnchor')varresult=anchor.toString()//Returns:'https://developer.mozilla.org/en-US/docs/Location/toString'```","Front-End\\浏览器\\Web Api\\postMessage.md":"#PostMessage>`window.postMessage()`方法可以安全地实现跨源通信。>>通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机(两个页面的模数[`Document.domain`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain)设置为相同的值)时，这两个脚本才能相互通信。>>`window.postMessage()`方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。从广义上讲，一个窗口可以获得对另一个窗口的引用（比如`targetWindow=window.opener`），然后在窗口上调用`targetWindow.postMessage()`方法分发一个[`MessageEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent)消息。接收消息的窗口可以根据需要自由[处理此事件(en-US)](https://developer.mozilla.org/en-US/docs/Web/Events)。传递给window.postMessage()的参数（比如message）将[通过消息事件对象暴露给接收消息的窗口](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#The_dispatched_event)。##[语法](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#syntax)```jsotherWindow.postMessage(message,targetOrigin,[transfer])```-`otherWindow`其他窗口的一个引用，比如iframe的contentWindow属性、执行[window.open](https://developer.mozilla.org/en-US/docs/Web/API/Window/open)返回的窗口对象、或者是命名过或数值索引的[window.frames](https://developer.mozilla.org/en-US/docs/Web/API/Window/frames)。-`message`将要发送到其他window的数据。它将会被[结构化克隆算法](https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm)序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。[[1](https://developer.mozilla.org/en-US/docs/)]-`targetOrigin`通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串\"\\*\"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\\*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。**-`transfer`可选是一串和message同时传递的[Transferable](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable)对象.这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。##[Thedispatchedevent](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#the_dispatched_event)执行如下代码,其他window可以监听分发的message:```jswindow.addEventListener('message',receiveMessage,false)functionreceiveMessage(event){//ForChrome,theoriginpropertyisintheevent.originalEvent//object.//这里不准确，chrome没有这个属性//varorigin=event.origin||event.originalEvent.origin;varorigin=event.originif(origin!=='http://example.org:8080')return//...}```CopytoClipboardmessage的属性有:-`data`从其他window中传递过来的对象。-`origin`调用`postMessage`时消息发送方窗口的[origin](https://developer.mozilla.org/en-US/docs/Origin).这个字符串由协议、“://“、域名、“:端口号”拼接而成。例如“`https://example.org`(隐含端口`443`)”、“`http://example.net`(隐含端口`80`)”、“`http://example.com:8080`”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。-`source`对发送消息的[窗口](https://developer.mozilla.org/en-US/docs/Web/API/Window)对象的引用;您可以使用此来在具有不同origin的两个窗口之间建立双向通信。##[安全问题](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#security_concerns)**如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器。**这是一个完全万无一失的方式来避免安全问题。如果您确实希望从其他网站接收message，请**始终使用origin和source属性验证发件人的身份**。任何窗口（包括例如http://evil.example.com）都可以向任何其他窗口发送消息，并且您不能保证未知发件人不会发送恶意消息。但是，验证身份后，您仍然应该**始终验证接收到的消息的语法**。否则，您信任只发送受信任邮件的网站中的安全漏洞可能会在您的网站中打开跨网站脚本漏洞。**当您使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是\\*。**恶意网站可以在您不知情的情况下更改窗口的位置，因此它可以拦截使用postMessage发送的数据。##[示例](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#example)```js/**A窗口的域名是<http://example.com:8080>，以下是A窗口的script标签下的代码：*/varpopup=window.open(...popupdetails...);//如果弹出框没有被阻止且加载完成//这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对）popup.postMessage(\"Theuseris'bob'andthepasswordis'secret'\",\"https://secure.example.net\");//假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）popup.postMessage(\"hellothere!\",\"http://example.org\");functionreceiveMessage(event){//我们能相信信息的发送者吗?(也许这个发送者和我们最初打开的不是同一个页面).if(event.origin!==\"http://example.org\")return;//event.source是我们通过window.open打开的弹出页面popup//event.data是popup发送给当前页面的消息\"hithereyourself!thesecretresponseis:rheeeeet!\"}window.addEventListener(\"message\",receiveMessage,false);```CopytoClipboard```js/**弹出页popup域名是<http://example.org>，以下是script标签中的代码:*///当A页面postMessage被调用后，这个function被addEventListener调用functionreceiveMessage(event){//我们能信任信息来源吗？if(event.origin!=='http://example.com:8080')return//event.source就当前弹出页的来源页面//event.data是\"hellothere!\"//假设你已经验证了所受到信息的origin(任何时候你都应该这样做),一个很方便的方式就是把event.source//作为回信的对象，并且把event.origin作为targetOriginevent.source.postMessage('hithereyourself!thesecretresponse'+'is:rheeeeet!',event.origin,)}window.addEventListener('message',receiveMessage,false)```CopytoClipboard###[**注意**](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#notes)>-任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。因此，用于接收消息的任何事件监听器**必须**首先使用origin和source属性来检查消息的发送者的身份。**这不能低估：无法检查origin和source属性会导致跨站点脚本攻击。**>-与任何异步调度的脚本（超时，用户生成的事件）一样，postMessage的调用者不可能检测到侦听由postMessage发送的事件的事件处理程序何时抛出异常。>-分派事件的origin属性的值不受调用窗口中document.domain的当前值的影响。>-仅对于IDN主机名，origin属性的值不是始终为Unicode或punycode;在使用此属性时，如果您期望来自IDN网站的消息，则最大程度地兼容性检查IDN和punycode值。这个值最终将始终是IDN，但现在你应该同时处理IDN和punycode表单。>-当发送窗口包含`javascript:`或`data:`URL时，origin属性的值是加载URL的脚本的###[在扩展中使用window.postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#在扩展non-standard_inline中使用window.postmessage)`window.postMessage`可用于以chrome代码运行的JavaScript（例如，在扩展和特权代码中），但是分派事件的source属性总是为空作为安全限制。（其他属性具有其期望值。）发送到位于chrome：URL的窗口的消息的`targetOrigin`参数当前被错误解释，使得将导致发送消息的唯一值为`“*”`。由于此值是不安全的，当目标窗口可以导航到其他地方的恶意网站，建议postMessage不用于与chrome：页面的沟通;使用不同的方法（如打开窗口时的查询字符串）与chrome窗口进行通信。最后，在文件中向页面发布消息：URL当前要求`targetOrigin`参数为`“*”`。`file://`不能用作安全限制;这个限制可能会在将来被修改。##Eg>原理>利用postMessage不能和服务端交换数据，只能在两个窗口（iframe）之间交换数据>两个窗口能通信的前提是，一个窗口以iframe的形式存在于另一个窗口，或者一个窗口是从另一个窗口通过window.open()或者超链接的形式打开的（同样可以用window.opener获取源窗口）###index.html```html<!doctypehtml><html><head><metacharset=\"UTF-8\"/></head><body><formid=\"form\"><inputtype=\"text\"placeholder=\"Entermessage\"name=\"message\"autocomplete=\"off\"/><inputtype=\"submit\"value=\"Clicktosend\"/></form><iframesrc=\"./iframe.html\"id=\"iframe\"style=\"display:block;height:300px\"></iframe><script>form.onsubmit=function(){iframe.contentWindow.postMessage(this.message.value,'http://localhost:3000/iframe.html',)returnfalse}</script></body></html>```###iframe.html```html<!doctypehtml><html><head><metacharset=\"UTF-8\"/></head><body><divid=\"showhere\"></div>Receivingiframe.<script>window.addEventListener('message',function(event){console.log(`Received${event.data}from${event.origin}`)document.getElementById('showhere').innerHTML+=event.data})</script></body></html>```","Front-End\\浏览器\\Web Api\\requestAnimationFrame.md":"#window.requestAnimationFrame>`window.requestAnimationFrame()`告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。>>该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行```js;(()=>{letn=0functiontest(){n++console.log(`🚀🚀hello~requestAnimationFrame${n}`)if(n<11)requestAnimationFrame(test)}requestAnimationFrame(test)})()```","Front-End\\浏览器\\web点击劫持X-Frame-Options.md":"#Web点击劫持X-Frame-Options###原理解释>点击劫持，[clickjacking](https://baike.baidu.com/item/clickjacking)，也被称为UI-覆盖攻击。这个词首次出现在2008年，是由[互联网](https://baike.baidu.com/item/互联网)安全专家罗伯特·汉森和耶利米·格劳斯曼首创的。它是通过覆盖不可见的框架误导受害者点击。虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。这种攻击利用了HTML中`<iframe>`标签的透明属性。就像一张图片上面铺了一层透明的纸一样，你看到的是黑客的页面，但是其实这个页面只是在底部，而你真正点击的是被黑客透明化的另一个网页。一个简单的点击劫持例子，就是当你点击了一个不明链接之后，自动关注了某一个人的博客或者订阅了视频。假如我在优酷发布了很多视频，想让更多的人关注它，于是我们准备了一个页面：```html<!DOCTYPEhtml><html><metahttp-equiv=\"Content-Type\"content=\"text/html;charset=utf-8\"/><head><title>点击劫持POC</title><style>iframe{width:1440px;height:900px;position:absolute;top:-0px;left:-0px;z-index:2;-moz-opacity:0;opacity:0;filter:alpha(opacity=0);}button{position:absolute;top:270px;left:1150px;z-index:1;width:90px;height:40px;}</style></head><body><button>美女图片</button><imgsrc=\"http://pic1.win4000.com/wallpaper/2018-03-19/5aaf2bf0122d2.jpg\"/><iframesrc=\"http://i.youku.com/u/UMjA0NTg4Njcy\"scrolling=\"no\"></iframe></body></html>```当然真正的页面肯定会更精致一些，不会这么简陋。然而这个页面只是表象而已，我们把iframe的透明度改成0.3以后再看看![img](web点击劫持X-Frame-Options.assets/20180319164653726)当你点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了![img](web点击劫持X-Frame-Options.assets/20180319164951941)当然点击劫持的危害可大可小，并不仅仅是关注订阅之类的东西，但是原理类似。###解决方案X-Frame-OptionsHTTP响应头是用来给浏览器指示允许一个页面可否在<frame>,</iframe>或者<object>中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌套到别人的网站中去，也从而避免了点击劫持(clickjacking)的攻击。X-Frame-Options三个参数:1、DENY表示该页面不允许在frame中展示，即便是在相同域名的页面中嵌套也不允许。2、SAMEORIGIN表示该页面可以在相同域名页面的frame中展示。3、ALLOW-FROMuri表示该页面可以在指定来源的frame中展示。换一句话说，如果设置为DENY，不光在别人的网站frame嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为SAMEORIGIN，那么页面就可以在同域名页面的frame中嵌套。正常情况下我们通常使用SAMEORIGIN参数。Apache配置需要把下面这行添加到'site'的配置中```bashHeaderalwaysappendX-Frame-OptionsSAMEORIGIN```nginx配置需要添加到‘http’,‘server’或者‘location’的配置项中，个人来讲喜欢配置在‘server’中正常情况下都是使用SAMEORIGIN参数，允许同域嵌套```bashadd_headerX-Frame-OptionsSAMEORIGIN;```允许单个域名iframe嵌套```bashadd_headerX-Frame-OptionsALLOW-FROMhttp://whsir.com/;```允许多个域名iframe嵌套，注意这里是用**逗号**分隔```bashadd_headerX-Frame-Options\"ALLOW-FROMhttp://whsir.com/,https://cacti.org.cn/\";```IIS配置添加下面的配置到‘Web.config’文件中```xml<system.webServer>...<httpProtocol><customHeaders><addname=\"X-Frame-Options\"value=\"SAMEORIGIN\"/></customHeaders></httpProtocol>...</system.webServer>```HAProxy配置添加下面这行到‘front-end,listen,orbackend’配置中```bashrspaddX-Frame-Options:\\SAMEORIGIN```Tomcat配置在‘conf/web.xml’填加以下配置```xml<filter><filter-name>httpHeaderSecurity</filter-name><filter-class>org.apache.catalina.filters.HttpHeaderSecurityFilter</filter-class><init-param><param-name>antiClickJackingOption</param-name><param-value>SAMEORIGIN</param-value></init-param><async-supported>true</async-supported></filter><filter-mapping><filter-name>httpHeaderSecurity</filter-name><url-pattern>/*</url-pattern><dispatcher>REQUEST</dispatcher><dispatcher>FORWARD</dispatcher></filter-mapping>```配置后如何确定X-Frame-Options是否已生效呢？我这里以Google浏览器为例，打开网站按F12键，选择Network，找到对应的Headers，如下图所示![img](web点击劫持X-Frame-Options.assets/aHR0cHM6Ly9jZG4ud2hzaXIuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzAzL1gtRnJhbWUtT3B0aW9uc19IZWFkZXJzLnBuZw)","Front-End\\浏览器\\window\\closed.md":"#window.closed>-只读>-表示所引用的窗口是```jsisClosed=windowRef.closed````isClosed`:-`true`:窗口已被关闭-`false`:窗口是打开的##example###更改一个弹出窗口的URL>下面的示例演示怎样更改一个已打开的弹出窗口的URL。尝试更改URL之前，它使用`window.opener`属性来检查有窗口被打开，并且该窗口没有关闭```js//Checkthatanopenerexistsandisnotclosedif(window.opener&&!window.opener.closed){window.opener.location.href='http://www.mozilla.org'}```>请注意，弹出窗口只能访问打开他们的窗口。###刷新先前打开的弹出窗口>在这个例子中，函数`refreshPopupWindow()`调用重载方法的弹出的位置要刷新其数据的对象>如果弹出窗口尚未打开，或者用户已关闭它打开一个新窗口```jsvarpopupWindow=nullfunctionrefreshPopupWindow(){if(popupWindow&&!popupWindow.closed){//popupWindowisopen,refreshitpopupWindow.location.reload(true)}else{//OpenanewpopupwindowpopupWindow=window.open('popup.html','dataWindow')}}```","Front-End\\浏览器\\window\\content.md":"#content>-不属于W3C规范>-返回主内容窗口的Window对象.该属性只在包含有属性type=\"content-primary\"的`<browser>`(或者`tabbrowser`或者`<iframe>`)标签的XUL窗口下才会用到。最常用到的地方就是Firefox的主窗口，browser.xul.在这种情况下，content返回一个浏览器中的当前页面的Window对象的引用.相当于browserRef.contentWindow的快捷方式.-在一个非特权的内容窗口中(网页),content等同于普通的top(除非网页是在侧边栏中加载的，content仍然会指向当前标签页中的Window对象).-一些旧的代码示例中使用了\\_content而不是content.该形式的属性名已经被废弃很久了，你应该在新的代码中使用content.```jsvarwindowObject=window.content```##example在一个拥有`<browsertype=\"content-primary\"/>`标签的chromeXUL窗口下运行下面的代码。会在浏览器当前显示的页面上的第一个div标签上添加一个红色的边框：```jscontent.document.getElementsByTagName['div'](0).style.border='solidred1px'```","Front-End\\浏览器\\window\\customElements.md":"#customElements>`customElements`是Window对象上的一个只读属性，接口返回一个`CustomElementRegistry`对象的引用，可用于注册新的`customelements`，或者获取之前定义过的自定义元素的信息##example>这个属性最常用的例子是用来获取使用`CustomElementRegistry.define()`方法定义和注册的自定义元素```jsletcustomElementRegistry=window.customElementscustomElementRegistry.define('my-custom-element',MyCustomElement)```通常缩写：```jscustomElements.define('element-details',classextendsHTMLElement{constructor(){super()consttemplate=document.getElementById('element-details-template',).contentconstshadowRoot=this.attachShadow({mode:'open'}).appendChild(template.cloneNode(true),)}},)```","Front-End\\浏览器\\window\\devicePixelRatio.md":"#[devicePixelRatio](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/devicePixelRatio)>-`Window`接口的`devicePixelRatio`返回当前显示设备的物理像素分辨率与CSS像素分辨率之比。>-可解释为像素大小的比率：一个CSS像素的大小与一个物理像素的大小。简单来说，它告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素>-当处理标准显示器与HiDPI或Retina显示器之间的差异时，这很有用，后者使用更多的屏幕像素绘制相同的对象，从而获得更清晰的图像>-可以使用`window.matchMedia()`检查`devicePixelRatio`的值是否发生更改（例如，如果用户将窗口拖动到带有不同的像素密度）```jsvalue=window.devicePixelRatio```##值Value一个双精度浮点值，指示显示器的物理像素分辨率与CSS像素分辨率之比-值1表示经典96DPI（在某些平台上为76DPI）显示-对于HiDPI/Retina显示屏则期望值为2。在异常低分辨率的显示器中-当屏幕的像素深度比简单地将96或76DPI的标准分辨率提高一倍时，可能还会返回其他值。##在`<canvas>`中更正分辨率>`<canvas>`可能在视网膜屏幕上显得太模糊>使用`window.devicePixelRatio`确定应添加多少额外的像素密度以使图像更清晰```html<canvasid=\"canvas\"></canvas>``````jsvarcanvas=document.getElementById('canvas')varctx=canvas.getContext('2d')//Setdisplaysize(csspixels).varsize=200canvas.style.width=size+'px'canvas.style.height=size+'px'//Setactualsizeinmemory(scaledtoaccountforextrapixeldensity).varscale=window.devicePixelRatio//Changeto1onretinascreenstoseeblurrycanvas.canvas.width=Math.floor(size*scale)canvas.height=Math.floor(size*scale)//Normalizecoordinatesystemtousecsspixels.ctx.scale(scale,scale)ctx.fillStyle='#bada55'ctx.fillRect(10,10,300,300)ctx.fillStyle='#ffffff'ctx.font='18pxArial'ctx.textAlign='center'ctx.textBaseline='middle'varx=size/2vary=size/2vartextString='IloveMDN'ctx.fillText(textString,x,y)```![](./.assets/devicePixelRatio-2022-12-09-10-46-05.png)##监视屏幕分辨率或缩放级别的更改>在此示例中，我们将设置一个媒体查询并观看它以查看设备分辨率何时更改，以便我们可以检查`devicePixelRatio`的值来处理所需的任何更新>JavaScript代码创建媒体查询，以监控设备分辨率并在每次更改时检查`devicePixelRatio`的值```jsletpixelRatioBox=document.querySelector('.pixel-ratio')letmqString=`(resolution:${window.devicePixelRatio}dppx)`constupdatePixelRatio=()=>{letpr=window.devicePixelRatioletprString=(pr*100).toFixed(0)pixelRatioBox.innerText=`${prString}%(${pr.toFixed(2)})`}updatePixelRatio()matchMedia(mqString).addListener(updatePixelRatio)```>字符串`mqString`设置为媒体查询本身。媒体查询以`(resolution:1dppx)`（对于标准显示）或`(resolution:2dppx)`（对于`Retina`/`HiDPI`显示）开始，检查当前显示分辨率是否与每个像素px的实际设备像素点匹配>`updatePixelRatio()`函数获取`devicePixelRatio`的当前值，然后将`pixelRatioBox`的`innerText`设置为一个字符串，该字符串同时显示百分比和原始十进制值比率，最多两位小数>调用`updatePixelRatio()`函数一次以显示起始值，然后使用`matchMedia()`和`addEventListener()`来将updatePixelRatio()设置为change事件的处理程序>HTML将创建包含说明的框和将显示当前像素比率信息的pixel-ratio框。```html<divclass=\"container\"><divclass=\"inner-container\"><p>Thisexampledemonstratestheeffectofzoomingthepageinandout(ormovingittoascreenwithadifferentscalingfactor)onthevalueoftheproperty<code>Window.devicePixelRatio</code>.Tryitandwatchwhathappens!</p></div><divclass=\"pixel-ratio\"></div></div>``````cssbody{font:22pxarial,sans-serif;}.container{top:2em;width:22em;height:14em;border:2pxsolid#22d;margin:0auto;padding:0;background-color:#a9f;}.inner-container{padding:1em2em;text-align:justify;text-justify:auto;}.pixel-ratio{position:relative;margin:auto;height:1.2em;text-align:right;bottom:0;right:1em;font-weight:bold;}```![](./.assets/devicePixelRatio-2022-12-09-10-52-02.png)>>`devicePixelRatio`=1时候","Front-End\\浏览器\\window\\document\\index.md":"#[`document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/document)>`window.document`返回当前窗口内的文档节点[`document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)","Front-End\\浏览器\\window\\frameElement.md":"#[`frameElement`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/frameElement)>返回嵌入当前window对象的元素(比如`<iframe>`或者`<object>`),如果当前window对象已经是顶层窗口，则返回`null````jsvarframeEl=window.frameElement```##example```jsvarframeEl=window.frameElement//如果当前窗口被包含在一个框架里面，则将该框架的地址跳到'http://mozilla.org/'if(frameEl)frameEl.src='http://mozilla.org/'```>虽然该属性名为frameElement,但该属性也会返回其他类型比如`<object>`或者其他可嵌入窗口的元素##相关链接-`window.frames`返回一个类数组对象，返回当前窗口的所有子框架元素-`window.parent`返回当前窗口的父窗口，也就是说，包含当前窗口所在的frameElement元素的窗口","Front-End\\浏览器\\window\\frames.md":"#[`frames`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/frames)>返回当前窗口，一个类数组对象，列出了当前窗口的所有直接子窗口```jsframeList=window.frames```-frameList是一个frame对象的集合，它类似一个数组，有length属性且可以使用索引（[i]）来访问-frameList===window计算结果为true-在window.frames类数组中的每一项都代表了窗口对应给定对象的`<frame>`或`<iframe>`的内容，而不是`(i)frameDOM`元素（即`window.frames[0]`与`document.getElementsByTagName[\"iframe\"](0).contentWindow`是相同的）```jsvarframes=window.frames//或//varframes=window.parent.frames;for(vari=0;i<frames.length;i++){//在这对frames的一个frame做点什么frames[i].document.body.style.background='red'}```","Front-End\\浏览器\\window\\history.md":"#[`history`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/history)-`Window.history`是一个只读属性，用来获取`History`对象的引用，`History`对象提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口-`History`对象有如下方法：参见[`Manipulatingthebrowserhistory`](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)中的示例和详情。尤其指出的是文章里解释了在使用`pushState()`和`replaceState()`方法前，你需要了解的安全问题```jsvarhistoryObj=window.historyhistory.back()//等同于点击浏览器的回退按钮history.go(-1)//等同于history.back();```##附注-在顶层页面中，浏览器的回退和前进按钮旁的下拉菜单显示了可以通过History对象访问到的页面会话历史（sessionhistory）列表。-出于安全考虑，History对象不允许未授权代码访问会话历史（sessionHistory）中其它页面的URLs，但可以导航到其它会话历史（sessionHistory）指向的页面。-未授权代码无法清除会话历史（sessionHistory），也不能禁用回退/前进功能。最快捷的可用方式是使用location.replace()方法，提供指定的URL来替换当前的会话历史（sessionhistory）。","Front-End\\浏览器\\window\\innerHeight.md":"#[`innerHeight`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/innerHeight)>-浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度>-任何窗口对象，如window、frame、frameset或secondarywindow都支持innerHeight属性```jsvarintViewportHeight=window.innerHeight```-`intViewportHeight`为浏览器窗口的视口的高度-`window.innerHeight`属性为只读，且没有默认值有一个算法用来获取不包括水平滚动条的视口高度。##Example>frameset```jsvarintFrameHeight=window.innerHeight//orvarintFrameHeight=self.innerHeight//返回frameset里面的frame视口的高度varintFramesetHeight=parent.innerHeight//返回上一级frameset的视口的高度varintOuterFramesetHeight=top.innerHeight//返回最外部frameset的视口的高度```{{todo(\"linktoaninteractivedemohere\")}}改变一个窗口的大小，可以查看`window.resizeBy()`和`window.resizeTo()`想获取窗口的外层高度（outerheight），即整个浏览器窗口的高度，请查看`window.outerHeight`","Front-End\\浏览器\\window\\innerWidth.md":"#[innerWidth](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/innerWidth)>-只读的Window属性innerWidth返回以像素为单位的窗口的内部宽度>-如果垂直滚动条存在，则这个属性将包括它的宽度>>`innerWidth`返回窗口的`layoutviewport(en-US)`的宽度。窗口的内部高度——布局视口的高度——可以从`innerHeight`属性中获取到```jsletintViewportWidth=window.innerWidth```-一个整数型的值表示窗口的布局视口宽度是以像素为单位的。这个属性是只读的，并且没有默认值。-若要更改窗口的宽度，请使用`Window`的方法来调整窗口的大小，例如`resizeBy()`或者`resizeTo()`使用说明-如果你需要获取除去滚动条和边框的窗口宽度，请使用根元素`<html>`的clientWidth属性-`innerWidth`属性在任何表现类似于窗口的任何窗口或对象（例如框架或选项卡）上都是可用的```js//返回视口的宽度varintFrameWidth=window.innerWidth//返回一个框架集内的框架的视口宽度varintFrameWidth=self.innerWidth//返回最近的父级框架集的视口宽度varintFramesetWidth=parent.innerWidth//返回最外层框架集的视口宽度varintOuterFramesetWidth=top.innerWidth```","Front-End\\浏览器\\window\\length.md":"#[`window.length`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/length)>返回当前窗口中包含的框架数量(框架包括`frame`和`iframe`两种元素)","Front-End\\浏览器\\window\\localStorage.md":"#[`localStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage)>只读的localStorage属性允许你访问一个Document源（origin）的对象`Storage`；存储的数据将保存在浏览器会话中。localStorage类似sessionStorage，但其区别在于：>存储在localStorage的数据可以长期保留；>而当页面会话结束——也就是说，当页面被关闭时，存储在sessionStorage的数据会被清除。应注意，无论数据存储在localStorage还是sessionStorage，它们都特定于页面的协议。>localStorage中的键值对总是以字符串的形式存储。(需要注意，和js对象相比，键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型)```jsmyStorage=localStorage```>一个可被用于访问当前源（origin）的本地存储空间的Storage对象。##异常##`SecurityError`>请求违反了一个策略声明，或者源（origin）不是一个有效的scheme/host/porttuple（例如如果origin使用file:或者data:形式将可能发生）。比如，用户可以有禁用允许对指定的origin存留数据的浏览器配置。##示例下面的代码片段访问了当前域名下的本地Storage对象，并通过Storage.setItem()增加了一个数据项目。`localStorage.setItem('myCat','Tom')`该语法用于读取localStorage项，如下：`letcat=localStorage.getItem('myCat')`该语法用于移除localStorage项，如下：`localStorage.removeItem('myCat')`该语法用于移除所有的localStorage项，如下：//移除所有localStorage.clear();","Front-End\\浏览器\\window\\location.md":"#[`location`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location)","Front-End\\浏览器\\window\\open.md":"##开启一个新弹框```jswindow.open('page.html','newwindow','height=100,width=400,top=0,left=0,toolbar=no,menubar=no,scrollbars=no,resizable=no,location=no,status=no',)```【1、最基本的弹出窗口代码】<SCRIPTLANGUAGE=”javascript”><!–window.open(‘page.html’)–></SCRIPT>因为这是一段javascripts代码，所以它们应该放在<SCRIPTLANGUAGE=”javascript”>标签和</script>之间。<!–和–>是对一些版本低的浏览器起作用，在这些老浏览器中不会将标签中的代码作为文本显示出来。要养成这个好习惯啊。window.open(‘page.html’)用于控制弹出新的窗口page.html，如果page.html不与主窗口在同一路径下，前面应写明路径，绝对路径(<http://)和相对路径(../)均可。用单引号和双引号都可以，只是不要混用。这一段代码可以加入HTML>的任意位置，<head>和</head>之间可以，<body>间</body>也可以，越前越早执行，尤其是页面代码长，又想使页面早点弹出就尽量往前放。【2、经过设置后的弹出窗口】下面再说一说弹出窗口的设置。只要再往上面的代码中加一点东西就可以了。我们来定制这个弹出的窗口的外观，尺寸大小，弹出的位置以适应该页面的具体情况。<SCRIPTLANGUAGE=”javascript”><!–window.open(‘page.html’,‘newwindow’,‘height=100,width=400,top=0,left=0,toolbar=no,menubar=no,scrollbars=no,resizable=no,location=no,status=no’)//这句要写成一行–></SCRIPT>参数解释：<SCRIPTLANGUAGE=”javascript”>js脚本开始；window.open弹出新窗口的命令；‘page.html’弹出窗口的文件名；‘newwindow’弹出窗口的名字（不是文件名），非必须，可用空”代替；height=100窗口高度；width=400窗口宽度；top=0窗口距离屏幕上方的象素值；left=0窗口距离屏幕左侧的象素值；toolbar=no是否显示工具栏，yes为显示；menubar，scrollbars表示菜单栏和滚动栏。resizable=no是否允许改变窗口大小，yes为允许；location=no是否显示地址栏，yes为允许；status=no是否显示状态栏内的信息（通常是文件已经打开），yes为允许；</SCRIPT>js脚本结束【3、用函数控制弹出窗口】下面是一个完整的代码。<html><head><scriptLANGUAGE=”JavaScript”><!–functionopenwin(){window.open(“page.html”,“newwindow”,“height=100,width=400,toolbar=no,menubar=no,scrollbars=no,resizable=no,location=no,status=no”)//写成一行}//–></script></head><bodyοnlοad=”openwin()”>任意的页面内容…</body></html>这里定义了一个函数openwin(),函数内容就是打开一个窗口。在调用它之前没有任何用途。怎么调用呢？方法一：<bodyοnlοad=”openwin()”>浏览器读页面时弹出窗口；方法二：<bodyοnunlοad=”openwin()”>浏览器离开页面时弹出窗口；方法三：用一个连接调用：<ahref=”#”οnclick=”openwin()”>打开一个窗口</a>注意：使用的“#”是虚连接。方法四：用一个按钮调用：<inputtype=”button”οnclick=”openwin()”value=”打开窗口”>【4、同时弹出2个窗口】对源代码稍微改动一下：<scriptLANGUAGE=”JavaScript”><!–functionopenwin(){window.open(“page.html”,“newwindow”,“height=100,width=100,top=0,left=0,toolbar=no,menubar=no,scrollbars=no,resizable=no,location=no,status=no”)//写成一行window.open(“page2.html”,“newwindow2″,“height=100,width=100,top=100,left=100,toolbar=no,menubar=no,scrollbars=no,resizable=no,location=no,status=no”)//写成一行}//–></script>为避免弹出的2个窗口覆盖，用top和left控制一下弹出的位置不要相互覆盖即可。最后用上面说过的四种方法调用即可。注意：2个窗口的name(newwindows和newwindow2)不要相同，或者干脆全部为空。【5、主窗口打开文件1.htm，同时弹出小窗口page.html】如下代码加入主窗口<head>区：<scriptlanguage=”javascript”><!–functionopenwin(){window.open(“page.html”,””,”width=200,height=200″)}//–></script>加入<body>区：<ahref=”1.htm”οnclick=”openwin()”>open</a>即可。【6、弹出的窗口之定时关闭控制】下面我们再对弹出的窗口进行一些控制，效果就更好了。如果我们再将一小段代码加入弹出的页面(注意是加入page.html的HTML中，不是主页面中)，让它10秒后自动关闭是不是更酷了？首先，将如下代码加入page.html文件的<head>区：<scriptlanguage=”JavaScript”>functioncloseit(){setTimeout(“self.close()”,10000)//毫秒}</script>然后，再用<bodyοnlοad=”closeit()”>这一句话代替page.html中原有的<BODY>这一句就可以了。(这一句话千万不要忘记写啊！这一句的作用是调用关闭窗口的代码，10秒钟后就自行关闭该窗口。)","Front-End\\浏览器\\兼容开发\\IE8.md":"#IE8##IE在input内回车关闭自动触发button<https://www.qttc.net/393-ie-enter-trigger-button-click.html>>在IE中有一个现象，当你在input内敲回车时，IE会自动寻找第一个button标签并且触发它。index.html:```html<p><buttononclick=\"console.log('frombuttonclick');\">button</button></p><p><inputtype=\"text\"value=\"在这里回车就触发提交按钮\"style=\"width:300px;\"/></p>```>使用IE打开，并且在input内回车，就会执行button的onclick事件，如果你有两个button，只会触发第一个，如```html<p><buttononclick=\"console.log('frombuttonclick1');\">button1</button></p><p><buttononclick=\"console.log('frombuttonclick2');\">button2</button></p><p><inputtype=\"text\"value=\"在这里回车就触发提交按钮\"style=\"width:300px;\"/></p>```>回车后只会触发button1的onclick，但可笑的如果你把button标签换成input然后在把type设置为button却不会发生这个奇怪的事，虽然效果是一样。```html<p><inputtype=\"button\"onclick=\"console.log('frombuttonclick1');\"value=\"button1\"/></p><p><buttononclick=\"console.log('frombuttonclick2');\">button2</button></p><p><inputtype=\"text\"value=\"在这里回车就触发提交按钮\"style=\"width:300px;\"/></p>```>回车会避开button1，执行button2。>如果你不想在input内执行回车就被执行button的onclick事件可以在页面顶部添加一个button，毕竟在input内敲回车是一种经常犯的毛病。如:```html<p><button>禁止input回车触发的button</button></p><p><buttononclick=\"console.log('frombuttonclick1');\">button1</button></p><p><buttononclick=\"console.log('frombuttonclick2');\">button2</button></p><p><inputtype=\"text\"value=\"在这里回车就触发提交按钮\"style=\"width:300px;\"/></p>```>这样第一个button就劫持了input的回车事件，防止了后面功能onclick被意外触发的可能性，但页面不美观>但不能把button设置display:none给隐藏，或者visibility:hidden占位隐藏，否则不能起到劫持input内回车事件，如```html<p><buttonstyle=\"display:none;\">禁止input回车触发的button</button></p><p><buttononclick=\"console.log('frombuttonclick1');\">button1</button></p><p><buttononclick=\"console.log('frombuttonclick2');\">button2</button></p><p><inputtype=\"text\"value=\"在这里回车就触发提交按钮\"style=\"width:300px;\"/></p>```>以上代码在input回车仍然会找到button1并执行onclick事件，如果要隐藏它，但又能保持劫持input回车事件的功能，可以把在button外面再套一层父标签并且把父标签设置为宽与高为0即可###解决####方法一:使用`input[type='text']`替代```html<divstyle=\"display:block;width:0;height:0;overflow:hidden;\"><button>禁止input回车触发的button</button></div><p><buttononclick=\"console.log('frombuttonclick1');\">button1</button></p><p><buttononclick=\"console.log('frombuttonclick2');\">button2</button></p><p><inputtype=\"text\"value=\"在这里回车就触发提交按钮\"style=\"width:300px;\"/></p>```>这样就相当于把button隐藏了，并且还保住了功能，如果嫌麻烦可以直接把button改成input[type=button]或者使用a标签代替####方法二:添加`type='text'`>给button标签添加`type='text'`属性####方法三:使用`a`标签替换","Front-End\\浏览器\\兼容开发\\var.md":"#var##var在for循环问题###问题分析>1.for循环是同步的，内部事件处理函数是异步的，所以等到异步事件触发的时候，同步代码已经跑完，因此i也加完了（这就是为什么i固定为最大值不变的原因）。>>2.处理的核心思想就是在他跑完前就立即记录i的值，以备异步事件处理函数使用。>>3.说白了就是利用var只有函数作用域，制造独立空间，让每个i都是独立的。>>var只有函数作用域,没有块级作用域###解决方法####添加自启动函数>思路:固定i>>-制作属性进行固定>-利用标签属性进行固定```jsfor(vari=0;i<btn.length;i++){btn[i].onclick=function(){console.log(i)}}```","Front-End\\浏览器\\分析页面\\分析页面加载时间.md":"#chrome分析页面加载时间##在Network面板查看![](./.assets/分析页面加载时间-2022-11-28-17-13-14.png)-finish：页面最后一个请求截止的时间，如果页面加载完成后，触发了ajax请求，那么该时间会变更。-DOMContentLoaded：dom内容加载并解析完成的时间，即页面白屏时间-load：页面所有的资源（图片、音频、视频等）加载完成的时间。当页面的初始的标记被解析完成时，会触发DOMContentLoaded，它在Network面板上的两个位置显示：-在Overview窗格中的蓝色垂直线表示这个事件。-在Summary窗格中，可以查看这个事件的确切耗时。当页面完全加载时触发load事件，它显示在三个地方：-在Overview窗格的红色垂直线表示这个事件。-在RequestTable中的红色垂直线也表示这个事件。-在Summary中，可以查看该事件的确切时间。##查看网络时序>点击Timing选项卡可以查看单个资源的请求生命周期的明细分类。![](./.assets/分析页面加载时间-2022-11-28-17-15-11.png)-Queuing队列-Stalled停滞-DNSlookupDNS查找-initialconnection初始连接-SSLhandshakeSSL握手-Requestsent请求发送-Waiting等待，具体指到开始下载第一个字节的时间（TTFB：timeforfirstbyte）-ContentDownload内容下载##资源加载时序>所有网络请求都被视为资源，当它们通过网络检索时，分为不同的生命周期。一个完整请求生命周期的主要阶段如下###Redirect重定向-立即开始startTime-如果发生重定向，redirectStart也会开始计时-如果重定向发生在此阶段结束，那么redirectEnd被采用###AppCache应用程序缓存-如果浏览器有缓存，将采用fetchStart时间###DNS-domainLookupStart记录DNS请求开始时间-domainLookupEnd记录DNS请求结束的时间###TCP-connectStart记录开始连接到服务器的时间-如果用了TLS或者SSL，secureConnectionStart记录开始连接时间-connectEnd记录连接完毕时间###Request请求-requestStart记录请求发生到服务器的时间###Response响应-responeseStart记录最开始的响应时间-responseEnd记录响应结束时间![](./.assets/分析页面加载时间-2022-11-28-17-17-36.png)##timing面板信息详解##Queuing排队如果一个请求排队，则表明-请求被渲染引擎推迟，因为它比关键资源（如脚本/样式）的优先级低。例如，images。-这个请求被搁置，在等待一个即将被释放的不可用的TCPsocket-这个请求被搁置，因为浏览器限制。在HTTP1协议中，每个源上只能有6个TCP连接。-正在生成磁盘缓存条目（通常非常快）##Stalled/Blocking停止/阻塞-发送请求之前的等待时间。它可能因为进入队列的任意原因而被阻塞。这个时间包括代理协商的时间。###ProxyNegotiation代理协商-与代理服务器连接协商花费的时间###DNSLookupDNS查找-执行DNS查找所用的时间。页面上的每个新域都需要完整的往返（roundtrip）才能进行DNS查找。###InitialConnection/Connecting初始连接/连接-连接连接所需的时间，包括TCP握手/重试和协商SSL。###SSL-完成SSL握手所用的时间###RequestSent/Sending请求已经发送/正在发送-发出网络请求所花费的时间，通常是几分之一毫秒###Waiting（TTFB）等待-等待初始响应所花费的时间。这个时间包含：等待服务器传递响应花费的时间、捕获到服务器发送数据的延迟时间###ContentDownload/Downloading内容下载/下载-接收响应数据所花费的时间：从接收到第一个字节开始，到下载完最后一个字节结束。##Network面板诊断网络问题-排队或者阻塞：很多个请求队列被阻塞。这表示单个客户端检索的资源太多。在HTTP1.0/1.1连接协议中，Chrome限制每个域名最多执行6个TCP连接。-解决方法：分域，即用多个字域名提供服务资源，将资源拆分到多个子域中，均匀分配。-HTTP2，TCP连接支持多路复用，消除了HTTP1的6个连接限制，并且可以通过单个连接同时传输多个资源。-接收到第一个字节的时间很慢：很多绿色。解决方法：1、尽量减少网络连接。理想情况下，在本地托管应用程序（部署在本地）。2、优化应用程序的响应速度-加载缓慢：很多蓝色。解决方法：减少响应的字节。例如，优化图片","Front-End\\浏览器\\开启手机控制台.md":"#开启手机控制台```js//开启手机控制台<scriptsrc=\"//cdn.jsdelivr.net/npm/eruda\"></script><script>eruda.init();</script>``````html<scriptsrc=\"https://cdn.bootcss.com/vConsole/3.2.0/vconsole.min.js\"></script><script>//初始化一下就可以了，letvConsole=newVConsole()//你打印的数据比如console.log('test')//就可像小程序一样的看了和调试了。</script>``````shell//如果是在vue中要先安装包npminstallvconsole//然后引入importVconsolefrom'vconsole';//然后在created或者mounted生命周期中初始化一下letvConsole=newVConsole();//在手机上就可以像上面一样的效果了```","Front-End\\浏览器\\怪异模式.md":"#浏览器的怪异模式和标准模式-怪异模式的产生:早起没有固定的标准,导致浏览器都是自己写自己,没有固定的标准||标准模式|怪异模式||---------------|-----------------------|-----------------------------------------------------------------||解析方式|按照W3C标准解析|使用浏览器自己的方式解析||盒模型|W3C的标准模型|IE盒子模型||Table元素中字体|font属性可以继承|不可以从父级继承||内联元素的尺寸|无法定义自己的宽度|定义width和height都可以影响到与拿书的尺寸||元素溢出|overflow默认值为visible|元素大小由内容界定,溢出不会裁剪,<br>元素框自动调整,包括溢出内容|","Front-End\\浏览器\\控制台Api\\控制台Api.md":"#[`控制台Api`](https://developer.chrome.com/docs/devtools?hl=zh-cn)##`$0-4`-`$0`最常用，返回当前选中的dom元素。因为我从事的工作原因，经常会使用到它-`$1-4`分别表示最近选中的元素。例如$1表示上次选中的元素，以此类推##`$_`-返回终端中上一次计算的表达式的值![](./.assets/控制台Api-2024-06-13-15-41-17.png)##`$(selector,parentNode?)`-`$(selector,parentNode?)`是`document.querySelector()`的快捷方式。还支持参数二，表示从哪个节点下查找,默认值document。##`$$(selector,parentNode?)`-`$$(selector,parentNode)`等价于`Array.from(document.querySelectorAll())`。注意他返回的是一个数组，而不是一个类数组，因此我们可以直接调用数据api,用法同`$(selector,parentNode?)`##`copy(target)`-将指定对象的字符串表示形式复制到剪贴板。将控制台变量复制到剪贴板让我们使用##`inspect(dom/fn)`-定位到dom元素（Elements）和控制台中的js函数（在Sources中打开展示）##`getEventListeners(dom)`-返回在指定对象上注册的事件监听器。返回值是一个对象，其中包含每个已注册事件类型（例如click或keydown）的数组。每个数组的成员都是对象，用于描述为每个类型注册的监听器。就是elements面板中的EventListenerstab。如果你需要分析网站交互，这个就可以快速找到绑定的事件，很方便。##`monitor(function)`-调用指定的函数时，控制台会记录一条消息，指明函数名称以及调用时传递给该函数的参数。使用unmonitor(function)可停止监控![](./.assets/控制台Api-2024-06-13-16-04-04.png)##`monitorEvents(dom[,events])`-当指定dom对象上发生其中一个指定事件时，该Event对象会记录到控制台中。您可以指定要监控的单个事件、事件数组或映射到预定义事件集合的某种通用事件“类型”。使用`unmonitorEvents(dom[,events])`可停止监控-可以先使用getEventListeners(dom)去查看当前dom绑定了哪些事件，然后在进行特定事件监听，不然输出内容很多![](./.assets/控制台Api-2024-06-13-16-21-48.png)##`queryObjects(Constructor)`-以数组形式返回使用指定构造函数创建的对象。查找范围为当前选择的执行上下文![](./.assets/控制台Api-2024-06-13-16-25-10.png)##简写-`keys(object)`=>`Object.keys(object)`-`values(object)`=>`Object.values(object)`","Front-End\\浏览器\\标签.md":"#标签##标签相关html中定义六个属性```js1.async属性:表示立即下载脚本，但不会影响页面的其他操作。[规定脚本将被异步执行]2.charset属性:规定在外部脚本把文件中使用的编码不同。3.defer属性:表示脚本可以延迟到文档被解析和显示之后再执行。只有对外部脚本有效。4.src属性:表示包含要执行代码的外部文件。5.type属性:规定了脚本的MIME属性[内容属性]6.language属性:已废弃。```","Front-End\\浏览器\\浏览器多进程&JS单线程.md":"#浏览器多进程&JS单进程[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)>-进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）>-线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）##浏览器>-浏览器是多进程的>-浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）>-简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。###浏览器主要进程>1.Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有>-负责浏览器界面显示，与用户交互。如前进，后退等>-负责各个页面的管理，创建和销毁其他进程>-将Renderer进程得到的内存中的Bitmap，绘制到用户界面上>-网络资源的管理，下载等>2.第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建>3.GPU进程：最多一个，用于3D绘制等>4.浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为>-页面渲染，脚本执行，事件处理等###浏览器内核>浏览器内核包括![image-20210812144930799](.assets/image-20210812144930799-16287509744381.png)","Front-End\\浏览器\\浏览器插件\\manifest.md":"#manifest.json配置文件>manifest.json是扩展的配置文件，指明了扩展的各种信息。一个manifest.json格式如下：```js{//必须的字段3个\"name\":\"MyExtension\",//扩展名称\"version\":\"1.0\",//版本。由1到4个整数构成。多个整数间用\".\"隔开\"manifest_version\":2,//manifest文件版本号。Chrome18开始必须为2//建议提供的字段3个\"description\":\"\",//描述。132个字符以内\"icons\":{\"16\":\"image/icon-16.png\",\"48\":\"image/icon-48.png\",\"128\":\"image/icon-128.png\"},//扩展图标。推荐大小16，48，128\"default_locale\":\"en\",//国际化//以下字段多选一，或者都不提供\"browser_action\":{\"default_icon\":\"image/icon-128.png\",\"default_title\":\"MyTest\",\"default_popup\":\"html/browser.html\"},//地址栏右侧图标管理。含图标及弹出页面的设置等\"page_action\":{\"default_icon\":\"image/icon-48.png\",\"default_title\":\"MyTest\",\"default_popup\":\"html/page.html\"},//地址栏最后附加图标。含图标及行为等\"theme\":{},//主题，用于更改整个浏览器的外观\"app\":{},//指定扩展需要跳转到的URL//根据需要提供\"background\":{\"scripts\":[\"lib/jquery-3.3.1.min.js\",\"js/background.js\"],\"page\":\"html/background.html\"},//指定扩展进程的background运行环境\"chrome_url_overrides\":{\"pageToOverride\":\"html/overrides.html\"},//替换页面。详见注释1\"content_scripts\":[{\"matches\":[\"https://www.baidu.com/*\"],\"css\":[\"css/mystyles.css\"],\"js\":[\"lib/jquery-3.3.1.min.js\",\"js/content.js\"]}],//指定在web页面运行的脚本。详见注释2\"content_security_policy\":\"\",//安全策略\"file_browser_handlers\":[],\"homepage_url\":\"http://xxx\",//扩展的官方主页\"incognito\":\"spanning\",//或\"split\"。详见注释3\"intents\":{},//用户操作意图描述\"key\":\"\",//扩展唯一标识。不需要人为指定\"minimum_chrome_version\":\"1.0\",//扩展所需chrome的最小版本\"nacl_modules\":[],//消息与本地处理模块映射\"offline_enabled\":true,//是否允许脱机运行\"omnibox\":{\"keyword\":\"myKey\"},//ominbox即地址栏。用于响应地址栏的输入事件\"options_page\":\"aFile.html\",//选项页。用于在扩展管理页面跳转到选项设置\"permissions\":[\"https://www.baidu.com/*\",\"background\",\"tabs\"],//权限。详见注释4\"plugins\":[{\"path\":\"extension_plugin.dll\",\"public\":true}],//扩展。可调用第三方扩展\"requirements\":{},//指定所需要的特殊技术。目前只支持\"3D\"\"update_url\":\"http://path/to/updateInfo.xml\",//自动升级\"web_accessible_resources\":[]//指定资源路径，为String数组}```##注释###chrome_url_overrides>替换页面。用于将原定显示的页面替换为自定义的页面。其取值有4个：①pageToOverride：页面。②bookmarks：书签。③history：历史。④newtab：新标签页。###content_scripts>指定要向Web页面内注入的脚本。可注入多个css与js。扩展本身的运行环境为background，而background与web页面的运行环境是相互独立的。若希望在扩展中对web页面进行修改，那就需要使用content_scripts。content_scripts运行在一个隔离环境中，即与background和web页面运行环境都独立。但content_scripts共享了web页面的DOM，所以content_scripts可以对web页面DOM进行操作。然而共享仅限于DOM，不包括任何js变量与函数。同理，web页面的js也不能访问content_scripts中的js变量与函数。于是，二者引入的库也不能共享，各自使用各自的库。借助事件的监听与触发，content_scripts可以与web页面的js进行通信。content_scripts格式如下：```js\"content_scripts\":[{\"matches\":[\"https://www.baidu.com/*\"],\"css\":[\"mystyles.css\"],\"js\":[\"lib/jquery-3.3.1.min.js\",\"js/content.js\"],\"run_at\":\"document_idle\"}],```其数组元素的字段有：①matches：String数组，必须。定义content_scripts对哪些页面生效。其规则符合permissions的模式匹配。②css：String数组，可选。定义哪些css文件在web页面DOM创建前注入到web页面中。③js：String数组，可选。定义哪些js文件注入到web页面中。其js文件的注入顺序与数组中定义的顺序相同。至于这些js与web页面中所定义js的顺序关系，取决于run_at字段。④run_at：String，可选。定义content_scripts的注入时机，从而影响到js与web页面所定义js的顺序关系。取值有：·document_start：所有css加载完毕，但DOM尚未创建时。·document_end：DOM创建完成，但图片及frame等子资源尚未加载时。·document_idle：document_end之后，window.onload之前。默认是document_idle，也就是content_scripts的js都罗列在web页面的js之后。⑤all_frames：boolean，可选。是否运行在页面所有的frame中。若为false，则只运行在最上层的frame中。默认为false。⑥include_globs：String数组，可选。用于规定页面匹配的白名单。一个URL，必须同时满足：匹配matches，匹配include_globs白名单，不匹配exclude_globs黑名单这三个条件才可以。注意include_globs和exclude_globs中的匹配语法与permissions和matches所用的匹配模式不同。⑦exclude_globs：String数组，可选。用于规定页面匹配的黑名单。同⑥。###incognito>取值为：”spanning”/“split”。指定当浏览器处于隐身模式下时，扩展如何响应。默认为”spanning”。①spanning：扩展会运行在共享进程中。标签页的事件和消息会发送给这个进程，来源通过incognito标志区分。②split：扩展运行在独立的进程中。每个进程都只能看到自己的事件和消息，各进程间不能通信。###permissions>扩展所需要的权限。permissions是一个String数组，每一个权限都使用String来表示。某些权限在安装前会告知用户。特别注意permissions中若有不可识别的配置项，那么所有permissions配置项都会失效，即使其他的permissions配置项是正确的。permissions部分常用值如下：①模式配匹：用于指定扩展会在哪些URL中生效。例如：http://_/_：匹配任何http协议的URL。_://_/\\*：匹配任何http/https协议的URL。<http://127.0.0.1/*：匹配任何本地请求URL>。<https://www.baidu.com/*：匹配https://www.baidu.com/开头的所有URL>。<all_urls>：匹配所有url。使用模式匹配时，直接将匹配规则字符串添加到permissions即可。可添加多个匹配规则字符串，匹配效果是这些规则的并集。若不添加匹配规则字符串，则默认对所有URL生效。②background：启用扩展后端环境。即在浏览器运行期始终运行，与单个页面无关。可以在这里调用浏览器的API，通常在这里进行扩展主要逻辑的开发。配合manifest.json的background字段使用。③bookmarks：启用书签权限。④contextMenus：启用右键菜单权限。可针对不同文档单独定制。⑤cookies：启用cookies权限。⑥experimental：启用chrome的实验功能API。⑦geolocation：允许扩展使用HTML5的地理位置API，无论用户是否有该权限。⑧history：启用history权限。⑨idle：启用延迟加载。⑩management：启用管理权限。用于管理已安装和正在运行的扩展。⑪notifications：启用桌面通知权限。不同平台下表现不同，但往往都是一个小弹窗。⑫tabs：启用标签权限。用于管理chrome浏览器的标签栏，例如创建，修改，重新排列标签等，以及修改chrome窗体。实际上，大部分的chrome.tabs.API不需要任何权限就可以使用。tab的url、title和favIconUrl属性必须具有tabs权限才可以使用；tabs.captureVisibleTab必须有<all_urls>或activeTab权限才能使用。⑬activeTab：启用活动标签权限。通常来说，tabs更多是用于操作tab标签和窗体属性的。对那些可以与当前web页面交互的API，往往都需要activeTab权限。例如，tabs.executeScript（向页面临时注入js并执行）和tabs.insertCSS（向页面临时注入css并执行），执行浏览器按钮，执行页面按钮，执行右键菜单项，通过命令API执行键盘快捷键等。","Front-End\\浏览器\\浏览器插件\\插件.md":"#Edge浏览器插件开发>开发模板:[chrome-extension-boilerplate-react](https://github.com/lxieyang/chrome-extension-boilerplate-react)##文件目录介绍pages里面的模块-Popup:点击插件显示的弹框-Newtab:新页面显示的页面-Panel:控制台里面的tap页-Options:插件的设置界面##Newtab重写`index.html`:真正的入口文件`index.jsx`:开发的入口文件`Newtab.jsx`:开发的模板文件`Newtab.scss`:开发模板文件的样式文件##permissions权限声明-`chrome`浏览器声明权限列表以及权限描述|权限|描述||:--------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------||`activeTab`|请求根据activeTab规范授予扩展名权限。||`alarms`|扩展程序访问chrome.alarmsAPI。||`background`|具有后台权限，可以在后台运行，直到退出chrome；通常，“背景”权限与背景页面，事件页面或背景窗口一起使用。||`bookmarks`|扩展程序访问chrome.bookmarksAPI的权限。||`browsingData`|扩展程序可以访问chrome.browsingDataAPI。||`certificateProvider`|扩展程序授予chrome.certificateProviderAPI的访问权限。||`clipboardRead`|如果扩展程序或应用程序使用，则为必填document.execCommand(‘paste’)。||`clipboardWrite`|表示扩展程序或应用程序使用document.execCommand(‘copy’)或document.execCommand(‘cut’)。||`contentSettings`|扩展程序访问chrome.contentSettingsAPI。||`contextMenus`|扩展程序访问chrome.contextMenusAPI。||`cookies`|扩展程序访问chrome.cookiesAPI。||`debugger`|扩展程序访问chrome.debuggerAPI。||`declarativeContent`|扩展程序访问chrome.declarativeContentAPI的权限。||`declarativeNetRequest`|扩展程序访问chrome.declarativeNetRequestAPI的权限。||`declarativeNetRequestFeedback`|授予扩展程序对chrome.declarativeNetRequestAPI中的事件和方法的访问权限。||`declarativeWebRequest`|扩展程序对chrome.declarativeWebRequestAPI的访问权限。||`desktopCapture`|扩展程序可以访问chrome.desktopCaptureAPI。||`displaySource`|扩展程序授予chrome.displaySourceAPI的访问权限。||`dns`|扩展程序访问chrome.dnsAPI。||`documentScan`|扩展程序访问chrome.documentScanAPI的权限。||`downloads`|扩展程序访问chrome.downloadsAPI。||`enterprise`.deviceAttributes|扩展程序访问chrome.enterprise.deviceAttributesAPI。||`enterprise`.hardwarePlatform|扩展程序访问chrome.enterprise.hardwarePlatformAPI。||`enterprise`.networkingAttributes|扩展程序访问chrome.enterprise.networkingAttributesAPI。||`enterprise`.platformKeys|扩展程序访问chrome.enterprise.platformKeysAPI。||`experimental`|扩展程序或应用程序使用任何chrome.experimental.\\*API，则为必填项。||`fileBrowserHandler`|扩展程序授予chrome.fileBrowserHandlerAPI的访问权限。||`fileSystemProvider`|扩展程序访问chrome.fileSystemProviderAPI的权限。||`fontSettings`|扩展程序访问chrome.fontSettingsAPI。||`gcm`|扩展程序访问chrome.gcmAPI。||`geolocation`|扩展程序或应用程序使用建议的HTML5地理位置API，而无需提示用户进行许可。||`history`|扩展程序访问chrome.historyAPI。||`identity`|扩展程序访问chrome.identityAPI。||`idle`|扩展程序可以访问chrome.idleAPI。||`idltest`|扩展程序可以访问chrome.idltestAPI。||`login`|扩展程序可以访问chrome.loginAPI。||`loginScreenStorage`|扩展程序访问chrome.loginScreenStorageAPI的权限。||`loginState`|扩展程序对chrome.loginStateAPI的访问权限。||`management`|扩展程序访问chrome.managementAPI。||`nativeMessaging`|扩展程序可以访问本机消息传递API。||`notifications`|扩展程序访问chrome.notificationsAPI。||`pageCapture`|扩展程序可以访问chrome.pageCaptureAPI。||`platformKeys`|扩展程序可以访问chrome.platformKeysAPI。||`power`|扩展程序访问chrome.powerAPI。||`printerProvider`|扩展程序访问chrome.printerProviderAPI的权限。||`printing`|扩展程序访问chrome.printingAPI。||`printingMetrics`|扩展程序可以访问chrome.printingMetricsAPI。||`privacy`|扩展程序访问chrome.privacyAPI。||`processes`|扩展程序可以访问chrome.processesAPI。||`proxy`|扩展程序可以访问chrome.proxyAPI。||`scripting`|扩展程序可以访问chrome.scriptingAPI。||`search`|扩展程序可以访问chrome.searchAPI。||`sessions`|扩展程序访问chrome.sessionsAPI。||`signedInDevices`|扩展程序可以访问chrome.signedInDevicesAPI。||`storage`|扩展程序可以访问chrome.storageAPI。||`system`.cpu|扩展程序访问chrome.system.cpuAPI。||`system`.display|扩展程序访问chrome.system.displayAPI。||`system`.memory|扩展程序访问chrome.system.memoryAPI。||`system`.storage|扩展程序访问chrome.system.storageAPI。||`tabCapture`|扩展程序访问chrome.tabCaptureAPI。||`tabGroups`|扩展程序访问chrome.tabGroupsAPI的权限。||`tabs`|扩展程序可以访问Tab包括chrome.tabs和chrome.windows在内的多个API使用的对象的特权字段。在许多情况下，您的扩展程序无需声明\"tabs\"使用这些API的权限。||`topSites`|扩展程序访问chrome.topSitesAPI。||`tts`|扩展程序可以访问chrome.ttsAPI。||`ttsEngine`|扩展程序访问chrome.ttsEngineAPI的权限。||`unlimitedStorage`|提供无限的配额来存储HTML5客户端数据，例如数据库和本地存储文件。没有此许可，扩展程序或应用程序仅限于5MB本地存储。||`vpnProvider`|扩展程序访问chrome.vpnProviderAPI的权限。||`wallpaper`|扩展程序访问chrome.wallpaperAPI。||`webNavigation`|扩展程序访问chrome.webNavigationAPI的权限。||`webRequest`|扩展程序可以访问chrome.webRequestAPI||`webRequestBlocking`|扩展程序以阻止方式使用chrome.webRequestAPI，则为必填。|","Front-End\\浏览器\\画中画\\index.md":"#画中画<https://juejin.cn/post/7441954981342036006>","Front-End\\浏览器\\缓存\\http缓存.md":"#http缓存##分类>`强制缓存`和`协商缓存`![](./.assets/http缓存-2022-11-14-16-29-49.png)##强缓存>强制缓存###`Expires`![](./.assets/http缓存-2022-11-14-16-32-24.png)>-`Expires`字段的作用是，设定一个强缓存时间。在此时间范围内，则从内存（或磁盘）中读取缓存返回。>-比如说将某一资源设置响应头为:`Expires:newDate(\"2022-7-3023:59:59\")`>那么，该资源在`2022-7-3023:59:59`之前，都会去本地的磁盘（或内存）中读取，不会去服务器请求>但是，Expires已经被废弃了。对于强缓存来说，Expires已经不是实现强缓存的首选>-`Expires`判断强缓存是否过期的机制是:获取本地时间戳，并对先前拿到的资源文件中的`Expires`字段的时间做比较。来判断是否需要对服务器发起请求。这里有一个巨大的漏洞：“如果我本地时间不准咋办？”>`Expires`过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。所以，`Expires`字段几乎不被使用了。现在的项目中，我们并不推荐使用`Expires`，强缓存功能通常使用`cache-control`字段来代替`Expires`字段###`Cache-control`>替代`Expires`的强缓存实现方法>`Cache-control`这个字段在`http1.1`中被增加，`Cache-control`完美解决了Expires本地时间和服务器时间不同步的问题。是当下的项目中实现强缓存的最常规方法。>`Cache-control`的使用方法页很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒```js//往响应头中写入需要缓存的时间res.writeHead(200,{'Cache-Control':'max-age=10',})```>在该资源第一次返回的时候开始,往后10秒内,如果该资源背再次请求,则从缓存中读取![](./.assets/http缓存-2022-11-14-16-43-20.png)`Cache-Control`:-`max-age=N`:`N`就是需要缓存的秒数,从第一次请求资源开始,往后N秒内,资源若再次请求,则直接从磁盘(或内存中读取),不与服务器交互-`max-age`:决定客户端资源被缓存多久-`s-maxage`:决定代理服务器缓存的时长-`no-cache`:强制进行协商缓存-`no-store`:禁止任何缓存策略-`public`:资源即可以被浏览器缓存也可以被代理服务器缓存-`private`:资源只能被浏览器缓存补充:-`no-cache`和`no-store`为互斥属性,不可同时出现在`Cache-Control`中####`public`和`private`>一般请求![](./.assets/http缓存-2022-11-14-17-05-32.png)>出现代理服务器![](./.assets/http缓存-2022-11-14-17-05-40.png)`public`:表示资源在客户端和代理服务器都可以被缓存`private`:-表示资源只能在客户端被缓存,拒绝资源在代理服务器缓存-两值没有设置,默认是`private`>`public`和`private`是互斥属性,不可同时出现###`max-age`和`s-maxage`-max-age表示的时间资源在客户端缓存的时长，而s-maxage表示的是资源在代理服务器可以缓存的时长。在一般的项目架构中max-age就够用。-s-maxage因为是代理服务端的缓存时长，他必须和上面说的public属性一起使用（public属性表示资源可以在代理服务器中缓存）。>`max-age`和`s-maxage`不互斥`Cache-control`如何设置多个值呢？用逗号分割:`Cache-control:max-age=10000,s-maxage=200000,public`>`Cache-control`是`Expires`的完全替代品，但是如果要考虑向下兼容的话，在`Cache-control`不支持的时候，还是要使用`Expires`##协商缓存基于last-modified的协商缓存实现方式是:1.首先需要在服务器端读出文件修改时间2.将读出来的修改时间赋给响应头的last-modified字段3.最后设置Cache-control:no-cache![](./.assets/http缓存-2022-11-23-15-37-36.png)>-第一行，读出修改时间>-第二行，给该资源响应头的last-modified字段赋值修改时间>-第三行，给该资源响应头的Cache-Control字段值设置为:no-cache.(上文有介绍，Cache-control:no-cache的意思是跳过强缓存校验，直接进行协商缓存。)当客户端读取到last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since![](./.assets/http缓存-2022-11-23-15-42-11.png)而这个请求头中的If-Modified-Since就是服务器第一次修改时候给他的时间，也就是上图中的![](./.assets/http缓存-2022-11-23-15-43-00.png)>那么之后每次对该资源的请求，都会带上If-Modified-Since这个字段，而务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源![](./.assets/http缓存-2022-11-23-15-44-14.png)![](./.assets/http缓存-2022-11-23-15-44-32.png)使用以上方式的协商缓存已经存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。1.因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。2.当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会返回新的文件。为了解决上述的这两个问题。从http1.1开始新增了一个头信息，ETag(Entity实体标签)##基础ETag的协商缓存>-`ETag`就是将原先协商缓存的比较时间戳的形式修改成了比较文件指纹>-`文件指纹`:根据文件内容计算出的唯一哈希值,文件一旦改变则指纹改变###流程1.第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的`etag`字段中跟资源一起返回给客户端。2.第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的ETag也就是文件指纹。并赋给请求头的`if-None-Match`字段，让上一次的文件指纹跟随请求一起回到服务端。3.服务端拿到请求头中的is-None-Match字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端![](./.assets/http缓存-2022-11-23-15-55-20.png)![](./.assets/http缓存-2022-11-23-15-55-31.png)###ETag也有缺点>ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。>如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。>ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。>ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。>值得注意的一点是，不同于cache-control是expires的完全替代方案(说人话:能用`cache-control`就不要用`expires`)。ETag并不是`last-modified`的完全替代方案。而是`last-modified`的补充方案（说人话：项目中到底是用`ETag`还是`last-modified`完全取决于业务场景，这两个没有谁更好谁更坏）","Front-End\\浏览器\\缓存\\web缓存.md":"#web缓存##浏览器缓存>主要是`localStorage`和`sessionStorage`,`Cookie`##[http缓存](/Front-End/浏览器/缓存/http缓存.md)>-web缓存核心>-可以自动保存常见文档副本的`HTTP`设备,当`Web`请求抵达缓存时,若本地有\"已缓存\"的副本,就可以从本地存储设备而不是原始服务器提取>解决问题:>>-减少不必要的网络传输,节约带宽>-增加页面加载速度>-减少服务器复制>>缺点:>>-占用内存","Front-End\\浏览器\\调试.md":"#前端调试**1.开启开发者工具的实验性功能**你可以到`chrome://flags`页面，然后开启`DeveloperToolsexperiments`选项。当开启后，在开发者工具的设置页面，可以发现多了一个`Experiments`选项。如果我使用的一些功能你没有看到，那么请到`Experiments`窗口打开。**2.超级实验性功能**如果我使用到的功能在`Experiments`列表没有，那么它可能是一个WIP功能(WIP指workinginprogress)。你可以这样开启：页面处在`Experiments`界面，连续敲击`shift`键6次来开启WIP功能。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f23f2b36f2bb~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fwip.gif)###**Console**当Debug的时候，我们绝大部分时间是在和Console打交道。我们往往在代码中插入很多Consolelogs，通过打印变量值来debug。鉴于Console对于我们这么重要，很有必要了解所有开发者工具提供的相关的APIs和快捷键。**3.总是打印对象**我的第一个建议其实和开发者工具没有关系，而是我一直使用的一个技巧。在使用`console.log();`的时候，不仅仅打印变量，而是要打印对象，用大括号(`{}`)将变量包围起来。这样的优点是不仅会把变量的值打印，同时还会将变量名打印出来。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f23f2b52f08d~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flogvar.png)[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f23f2f062636~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flogobj.png)**4.使用console.table来打印多条目数据**如果你要打印的变量是一个数组，每一个元素都是一个对象。我建议你使用`console.table`来打印，其表格化的呈现更加美观易读。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f23f49221722~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flogtable.png)**5.给log加点颜色**log有时候变得非常多，包含你自己的、一些第三方扩展或者浏览器的logs。除了使用过滤器(filter)以外，你还可以使用颜色来更好地区分。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f2400f11e811~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flogcolor.png)**6.$和?**如果你在console下没有任何库使用`$`和`?`，那么你可以使用它们分别作为`document.querySelector()`和`document.querySelectorAll()`的快捷键。除了提供了一个更加快捷的方式外，还有一个好处，`?`返回一个数组，而不是[array-like](https://link.juejin.cn?target=http%3A%2F%2F2ality.com%2F2013%2F05%2Fquirk-array-like-objects.html)的[NodeList](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FNodeList).所以你可以直接使用[map](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Fmap),[reduce](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Freduce)和[filter](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Ffilter)函数。你可以使用`?`检查页面中的无效链接：```jsPromise.all(?('a').map(link=>link.href).map(href=>fetch(href))).then(()=>console.log('Alllinksworking')).catch(()=>console.error('Somelinksarebroken'));```**7.$0**如果你想引用某个DOM元素，使用`$0`。`$0`指向你当前在Element中选中的元素。如果指定了`$0`，`$1`指向之前选中的元素。以此类推，直到`$4`都可以使用。**8.$\\_**`$_`记录了最后一次在Console计算的表达式。**9.getEventListeners()**`getEventListeners(domElement)`返回在DOM元素上注册的所有的事件。请看下面的例子：[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f8f28abfc96f~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2FgeteventListeners.gif)你也许注意到了，当我在console里输入表达式的时候，其结果立即被计算出来了。你可以看到我并没有敲击Enter键，而结果已经显示出来。这个是金丝雀版本的一个新功能，叫做”EagerEvaluation”。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f240125356e4~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Feager.png)**10.debug(fn)**在上面的例子中，如果你想在点击按钮后的执行过程中暂停，你可以使用`debug`函数。`debug(fn)`接收一个函数作为参数，当每次该函数被调用时，Debugger就会在该函数的第一行中断执行。想象一下你要debug一个按钮的问题，但是你不知道这个按钮对应的事件函数在代码中什么位置。除了去大量的源代码中慢慢寻找之外，还有一个巧妙的方法。使用`getEventListeners`函数，然后将`debug`方法注入进去。这样，当你点击按钮的时候，就会在该函数的第一行停下来。**11.copy(obj)**`copy(anything)`是一个很有用的工具函数方便你将任何东西拷贝到系统的粘贴板暂存。给`copy`函数传入一个没有格式的JSON，会返回格式化的结果：[![img](https://blog.fundebug.com/2018/08/22/art-of-debugging-with-chrome-devtools/copy.gif)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fcopy.gif)**12.Top-levelawait**`async/await`使得异步操作变得更加容易和可读。唯一的问题在于`await`需要在async函数中使用。如果我们要在DevTools的控制台使用，需要一些特殊的处理，使用**I**mmediately**I**nvoked**A**sync**F**unction**E**xpression(IIAFE).一点都不方便。好在DevTools已经支持直接使用await了。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f2409dfbbab4~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fawait.png)###DebuggingintheSourcespanel在source面板，使用breakpoints，stepping-into,stepping-over等方式，你可以很好地掌控程序的执行状态，来发现代码问题。接下里我不会介绍大家都知道的基础内容，而是一些我经常使用的建议和技巧。**13.开启auto-prettyprint**在金丝雀版本的实验模式下，你可以开启自动美化代码模式。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f241045dadf7~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fpp.png)**14.使用条件断点在生产环境中注入consolelogs**断点是一个很棒的功能。但还有一个更棒的：条件断点。只有当设定的条件满足的时候，中断才会执行。也就是说DevTools并不会每次都中断程序的执行，而只是在你想要它中断的时候才中断。想了解更多：查看[这里](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2015%2F07%2Fset-a-breakpoint-based-on-a-certain-condition).在生产环境下，因为不能修改源代码，我喜欢使用条件断点来注入console.log。如果我的断点仅仅是一个console.log，DevTools不会中断，因为console.log返回undefined,，是一个false的值。但是它会执行我注入的表达式，可以看到输出结果。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f241a92dd8af~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fcb.gif)为什么不直接使用普通的断点，并且查看变量呢？有时候我并不想这样做。比如，当我在分析那些频繁执行的操作，例如触摸或则滑动。我并不想每一次都导致Debugger触发程序中断，但是我想看到程序输出的结果。**15.暂停UI在Hover状态下的展示结果**我们很难去检查一个只有在Hover状态下展示的元素。比如，如何去检查一个tooltip？如果你右键并选择检查，元素已经消失了。那么有办法吗？我是这么操作的：1.打开sources面板2.显示tooltip3.使用快捷键来暂停脚本执行(将鼠标停留在暂停的图标上查看快捷键)4.回到Elements面板，然后像通常一样去检查元素[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f241aa9f5f88~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Ftooltip.gif)**16.XHRbreakpoints**如果想要理解一个请求是如何执行的，可以使用sources面板的XHRbreakpoints。**17.使用DevTools作为IDE**DevTools的source面板可以说相当强大。你可以快速查找，跳转到某一行，某个函数，执行一段代码，使用多行光标等等。这些功能在[这篇medium文章中有详细描述](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fgoogle-developers%2Fdevtools-tips-for-sublime-text-users-cdd559ee80f8)。既然如此，为啥不把整个开发都搬到这里呢。这样就不需要浪费时间切换IDE和浏览器了。如果你有一个使用[create-react-app](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fcreate-react-app)或则[vue-cli](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-cli)构建的项目，你可以直接把整个文件夹拖到Sources面板下。DevTools会自动对所有文件做映射。所以，你可以在DevTools下修改文件并立即查看。这样，整个开发效率，特别是Debugging效率绝对提高了。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f242a31a96c7~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fdevtoolsaside.gif)**18.使用networkoverrides来简单调试生产代码**如果你正在Debugging一个生产环境下面的bug，你可以使用`networkoverrides`来调试，而不用在本地搭建整个配置。你可以很容易将任何远程的资源下载一份本地的版本，然后可以在DevTools下编辑，并且DevTools会更新展示你编辑后的文件。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f242e18f67e7~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flocalcopy.gif)在生产环境下，也可以很容易Debugging，并且做一些性能上的测试也变得容易。###**19.Nodejsdebugging**如果你想使用DevTools的Debugger来debugNode.js应用，你可以使用`--inspect-brk`flag来开启：```node--inspect-brkscript.js```跳转到`chrome://inspect`页面，在`RemoteTarget`选项，可以看到Node程序。并且，在DevTools中你会看到一个绿色的Node图标，点击图标会打开针对Node的ChromeDebugger。[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f2441a2b4ca7~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fnodedebug.gif)如果你想要用DevToolsDebugger来debug你的单元测试，你需要这样调用：```node--inspect-brk./node_modules/.bin/jest```不过这样做其实很麻烦，我们需要自己找到相应的路径。GoogleChromeLabs最近发布了一个新的工具非常好用，叫做：[ndb](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FGoogleChromeLabs%2Fndb)。使用ndb，你只需要：```ndbnpxjest```如果你有一个自定义的脚本，你可以这样调用：```ndbnpmrununit```更妙的是，如果你在一个有配置`package.json`的项目下调用`ndb`，他甚至会自动分析package.json中的脚本，方便你直接使用DevTools。**20.使用Snippets来辅助Debugging**DevTools提供了一个可以创建和保存小段代码的工具，我很喜欢用它们来加速我的工作。比如lodashify—可以快速给任何应用添加lodash。```(function(){'usestrict';varelement=document.createElement('script');element.src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.15.0/lodash.min.js\";element.type=\"text/javascript\";document.head.appendChild(element);})();```另一个小的工具函数式用来增强对象的属性，每次被访问或则修改，它都会提供给我充分的信息，比如谁访问了，谁更改了它。在Debugging的时候，非常有用。```consttraceProperty=(object,property)=>{letvalue=object[property];Object.defineProperty(object,property,{get(){console.trace(`${property}requested`);returnvalue;},set(newValue){console.trace(`setting${property}to`,newValue);value=newValue;},})};```[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f2441a3c692c~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fsnippet.gif)还有很多非常有用的[devtools代码片段](https://link.juejin.cn?target=http%3A%2F%2Fbgrins.github.io%2Fdevtools-snippets%2F)，你可以直接拿去使用。","Front-End\\项目搭建\\esbuild\\index.md":"#esbuild>不支持转换为ES5,暂时不学习","Front-End\\项目搭建\\Gulp\\index.md":"#Gulp>[官网](https://www.gulpjs.com.cn/docs/getting-started/quick-start/)","Front-End\\项目搭建\\Rollup\\index.md":"#Roadhog>[roadhog介绍-echo丶若梦-博客园(cnblogs.com)](https://www.cnblogs.com/gaoht/p/9400386.html)##安装`npminstallrollup-g`##插件###babel####rollup-plugin-babel>使用未被浏览器或node.js支持的js特性```js//rollup.config.jsimportresolvefrom'rollup-plugin-node-resolve'importbabelfrom'rollup-plugin-babel'exportdefault{input:'src/main.js',output:{file:'bundle.js',format:'cjs',},plugins:[resolve(),babel({exclude:'node_modules/**',//只编译我们的源代码}),],}``````js//.babelrc{\"presets\":[[\"latest\",{\"es2015\":{\"modules\":false}}]],\"plugins\":[\"external-helpers\"]}```###the-answer>将commonjs装换为ES2015###rollup-plugin-commonjs​>导入es6模块###rollup-plugin-node-resolve​>告诉Rollup如何查找外部模块```js//rollup.config.jsimportresolvefrom'rollup-plugin-node-resolve'exportdefault{input:'src/main.js',output:{file:'bundle.js',format:'cjs',},plugins:[resolve({//将自定义选项传递给解析插件customResolveOptions:{moduleDirectory:'node_modules',},}),],//指出应将哪些模块视为外部模块external:['lodash'],}```###json相关>解析json文件>`rollup-plugin-json`>`@rollup/plugin-json`(推荐)```jsimportjsonfrom\"rollup-plugin-json\"//或importjsonfrom\"@rollup/plugin-json\"exportdefault{//...plugins:[json()]//或//JSON文件可能会变得很大，您可能不需要所有内容。您可以将参数compact作为传递，//它将生成最少量的代码rueplugins:[json({compact:true})]}```##配置文件```js//rollup.config.jsexportdefault{//核心选项input,//必须external,plugins,//额外选项onwarn,//dangerzoneacorn,context,moduleContext,legacyoutput:{//必须(如果要输出多个，可以是一个数组)//核心选项file,//必须format,//必须name,globals,//额外选项paths,banner,footer,intro,outro,sourcemap,sourcemapFile,interop,//高危选项exports,amd,indentstrict},};```###使用配置文件>`--config`简写`-c````shell#默认使用rollup.config.js$rollup--config#或者,使用自定义的配置文件，这里使用my.config.js作为配置文件$rollup--configmy.config.js```##rollup.watch>检测某个模块已经改变,就会重新构建文件束>`--watch`:此函数会被内部使用```jsconstrollup=require('rollup');constwatchOptions={...};constwatcher=rollup.watch(watchOptions);watcher.on('event',event=>{//event.code会是下面其中一个：//START—监听器正在启动（重启）//BUNDLE_START—构建单个文件束//BUNDLE_END—完成文件束构建//END—完成所有文件束构建//ERROR—构建时遇到错误//FATAL—遇到无可修复的错误});//停止监听watcher.close();```##选项表###监听参数(watchOptions)>-输入(input-i/--input)​>-String这个包的入口点(例如：你的main.js或者app.js或者index.js)>-文件(file-o/--output.file)​>-String要写入的文件。也可用于生成sourcemaps，如果适用>-格式(format-f/--output.format)​>-String生成包的格式。下列之一:>-amd–异步模块定义，用于像RequireJS这样的模块加载器>-cjs–CommonJS，适用于Node和Browserify/Webpack>-esm–将软件包保存为ES模块文件，在现代浏览器中可以通过`<scripttype=module>`标签引入>-iife–一个自动执行的功能，适合作为`<script>`标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。）>-umd–通用模块定义，以amd，cjs和iife为一体>-system-SystemJS加载器格式###生成包名称(name-n/--name)​String变量名，代表你的iife/umd包，同一页上的其他脚本可以访问它。```js//rollup.config.jsexportdefault{...,output:{file:'bundle.js',format:'iife',name:'MyBundle'}};//->varMyBundle=(function(){...```###插件(plugins)​>插件对象数组Array(或一个插件对象)–有关详细信息请参阅插件入门。记住要调用导入的插件函数(即commonjs(),而不是commonjs).```js//rollup.config.jsimportresolvefrom'rollup-plugin-node-resolve'importcommonjsfrom'rollup-plugin-commonjs'exportdefault{entry:'main.js',plugins:[resolve(),commonjs()],}```###外链(external-e/--external)​>两者任一Function需要一个id并返回true（外部引用）或false（不是外部的引用），或者Array应该保留在bundle的外部引用的模块ID。ID应该是：外部依赖的名称一个已被找到路径的ID（像文件的绝对路径）```js//rollup.config.jsimportpathfrom'path';exportdefault{...,external:['some-externally-required-library',path.resolve('./src/some-local-file-that-should-not-be-bundled.js')]};```当作为命令行参数给出时，它应该是以逗号分隔的ID列表：`rollup-isrc/main.js...-efoo,bar,baz`全局模块(globals-g/--globals)​Object形式的id:name键值对，用于umd/iife包。例如：在这样的情况下...```jsimport$from'jquery';//...我们想告诉Rollupjquery模块的id等同于$变量://rollup.config.jsexportdefault{...,format:'iife',name:'MyBundle',globals:{jquery:'$'}};/*varMyBundle=(function($){//代码到这里}(window.jQuery));*/.```或者，提供将外部模块ID转换为全局模块的功能。当作为命令行参数给出时，它应该是一个逗号分隔的“id：name”键值对列表：`rollup-isrc/main.js...-gjquery:$,underscore:_````jsconstwatchOptions={...inputOptions,output:[outputOptions],watch:{chokidar,include,exclude,},}```###路径(paths)>Function，它获取一个ID并返回一个路径，或者id：path对的Object。>在提供的位置，这些路径将被用于生成的包而不是模块ID，从而允许您（例如）从CDN加载依赖关系：```js//app.jsimport{selectAll}from'd3'selectAll('p').style('color','purple')//...//rollup.config.jsexportdefault{input:'app.js',external:['d3'],output:{file:'bundle.js',format:'amd',paths:{d3:'https://d3js.org/d3.v4.min',},},}//bundle.jsdefine(['https://d3js.org/d3.v4.min'],function(d3){d3.selectAll('p').style('color','purple')//...})```###intro/outro​>String类似于banner和footer，除了代码在内部任何特定格式的包装器(wrapper)```jsexportdefault{...,intro:'varENVIRONMENT=\"production\";'};```###缓存(cache)​>Object以前生成的包。使用它来加速后续的构建——Rollup只会重新分析已经更改的模块。###onwarn​Function将拦截警告信息。如果没有提供，警告将被复制并打印到控制台。警告是至少有一个code和message属性的对象，这意味着您可以控制如何处理不同类型的警告：```jsonwarn(warning){//跳过某些警告if(warning.code==='UNUSED_EXTERNAL_IMPORT')return;//抛出异常if(warning.code==='NON_EXISTENT_EXPORT')thrownewError(warning.message);//控制台打印一切警告console.warn(warning.message);}```许多警告也有一个loc属性和一个frame，你可以定位到警告的来源：```jsonwarn({loc,frame,message}){//打印位置（如果适用）if(loc){console.warn(`${loc.file}(${loc.line}:${loc.column})${message}`);if(frame)console.warn(frame);}else{console.warn(message);}}```###sourcemap-m/--sourcemap​>如果true，将创建一个单独的sourcemap文件。如果inline，sourcemap将作为数据URI附加到生成的output文件中。###sourcemapFile​>String生成的包的位置。如果这是一个绝对路径，sourcemap中的所有源代码路径都将相对于它。map.file属性是sourcemapFile的基本名称(basename)，因为sourcemap的位置被假定为与bundle相邻>如果指定output，sourcemapFile不是必需的，在这种情况下，将通过给bundle输出文件添加“.map”后缀来推断输出文件名。###interop​>Boolean是否添加'interop块'。默认情况下（interop：true），为了安全起见，如果需要区分默认和命名导出，则Rollup会将任何外部依赖项“default”导出到一个单独的变量。这通常只适用于您的外部依赖关系（例如与Babel）（如果您确定不需要它），则可以使用“interop：false”来节省几个字节。###Watchoptions​>这些选项仅在运行Rollup时使用--watch标志或使用rollup.watch时生效。####watch.chokidar​>一个Boolean值表示应该使用chokidar而不是内置的fs.watch，或者是一个传递给chokidar的选项对象。>如果你希望使用它，你必须单独安装chokidar。####watch.include​>限制文件监控至某些文件```js//rollup.config.jsexportdefault{...,watch:{include:'src/**'}};```####watch.exclude​>防止文件被监控：```js//rollup.config.jsexportdefault{...,watch:{exclude:'node_modules/**'}};```##命令行参数```shell-i,--input<filename>要打包的文件（必须）-o,--file<output>输出的文件(如果没有这个参数，则直接输出到控制台)-f,--format<format>输出的文件类型(amd,cjs,esm,iife,umd)-e,--external<ids>将模块ID的逗号分隔列表排除-g,--globals<pairs>以`moduleID:Global`键值对的形式，用逗号分隔开任何定义在这里模块ID定义添加到外部依赖-n,--name<name>生成UMD模块的名字-h,--help输出help信息-m,--sourcemap生成sourcemap(`-minline`forinlinemap)--amd.idAMD模块的ID，默认是个匿名函数--amd.define使用Function来代替`define`--no-strict在生成的包中省略`\"usestrict\";`--no-conflict对于UMD模块来说，给全局变量生成一个无冲突的方法--intro在打包好的文件的块的内部(wrapper内部)的最顶部插入一段内容--outro在打包好的文件的块的内部(wrapper内部)的最底部插入一段内容--banner在打包好的文件的块的外部(wrapper外部)的最顶部插入一段内容--footer在打包好的文件的块的外部(wrapper外部)的最底部插入一段内容--interop包含公共的模块（这个选项是默认添加的）```","Front-End\\项目搭建\\Rollup\\问题.md":"#问题##Missingglobalvariablenames报错信息：```shell(!)MissingglobalvariablenameUseoutput.globalstospecifybrowserglobalvariablenamescorrespondingtoexternalmodulesaxios(guessing'axios')```解决方法：在配置文件增加globalrollup.config.js```js{external:['react','react-dom','prop-types'],output:{globals:{'axios':'axios'},...},...}```参考资料：<https://github.com/rollup/rollup-plugin-babel/issues/162>##Youhavepassedanunrecognizedoption报错信息：```shell(!)YouhavepassedanunrecognizedoptionUnknowninputoption:plugin.Allowedoptions:acorn,acornInjectPlugins,cache,chunkGroupingSize,context,experimentalCacheExpiry,experimentalOptimizeChunks,experimentalTopLevelAwait,external,inlineDynamicImports,input,manualChunks,moduleContext,onwarn,perf,plugins,preserveModules,preserveSymlinks,shimMissingExports,strictDeprecations,treeshake,watch```解决方法：我傻了，手残把配置文件中的plugins错打成plugin(:з」∠)参考资料：<https://github.com/rollup/rollup/issues/2682>##Babel7.0.0-beta.56hasdroppedsupportforthe‘helpersNamespace’utility报错信息：```shell[!](pluginbabel)Error:Babel7.0.0-beta.56hasdroppedsupportforthe'helpersNamespace'utility.Ifyouareusing@babel/plugin-external-helpersyouwillneedtouseanewerversionthantheoneyoucurrentlyhaveinstalled.Ifyouhaveyourownimplementation,you'llwanttoexploreusing'helperGenerator'alongside'file.availableHelper()'.```解决方法：方法1.安装babel6.x`npminstall--save-devrollup-plugin-babel@3`安装了之后出现新的问题[!]Error:Cannotfindmodule'babel-core'继续安装babel-core`npminstall--save-devbabel-core`方法2.安装babel-upgrade`npminstall--save-devbabel-upgrade`安装了之后出现新的问题```shell[!](pluginbabel)Error:Babel7.0.0-beta.56hasdroppedsupportforthe'helpersNamespace'utility.Ifyouareusing@babel/plugin-external-helpersyouwillneedtouseanewerversionthantheoneyoucurrentlyhaveinstalled.Ifyouhaveyourownimplementation,you'llwanttoexploreusing'helperGenerator'alongside'file.availableHelper()'.```配置文件rollup.config.js```jsplugins:[//...babel(babelrc({addExternalHelpersPlugin:false,exclude:/node_modules/,runtimeHelpers:false,}),),//...]```有新的报错：`[!](pluginbabel)ReferenceError:Unknownoption:.addExternalHelpersPlugin.Checkout<https://babeljs.io/docs/en/babel-core/#options>formoreinformationaboutoptions.`累了，放弃这个方法(:з」∠)参考资料：<https://github.com/rollup/rollup-plugin-babel/issues/237>##Unexpectedtoken(Notethatyouneedrollup-plugin-jsontoimportJSONfiles)报错信息：`[!]Error:Unexpectedtoken(Notethatyouneedrollup-plugin-jsontoimportJSONfiles)`解决方法：这个错误看得懂，就安装一下rollup-plugin-json`npminstall--save-devrollup-plugin-json`添加以下配置到配置文件rollup.config.js```jsimportjsonfrom'rollup-plugin-json'exportdefault{input:'src/main.js',output:{file:'dist/bundle.js',format:'iife',},plugins:[json({//默认情况下将解析所有JSON文件,//但您可以专门包含/排除文件include:'node_modules/**',exclude:['node_modules/foo/**','node_modules/bar/**'],//对于tree-shaking,属性将声明为//变量,使用`var`或者`const`preferConst:true,//默认是false//为生成的默认导出指定缩进—//默认为't'indent:'',//忽略缩进并生成最小的代码compact:true,//默认是false//为JSON对象的每个属性生成一个命名导出namedExports:true,//默认是true}),],}```##MissingshimsforNode.jsbuilt-ins报错信息：```shell(!)MissingshimsforNode.jsbuilt-insCreatingabrowserbundlethatdependson'http','https','url','assert','stream','tty','util','os'and'zlib'.Youmightneedtoinclude<https://www.npmjs.com/package/rollup-plugin-node-builtins>```解决方法：安装rollup-plugin-node-builtins```shellnpminstall--save-devrollup-plugin-node-builtinsimportbuiltinsfrom'rollup-plugin-node-builtins';importglobalsfrom'rollup-plugin-node-globals';rollup({entry:'main.js',plugins:[globals(),builtins()]})```##Cannotfindmodule‘rollup-plugin-node-globals’报错信息：`[!]Error:Cannotfindmodule'rollup-plugin-node-globals'`解决方法：安装rollup-plugin-node-globals`npminstall--save-devrollup-plugin-node-globals`##Pluginnode-resolve:preferringbuilt-inmodule‘https’……报错信息：```shellPluginnode-resolve:preferringbuilt-inmodule'https'overlocalalternativeat'https',pass'preferBuiltins:false'todisablethisbehavioror'preferBuiltins:true'todisablethiswarning```解决方法：```jsplugins:[//...resolve({preferBuiltins:true,mainFields:['browser'],}),//...]```##Error:Unexpectedcharacter‘@’(NotethatyouneedpluginstoimportfilesthatarenotJavaScript)报错信息：```shell[!]Error:Unexpectedcharacter'@'(NotethatyouneedpluginstoimportfilesthatarenotJavaScript)node_modulesanimate.cssanimate.css(1:0)1:@charset\"UTF-8\";^2:3:/*!Error:Unexpectedcharacter'@'(NotethatyouneedpluginstoimportfilesthatarenotJavaScript)aterror(E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:9419:30)atModule.error(E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:13402:9)attryParse(E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:13315:16)atModule.setSource(E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:13629:33)atPromise.resolve.catch.then.then.then(E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:16423:20)at<anonymous>```原因：不支持css文件的打包，需要安装相关的插件解决方法：安装rollup-plugin-css-porter`npminstall--save-devrollup-plugin-css-porter`##(!)Useofevalisstronglydiscouraged报错信息：```shell(!)Useofevalisstronglydiscouraged<https://rollupjs.org/guide/en/#avoiding-eval>packageslocateManagerGeometryZoomCtrl.js53:ext.xmin+=wValue;54:ext.xmax+=wValue;55:if(typeofeval(ext.expand)==\"function\"){^56:ext=ext.expand(_LocateManagerCtrl.locateManagerCtrl.factor);57:}```rollup强烈反对使用eval，原因：```shellYouprobablyalreadyknowthat‘evalisevil’,atleastaccordingtosomepeople.Butit’sparticularlyharmfulwithRollup,becauseofhowitworks–unlikeothermodulebundlers,whichwrapeachmoduleinafunction,Rollupputsallyourcodeinthesamescope.That’smoreefficient,butitmeansthatthesharedscopeis‘polluted’wheneveryouuseeval,whereaswithadifferentbundler,modulesthatdidn’tuseevalwouldnotbepolluted.Aminifiercan’tmanglevariablenamesinpollutedcode,becauseitcan’tguaranteethatthecodetobeevaluateddoesn’treferencethosevariablenames.Furthermore,itposesasecurityriskinthatamaliciousmodulecouldaccessanothermodule’sprivatevariableswitheval('SUPER_SEKRIT').```简而言之，它会污染变量而且存在安全隐患。解决方法：```shelleval2=evalSimply‘copying’evalprovidesyouwithafunctionthatdoesexactlythesamething,butwhichrunsintheglobalscoperatherthanthelocalone:vareval2=eval;(function(){varfoo=42;eval('console.log(\"witheval:\",foo)');//logs'witheval:42'eval2('console.log(\"witheval2:\",foo)');//throwsReferenceError})();newFunctionUsingtheFunctionconstructorgeneratesafunctionfromthesuppliedstring.Again,itrunsintheglobalscope.Ifyouneedtocallthefunctionrepeatedly,thisismuch,muchfasterthanusingeval.```##(!)thishasbeenrewrittentoundefined报错信息：```shell(!)`this`hasbeenrewrittento`undefined`<https://rollupjs.org/guide/en/#error-this-is-undefined>packagesvisualizationesriClusterLayerEsriClusterLayer.js1:2:var__extends=this&&this.__extends||function(){^3:varextendStatics=function(d,b){4:extendStatics=Object.setPrototypeOf||{**proto**:[]}instanceofArray&&function(d,b){...and5otheroccurrences```原因：为什么会出现这个问题，官方文档是说：```shellError:“thisisundefined”InaJavaScriptmodule,thisisundefinedatthetoplevel(i.e.,outsidefunctions).Becauseofthat,Rollupwillrewriteanythisreferencestoundefinedsothattheresultingbehaviourmatcheswhatwillhappenwhenmodulesarenativelysupported.Thereareoccasionalvalidreasonsforthistomeansomethingelse.Ifyou’regettingerrorsinyourbundle,youcanuseoptions.contextandoptions.moduleContexttochangethisbehaviour.```我本身的情况是因为使用了es6中的class，所以会出现this，然后被替换成了`undefined`。解决方法：添加以下配置到配置文件`rollup.config.js````jsexportdefault{entry:'ng2-App/Bootstrapper/Components/main-aot.js',...onwarn:function(warning){if(warning.code==='THIS_IS_UNDEFINED'){return;}console.error(warning.message);},plugins:[...]};```参考资料：<https://github.com/rollup/rollup/issues/794>##(plugincommonjs)TypeError[ERR_INVALID_ARG_TYPE]:The“path”argumentmustbeoftypestring报错内容：[!](plugincommonjs)TypeError[ERR_INVALID_ARG_TYPE]:The\"path\"argumentmustbeoftypestringTypeError[ERR_INVALID_ARG_TYPE]:The\"path\"argumentmustbeoftypestring解决方法：rollup.config.js配置文件中的input字段输入有误，检查路径是否正确##[!](pluginbabel)SyntaxError报错内容：```shell[!](pluginbabel)SyntaxError:E:/mproject/oauth-login-package/node_modules/axios/package.json:Unexpectedtoken,expected;(2:9)node_modulesaxiospackage.json(2:9)SyntaxError:E:/mproject/oauth-login-package/node_modules/axios/package.json:Unexpectedtoken,expected;(2:9)1|{>2|\"_from\":\"axios@^0.19.0\",|^3|\"_id\":\"axios@0.19.0\",4|\"_inBundle\":false,5|\"_integrity\":\"sha1-jgm/89kSLhM/e4EByPvdAO09Krg=\",```解决方法：修改rollup配置文件中的babel配置rollup.config.js```jsbabel({exclude:'node_modules/**',runtimeHelpers:true,}),```##[!](pluginuglify)Error:Unexpectedtoken:punc«,»报错内容：```shell[!](pluginuglify)Error:Unexpectedtoken:punc«,»SyntaxError:Unexpectedtoken:punc«,»```解决方法：这个错误定位后发现与rollup-plugin-uglify插件有关，rollup-plugin-uglify不能压缩es6的代码文件。rollup-plugin-uglify的官方文档是说>Note:uglify-jsisabletotranspileonlyes5syntax.Ifyouwanttotranspilees6+syntaxuseterserinstead>顺着这个思路有两种解决方法，一只要把es6的代码用babel转换成es5即可。二使用rollup-plugin-terser插件代替rollup-plugin-uglify安装rollup-plugin-terser`yarnaddrollup-plugin-terser--dev`使用rollup-plugin-terser```jsimport{rollup}from'rollup'import{terser}from'rollup-plugin-terser'rollup({input:'main.js',plugins:[terser()],})```##preferringbuilt-inmodule‘http’overlocalalternativeat‘http’,pass‘preferBuiltins:false’todisablethisbehavioror‘preferBuiltins:true’todisablethiswarning报错内容：```shell(!)Pluginnode-resolve:preferringbuilt-inmodule'http'overlocalalternativeat'http',pass'preferBuiltins:false'todisablethisbehavioror'preferBuiltins:true'todisablethiswarning(!)Pluginnode-resolve:preferringbuilt-inmodule'https'overlocalalternativeat'https',pass'preferBuiltins:false'todisablethisbehavioror'preferBuiltins:true'todisablethiswarning(!)Pluginnode-resolve:preferringbuilt-inmodule'zlib'overlocalalternativeat'zlib',pass'preferBuiltins:false'todisablethisbehavioror'preferBuiltins:true'todisablethiswarning```解决方法：设置rollup.config.js```jsplugins:[...resolve({preferBuiltins:true,//这一句是重点mainFields:['browser']}),...],```或者可以这么做```jsexportdefault{...external:['http','https','zlib'],...}```##(!)Circulardependency报错内容：```shell(!)Circulardependency:node_modulesrollup-plugin-node-builtinssrces6readable-streamduplex.js->node_modulesrollup-plugin-node-builtinssrces6readable-streamreadable.js->node_modulesrollup-plugin-node-builtinssrces6readable-streamduplex.js```解决方法：参考<https://github.com/rollup/rollup/issues/1089>##[!](pluginbabel)TypeError:Cannotreadproperty‘length’ofundefined报错信息：```shell[!](pluginbabel)TypeError:Cannotreadproperty'length'ofundefinedpackages/index.jsTypeError:Cannotreadproperty'length'ofundefinedatObject.transform$1(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup-plugin-babel/dist/rollup-plugin-babel.cjs.js:148:21)atPromise.resolve.then(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup/dist/rollup.js:16621:25)```解决方法：安装rollup-plugin-babel@4.0.0以上版本的`npminstall--save-devrollup-plugin-babel@latest`参考资料：<https://github.com/rollup/rollup-plugin-babel/issues/172>##[!](pluginbabel)Error:Babel7.0.0-beta.56hasdroppedsupportforthe‘helpersNamespace’utility报错信息：```shell[!](pluginbabel)Error:Babel7.0.0-beta.56hasdroppedsupportforthe'helpersNamespace'utility.Ifyouareusing@babel/plugin-external-helpersyouwillneedtouseanewerversionthantheoneyoucurrentlyhaveinstalled.Ifyouhaveyourownimplementation,you'llwanttoexploreusing'helperGenerator'alongside'file.availableHelper()Error:Babel7.0.0-beta.56hasdroppedsupportforthe'helpersNamespace'utility.Ifyouareusing@babel/plugin-external-helpersyouwillneedtouseanewerversionthantheoneyoucurrentlyhaveinstalled.Ifyouhaveyourownimplementation,you'llwanttoexploreusing'helperGenerator'alongside'file.availableHelper()'.atFile.set(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transformation/file/file.js:127:13)atPluginPass.pre(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/babel-plugin-external-helpers/lib/index.js:10:12)attransformFile(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transformation/index.js:78:27)atrunSync(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transformation/index.js:45:3)attransformSync(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transform.js:43:38)atObject.transform(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transform.js:22:38)at/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup-plugin-babel/dist/rollup-plugin-babel.cjs.js:57:26atObject.transform$1(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup-plugin-babel/dist/rollup-plugin-babel.cjs.js:141:18)atPromise.resolve.then(/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup/dist/rollup.js:16621:25)```解决方法：下载安装`@babel/plugin-external-helpers``npminstall--save-dev@babel/plugin-external-helpers`","Front-End\\项目搭建\\vite\\index.md":"#Vite-`node>12`","Front-End\\项目搭建\\vite\\问题.md":"#vite问题##Vetur(1192)-将vscodevetur插件切换为volar##启动无法通过IP+端口方法进行访问-没有将服务暴露再局域网中###解决####方法一```jsexportdefaultdefineConfig({plugins:[...],//添加server:{host:'0.0.0.0'}})```####方法二```js{\"scripts\":{\"dev\":\"vite--host0.0.0.0\",\"build\":\"vue-tsc--noEmit&&vitebuild\",\"preview\":\"vitepreview\"},}```","Front-End\\项目搭建\\webpack\\Plugin\\EslintWebpackPlugin.md":"#EslintWebpackPlugin>eslint-webpack-plugin3.0仅支持webpack5。对于webpack4请查看2.x分支。>>该插件使用eslint来查找和修复JavaScript代码中的问题。##开始>首先，需要安装eslint-webpack-plugin：`npminstalleslint-webpack-plugin--save-dev`>注意:如果未安装eslint>=7，你还需先通过npm安装：`npminstalleslint--save-dev`然后把插件添加到你的webpack配置。例如：```jsconstESLintPlugin=require('eslint-webpack-plugin')module.exports={//...plugins:[newESLintPlugin(options)],//...}```##选项>你可以传入eslint参数。>注意你提供的配置选项会传给ESLint类。这是一组和你在package.json与.eslintrc所指定选项不同的选项。查阅eslint文档获取更多详情。>警告:在eslint-webpack-plugin1.x版本中，配置项会传递给已废弃的CLIEngine。###context>类型：String>默认值：compiler.context>指定文件根目录，类型为字符串。###eslintPath>类型：String>默认值：eslint>用于linting的eslint实例的路径。如果eslintPath是类似官方eslint的目录，或者指定了formatter选项，那么就不需要安装eslint了。###extensions>类型：String|Array[String]>默认值：'js'>指定需要检查的扩展名。###exclude>类型：String|Array[String]>默认值：'node_modules'>指定需要排除的文件及目录。必须是相对于options.context的相对路径。###files>类型：String|Array[String]>默认值：null>指定目录、文件或globs，必须是相对于options.context的相对路径。如果是目录则递归查找所有匹配options.extensions选项的文件。如果是文件或globs则忽略options.extensions选项。###fix>类型：Boolean>默认值：false>启用ESLint自动修复特性。小心:该选项会修改源文件。###formatter>类型：String|Function>默认值：'stylish'>接受一个有单一参数的函数：该参数为eslint消息（一个对象）的数组。函数必须返回字符串格式的output。可以使用官方的eslintformatters。###lintDirtyModulesOnly>类型：Boolean>默认值：false>只对内容修改了的文件进行lint，启动时跳过lint。###threads>类型：Boolean|Number>默认值：false>以线程池方式运行lint。线程池大小是自动的，除非你指定一个数值。错误以及警告该插件默认会根据eslint错误/警告的数量自动调整错误报告（errorreporting）。你也可以通过emitError或emitWarning强制开启错误报告行为：###emitError>类型：Boolean>默认值：true>总是发送发现的错误，设置为false以禁用。###emitWarning>类型：Boolean>默认值：true>总是发送发现的警告，设置为false以禁用。###failOnError>类型：Boolean>默认值：true>任何错误都会导致模块构建（modulebuild）失败，设置为false禁用。###failOnWarning>类型：Boolean>默认值：false>当设置为true时，任何警告都会导致模块构建（modulebuild）失败。###quiet>类型：Boolean>默认值：false>设置为true后，仅处理和报告错误，忽略警告。###outputReport>类型：Boolean|Object>默认值：false>把错误输出到一个文件，例如在JenkinsCI使用checkstylexml文件。filePath为绝对路径或者相对于webpack配置:output.path的相对路径。你可以为输出文件传入不同的formatter。如果没有传入，则使用默认的或已配置的formatter。","Front-End\\项目搭建\\webpack\\question.md":"#Webpackquestion##查找对应包的版本>去到对应webpack的版本的`package.json`,查看对应的包的版本,就是对应的包的版本","Front-End\\项目搭建\\webpack\\react-webpack-ts.md":"#webpack5手动搭建ReactTS项目##1.前言前段时间突发奇想，使用React这么长时间了，不是使用cra搭建项目就是使用antdpro，都是基本上帮你配置好了所有的配置项，你只需要写业务代码就好了。所以闲下来的时间打算手动从0开始一步一步搭建一个基于webpack5的ReactTs项目，于是就有了下面的实践，由于本人小白一名，所以有做得不对的地方欢迎大佬指正。##2.初始化项目找一个空白的目录然后执行下面代码:```bashmkdirwebpack5-react-ts-tempaltecdwebpack5-react-ts-tempaltenpminit-y```##3.初始化typeScript配置```bashnpminstall--save-devtypescriptts-loader```新建一个`tsconfig.json`文件，我这里直接采用的是webpack官网的tsconfig配置，可以通过查看[TypeScript官方文档](https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Ftsconfig-json.html)了解更多功能。```json{\"compilerOptions\":{\"outDir\":\"./dist/\",\"noImplicitAny\":true,\"module\":\"es6\",\"target\":\"es5\",\"jsx\":\"react\",\"allowJs\":true,\"moduleResolution\":\"node\",\"allowSyntheticDefaultImports\":true}}```##4.配置webpack相关```bashnpmiwebpackwebpack-cliwebpack-mergehtml-webpack-pluginclean-webpack-plugin--dev```由于我们的项目基本上都是分为开发环境和生产环境的，所以对于webpack的配置，个人新建了三个文件来存放不同的配置。新建`config`文件来存放webpack的配置文件：-`webpack.config.base.js`存放webpack的基本配置-`webpack.config.dev.js`存放webpack的开发环境配置-`webpack.config.prod.js`存放webpack的生产环境配置```jsx//config/webpack.config.base.jsconstpath=require('pathconst{CleanWebpackPlugin}=require('clean-webpack-plugin')constHtmlWebpackPlugin=require('html-webpack-plugin')/***@type{import('webpack').Configuration}*/module.exports={entry:{app:'./src/index.tsx',},output:{path:path.resolve(__dirname,'../dist'),filename:'[name].[hash].js',},resolve:{extensions:['.ts','.tsx','.js','.jsx'],},plugins:[newHtmlWebpackPlugin({title:'管理后台',template:path.resolve(__dirname,'../index.html'),filename:'index.html',}),newCleanWebpackPlugin(),],}```###合并配置项由于我们是分文件配置webpack，所以就会存在合并配置项这个操作。上面安装的`webpack-merge`就是实现这个功能的插件。```jsx//config/webpack.config.dev.jsconstwebpackMerge=require('webpack-merge')constbaseConfig=require('./webpack.config.base')constpath=require('path')/***@type{import('webpack').WebpackOptionsNormalized}*/constdevServer={port:3000,host:'localhost',contentBase:path.join(__dirname,'../publich'),watchContentBase:true,publicPath:'/',compress:true,historyApiFallback:true,hot:true,clientLogLevel:'error',//open:true,watchOptions:{ignored:/node_modules/,},}constdevConfig={mode:'development',devServer:devServer,}module.exports=webpackMerge.merge(baseConfig,devConfig)//config/webpack.config.prod.jsconstwebpackMerge=require('webpack-merge')constbaseConfig=require('./webpack.config.base')/***@type{import('webpack').WebpackOptionsNormalized}*/constprodConfig={mode:'production',}module.exports=webpackMerge.merge(baseConfig,prodConfig)```##5.配置babel安装依赖```bashnpmibabel-loaderbabel-plugin-import@babel/cli@babel/core@babel/preset-env@babel/preset-react@babel/preset-typescript--dev```在根目录新建`.babelrc`文件```json{\"presets\":[\"@babel/preset-env\",\"@babel/preset-react\"]}````webpack.config.base.js`中添加mode配置```jsxmodule.exports={...module:{rules:[{test:/\\.(js|jsx)$/,loader:'babel-loader',exclude:/node_modules/},{test:/\\.(ts|tsx)$/,loader:'ts-loader',exclude:/node_modules/},],},};```##6.配置React###安装依赖```bashnpmireactreact-domreact-router-domnpmi@types/react@types/react-dom@types/react-router-dom--dev```###新建html文件根目录新建`index.html````html<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"/><metahttp-equiv=\"X-UA-Compatible\"content=\"IE=edge\"/><metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\"/><title><%=htmlWebpackPlugin.options.title%></title></head><body><divid=\"root\"></div></body></html>```###新建工程入口文件新建`src`目录下新建`App.tsx``index.tsx````jsx//App.tsximportReactfrom'react'constApp=()=>{return<div>1234</div>}exportdefaultApp//index.tsximportReactfrom'react'importReactDOMfrom'react-dom'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))```##7.功能性配置###样式文件解析```bashnpmistyle-loadersass-loadersasscss-loaderpostcss-loaderpostcss-normalizeautoprefixerpostcss-preset-env-D```因为我们平时开发中不只是使用scss，也会使用到scssmodule，所以同时配置一下，安装依赖```bashnpmireact-dev-utilsresolve-url-loader-D````webpack.config.base.js`中添加mode配置,```jsxconstgetCSSModuleLocalIdent=require('react-dev-utils/getCSSModuleLocalIdent')module.exports={...module:{rules:[...{test:/\\.(css|scss)$/,exclude:/\\.module\\.scss$/,use:['style-loader','css-loader','postcss-loader','sass-loader'],},{test:/\\.module\\.scss$/,use:['style-loader',{loader:'css-loader',options:{modules:{getLocalIdent:getCSSModuleLocalIdent,},},},'postcss-loader','sass-loader',],},],},};```新增`postcss.config.js`文件并配置```jsxconstpostcssNormalize=require('postcss-normalize')module.exports={plugins:[['postcss-preset-env',{autoprefixer:{flexbox:'no-2009',},stage:3,},],postcssNormalize(),require('autoprefixer')({overrideBrowserslist:['last2version','>1%','ios7'],}),],}```###图片地址解析webpack5内置assets类型，我们不需要额外安装插件就可以进行图片等资源文件的解析，配置如下：```jsx{test:/\\.(jpe?g|png|gif|svg|woff|woff2|eot|ttf|otf)$/i,type:\"asset/resource\",},```##8.性能优化webpack5引入了缓存来提高二次构建速度，我们只需要在webpack配置文件中加入如下代码即可开心缓存```jsxcache:{type:'filesystem',//可选配置buildDependencies:{config:[__filename],//当构建依赖的config文件（通过require依赖）内容发生变化时，缓存失效},name:'development-cache',},```##9.完整配置###webpack.config.base.js```jsx//webpack.config.base.jsconstpath=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')constgetCSSModuleLocalIdent=require('react-dev-utils/getCSSModuleLocalIdent')const{CleanWebpackPlugin}=require('clean-webpack-plugin')/***@type{import('webpack').Configuration}*/module.exports={entry:{app:'./src/index.tsx',},output:{path:path.resolve(__dirname,'../dist'),filename:'[name].[hash].js',},module:{rules:[{test:/\\.(js|jsx)$/,loader:'babel-loader',exclude:/node_modules/},{test:/\\.(ts|tsx)$/,loader:'ts-loader',exclude:/node_modules/},{test:/\\.(css|scss)$/,exclude:/\\.module\\.scss$/,use:['style-loader','css-loader','postcss-loader','sass-loader'],},{test:/\\.module\\.scss$/,use:['style-loader',{loader:'css-loader',options:{modules:{getLocalIdent:getCSSModuleLocalIdent,},},},'postcss-loader','sass-loader',],},{test:/\\.(jpe?g|png|gif|svg|woff|woff2|eot|ttf|otf)$/i,type:'asset/resource',},],},resolve:{extensions:['.tsx','.ts','.js','.jsx'],},plugins:[newHtmlWebpackPlugin({title:'管理后台',template:path.resolve(__dirname,'../index.html'),filename:'index.html',}),newCleanWebpackPlugin(),],cache:{type:'filesystem',//可选配置buildDependencies:{config:[__filename],//当构建依赖的config文件（通过require依赖）内容发生变化时，缓存失效},name:'development-cache',},}```###webpack.config.dev.js```jsxconstwebpackMerge=require('webpack-merge')constbaseConfig=require('./webpack.config.base')constpath=require('path')/***@type{import('webpack').WebpackOptionsNormalized}*/constdevServer={port:3000,host:'localhost',contentBase:path.join(__dirname,'../publich'),watchContentBase:true,publicPath:'/',compress:true,historyApiFallback:true,hot:true,clientLogLevel:'error',//open:true,watchOptions:{ignored:/node_modules/,},}constdevConfig={mode:'development',devServer:devServer,}module.exports=webpackMerge.merge(baseConfig,devConfig)```###webpack.config.prod.js```jsxconstwebpackMerge=require('webpack-merge')constbaseConfig=require('./webpack.config.base')/***@type{import('webpack').WebpackOptionsNormalized}*/constprodConfig={mode:'production',}module.exports=webpackMerge.merge(baseConfig,prodConfig)```##10.css提取成单独的打包文件上述配置中的css是打包到js中的，所以如果想要把css单独打包出来，就需要做一下配置，安装依赖```bashnpminstall--save-devmini-css-extract-plugin```修改`webpack.config.base.js`中的配置```jsxconstMiniCssExtractPlugin=require('mini-css-extract-plugin');module.exports={...plugins:[newMiniCssExtractPlugin({filename:'css/[name].[hash].css',})],module:{rules:[{test:/\\.css$/i,use:[MiniCssExtractPlugin.loader,'css-loader'],},],},}```##11.配置开发服务器安装依赖```bashnpmiwebpack-dev-server--dev````package.json`中添加启动命令```json\"scripts\":{\"start\":\"webpackserve--config./config/webpack.config.dev.js\",\"build\":\"webpack--mode=production--config./config/webpack.config.prod.js\"},```##12.问题解决当完成上述的步骤的时候，当你运行的时候，可能会收到这么一个报错。```bashCannotfindmodule'./index.module.scss'oritscorrespondingtypedeclarations.```因为是ts的项目，所以这个时候需要进行声明文件的书写。新建`declaration.d.ts````tsxdeclaremodule'*.scss'{constcontent:Record<string,string>exportdefaultcontent}```##13.获取良好的css代码提示需要使用到一个插件```bashnpminstall-Dtypescript-plugin-css-modules```配置tsconfig.json```json{\"compilerOptions\":{\"plugins\":[{\"name\":\"typescript-plugin-css-modules\"}]}}```如果你使用的是`vscode`，可以跟我一样配置一下根目录新建.`vscode`文件夹，然后新建`settings.json`在文件中写入```json{\"typescript.tsdk\":\"node_modules/typescript/lib\",\"typescript.enablePromptUseWorkspaceTsdk\":true}```从工作区设置`TypeScript`版本，从而读取`tsconfig.json`文件![Untitled.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45dfc10b082946dbafc95b0209605933~tplv-k3u1fbpfcp-watermark.image)然后就可以获得良好的代码提示了","Front-End\\项目搭建\\webpack\\webpack.md":"#Webpack>五个核心概念>>1.Entry:入口指示webpack以哪个文件为入口起点开始打包,分析构建内部依赖图>2.Output:输出指示webpack打包后的志愿bundles输出到哪里去,以如何命名>3.Loader:Loader让文本pack能够去除那些非javascript文件(webpack自身只理解javascript)>4.Plugins:插件可以用于执行范围更广的任务,插件的范围包括,从打包优化和压缩,一直重新定义环境中的变量>5.Mode:模式指示webpack使用相应模式的配置>1.development:开发模式,能够让代码在本地调试,会将proces.env.NODE_ENV的值设为development>2.production:产品模式,能够让代码优化上线运行的环境,会将process.env.NDOE_ENV的值设置为production##初体验>全局安装:`yarnglobaladdwebpackwebpack-cli`>>1.webpack能处理js/json资源,不能处理css/img等其他资源>2.生产环境和开发环境将ES6模块化编译成浏览器能识别的模块>3.生产环境比开发环境多一个压缩js代码,注释也会删除```texwebpack./src/index.js-o./build/built.js--mode=production./src/index.js入口文件(Entry)./build/输出路径(Output)--mode=development打包模式,还可以改成生产模式production```###获取npm命令参数###命令行直接输入`npmrundev--aaa=/webpack/src````jsconstserverPath=process.env.npm_config_aaaconsole.log(serverPath)//输出结果：/webpack/src```###添加到package.json的script里面`npmrundev````js//package.json\"scripts\":{\"dev\":\"webpack-dev-server--configbuild/webpack.local--这里是自定义参数随便写\"}``````jsconstarg=process.argvconsole.log(process.argv)/**输出结果是个数组（需要什么）：['--config','build/webpack.local','--这里是自定义参数随便写']**/```##loader的使用>解决非js/json资源的解析>>创建webpack.config.jswebpack的配置文件:指示webpack的加载>>配置好后,使用`webpack`指令执行打包```js//resolve用来拼接绝对路径的方法const{resolve}=require('path')module.exports={entry:'./src/index.js',output:{filename:'main.js',path:resolve(__dirname,'build'),},//loader配置module:{rules:[//详细配置{test:/\\.css$/,use:[//use数组中的loader执行顺序:从左到右,从上到下依次执行//创建style标签,将js中的样式资源引入进行,添加到head中生效'style-loader',//将css文件变成commonjs模块加载js中,里面的内容是格式样式字符串'css-loader',],},{test:/\\.less$/,use:['style-loader','css-loader',//将less文件编译成css文件资源'less-loader',],},],},plugins:[//详细配置],//模式//mode:'development',mode:'production',}```##打包资源###html资源>在plugins:配置打包的配置>>使用html-webpack-plugin```js//resolve用来拼接绝对路径的方法const{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/index.js',output:{filename:'main.js',path:resolve(__dirname,'build'),},//loader配置module:{rules:[//详细配置{test:/\\.css$/,use:[//use数组中的loader执行顺序:从左到右,从上到下依次执行//创建style标签,将js中的样式资源引入进行,添加到head中生效'style-loader',//将css文件变成commonjs模块加载js中,里面的内容是格式样式字符串'css-loader',],},{test:/\\.less$/,use:['style-loader','css-loader',//将less文件编译成css文件资源'less-loader',],},],},plugins:[//详细配置//html-webpack-plugin//功能:默认创建一个空的HTML,动引入输出的所有资源(JS/CSS)//需求:需要有结构的HTML文件newHtmlWebpackPlugin({//复制'./src/index.hmlt',并自动引入打包输出的所有资源(JS/CSS)template:'./src/index.html',}),],//模式//mode:'development',mode:'production',}```###图片资源>使用url-loader,file-loader,html-loader```js//resolve用来拼接绝对路径的方法const{resolve}=require('path');constHtmlWebpackPlugin=require('html-webpack-plugin')module:{rules:[{//问题:默认处理不了html中img图片//处理图片资源test:/\\.(jpg|png|gif)$/,//使用一个loader//下载url-loaderfile-loaderloader:'url-loader',options:{/***图片大小小于8kb,就会被base64处理*优点:减少请求数量(减轻服务器压力)*缺点:图片体积会更大(文件请求速度会更加慢)*///limit:8*1024,/***问题:因为url-loader默认使用es6模块化解析,而html-loader引入图片是commonjs*解析时会出现问题*解决:关闭url-loader模块化,使用commonjs解析*/esModule:false,}},{test:/\\.html$/,//处理html文件中的img图片(负责引入img,从而能被url-loader进行处理)loader:'html-loader'}]},plugins:[//详细配置//html-webpack-plugin//功能:默认创建一个空的HTML,动引入输出的所有资源(JS/CSS)//需求:需要有结构的HTML文件newHtmlWebpackPlugin({//复制'./src/index.hmlt',并自动引入打包输出的所有资源(JS/CSS)template:'./src/index.html'})],//模式//mode:'development',mode:'production'}```###其他资源>这里排除的文件资源要看自己的有哪些```jsmodule:{rules:[//打包其他资源(除了html/js/css资源以外的资源){//排除css/js/html资源exclude:/\\.(css|js|html|json|less|jpg)$/,loader:'file-loader',},]}```###devServer>开发服务器devServer:用来自动化编译>>特点:只会在内存中打包编译,不会有任何输出>>启动devServer指令为:npxwebpack-dev-server```jsmodule:{rules:[devServer:{//项目路径contentBase:resolve(__dirname,'build'),//启动gzip压缩compress:true,//端口号port:3000,//自动打开(默认)浏览器open:true,}]}```###分文件夹```js//resolve用来拼接绝对路径的方法const{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/main.js',path:resolve(__dirname,'build'),},//loader配置module:{rules:[//详细配置{test:/\\.css$/,use:[//use数组中的loader执行顺序:从左到右,从上到下依次执行//创建style标签,将js中的样式资源引入进行,添加到head中生效'style-loader',//将css文件变成commonjs模块加载js中,里面的内容是格式样式字符串'css-loader',],},{test:/\\.less$/,use:['style-loader','css-loader',//将less文件编译成css文件资源'less-loader',],},{//问题:默认处理不了html中img图片//处理图片资源test:/\\.(jpg|png|gif)$/,//使用一个loader//下载url-loaderfile-loaderloader:'url-loader',options:{//设置输出文件夹outputPath:'image',//name:'[hash:10].[ext]',/***图片大小小于8kb,就会被base64处理*优点:减少请求数量(减轻服务器压力)*缺点:图片体积会更大(文件请求速度会更加慢)*///limit:8*1024,/***问题:因为url-loader默认使用es6模块化解析,而html-loader引入图片是commonjs*解析时会出现问题*解决:关闭url-loader模块化,使用commonjs解析*///esModule:false,},},{test:/\\.html$/,//处理html文件中的img图片(负责引入img,从而能被url-loader进行处理)loader:'html-loader',},//打包其他资源(除了html/js/css资源以外的资源){//排除css/js/html资源exclude:/\\.(css|js|html|json|less|jpg)$/,loader:'file-loader',options:{outputPath:'media',},},],},plugins:[//详细配置//html-webpack-plugin//功能:默认创建一个空的HTML,动引入输出的所有资源(JS/CSS)//需求:需要有结构的HTML文件newHtmlWebpackPlugin({//复制'./src/index.hmlt',并自动引入打包输出的所有资源(JS/CSS)template:'./src/index.html',}),],//模式//mode:'development',mode:'production',//开发服务器devServer:用来自动化编译//特点:只会在内存中打包编译,不会有任何输出//启动devServer指令为:npxwebpack-dev-serverdevServer:{//项目路径contentBase:resolve(__dirname,'build'),//启动gzip压缩compress:true,//端口号port:3000,//自动打开(默认)浏览器open:true,},//关闭webpack的性能提示performance:{hints:false,},}```###提取css文件为单独css文件```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')constMiniCssExtractPlugin=require('mini-css-extract-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[{test:/\\.css$/,use:[//创建style标签，将样式放入//'style-loader',//这个loader取代style-loader。作用：提取js中的css成单独文件MiniCssExtractPlugin.loader,//将css文件整合到js文件中'css-loader',],},],},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',}),newMiniCssExtractPlugin({//对输出的css文件进行重命名filename:'css/built.css',}),],mode:'development',}```###css兼容性处理```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')constMiniCssExtractPlugin=require('mini-css-extract-plugin')//设置nodejs环境变量//process.env.NODE_ENV='development';module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[{test:/\\.css$/,use:[MiniCssExtractPlugin.loader,'css-loader',/*css兼容性处理：postcss-->postcss-loaderpostcss-preset-env帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式\"browserslist\":{//开发环境-->设置node环境变量：process.env.NODE_ENV=development\"development\":[\"last1chromeversion\",\"last1firefoxversion\",\"last1safariversion\"],//生产环境：默认是看生产环境\"production\":[\">0.2%\",\"notdead\",\"notop_miniall\"]}*///使用loader的默认配置//'postcss-loader',//修改loader的配置{loader:'postcss-loader',options:{ident:'postcss',plugins:()=>[//postcss的插件require('postcss-preset-env')(),],},},],},],},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',}),newMiniCssExtractPlugin({filename:'css/built.css',}),],mode:'development',}```###压缩css```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')constMiniCssExtractPlugin=require('mini-css-extract-plugin')constOptimizeCssAssetsWebpackPlugin=require('optimize-css-assets-webpack-plugin')//设置nodejs环境变量//process.env.NODE_ENV='development';module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[{test:/\\.css$/,use:[MiniCssExtractPlugin.loader,'css-loader',{loader:'postcss-loader',options:{ident:'postcss',plugins:()=>[//postcss的插件require('postcss-preset-env')(),],},},],},],},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',}),newMiniCssExtractPlugin({filename:'css/built.css',}),//压缩cssnewOptimizeCssAssetsWebpackPlugin(),],mode:'development',}```###js语法检查```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[/*语法检查：eslint-loadereslint注意：只检查自己写的源代码，第三方的库是不用检查的设置检查规则：package.json中eslintConfig中设置~\"eslintConfig\":{\"extends\":\"airbnb-base\"}airbnb-->eslint-config-airbnb-baseeslint-plugin-importeslint*/{test:/\\.js$/,exclude:/node_modules/,loader:'eslint-loader',options:{//自动修复eslint的错误fix:true,},},],},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',}),],mode:'development',}```###js兼容性处理```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[/*js兼容性处理：babel-loader@babel/core1.基本js兼容性处理-->@babel/preset-env问题：只能转换基本语法，如promise高级语法不能转换2.全部js兼容性处理-->@babel/polyfill问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~3.需要做兼容性处理的就做：按需加载-->core-js*/{test:/\\.js$/,exclude:/node_modules/,loader:'babel-loader',options:{//预设：指示babel做怎么样的兼容性处理presets:[['@babel/preset-env',{//按需加载useBuiltIns:'usage',//指定core-js版本corejs:{version:3,},//指定兼容性做到哪个版本浏览器targets:{chrome:'60',firefox:'60',ie:'9',safari:'10',edge:'17',},},],],},},],},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',}),],mode:'development',}```###js压缩```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',}),],//生产环境下会自动压缩js代码mode:'production',}```###html压缩```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',//压缩html代码minify:{//移除空格collapseWhitespace:true,//移除注释removeComments:true,},}),],mode:'production',}```###生产环境配置```jsconst{resolve}=require('path')constMiniCssExtractPlugin=require('mini-css-extract-plugin')constOptimizeCssAssetsWebpackPlugin=require('optimize-css-assets-webpack-plugin')constHtmlWebpackPlugin=require('html-webpack-plugin')//定义nodejs环境变量：决定使用browserslist的哪个环境process.env.NODE_ENV='production'//复用loaderconstcommonCssLoader=[MiniCssExtractPlugin.loader,'css-loader',{//还需要在package.json中定义browserslistloader:'postcss-loader',options:{ident:'postcss',plugins:()=>[require('postcss-preset-env')()],},},]module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[{test:/\\.css$/,use:[...commonCssLoader],},{test:/\\.less$/,use:[...commonCssLoader,'less-loader'],},/*正常来讲，一个文件只能被一个loader处理。当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：先执行eslint在执行babel*/{//在package.json中eslintConfig-->airbnbtest:/\\.js$/,exclude:/node_modules/,//优先执行enforce:'pre',loader:'eslint-loader',options:{fix:true,},},{test:/\\.js$/,exclude:/node_modules/,loader:'babel-loader',options:{presets:[['@babel/preset-env',{useBuiltIns:'usage',corejs:{version:3},targets:{chrome:'60',firefox:'50',},},],],},},{test:/\\.(jpg|png|gif)/,loader:'url-loader',options:{limit:8*1024,name:'[hash:10].[ext]',outputPath:'imgs',esModule:false,},},{test:/\\.html$/,loader:'html-loader',},{exclude:/\\.(js|css|less|html|jpg|png|gif)/,loader:'file-loader',options:{outputPath:'media',},},],},plugins:[newMiniCssExtractPlugin({filename:'css/built.css',}),newOptimizeCssAssetsWebpackPlugin(),newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),],mode:'production',}```###webpack优化配置####开发环境性能优化#####优化打包构建速度#####HMR```js/*HMR:hotmodulereplacement热模块替换/模块热替换作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块）极大提升构建速度样式文件：可以使用HMR功能：因为style-loader内部实现了~js文件：默认不能使用HMR功能-->需要修改js代码，添加支持HMR功能的代码注意：HMR功能对js的处理，只能处理非入口js文件的其他文件。html文件:默认不能使用HMR功能.同时会导致问题：html文件不能热更新了~（不用做HMR功能）解决：修改entry入口，将html文件引入*/const{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:['./src/js/index.js','./src/index.html'],output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[//loader的配置{//处理less资源test:/\\.less$/,use:['style-loader','css-loader','less-loader'],},{//处理css资源test:/\\.css$/,use:['style-loader','css-loader'],},{//处理图片资源test:/\\.(jpg|png|gif)$/,loader:'url-loader',options:{limit:8*1024,name:'[hash:10].[ext]',//关闭es6模块化esModule:false,outputPath:'imgs',},},{//处理html中img资源test:/\\.html$/,loader:'html-loader',},{//处理其他资源exclude:/\\.(html|js|css|less|jpg|png|gif)/,loader:'file-loader',options:{name:'[hash:10].[ext]',outputPath:'media',},},],},plugins:[//plugins的配置newHtmlWebpackPlugin({template:'./src/index.html',}),],mode:'development',devServer:{contentBase:resolve(__dirname,'build'),compress:true,port:3000,open:true,//开启HMR功能//当修改了webpack配置，新配置要想生效，必须重新webpack服务hot:true,},}```#####优化代码调试#####source-map```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:['./src/js/index.js','./src/index.html'],output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[//loader的配置{//处理less资源test:/\\.less$/,use:['style-loader','css-loader','less-loader'],},{//处理css资源test:/\\.css$/,use:['style-loader','css-loader'],},{//处理图片资源test:/\\.(jpg|png|gif)$/,loader:'url-loader',options:{limit:8*1024,name:'[hash:10].[ext]',//关闭es6模块化esModule:false,outputPath:'imgs',},},{//处理html中img资源test:/\\.html$/,loader:'html-loader',},{//处理其他资源exclude:/\\.(html|js|css|less|jpg|png|gif)/,loader:'file-loader',options:{name:'[hash:10].[ext]',outputPath:'media',},},],},plugins:[//plugins的配置newHtmlWebpackPlugin({template:'./src/index.html',}),],mode:'development',devServer:{contentBase:resolve(__dirname,'build'),compress:true,port:3000,open:true,hot:true,},devtool:'eval-source-map',}/*source-map:一种提供源代码到构建后代码映射技术（如果构建后代码出错了，通过映射可以追踪源代码错误）[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-mapsource-map：外部错误代码准确信息和源代码的错误位置inline-source-map：内联只生成一个内联source-map错误代码准确信息和源代码的错误位置hidden-source-map：外部错误代码错误原因，但是没有错误位置不能追踪源代码错误，只能提示到构建后代码的错误位置eval-source-map：内联每一个文件都生成对应的source-map，都在eval错误代码准确信息和源代码的错误位置nosources-source-map：外部错误代码准确信息,但是没有任何源代码信息cheap-source-map：外部错误代码准确信息和源代码的错误位置只能精确的行cheap-module-source-map：外部错误代码准确信息和源代码的错误位置module会将loader的sourcemap加入内联和外部的区别：1.外部生成了文件，内联没有2.内联构建速度更快开发环境：速度快，调试更友好速度快(eval>inline>cheap>...)eval-cheap-souce-mapeval-source-map调试更友好souce-mapcheap-module-souce-mapcheap-souce-map-->eval-source-map/eval-cheap-module-souce-map生产环境：源代码要不要隐藏?调试要不要更友好内联会让代码体积变大，所以在生产环境不用内联nosources-source-map全部隐藏hidden-source-map只隐藏源代码，会提示构建后代码错误信息-->source-map/cheap-module-souce-map*/```###生产环境性能优化####优化打包构建速度#####oneOf```jsconst{resolve}=require('path')constMiniCssExtractPlugin=require('mini-css-extract-plugin')constOptimizeCssAssetsWebpackPlugin=require('optimize-css-assets-webpack-plugin')constHtmlWebpackPlugin=require('html-webpack-plugin')//定义nodejs环境变量：决定使用browserslist的哪个环境process.env.NODE_ENV='production'//复用loaderconstcommonCssLoader=[MiniCssExtractPlugin.loader,'css-loader',{//还需要在package.json中定义browserslistloader:'postcss-loader',options:{ident:'postcss',plugins:()=>[require('postcss-preset-env')()],},},]module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},module:{rules:[{//在package.json中eslintConfig-->airbnbtest:/\\.js$/,exclude:/node_modules/,//优先执行enforce:'pre',loader:'eslint-loader',options:{fix:true,},},{//以下loader只会匹配一个//注意：不能有两个配置处理同一种类型文件oneOf:[{test:/\\.css$/,use:[...commonCssLoader],},{test:/\\.less$/,use:[...commonCssLoader,'less-loader'],},/*正常来讲，一个文件只能被一个loader处理。当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：先执行eslint在执行babel*/{test:/\\.js$/,exclude:/node_modules/,loader:'babel-loader',options:{presets:[['@babel/preset-env',{useBuiltIns:'usage',corejs:{version:3},targets:{chrome:'60',firefox:'50',},},],],},},{test:/\\.(jpg|png|gif)/,loader:'url-loader',options:{limit:8*1024,name:'[hash:10].[ext]',outputPath:'imgs',esModule:false,},},{test:/\\.html$/,loader:'html-loader',},{exclude:/\\.(js|css|less|html|jpg|png|gif)/,loader:'file-loader',options:{outputPath:'media',},},],},],},plugins:[newMiniCssExtractPlugin({filename:'css/built.css',}),newOptimizeCssAssetsWebpackPlugin(),newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),],mode:'production',}```#####babel缓存```jsconst{resolve}=require('path')constMiniCssExtractPlugin=require('mini-css-extract-plugin')constOptimizeCssAssetsWebpackPlugin=require('optimize-css-assets-webpack-plugin')constHtmlWebpackPlugin=require('html-webpack-plugin')/*缓存：babel缓存cacheDirectory:true-->让第二次打包构建速度更快文件资源缓存hash:每次wepack构建时会生成一个唯一的hash值。问题:因为js和css同时使用一个hash值。如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样问题:js和css的hash值还是一样的因为css是在js中被引入的，所以同属于一个chunkcontenthash:根据文件的内容生成hash值。不同文件hash值一定不一样-->让代码上线运行缓存更好使用*///定义nodejs环境变量：决定使用browserslist的哪个环境process.env.NODE_ENV='production'//复用loaderconstcommonCssLoader=[MiniCssExtractPlugin.loader,'css-loader',{//还需要在package.json中定义browserslistloader:'postcss-loader',options:{ident:'postcss',plugins:()=>[require('postcss-preset-env')()],},},]module.exports={entry:'./src/js/index.js',output:{filename:'js/built.[contenthash:10].js',path:resolve(__dirname,'build'),},module:{rules:[{//在package.json中eslintConfig-->airbnbtest:/\\.js$/,exclude:/node_modules/,//优先执行enforce:'pre',loader:'eslint-loader',options:{fix:true,},},{//以下loader只会匹配一个//注意：不能有两个配置处理同一种类型文件oneOf:[{test:/\\.css$/,use:[...commonCssLoader],},{test:/\\.less$/,use:[...commonCssLoader,'less-loader'],},/*正常来讲，一个文件只能被一个loader处理。当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：先执行eslint在执行babel*/{test:/\\.js$/,exclude:/node_modules/,loader:'babel-loader',options:{presets:[['@babel/preset-env',{useBuiltIns:'usage',corejs:{version:3},targets:{chrome:'60',firefox:'50',},},],],//开启babel缓存//第二次构建时，会读取之前的缓存cacheDirectory:true,},},{test:/\\.(jpg|png|gif)/,loader:'url-loader',options:{limit:8*1024,name:'[hash:10].[ext]',outputPath:'imgs',esModule:false,},},{test:/\\.html$/,loader:'html-loader',},{exclude:/\\.(js|css|less|html|jpg|png|gif)/,loader:'file-loader',options:{outputPath:'media',},},],},],},plugins:[newMiniCssExtractPlugin({filename:'css/built.[contenthash:10].css',}),newOptimizeCssAssetsWebpackPlugin(),newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),],mode:'production',devtool:'source-map',}```####多进程打包```jsconst{resolve}=require('path')constMiniCssExtractPlugin=require('mini-css-extract-plugin')constOptimizeCssAssetsWebpackPlugin=require('optimize-css-assets-webpack-plugin')constHtmlWebpackPlugin=require('html-webpack-plugin')constWorkboxWebpackPlugin=require('workbox-webpack-plugin')/*PWA:渐进式网络开发应用程序(离线可访问)workbox-->workbox-webpack-plugin*///定义nodejs环境变量：决定使用browserslist的哪个环境process.env.NODE_ENV='production'//复用loaderconstcommonCssLoader=[MiniCssExtractPlugin.loader,'css-loader',{//还需要在package.json中定义browserslistloader:'postcss-loader',options:{ident:'postcss',plugins:()=>[require('postcss-preset-env')()],},},]module.exports={entry:'./src/js/index.js',output:{filename:'js/built.[contenthash:10].js',path:resolve(__dirname,'build'),},module:{rules:[{//在package.json中eslintConfig-->airbnbtest:/\\.js$/,exclude:/node_modules/,//优先执行enforce:'pre',loader:'eslint-loader',options:{fix:true,},},{//以下loader只会匹配一个//注意：不能有两个配置处理同一种类型文件oneOf:[{test:/\\.css$/,use:[...commonCssLoader],},{test:/\\.less$/,use:[...commonCssLoader,'less-loader'],},/*正常来讲，一个文件只能被一个loader处理。当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：先执行eslint在执行babel*/{test:/\\.js$/,exclude:/node_modules/,use:[/*开启多进程打包。进程启动大概为600ms，进程通信也有开销。只有工作消耗时间比较长，才需要多进程打包*/{loader:'thread-loader',options:{workers:2,//进程2个},},{loader:'babel-loader',options:{presets:[['@babel/preset-env',{useBuiltIns:'usage',corejs:{version:3},targets:{chrome:'60',firefox:'50',},},],],//开启babel缓存//第二次构建时，会读取之前的缓存cacheDirectory:true,},},],},{test:/\\.(jpg|png|gif)/,loader:'url-loader',options:{limit:8*1024,name:'[hash:10].[ext]',outputPath:'imgs',esModule:false,},},{test:/\\.html$/,loader:'html-loader',},{exclude:/\\.(js|css|less|html|jpg|png|gif)/,loader:'file-loader',options:{outputPath:'media',},},],},],},plugins:[newMiniCssExtractPlugin({filename:'css/built.[contenthash:10].css',}),newOptimizeCssAssetsWebpackPlugin(),newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),newWorkboxWebpackPlugin.GenerateSW({/*1.帮助serviceworker快速启动2.删除旧的serviceworker生成一个serviceworker配置文件~*/clientsClaim:true,skipWaiting:true,}),],mode:'production',devtool:'source-map',}```####externals```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',}),],mode:'production',externals:{//拒绝jQuery被打包进来jquery:'jQuery',},}```####dllwebpack.config.js```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/built.js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',}),],mode:'production',externals:{//拒绝jQuery被打包进来jquery:'jQuery',},}```webpack.dll.js```js/*使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包当你运行webpack时，默认查找webpack.config.js配置文件需求：需要运行webpack.dll.js文件-->webpack--configwebpack.dll.js*/const{resolve}=require('path')constwebpack=require('webpack')module.exports={entry:{//最终打包生成的[name]-->jquery//['jquery']-->要打包的库是jqueryjquery:['jquery'],},output:{filename:'[name].js',path:resolve(__dirname,'dll'),library:'[name]_[hash]',//打包的库里面向外暴露出去的内容叫什么名字},plugins:[//打包生成一个manifest.json-->提供和jquery映射newwebpack.DllPlugin({name:'[name]_[hash]',//映射库的暴露的内容名称path:resolve(__dirname,'dll/manifest.json'),//输出文件路径}),],mode:'production',}```####优化代码运行的性能####缓存(hash-chunkhash-contenthash)####treeshaking```jsconst{resolve}=require('path')constMiniCssExtractPlugin=require('mini-css-extract-plugin')constOptimizeCssAssetsWebpackPlugin=require('optimize-css-assets-webpack-plugin')constHtmlWebpackPlugin=require('html-webpack-plugin')/*treeshaking：去除无用代码前提：1.必须使用ES6模块化2.开启production环境作用:减少代码体积在package.json中配置\"sideEffects\":false所有代码都没有副作用（都可以进行treeshaking）问题：可能会把css/@babel/polyfill（副作用）文件干掉\"sideEffects\":[\"*.css\",\"*.less\"]*///定义nodejs环境变量：决定使用browserslist的哪个环境process.env.NODE_ENV='production'//复用loaderconstcommonCssLoader=[MiniCssExtractPlugin.loader,'css-loader',{//还需要在package.json中定义browserslistloader:'postcss-loader',options:{ident:'postcss',plugins:()=>[require('postcss-preset-env')()],},},]module.exports={entry:'./src/js/index.js',output:{filename:'js/built.[contenthash:10].js',path:resolve(__dirname,'build'),},module:{rules:[{//在package.json中eslintConfig-->airbnbtest:/\\.js$/,exclude:/node_modules/,//优先执行enforce:'pre',loader:'eslint-loader',options:{fix:true,},},{//以下loader只会匹配一个//注意：不能有两个配置处理同一种类型文件oneOf:[{test:/\\.css$/,use:[...commonCssLoader],},{test:/\\.less$/,use:[...commonCssLoader,'less-loader'],},/*正常来讲，一个文件只能被一个loader处理。当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：先执行eslint在执行babel*/{test:/\\.js$/,exclude:/node_modules/,loader:'babel-loader',options:{presets:[['@babel/preset-env',{useBuiltIns:'usage',corejs:{version:3},targets:{chrome:'60',firefox:'50',},},],],//开启babel缓存//第二次构建时，会读取之前的缓存cacheDirectory:true,},},{test:/\\.(jpg|png|gif)/,loader:'url-loader',options:{limit:8*1024,name:'[hash:10].[ext]',outputPath:'imgs',esModule:false,},},{test:/\\.html$/,loader:'html-loader',},{exclude:/\\.(js|css|less|html|jpg|png|gif)/,loader:'file-loader',options:{outputPath:'media',},},],},],},plugins:[newMiniCssExtractPlugin({filename:'css/built.[contenthash:10].css',}),newOptimizeCssAssetsWebpackPlugin(),newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),],mode:'production',devtool:'source-map',}```####codesplitdemo1```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={//单入口//entry:'./src/js/index.js',entry:{//多入口：有一个入口，最终输出就有一个bundleindex:'./src/js/index.js',test:'./src/js/test.js',},output:{//[name]：取文件名filename:'js/[name].[contenthash:10].js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),],mode:'production',}```demo2```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={//单入口//entry:'./src/js/index.js',entry:{index:'./src/js/index.js',test:'./src/js/test.js',},output:{//[name]：取文件名filename:'js/[name].[contenthash:10].js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),],/*1.可以将node_modules中代码单独打包一个chunk最终输出2.自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk*/optimization:{splitChunks:{chunks:'all',},},mode:'production',}```demo3```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={//单入口entry:'./src/js/index.js',output:{//[name]：取文件名filename:'js/[name].[contenthash:10].js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),],/*1.可以将node_modules中代码单独打包一个chunk最终输出2.自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk*/optimization:{splitChunks:{chunks:'all',},},mode:'production',}```####懒加载/预加载```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={//单入口entry:'./src/js/index.js',output:{filename:'js/[name].[contenthash:10].js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),],optimization:{splitChunks:{chunks:'all',},},mode:'production',}```####pwa```jsconst{resolve}=require('path')constMiniCssExtractPlugin=require('mini-css-extract-plugin')constOptimizeCssAssetsWebpackPlugin=require('optimize-css-assets-webpack-plugin')constHtmlWebpackPlugin=require('html-webpack-plugin')constWorkboxWebpackPlugin=require('workbox-webpack-plugin')/*PWA:渐进式网络开发应用程序(离线可访问)workbox-->workbox-webpack-plugin*///定义nodejs环境变量：决定使用browserslist的哪个环境process.env.NODE_ENV='production'//复用loaderconstcommonCssLoader=[MiniCssExtractPlugin.loader,'css-loader',{//还需要在package.json中定义browserslistloader:'postcss-loader',options:{ident:'postcss',plugins:()=>[require('postcss-preset-env')()],},},]module.exports={entry:'./src/js/index.js',output:{filename:'js/built.[contenthash:10].js',path:resolve(__dirname,'build'),},module:{rules:[{//在package.json中eslintConfig-->airbnbtest:/\\.js$/,exclude:/node_modules/,//优先执行enforce:'pre',loader:'eslint-loader',options:{fix:true,},},{//以下loader只会匹配一个//注意：不能有两个配置处理同一种类型文件oneOf:[{test:/\\.css$/,use:[...commonCssLoader],},{test:/\\.less$/,use:[...commonCssLoader,'less-loader'],},/*正常来讲，一个文件只能被一个loader处理。当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：先执行eslint在执行babel*/{test:/\\.js$/,exclude:/node_modules/,loader:'babel-loader',options:{presets:[['@babel/preset-env',{useBuiltIns:'usage',corejs:{version:3},targets:{chrome:'60',firefox:'50',},},],],//开启babel缓存//第二次构建时，会读取之前的缓存cacheDirectory:true,},},{test:/\\.(jpg|png|gif)/,loader:'url-loader',options:{limit:8*1024,name:'[hash:10].[ext]',outputPath:'imgs',esModule:false,},},{test:/\\.html$/,loader:'html-loader',},{exclude:/\\.(js|css|less|html|jpg|png|gif)/,loader:'file-loader',options:{outputPath:'media',},},],},],},plugins:[newMiniCssExtractPlugin({filename:'css/built.[contenthash:10].css',}),newOptimizeCssAssetsWebpackPlugin(),newHtmlWebpackPlugin({template:'./src/index.html',minify:{collapseWhitespace:true,removeComments:true,},}),newWorkboxWebpackPlugin.GenerateSW({/*1.帮助serviceworker快速启动2.删除旧的serviceworker生成一个serviceworker配置文件~*/clientsClaim:true,skipWaiting:true,}),],mode:'production',devtool:'source-map',}```##webpack配置详解###entry```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')/*entry:入口起点1.string-->'./src/index.js'单入口打包形成一个chunk。输出一个bundle文件。此时chunk的名称默认是main2.array-->['./src/index.js','./src/add.js']多入口所有入口文件最终只会形成一个chunk,输出出去只有一个bundle文件。-->只有在HMR功能中让html热更新生效~3.object多入口有几个入口文件就形成几个chunk，输出几个bundle文件此时chunk的名称是key-->特殊用法{//所有入口文件最终只会形成一个chunk,输出出去只有一个bundle文件。index:['./src/index.js','./src/count.js'],//形成一个chunk，输出一个bundle文件。add:'./src/add.js'}*/module.exports={entry:{index:['./src/index.js','./src/count.js'],add:'./src/add.js',},output:{filename:'[name].js',path:resolve(__dirname,'build'),},plugins:[newHtmlWebpackPlugin()],mode:'development',}```###output```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/index.js',output:{//文件名称（指定名称+目录）filename:'js/[name].js',//输出文件目录（将来所有资源输出的公共目录）path:resolve(__dirname,'build'),//所有资源引入公共路径前缀-->'imgs/a.jpg'-->'/imgs/a.jpg'publicPath:'/',chunkFilename:'js/[name]_chunk.js',//非入口chunk的名称//library:'[name]',//整个库向外暴露的变量名//libraryTarget:'window'//变量名添加到哪个上browser//libraryTarget:'global'//变量名添加到哪个上node//libraryTarget:'commonjs'},plugins:[newHtmlWebpackPlugin()],mode:'development',}```###module```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/index.js',output:{filename:'js/[name].js',path:resolve(__dirname,'build'),},module:{rules:[//loader的配置{test:/\\.css$/,//多个loader用useuse:['style-loader','css-loader'],},{test:/\\.js$/,//排除node_modules下的js文件exclude:/node_modules/,//只检查src下的js文件include:resolve(__dirname,'src'),//优先执行enforce:'pre',//延后执行//enforce:'post',//单个loader用loaderloader:'eslint-loader',options:{},},{//以下配置只会生效一个oneOf:[],},],},plugins:[newHtmlWebpackPlugin()],mode:'development',}```###resolve```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/[name].js',path:resolve(__dirname,'build'),},module:{rules:[{test:/\\.css$/,use:['style-loader','css-loader'],},],},plugins:[newHtmlWebpackPlugin()],mode:'development',//解析模块的规则resolve:{//配置解析模块路径别名:优点简写路径缺点路径没有提示alias:{$css:resolve(__dirname,'src/css'),},//配置省略文件路径的后缀名extensions:['.js','.json','.jsx','.css'],//告诉webpack解析模块是去找哪个目录modules:[resolve(__dirname,'../../node_modules'),'node_modules'],},}```###devserver```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/[name].js',path:resolve(__dirname,'build'),},module:{rules:[{test:/\\.css$/,use:['style-loader','css-loader'],},],},plugins:[newHtmlWebpackPlugin()],mode:'development',resolve:{alias:{$css:resolve(__dirname,'src/css'),},extensions:['.js','.json','.jsx','.css'],modules:[resolve(__dirname,'../../node_modules'),'node_modules'],},devServer:{//运行代码的目录contentBase:resolve(__dirname,'build'),//监视contentBase目录下的所有文件，一旦文件变化就会reloadwatchContentBase:true,watchOptions:{//忽略文件ignored:/node_modules/,},//启动gzip压缩compress:true,//端口号port:5000,//域名host:'localhost',//自动打开浏览器open:true,//开启HMR功能hot:true,//不要显示启动服务器日志信息clientLogLevel:'none',//除了一些基本启动信息以外，其他内容都不要显示quiet:true,//如果出错了，不要全屏提示~overlay:false,//服务器代理-->解决开发环境跨域问题proxy:{//一旦devServer(5000)服务器接受到/api/xxx的请求，就会把请求转发到另外一个服务器(3000)'/api':{target:'http://localhost:3000',//发送请求时，请求路径重写：将/api/xxx-->/xxx（去掉/api）pathRewrite:{'^/api':'',},},},},}```###optimization```jsconst{resolve}=require('path')constHtmlWebpackPlugin=require('html-webpack-plugin')constTerserWebpackPlugin=require('terser-webpack-plugin')module.exports={entry:'./src/js/index.js',output:{filename:'js/[name].[contenthash:10].js',path:resolve(__dirname,'build'),chunkFilename:'js/[name].[contenthash:10]_chunk.js',},module:{rules:[{test:/\\.css$/,use:['style-loader','css-loader'],},],},plugins:[newHtmlWebpackPlugin()],mode:'production',resolve:{alias:{$css:resolve(__dirname,'src/css'),},extensions:['.js','.json','.jsx','.css'],modules:[resolve(__dirname,'../../node_modules'),'node_modules'],},optimization:{splitChunks:{chunks:'all',//默认值，可以不写~/*minSize:30*1024,//分割的chunk最小为30kbmaxSiza:0,//最大没有限制minChunks:1,//要提取的chunk最少被引用1次maxAsyncRequests:5,//按需加载时并行加载的文件的最大数量maxInitialRequests:3,//入口js文件最大并行请求数量automaticNameDelimiter:'~',//名称连接符name:true,//可以使用命名规则cacheGroups:{//分割chunk的组//node_modules文件会被打包到vendors组的chunk中。-->vendors~xxx.js//满足上面的公共规则，如：大小超过30kb，至少被引用一次。vendors:{test:/[\\\\/]node_modules[\\\\/]/,//优先级priority:-10},default:{//要提取的chunk最少被引用2次minChunks:2,//优先级priority:-20,//如果当前要打包的模块，和之前已经被提取的模块是同一个，就会复用，而不是重新打包模块reuseExistingChunk:true}}*/},//将当前模块的记录其他模块的hash单独打包为一个文件runtime//解决：修改a文件导致b文件的contenthash变化runtimeChunk:{name:(entrypoint)=>`runtime-${entrypoint.name}`,},minimizer:[//配置生产环境的压缩方案：js和cssnewTerserWebpackPlugin({//开启缓存cache:true,//开启多进程打包parallel:true,//启动source-mapsourceMap:true,}),],},}```","Front-End\\项目搭建\\webpack\\webpack重构.md":"#webpack区分生产环境和开发环境>webpack的配置一般写在webpack.config.js文件夹中,但是生产环境的配置和开发环境不一样,需要将两个环境分开##cross-env在node里，我们有一个process对象，它里面包括了node的一些信息，env和它的一个属性，但是并没有process.env.NODE_ENV，这是我们自己添加的一个用来区分环境的变量，我们通过这个来区分生产开发环境。但是不同电脑上设置的方式是不一样的，所以cross-env就来了，它可以跨平台设置环境和使用环境变量。我们需要在控制台执行：```shellyarnaddcross-env-D```然后我们在package.json里配置：```shell\"build\":\"cross-envNODE_ENV=productionwebpack\",\"dev\":\"cross-envNODE_ENV=developmentwebpack-dev-server\"```我们在webpack.config.js里添加：```shellconstNODE_ENV=process.env.NODE_ENV;console.log(\"--------\"+NODE_ENV+\"-----------\");```然后去控制台执行，当执行yarnrunbuild时：![在这里插入图片描述](.assets/16903cbe8ec23b4e)控制台打印出了我们设置的production。vim执行yarnrundev的时候：![在这里插入图片描述](.assets/16903cbe8ed36e78)打印出了devlopment，说明我们已经设置完成了。##webpack-merge设置了环境之后我们需要将配置分开，我们先在根目录下新建==webpack.config.dev.js==（开发环境），==webpack.config.prod.js==（生产环境），将原本的webpack.config.js修改成==webpack.config.common.js==（公共）。分离开的环境需要和common里的代码合并使用，所以我们就需要用到webapck-merge插件，我们在控制台执行：```shellyarnaddwebpack-merge-D```下载好后先去package.json里修改配置：```shell//--config是可以设置我们执行哪个webpack文件，默认是执行webpack.config.js,但是我们现在修改文件名了，所以我们要设置一下\"build\":\"cross-envNODE_ENV=productionwebpack--configwebpack.config.prod.js\",\"dev\":\"cross-envNODE_ENV=developmentwebpack-dev-server--configwebpack.config.dev.js\"```我们将一些开发环境用到的东西移到==webpack.config.dev.js==里：```jsconstpath=require('path')constwebpack=require('webpack')constmerge=require('webpack-merge')//这里引入mergeconstcommon=require('./webpack.config.common.js')//这里引入公共代码module.exports=merge(common,{//注意这里的写法mode:'development',devtool:'cheap-module-eval-source-map',module:{rules:[],},devServer:{contentBase:path.join(__dirname,'dist'),compress:true,//开启gzip压缩port:8080,open:true,hot:true,overlay:true,},plugins:[newwebpack.HotModuleReplacementPlugin()],})```生产环境的移到==webpack.config.prod.js==：```jsconstmerge=require('webpack-merge')constwebpack=require('webpack')constcommon=require('./webpack.config.common.js')constMiniCssExtractPlugin=require('mini-css-extract-plugin')const{BundleAnalyzerPlugin}=require('webpack-bundle-analyzer')constUglifyJsPlugin=require('uglifyjs-webpack-plugin')constOptimizeCSSAssetsPlugin=require('optimize-css-assets-webpack-plugin')constCleanWebpackPlugin=require('clean-webpack-plugin')module.exports=merge(common,{mode:'production',module:{rules:[],},plugins:[newMiniCssExtractPlugin({//提取cssfilename:'css/main.css',}),newCleanWebpackPlugin('./dist'),//删除dist目录下的文件newBundleAnalyzerPlugin({analyzerPort:8090}),],})```然后去==webpack.config.common.js==里将相关代码删除就行了。这里还有个注意点，在使用MiniCssExtractPlugin.loader的时候是不支持热更新的，所以我们需要根据环境来区分这个，我们在==webpack.config.common.js==里修改一下：```json//开发环境使用style-loader{loader:NODE_ENV===\"production\"?MiniCssExtractPlugin.loader:\"style-loader\"}```","Front-End\\项目搭建\\webpack\\增量打包多页应用.md":"#webpack增量打包多页应用其实webpack关于缓存方面的功能，提供了很多功能强大的插件，例如：-CommonsChunkPlugin可以用来在打包的时候提取公共js代码-ExtractTextPlugin可以用来从js中提出css，将其输出到一个独立的文件利用这两个插件，我们能够将我们打包的精度加以划分，将公共引用的部分打包为一个单独的文件如果公共引用的部分变为了一个单独的文件，再添加上hash进行缓存，当再次修改的时候只要更新hash，这样我们不就能够确定，究竟改动了哪个文件了吗**既然如此，我们一步一步进行探索：**##1，首先使用CommonsChunkPlugin，提取公共js现在我们创建测试入口文件：src/one.js:```jsimportjqueryfrom'jquery'console.log('one')```src/two.js:```jsimportjqueryfrom'jquery'console.log('two')```webpack.config.js```jsvarpath=require('path')module.exports={entry:{one:'./src/one.js',two:'./src/two.js',},output:{path:path.resolve(__dirname,'dist'),filename:'[name].js',},}```执行webpack![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166363962adf3~tplv-t2oaga2asx-watermark.awebp)输出了2个文件，大小都是271kb，这是因为one.js和two.js都引用了jquery，jquery打包了2次，分别打包到了两个文件中这样显然不是很友好，像jquery这种文件，显然平时不会改动，还是缓存起来比较好，修改webpack.config.js```jsvarwebpack=require('webpack')varpath=require('path')module.exports={entry:{one:'./src/one.js',two:'./src/two.js',},output:{path:path.resolve(__dirname,'dist'),filename:'[name].js',},plugins:[newwebpack.optimize.CommonsChunkPlugin({name:'common',}),],}```现在我们添加了CommonsChunkPlugin插件，它的作用是提取公共js，再次执行webpack![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663639851705~tplv-t2oaga2asx-watermark.awebp)可以看到one.js和two.js的大小已经不到1k了，而common则274k，可以看到jquery已经被打包到了common.js当中##2，为文件添加hash```varwebpack=require(\"webpack\");varpath=require('path');module.exports={entry:{one:\"./src/one.js\",two:\"./src/two.js\"},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[hash:6].js\"},plugins:[newwebpack.optimize.CommonsChunkPlugin({name:\"common\",}),]};```上面修改了output的输出内容`[name].[hash].js`现在执行webpack：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166363985ac91~tplv-t2oaga2asx-watermark.awebp)可以看到打包的三个文件都有了hash，但需要主意，此时每个文件的hash都是一样的再次执行一遍webpack：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663639be42d0~tplv-t2oaga2asx-watermark.awebp)可以看到，两次构建输出的结果一致，这很好，因为没有修改文件，自然不希望hash发生改变那么接下来，修改一下文件：one.js```importjqueryfrom'jquery';console.log('修改one');```![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663639e347e8~tplv-t2oaga2asx-watermark.awebp)悲剧了，所有文件全部修改了hash，查看输出的结果：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166363f936501~tplv-t2oaga2asx-watermark.awebp)可以发现只修改一个文件，却修改了全部文件的hash，这个问题很严重，显然不是我们想要的##3，使用chunkhash替代hashwebpack中关于缓存，提供了好几种添加hash的方法，其中就有chunkhashchunkhash简单来说，就是根据模块内容来添加hash，既然这样的话，只要文件没有改变，就不会生成新的hash```varwebpack=require(\"webpack\");varpath=require('path');module.exports={entry:{one:\"./src/one.js\",two:\"./src/two.js\"},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},plugins:[newwebpack.optimize.CommonsChunkPlugin({name:\"common\",}),]};```如上图，修改`filename:[name].[chunkhash:8]/js`执行webpack![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663691205305~tplv-t2oaga2asx-watermark.awebp)可以看到这一次生成的hash是4897....但是输出的每个文件的hash却不是4897....很好，接下来再执行一次webpack：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636947674a1~tplv-t2oaga2asx-watermark.awebp)可以看到两次输出之间hash并没有发生变化现在，修改one.js,再执行webapck```importjqueryfrom'jquery';console.log('使用chunkhash后修改one');```![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663694c7dc37~tplv-t2oaga2asx-watermark.awebp)可以看到two.js的hash没有改变one.js的hash改变了，但common.js的hash竟然也改了...##4，提取manifest前面用CommonsChunkPlugin提取代码后，公共的代码已经被抽离，但是他们之间肯定存在一个映射关系,例如![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663699342c1a~tplv-t2oaga2asx-watermark.awebp)之所以commonjs的hash会变，是因为修改one.js生成了新的hash，而jquery又与one.js存在映射关系，`映射关系会更新`，也就是说common.js它要从新的one.js中提取了jquery而`manifest`就可以简单理解为模块映射关系的集合，而这个manifest将随着这些被分离出来的代码共同打包！！！所以现在分离manifest```varwebpack=require(\"webpack\");varpath=require('path');module.exports={entry:{one:\"./src/one.js\",two:\"./src/two.js\"},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},plugins:[newwebpack.optimize.CommonsChunkPlugin({name:\"common\",}),newwebpack.optimize.CommonsChunkPlugin({name:'manifest'//用于提取manifest})]};```这里主要是利用CommonsChunkPlugin的一个功能，通过默认的名字，来提取公共代码，因为webpack打包的是有有一个默认模块就是manifest，所以我们可以通过这个来实现现在我们执行webpack：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663697055890~tplv-t2oaga2asx-watermark.awebp)可以看到，多输出了一个manifest.js接下来，再修改one.js```importjqueryfrom'jquery';console.log('分离manifest后修改one');```![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636b58469af~tplv-t2oaga2asx-watermark.awebp)可以看到，现在只有one.js和manifest.js的hash发生了改变，common.js被成功缓存了使用代码对比工具，比较两次manifest之间的区别，可以看到确实是映射的chunkid发生了改变![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636ba6f6614~tplv-t2oaga2asx-watermark.awebp)##5，使用webpack-md5-hash插件前面我们输出了一个manifest.js，但这样还需要单独处理这个manifest.js，所以可以使用webpack的另一个插件webpack-md5-hash```varwebpack=require(\"webpack\");varWebpackMd5Hash=require('webpack-md5-hash');varpath=require('path');module.exports={entry:{one:\"./src/one.js\",two:\"./src/two.js\"},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},plugins:[newWebpackMd5Hash(),newwebpack.optimize.CommonsChunkPlugin({name:\"common\",}),]};```执行一次打包：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636bab5627e~tplv-t2oaga2asx-watermark.awebp)没有manifest输出，修改one.js```importjqueryfrom'jquery';console.log('使用WebpackMd5Hash修改one');```再次打包：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636bb68ae2e~tplv-t2oaga2asx-watermark.awebp)这一次仅有one.js的hash发生了改变虽然webpack-md5-hash解决了我们的问题，但这也让打包的模块关系变成了黑盒，存在一定的未知风险，还需要仔细实践评估是否有问题##6，打包修改频率超级低的库前面已经抽离出来了公共代码，但是还存在问题，假如这时候又需要引入lodash，那common的hash是否会改变？修改one.js```importjqueryfrom'jquery';importlodashfrom'lodash';console.log('引入lodash修改one');```修改two.js```importjqueryfrom'jquery';importlodashfrom'lodash';console.log('引入lodash修改two');```![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636c2194058~tplv-t2oaga2asx-watermark.awebp)这一次，所有文件的hash都发生了改变，不仅如此，而且更显著的是common的体积增大了这就意味者lodash也被打进了common当中，但这本身是一个错误的行为，lodash和jquery，平时根本不会对其进行修改，既然如此，那还需要优化，把他们单独打包出去现在修改webapack.config.js```varwebpack=require(\"webpack\");varWebpackMd5Hash=require('webpack-md5-hash');varpath=require('path');module.exports={entry:{two:\"./src/two.js\",one:\"./src/one.js\",common:['jquery','lodash']},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},plugins:[newWebpackMd5Hash(),newwebpack.optimize.CommonsChunkPlugin({name:\"common\",}),]};```这一次在入口处添加了一个common，common单独指向了jquery和lodash，这一次我们执行打包![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636e2efa2c9~tplv-t2oaga2asx-watermark.awebp)此时，输出的内容没有明显变化，同样是3个文件,大小也完全一致，hash也没有问题可以看到，common的大小是817k如果这时，再应用了其他的包呢？例如引入react修改one.js```importjqueryfrom'jquery';importlodashfrom'lodash';importreactfrom'react';console.log('引入react修改one');```修改two.js```importjqueryfrom'jquery';importlodashfrom'lodash';importreactfrom'react';console.log('引入react修改one');```执行webpack![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636c3a62be8~tplv-t2oaga2asx-watermark.awebp)问题来了，common的大小增加了，很显然react被打包进去了，但如果我们此时，只想永久缓存jquery和lodash呢，这该怎么办？修改webpack.config.js```varwebpack=require(\"webpack\");varWebpackMd5Hash=require('webpack-md5-hash');varpath=require('path');module.exports={entry:{two:\"./src/two.js\",one:\"./src/one.js\",common:['jquery','lodash']},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},plugins:[newWebpackMd5Hash(),newwebpack.optimize.CommonsChunkPlugin({name:'common',minChunks:Infinity})]};```这一次，添加了一句话`minChunks:Infinity`minChunks属性的可以设置为2，意思是引用次数为2的模块就抽离出来，而`Infinity`则表示无限，无限就意味着不会有多余的被打包进来现在执行webpack打包![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636e2fe6346~tplv-t2oaga2asx-watermark.awebp)可以看到现在common又恢复了816k，当然react也没有抽出来，还在两个文件当中，接下来继续抽离react```varwebpack=require(\"webpack\");varWebpackMd5Hash=require('webpack-md5-hash');varpath=require('path');module.exports={entry:{two:\"./src/two.js\",one:\"./src/one.js\",common:['jquery','lodash'],react:['react','react-redux']},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},plugins:[newwebpack.optimize.CommonsChunkPlugin({name:['react','common'],//用于提取manifestminChunks:Infinity}),newWebpackMd5Hash(),]};```![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636e5784bd6~tplv-t2oaga2asx-watermark.awebp)通过上面的构建，我们已经将不会改动的类库，单独打包并维持住了hash。##7，引入HashedModuleIdsPlugin固定模块id前面看似完美，但如果我们现在改变一下入口的顺序```entry:{react:['react','react-redux'],two:\"./src/two.js\",one:\"./src/one.js\",common:['jquery','lodash'],}```![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636ebc1fed5~tplv-t2oaga2asx-watermark.awebp)可以看到common和react公共库的hash又变了，这是因为，模块id是根据webpack的解析顺序增量的，如果变换解析顺序，那模块id也会随之改变。所以就需要HashedModuleIdsPlugin了，它是根据模块相对路径生成模块标识，如果模块没有改变，那模块标识也不会改变```varwebpack=require(\"webpack\");varWebpackMd5Hash=require('webpack-md5-hash');varpath=require('path');module.exports={entry:{common:['jquery','lodash'],react:['react','react-redux'],two:\"./src/two.js\",one:\"./src/one.js\",},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},plugins:[newwebpack.optimize.CommonsChunkPlugin({name:['react','common'],//用于提取manifestminChunks:Infinity}),newwebpack.HashedModuleIdsPlugin(),newWebpackMd5Hash(),]};```![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636eded9e7d~tplv-t2oaga2asx-watermark.awebp)现在打包后，模块的标识不再是id了，而是一个四位的编码了，这样就可以固定住ip地址了。##8，使用extract-text-webpack-plugin提取css文件在src下创建one.css:```body{color:blue;}```two.css```h1{font-size:24px;}```修改one.js和two.js引入css```importjqueryfrom'jquery';importlodashfrom'lodash';importreactfrom'react';import'./one.css'console.log('引入css修改one');```修改webpack.config.js```varwebpack=require(\"webpack\");varWebpackMd5Hash=require('webpack-md5-hash');varpath=require('path');varExtractTextPlugin=require(\"extract-text-webpack-plugin\");module.exports={entry:{common:['jquery','lodash'],react:['react','react-redux'],two:\"./src/two.js\",one:\"./src/one.js\",},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},module:{rules:[{test:/\\.css$/,use:ExtractTextPlugin.extract({fallback:\"style-loader\",use:\"css-loader\"})}]},plugins:[newwebpack.optimize.CommonsChunkPlugin({name:['react','common'],//用于提取manifestminChunks:Infinity}),newExtractTextPlugin(\"[name].[chunkhash:8].css\"),newwebpack.HashedModuleIdsPlugin(),newWebpackMd5Hash()]};```执行webpack：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166370b90f78c~tplv-t2oaga2asx-watermark.awebp)可以看到，成功输出了js和css，但是有点疑问的是，one.css和one.js的hash是一样的，这样的话，如果我们改变one.css呢？修改one.css,再次打包：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166370b8bb338~tplv-t2oaga2asx-watermark.awebp)发现css的hash没有任何变化。接着再修改one.js,再次打包：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663711ccaa40~tplv-t2oaga2asx-watermark.awebp)这一次one.js和one.css的hash同时改变了。##9，使用contenthash提取固定css的hash-WhenusingtheExtractTextWebpackPlugin,use[contenthash]toobtainahashoftheextractedfile(neither[hash]nor[chunkhash]work).webpackoutput文档种有写，当提取css后，用contenthash添加hash```varwebpack=require(\"webpack\");varWebpackMd5Hash=require('webpack-md5-hash');varpath=require('path');varExtractTextPlugin=require(\"extract-text-webpack-plugin\");module.exports={entry:{common:['jquery','lodash'],react:['react','react-redux'],two:\"./src/two.js\",one:\"./src/one.js\",},output:{path:path.resolve(__dirname,'dist'),filename:\"[name].[chunkhash:8].js\"},module:{rules:[{test:/\\.css$/,use:ExtractTextPlugin.extract({fallback:\"style-loader\",use:\"css-loader\"})}]},plugins:[newwebpack.optimize.CommonsChunkPlugin({name:['react','common'],//用于提取manifestminChunks:Infinity}),newExtractTextPlugin(\"[name].[contenthash:8].css\"),newwebpack.HashedModuleIdsPlugin(),newWebpackMd5Hash()]};```这一次，只是修改了输出的hash，conenthash代表的是文本文件内容的hash值，也就是只有style文件的hash值。执行webpack：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166372478e5cd~tplv-t2oaga2asx-watermark.awebp)one.js和one.css的hash变的不一样了接下来，修改one.css```body{color:white;}```再次执行webpack：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663729fbfe0f~tplv-t2oaga2asx-watermark.awebp)至此，只有one.css发生了变化，准备工作基本就到这里了#四，优化多页打包时间，稳定hash##1,约束入口因为是多页应用，是通过扫入口文件来进行的打包，规则为js文件为入口文件，jsx为引用的资源不被识别为入口通过BundleAnalyzerPlugin插件分析，发现有部分组件被打包为了入口，梳理一遍后，重新打包，打包时间减少了2/3，当然这是在填以前的坑![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663733a477b4~tplv-t2oaga2asx-watermark.awebp)生产打包时间是`74578ms`此时压缩和不压缩的打包时间也是3倍的关系：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637345283b8~tplv-t2oaga2asx-watermark.awebp)开发打包时间是`24780ms`好的，围绕这两个时间，我们开始优化##2,使用UglifyjsWebpackPlugin开启多线程打包首先要做的其实是稳定hash，但因为生产环境的打包速度太慢，所以我们先优化打包速度，webpack默认提供的打包是单线程的```constUglifyJSPlugin=require('uglifyjs-webpack-plugin')module.exports={plugins:[newUglifyJSPlugin({parallel:true})]}```这个插件是webpack3提供的，至于低版本webapck的话，需要谨慎处理，不过效果很明显![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663733b6ac46~tplv-t2oaga2asx-watermark.awebp)现在生产打包时间是`51690ms`，比之前提速了1/3##3,使用HappyPack多线程加速loader```varHappyPack=require('happypack');varos=require('os');varhappyThreadPool=HappyPack.ThreadPool({size:os.cpus().length});...module:{rules:[{test:/\\.js[x]?$/,exclude:/(node_modules|bower_components)/,loader:'happypack/loader?id=happybabel',include:path.join(__dirname,'static/assets/js')}}plugins:[newHappyPack({id:'happybabel',loaders:['babel-loader?cacheDirectory=true'],threadPool:happyThreadPool,cache:true,verbose:true}),```上面module的rules属性中loader原本事babel-loader，现在将它变成了一个任务，其中有一个id，id对应的就是plugins中的happyPack实例![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166373db390c7~tplv-t2oaga2asx-watermark.awebp)此时，我们开启了babel-loader的多线程模式现在生产打包时间是`43855ms`，比之前又提速了1/9，这只是babel-loader，我们还可以为其它的loader开启接着处理less,css,style等loader，这些结合可以一口气搞定```module:{rules:[{test:require.resolve('zepto'),loader:'exports-loader?window.Zepto!script-loader'},{test:/\\.js[x]?$/,exclude:/(node_modules|bower_components)/,loader:'happypack/loader?id=happybabel',include:path.join(__dirname,'static/assets/js')},{test:/\\.less$/,use:extractTextPlugin.extract({fallback:\"style-loader\",//use:[\"css-loader\"+(ENV?'?minimize':''),\"less-loader\",\"postcss-loader\"]use:[\"happypack/loader?id=postcss\"]})}]}plugins:[newHappyPack({id:'happybabel',loaders:['babel-loader?cacheDirectory=true'],threadPool:happyThreadPool,//cache:true,verbose:true}),newHappyPack({id:'postcss',loaders:[\"css-loader\"+(ENV?'?minimize':''),\"less-loader\",'postcss-loader'],threadPool:happyThreadPool,//cache:true,verbose:true}),```这样，我们即处理了babel，同时也搞定了css，less，postcss这些loader![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663756ba4bc1~tplv-t2oaga2asx-watermark.awebp)上图happy[任务名]，可以看到打包行为全都开启了多线程，效果显著现在生产打包时间是`35130ms`，此时已经比第一此非优化的时候，提升了一倍的速度##4,使用dll拆分代码经过前面的过程，想必已经意识到了纯静态得库和组件都需要与打包环节分离开，这就需要dll技术了dll技术，其实就是将修改频率低或基本不修改且引用次数多的内容，单独打包因为设计dll后，config文件的数量剧增，所以需要重新整理目录结构![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637542b3379~tplv-t2oaga2asx-watermark.awebp)例如上图，将每一个webpack拆分出去，把所有配置文件分离开,例webpack.dev.js：```varbase=require('./webpack.base.js');varconfig={entry:require('./dev/entry.js'),output:require('./dev/output.js'),plugins:require('./dev/plugins.js'),devtool:'eval-source-map'}//把配置文件暴露出去;module.exports=Object.assign(base,config);```ok，基础拆分webpack完成后，我们创建一个webpack.dll.libs.js用于打包类库```module.exports={libs:['react','react-dom','react-motion','react-redux','redux','axios','prop-types','classnames',]}```修改plugins插件：```varwebpack=require('webpack');vardirVars=require('../common/dir.js');varpath=require('path');varUglifyJsPlugin=require('uglifyjs-webpack-plugin');//多线程打包vargetDefaultPlugins=require('../common/plugins.js').getDefaultPlugins;varAssetsPlugin=require('assets-webpack-plugin');//输出映射表varplugins=[newwebpack.DllPlugin({path:dirVars.dllLibsManiFest,}),newUglifyJsPlugin({parallel:true,cache:true}),newAssetsPlugin({filename:'static/dll/libs-rev-manifest.json'}),]module.exports=plugins.concat(getDefaultPlugins())```现在执行webpack![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663758664541~tplv-t2oaga2asx-watermark.awebp)可以看到，只需要1s,就打包了所有的类库，接下来，修改webpack.prod.js在plugins中添加：```newwebpack.DllReferencePlugin({manifest:'static/dll/libs-rev-manifest.json'}),```此时当我们执行webpack.prod.js进行打包，当扫描到libs中的打包的内容时，就不会重复打包##4,开始继续约束hash前面已经彻底搞定了打包，但破坏性很大，所以需要系统的验证hash是否存在问题**case1:\bjs改变**修改一个业务代码的js，添加一句注释，再次打包![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637604c3f7c~tplv-t2oaga2asx-watermark.awebp)可以看到文件hash发生了改变，但很不幸，vendor也发生了改变![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166377da4882b~tplv-t2oaga2asx-watermark.awebp)**解决方案：添加webpack-md5-hash插件，使用之后，再次验证，发现vendorjs的hash不再发生变化****case2:\bless改变**![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166376469ca3c~tplv-t2oaga2asx-watermark.awebp)只有一个css的hash发生了变化，没问题**case3:修改一个入口下自己封装出去的公共方法**![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637823fba5f~tplv-t2oaga2asx-watermark.awebp)上面修改了一个入口内公共使用的tools插件，最终是入口的hash发生了改变，没问题**case4:修改公共方法组件js**主要是多个入口都会引用的组件![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663786a27fcb~tplv-t2oaga2asx-watermark.awebp)测试，只有单独打包出去的components的hash修改了**case5:修改公共方法组件less**![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637a2d0f998~tplv-t2oaga2asx-watermark.awebp)只有一个hash发生了改变**case6:添加一个公共组件**![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166378919dc87~tplv-t2oaga2asx-watermark.awebp)只有components的hash发生了改变未优化前打包时间180-200s优化：```1，约束入口，严格明确入口文件筛选条件后生产打包：74578ms开发打包：24780ms2，开启多线程压缩后生产打包：51690ms3，开启多线程编译生产打包：35130ms开发打包：15031ms4，拆包分解了打包过程，类库4s，组件4s，业务20s，总体30s左右```最终，流程变得可控，打包实现了定制化，hash得到了保持。","Front-End\\项目搭建\\代码类型检查\\eslint.md":"#ESLint>[rules](http://eslint.cn/docs/rules/)><https://juejin.cn/post/6955025103507849223>>>-root-限定配置文件的使用范围>-parser-指定eslint的解析器>-parserOptions-设置解析器选项>-extends-指定eslint规范>-plugins-引用第三方的插件>-env-指定代码运行的宿主环境>-rules-启用额外的规则或覆盖默认的规则>-globals-声明在代码中的自定义全局变量##取消格式检查>单行,行末添加`//eslint-disable-line`>单行指定忽略规则,行末添加`//eslint-disable-line[这里添加规则(不用括号)]`>单文件,首行添加`/*eslint-disable*/`>单文件指定忽略规则,首行添加`/*eslint-disable[这里添加规则(不用括号)]*/`","Front-End\\项目搭建\\代码类型检查\\prettierc.md":"#prettierc>[Options·Prettier](https://prettier.io/docs/en/options.html)>.prettierrc```json{\"printWidth\":100,//单行长度\"tabWidth\":2,//tab用两个空格替代\"useTabs\":false,//使用空格代替tab\"semi\":false,//不使用;\"singleQuote\":true,//使用单双引号\"bracketSpacing\":true,//jsx标签闭合位置,不开新一行\"jsxSingleQuote\":true,//jsx使用单引号\"htmlWhitespaceSensitivity\":\"ignore\",//忽略无效的空格\"endOfLine\":\"auto\",//保持现有换行\"trailingComma\":\"all\",//key和value到花括号之间有空格\"arrowParens\":\"avoid\"//箭头函数括号可以省略的,都省略}```","Front-End\\项目搭建\\代码类型检查\\tslint.md":"#TSLint>已经弃用,建议使用eslint##准备工作```shellnpmuninstall-gtypescriptnpminstall-gtypescripttslinttslint--inittslint--project```##配置```js{defaultSeverity:error,extends:[tslint:recommended],rules:{member-access:true,//设置成员对象的访问权限&#xff08;public,private,protect)member-ordering:[//设置修饰符顺序true,{order:[public-static-field,public-static-method,protected-static-field,protected-static-method,private-static-field,private-static-method,public-instance-field,protected-instance-field,private-instance-field,public-constructor,protected-constructor,private-constructor,public-instance-method,protected-instance-method,private-instance-method]}],//no-empty-interface:true,//不允许空接口no-parameter-reassignment:false,//不允许修改方法输入参数prefer-for-of:true,//如果for循环中没有使用索引&#xff0c;建议是使用for-of//功能特性no-namespace:false,only-arrow-functions:false,//禁止使用传统&#xff08;非箭头&#xff09;函数表达式no-shadowed-variable:true,//不允许子作用域与外层作用域声明同名变量no-string-literal:false,ban-types:false,//禁止内置原始类型await-promise:true,//不允许没有Promise的情况下使用awaitcurly:true,//if/for/do/while强制使用大括号forin:false,//使用forin语句时&#xff0c;强制进行hasOwnProperty检查no-arg:true,//不允许使用arguments.calleeno-bitwise:false,//不允许使用特殊运算符&amp;,&amp;&#61;,|,|&#61;,^,^&#61;,&lt;&lt;,&lt;&lt;&#61;,&gt;&gt;,&gt;&gt;&#61;,&gt;&gt;&gt;,&gt;&gt;&gt;&#61;,~no-conditional-assignment:true,//dowhile/for/if/while语句中将会对例如if(a&#61;b)进行检查no-console:true,//不允许使用console对象no-debugger:true,//不允许使用debuggerno-duplicate-super:true,//不允许super()两次使用在构造函数中no-empty:false,//函数体不允许空no-eval:true,//不允许使用evalno-for-in-array:true,//不允许对Array使用for-inno-invalid-template-strings:true,//只允许在模板字符串中使用${//no-invalid-this:true,//不允许在class之外使用this//no-null-keyword:true,//不允许使用null,使用undefined代替null&#xff0c;指代空指针对象no-sparse-arrays:true,//不允许array中有空元素no-string-throw:true,//不允许throw一个字符串no-switch-case-fall-through:true,//不允许case段落中在没有使用breack的情况下&#xff0c;在新启一段case逻辑no-unsafe-finally:true,//不允许在finally语句中使用return/continue/break/throwno-unused-expression:true,//不允许使用未使用的表达式no-use-before-declare:true,//在使用前必须声明no-var-keyword:true,//不允许使用varradix:false,//parseInt时&#xff0c;必须输入radix精度参数//restrict-plus-operands:true,//不允许自动类型转换&#xff0c;如果已设置不允许使用关键字var该设置无效triple-equals:false,//必须使用恒等号&#xff0c;进行等于比较use-isnan:true,//只允许使用isNaN方法检查数字是否有效//维护性功能indent:[true,spaces,4],//每行开始以4个空格符开始max-classes-per-file:[true,1],//每个文件中可定义类的个数max-file-line-count:[true,1000],//定义每个文件代码行数max-line-length:[true,300],//定义每行代码数no-default-export:true,//禁止使用exportdefault关键字&#xff0c;因为当export对象名称发生变化时&#xff0c;需要修改import中的对象名。https://github.com/palantir/tslint/issues/1182#issue-151780453no-duplicate-imports:true,//禁止在一个文件内&#xff0c;多次引用同一module//格式align:[true,parameters,arguments,statements,members,elements],//定义对齐风格array-type:[true,array],//建议使用T[]方式声明一个数组对象class-name:false,//类名以大驼峰格式命名comment-format:[true,check-space],//定义注释格式encoding:false,//定义编码格式默认utf-8import-spacing:true,//import关键字后加空格interface-name:[true,always-prefix],//interface必须以I开头jsdoc-format:false,//注释基于jsdoc风格new-parens:true,//调用构造函数时需要用括号object-literal-sort-keys:false,no-consecutive-blank-lines:[true,2],//不允许有空行//no-trailing-whitespace:[//不允许空格结尾//true,//ignore-comments,//ignore-jsdoc//],no-unnecessary-initializer:true,//不允许没有必要的初始化variable-name:[false,check-format,//定义变量命名规则allow-leading-underscore,allow-trailing-underscore,ban-keywords]},rulesDirectory:[],linterOptions:{exclude:[e2e/**/*]}}```","Front-End\\项目搭建\\提交前置\\commitlint.md":"#commitlint>约定式提交规范是一种基于提交信息的轻量级约定。><https://www.conventionalcommits.org/zh-hans/v1.0.0/>","Front-End\\项目搭建\\提交前置\\husky.md":"#husky##效果###正确提交`gitcommit-m\"refactor:描述\"`>`refactor`:提交类型,由[`commitlint.config.js`](#commitlint.config.js)配置###错误提交`gitcommit-m\"测试提交\"`![](./.assets/husky-2022-11-02-14-59-06.png)##安装```bashnpminstall-Dhuskynpminstall-Dcommitlintnpminstall-D@commitlint/config-conventional```##设置githooks>在`package.json`添加```jsonc{\"scripts\":{//add\"commitlint\":\"commitlint-e\",\"prepare\":\"huskyinstall\",},//add\"husky\":{\"hooks\":{\"commit-msg\":\"commitlint-e$HUSKY_GIT_PARAMS\",},},}``````shell#生成.huskynpmrunprepare```##配置相关文件`.husky/commit-msg````sh#!/usr/bin/envsh.\"$(dirname--\"$0\")/_/husky.sh\"npmruncommitlint--edit$1```<codeid=\"commitlint.config.js\">./commitlint.config.js</code>>[@commitlint/config-conventional](https://www.npmjs.com/package/@commitlint/config-conventional)```jsmodule.exports={extends:['@commitlint/config-conventional'],rules:{'type-enum':[2,'always',['bug',//此项特别针对bug号，用于向测试反馈bug列表的bug修改情况'feat',//新功能（feature）'fix',//修补bug'docs',//文档（documentation）'style',//格式（不影响代码运行的变动）'refactor',//重构（即不是新增功能，也不是修改bug的代码变动）'test',//增加测试'chore',//构建过程或辅助工具的变动'revert',//feat(pencil):add‘graphiteWidth’option(撤销之前的commit)'merge',//合并分支，例如：merge（前端页面）：feature-xxxx修改线程地址],],},}```","Front-End\\项目搭建\\案例.md":"#案例>[ts+rollup搭建工具库](https://juejin.cn/post/6844904035309322254)","HTML\\favicon\\添加favicon.md":"#给网站添加favicon```html<linkhref=\"favicon.ico\"mce_href=\"favicon.ico\"rel=\"bookmark\"type=\"image/x-icon\"/><linkhref=\"favicon.ico\"mce_href=\"favicon.ico\"rel=\"icon\"type=\"image/x-icon\"/><linkhref=\"favicon.ico\"mce_href=\"favicon.ico\"rel=\"shortcuticon\"type=\"image/x-icon\"/>```注意：（1）这里的favicon必须是16*16或者32*32的，必须是8位色或者24位色的，格式必须是png或者ico或者gif。16*16/32*32且8位或24位色且png/ico/gif。（2）当favicon.ico被置于文档根目录时，将会被一些不处理link元件的浏览器找到，即使没有您的站点上没有指向它的链接。参数解释：-href：这是你网页图标的位置，建议放在服务器根目录下，图标必须是ico文件。-rel：用于解释href链接的对象和该网页有毛线关系用的，毕竟全称就是relationship。说明：1.bookmark和icon的区别-bookmark：在收藏夹下显示图标-icon：资源管理器窗口，还是浏览器的收藏夹2.shortcuticon和icon代码的区别过去，为保证favicon出现，网站设计者和开发者采用了多种方法。很难明确地保证favicon可以在所有电脑上显示，即使是用同一版本的一种浏览器。下列代码另一个局限就是它把favicon关联到了某个特定的HTML或XHTML文档上。为避免这一点，favicon.ico文件应置于根目录下。多数浏览器将自动检测并使用它。```html<linkhref=\"favicon.ico\"mce_href=\"favicon.ico\"rel=\"icon\"type=\"image/x-icon\"/><linkhref=\"favicon.ico\"mce_href=\"favicon.ico\"rel=\"shortcuticon\"type=\"image/x-icon\"/>```>只有第一行是必须的，因为“shortcuticon”字符串将被多数遵守标准的浏览器识别为列出可能的关键词（“shortcut”将被忽略，而仅适用“icon”）；而InternetExplorer将会把它作为一个单独的名称（“shortcuticon”）。这样做的结果是所有浏览器都可以理解此代码。只有当希望为新浏览器提供另一种备用图像（例如动画GIF）时，才有必要添加第二行。","HTML\\favicon\\防止favicon请求.md":"#防止favicon请求-`<linkrel=\"shortcuticon\"href=\"data:image/x-icon;,\"type=\"image/x-icon\">`可以防止favicon请求","HTML\\HTML 符号.md":"#[`HTML符号`](/)##HTML支持的数学符号|字符|实体编号|实体名称|描述||:---|:--------|:---------|:----------------||∀|`&#8704;`|`&forall;`|forall||∂|`&#8706;`|`&part;`|part||∃|`&#8707;`|`&exist;`|exists||∅|`&#8709;`|`&empty;`|empty||∇|`&#8711;`|`&nabla;`|nabla||∈|`&#8712;`|`&isin;`|isin||∉|`&#8713;`|`&notin;`|notin||∋|`&#8715;`|`&ni;`|ni||∏|`&#8719;`|`&prod;`|prod||∑|`&#8721;`|`&sum;`|sum||−|`&#8722;`|`&minus;`|minus||∗|`&#8727;`|`&lowast;`|lowast||√|`&#8730;`|`&radic;`|squareroot||∝|`&#8733;`|`&prop;`|proportionalto||∞|`&#8734;`|`&infin;`|infinity||∠|`&#8736;`|`&ang;`|angle||∧|`&#8743;`|`&and;`|and||∨|`&#8744;`|`&or;`|or||∩|`&#8745;`|`&cap;`|cap||∪|`&#8746;`|`&cup;`|cup||∫|`&#8747;`|`&int;`|integral||∴|`&#8756;`|`&there4;`|therefore||∼|`&#8764;`|`&sim;`|similarto||≅|`&#8773;`|`&cong;`|congruentto||≈|`&#8776;`|`&asymp;`|almostequal||≠|`&#8800;`|`&ne;`|notequal||≡|`&#8801;`|`&equiv;`|equivalent||≤|`&#8804;`|`&le;`|lessorequal||≥|`&#8805;`|`&ge;`|greaterorequal||⊂|`&#8834;`|`&sub;`|subsetof||⊃|`&#8835;`|`&sup;`|supersetof||⊄|`&#8836;`|`&nsub;`|notsubsetof||⊆|`&#8838;`|`&sube;`|subsetorequal||⊇|`&#8839;`|`&supe;`|supersetorequal||⊕|`&#8853;`|`&oplus;`|circledplus||⊗|`&#8855;`|`&otimes;`|circledtimes||⊥|`&#8869;`|`&perp;`|perpendicular||⋅|`&#8901;`|`&sdot;`|dotoperator|##HTML支持的希腊字母|字符|实体编号|实体名称|描述||:---|:-------|:-----------|:-------------||Α|`&#913;`|`&Alpha;`|Alpha||Β|`&#914;`|`&Beta;`|Beta||Γ|`&#915;`|`&Gamma;`|Gamma||Δ|`&#916;`|`&Delta;`|Delta||Ε|`&#917;`|`&Epsilon;`|Epsilon||Ζ|`&#918;`|`&Zeta;`|Zeta||Η|`&#919;`|`&Eta;`|Eta||Θ|`&#920;`|`&Theta;`|Theta||Ι|`&#921;`|`&Iota;`|Iota||Κ|`&#922;`|`&Kappa;`|Kappa||Λ|`&#923;`|`&Lambda;`|Lambda||Μ|`&#924;`|`&Mu;`|Mu||Ν|`&#925;`|`&Nu;`|Nu||Ξ|`&#926;`|`&Xi;`|Xi||Ο|`&#927;`|`&Omicron;`|Omicron||Π|`&#928;`|`&Pi;`|Pi||Ρ|`&#929;`|`&Rho;`|Rho||Σ|`&#931;`|`&Sigma;`|Sigma||Τ|`&#932;`|`&Tau;`|Tau||Υ|`&#933;`|`&Upsilon;`|Upsilon||Φ|`&#934;`|`&Phi;`|Phi||Χ|`&#935;`|`&Chi;`|Chi||Ψ|`&#936;`|`&Psi;`|Psi||Ω|`&#937;`|`&Omega;`|Omega||α|`&#945;`|`&alpha;`|alpha||β|`&#946;`|`&beta;`|beta||γ|`&#947;`|`&gamma;`|gamma||δ|`&#948;`|`&delta;`|delta||ε|`&#949;`|`&epsilon;`|epsilon||ζ|`&#950;`|`&zeta;`|zeta||η|`&#951;`|`&eta;`|eta||θ|`&#952;`|`&theta;`|theta||ι|`&#953;`|`&iota;`|iota||κ|`&#954;`|`&kappa;`|kappa||λ|`&#955;`|`&lambda;`|lambda||μ|`&#956;`|`&mu;`|mu||ν|`&#957;`|`&nu;`|nu||ξ|`&#958;`|`&xi;`|xi||ο|`&#959;`|`&omicron;`|omicron||π|`&#960;`|`&pi;`|pi||ρ|`&#961;`|`&rho;`|rho||ς|`&#962;`|`&sigmaf;`|sigmaf||σ|`&#963;`|`&sigma;`|sigma||τ|`&#964;`|`&tau;`|tau||υ|`&#965;`|`&upsilon;`|upsilon||φ|`&#966;`|`&phi;`|phi||χ|`&#967;`|`&chi;`|chi||ψ|`&#968;`|`&psi;`|psi||ω|`&#969;`|`&omega;`|omega||ϑ|`&#977;`|`&thetasym;`|thetasymbol||ϒ|`&#978;`|`&upsih;`|upsilonsymbol||ϖ|`&#982;`|`&piv;`|pisymbol|##HTML支持的其他实体|字符|实体编号|实体名称|描述||:---|:--------|:---------|:--------------------------------||Œ|`&#338;`|`&OElig;`|capitalligatureOE||œ|`&#339;`|`&oelig;`|smallligatureoe||Š|`&#352;`|`&Scaron;`|capitalSwithcaron||š|`&#353;`|`&scaron;`|smallSwithcaron||Ÿ|`&#376;`|`&Yuml;`|capitalYwithdiaeres||ƒ|`&#402;`|`&fnof;`|fwithhook||ˆ|`&#710;`|`&circ;`|modifierlettercircumflexaccent||˜|`&#732;`|`&tilde;`|smalltilde|||`&#8194;`|`&ensp;`|enspace|||`&#8195;`|`&emsp;`|emspace|||`&#8201;`|`&thinsp;`|thinspace||‌|`&#8204;`|`&zwnj;`|zerowidthnon-joiner||‍|`&#8205;`|`&zwj;`|zerowidthjoiner||‎|`&#8206;`|`&lrm;`|left-to-rightmark||‏|`&#8207;`|`&rlm;`|right-to-leftmark||–|`&#8211;`|`&ndash;`|endash||—|`&#8212;`|`&mdash;`|emdash||'|`&#8216;`|`&lsquo;`|leftsinglequotationmark||'|`&#8217;`|`&rsquo;`|rightsinglequotationmark||‚|`&#8218;`|`&sbquo;`|singlelow-9quotationmark||\"|`&#8220;`|`&ldquo;`|leftdoublequotationmark||\"|`&#8221;`|`&rdquo;`|rightdoublequotationmark||„|`&#8222;`|`&bdquo;`|doublelow-9quotationmark||†|`&#8224;`|`&dagger;`|dagger||‡|`&#8225;`|`&Dagger;`|doubledagger||•|`&#8226;`|`&bull;`|bullet||…|`&#8230;`|`&hellip;`|horizontalellipsis||‰|`&#8240;`|`&permil;`|permille||′|`&#8242;`|`&prime;`|minutes||″|`&#8243;`|`&Prime;`|seconds||‹|`&#8249;`|`&lsaquo;`|singleleftanglequotation||›|`&#8250;`|`&rsaquo;`|singlerightanglequotation||‾|`&#8254;`|`&oline;`|overline||€|`&#8364;`|`&euro;`|euro||™|`&#8482;`|`or&#1`|53;&trade;trademark||←|`&#8592;`|`&larr;`|leftarrow||↑|`&#8593;`|`&uarr;`|uparrow||→|`&#8594;`|`&rarr;`|rightarrow||↓|`&#8595;`|`&darr;`|downarrow||↔|`&#8596;`|`&harr;`|leftrightarrow||↵|`&#8629;`|`&crarr;`|carriagereturnarrow||⌈|`&#8968;`|`&lceil;`|leftceiling||⌉|`&#8969;`|`&rceil;`|rightceiling||⌊|`&#8970;`|`&lfloor;`|leftfloor||⌋|`&#8971;`|`&rfloor;`|rightfloor||◊|`&#9674;`|`&loz;`|lozenge||♠|`&#9824;`|`&spades;`|spade||♣|`&#9827;`|`&clubs;`|club||♥|`&#9829;`|`&hearts;`|heart||♦|`&#9830;`|`&diams;`|diamond|","HTML\\html.md":"#html---##基础标签###a标签中href和tips```html<ahref=\"http://www.one.com\"target=\"_blank\">在HTML文档中插入ID:<aid=\"tips\">有用的提示部分</a>在HTML文档中创建一个链接到\"有用的提示部分(id=\"tips\"）\"：<ahref=\"#tips\">访问有用的提示部分</a>或者，从另一个页面创建一个链接到\"有用的提示部分(id=\"tips\"）\"：<ahref=\"http://www.one.com/html/html-links.html#tips\">访问有用的提示部分</a></a>```###table####第一种```html<tableborder=\"1\"><caption>标题</caption><colgroup><!--定义前两列样式--><colspan=\"2\"style=\"background-color:red\"><!--定义第三列的颜色--><colstyle=\"background-color:yellow\"></colgroup><th><td>表头</td><td>表头</td><td>表头</td></th><tr><td>row1,cell1</td><td>row1,cell2</td><td>row1,cell3</td></tr><tr><td>row2,cell1</td><td>row2,cell2</td><td>row2,cell3</td></tr></table>```####第二种```html<tableborder=\"1\"><!--表头(页眉)--><thead><tr><th>Month</th><th>Savings</th></tr></thead><!--页脚--><tfoot><tr><td>Sum</td><td>$180</td></tr></tfoot><!--主体--><tbody><tr><td>January</td><td>$100</td></tr><tr><td>February</td><td>$80</td></tr></tbody></table>```###表单form```html<formaction=\"demo_form.php\"method=\"get\"><!--定义围绕表单的边框--><fieldset><!--围绕边框的标题--><legend>Personalia:</legend>Firstname:<inputtype=\"text\"name=\"fname\"/><br/><labelfor=\"lastName\">Lastname:</label><inputtype=\"text\"name=\"lname\"/><br/><!--文本框--><textareaname=\"textContext\"rows=\"10\"cols=\"30\">我是一个文本框。</textarea><!--选择列表--><select><optgrouplabel=\"SwedishCars\"><optionvalue=\"volvo\">Volvo</option><optionvalue=\"saab\">Saab</option></optgroup><optgrouplabel=\"GermanCars\"><optionvalue=\"mercedes\">Mercedes</option><optionvalue=\"audi\">Audi</option></optgroup></select><!--定义选择列表--><inputlist=\"browsers\"name=\"browser\"/><datalistid=\"browsers\"><optionvalue=\"InternetExplorer\"></option><optionvalue=\"Firefox\"></option><optionvalue=\"Chrome\"></option><optionvalue=\"Opera\"></option><optionvalue=\"Safari\"></option></datalist><inputtype=\"submit\"value=\"提交\"/></fieldset></form>```###框架```html<iframesrc=\"//www.baidu.com\"><p>您的浏览器不支持iframe标签。</p></iframe>```###图像####img```html<!--图像--><imgsrc=\"https://images.gitee.com/uploads/images/2020/0310/232238_8efc4b0b_6545143.jpeg\"alt=\"Smileyface\"width=\"42\"height=\"42\"/>```####map(图像映射)```html<!--图像映射--><imgsrc=\"planets.gif\"width=\"145\"height=\"126\"alt=\"Planets\"usemap=\"#planetmap\"/><!--定义三片区域,点击这三个区域可以实现跳转--><mapname=\"planetmap\"><areashape=\"rect\"coords=\"0,0,82,126\"alt=\"Sun\"href=\"sun.htm\"/><areashape=\"circle\"coords=\"90,58,3\"alt=\"Mercury\"href=\"mercur.htm\"/><areashape=\"circle\"coords=\"124,58,8\"alt=\"Venus\"href=\"venus.htm\"/></map>```####canvas(通过脚本绘制图像)```html<canvasid=\"myCanvas\">你的浏览器不支持HTML5canvas标签。</canvas><script>varc=document.getElementById('myCanvas')varctx=c.getContext('2d')ctx.fillStyle='#FF0000'ctx.fillRect(0,0,80,100)</script>```####figure(通过标签与元素组合)```html<figure><imgsrc=\"img_pulpit.jpg\"alt=\"ThePulpitRock\"width=\"304\"height=\"228\"/><!--定义img的标题,这个是在下--><figcaption>Fig1.-AviewofthepulpitrockinNorway.</figcaption></figure>```###audio/video####audio```html<audiocontrols><!--浏览器支持则任意一个--><sourcesrc=\"horse.ogg\"type=\"audio/ogg\"/><sourcesrc=\"horse.mp3\"type=\"audio/mpeg\"/>您的浏览器不支持audio元素。</audio>```####track(字幕)```html<videowidth=\"320\"height=\"240\"controls><sourcesrc=\"forrest_gump.mp4\"type=\"video/mp4\"/><sourcesrc=\"forrest_gump.ogg\"type=\"video/ogg\"/><!--定义字幕--><tracksrc=\"subtitles_en.vtt\"kind=\"subtitles\"srclang=\"en\"label=\"English\"/><tracksrc=\"subtitles_no.vtt\"kind=\"subtitles\"srclang=\"no\"label=\"Norwegian\"/></video>```####video```html<videowidth=\"320\"height=\"240\"controls><sourcesrc=\"movie.mp4\"type=\"video/mp4\"/><sourcesrc=\"movie.ogg\"type=\"video/ogg\"/>您的浏览器不支持video标签。</video>```###链接```html<ahref=\"url\">访问菜鸟教程!</a><head><linkrel=\"stylesheet\"type=\"text/css\"href=\"theme.css\"/></head><nav><ahref=\"/html/\">HTML</a>|<ahref=\"/css/\">CSS</a>|<ahref=\"/js/\">JavaScript</a>|<ahref=\"/jquery/\">jQuery</a></nav>```###列表####无序列表```html<ul><li>Coffee</li><li>Tea</li><li>Milk</li></ul>```####有序列表```html<olstart=\"1\"><li>Coffee</li><li>Tea</li><li>Milk</li></ol>```####定义列表```html<dl><dt>Coffee</dt><!--描述--><dd>Blackhotdrink</dd><dt>Milk</dt><dd>Whitecolddrink</dd></dl>```###文档(article)```html<article><header>文档头部</header><section>文档的某个区域</section><aside>所处内容之外的内容</aside><footer>文档底部</footer></article>```###元信息-`<head>`:定义文档的信息-`<meta>`:关于HTML文档的原信息```html<metaname=\"author\"content=\"runoob\"/><metacharset=\"UTF-8\"/>```-`<base>`:订阅页面所有链接的默认地址或默认目标```html<head><basehref=\"url\"target=\"_blank\"/></head>```###嵌入flash动画片`<embedsrc=\"helloworld.swf\">`##base标签```html<head><basehref=\"http://example.com/here/is/my/deeply/nested/set/of/images/\"/><basetarget=\"_blank\"/>//还可以定义这个a标签的超链接方式</head><imgsrc=\"/here/is/my/deeply/nested/set/of/images/example-01.jpg\"alt=\"\"/><imgsrc=\"/here/is/my/deeply/nested/set/of/images/example-01.jpg\"alt=\"\"/><imgsrc=\"/here/is/my/deeply/nested/set/of/images/example-03.jpg\"alt=\"\"/>//就可以改成下面<imgsrc=\"example-01.jpg\"alt=\"\"/><imgsrc=\"example-01.jpg\"alt=\"\"/><imgsrc=\"example-03.jpg\"alt=\"\"/>```","HTML\\html5.md":"#HTML5##表单###输入类型####email`E-mail:<inputtype=\"email\"name=\"user_email\"/>`>==验证email域==的值####url`Homepage:<inputtype=\"url\"name=\"user_url\"/>`>==验证url域==的值####number`Points:<inputtype=\"number\"name=\"points\"min=\"1\"max=\"10\"/>`>限制接受数字的范围>>max:最大值;min:最小值;step:间隔;value:默认值;####range`<inputtype=\"range\"name=\"points\"min=\"1\"max=\"10\"/>`>包含一定范围数字值的输入域(类型为滑动条)####Datepickers(date,month,week,time,datetime,datetime-local)(日期选择器)```htmlDate:<inputtype=\"date\"name=\"user_date\"/>```>-date-选取日、月、年>-month-选取月、年>-week-选取周和年>-time-选取时间（小时和分钟）>-datetime-选取时间、日、月、年（UTC时间）>-datetime-local-选取时间、日、月、年（本地时间）####search>search类型用于搜索域，比如站点搜索或Google搜索。>>search域显示为常规的文本域。####color>选颜色###表单元素####datalist>datalist元素规定输入域的选项列表。>>列表是通过datalist内的option元素创建的。>>如需把datalist绑定到输入域，请用输入域的list属性引用datalist的id>>option里面的value一定要设置属性```htmlWebpage:<inputtype=\"url\"list=\"url_list\"name=\"link\"/><datalistid=\"url_list\"><optionlabel=\"W3School\"value=\"http://www.W3School.com.cn\"/><optionlabel=\"Google\"value=\"http://www.google.com\"/><optionlabel=\"Microsoft\"value=\"http://www.microsoft.com\"/></datalist>```####keygen>keygen元素的作用是提供一种验证用户的可靠方法。>>keygen元素是密钥对生成器（key-pairgenerator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。>>私钥（privatekey）存储于客户端，公钥（publickey）则被发送到服务器。公钥可用于之后验证用户的客户端证书（clientcertificate）。>>目前，==浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准==。```html<formaction=\"demo_form.asp\"method=\"get\">Username:<inputtype=\"text\"name=\"usr_name\"/>Encryption:<keygenname=\"security\"/><inputtype=\"submit\"/></form>```####output>output元素用于不同类型的输出，比如计算或脚本输出：<!DOCTYPEHTML><html><head><scripttype=\"text/javascript\">functionresCalc(){numA=document.getElementById(\"num_a\").value;numB=document.getElementById(\"num_b\").value;document.getElementById(\"result\").value=Number(numA)+Number(numB);}</script></head><body><p>使用output元素的简易计算器：</p><formonsubmit=\"returnfalse\"><inputid=\"num_a\"/>+<inputid=\"num_b\"/>=<outputid=\"result\"onforminput=\"resCalc()\"></output></form></body></html>###表单属性####新的form属性#####autocomplete->相当于有记忆功能>>适用于:<input>标签：text,search,url,telephone,email,password,datepickers,range以及color。```html<formaction=\"/example/html5/demo_form.asp\"method=\"get\"autocomplete=\"on\">Firstname:<inputtype=\"text\"name=\"fname\"/><br/>Lastname:<inputtype=\"text\"name=\"lname\"/><br/>E-mail:<inputtype=\"email\"name=\"email\"autocomplete=\"off\"/><br/><inputtype=\"submit\"/></form><p>请填写并提交此表单，然后重载页面，来查看自动完成功能是如何工作的。</p><p>请注意，表单的自动完成功能是打开的，而e-mail域是关闭的。</p>```#####novalidate>novalidate属性规定在提交表单时不应该验证form或input域。####新的input属性#####autofocus>页面加载时,自动获得焦点```htmlUsername:<inputtype=\"text\"name=\"user_name\"autofocus=\"autofocus\"/>```#####form```html<formaction=\"demo_form.asp\"method=\"get\"id=\"user_form\">Firstname:<inputtype=\"text\"name=\"fname\"/><inputtype=\"submit\"/></form>//这个不在form里面,但是form属性指向的form的id,可以把它和form标签绑定Lastname:<inputtype=\"text\"name=\"lname\"form=\"user_form\"/>```-表单重写属性formoverrides(formaction,formenctype,formmethod,formnovalidate,formtarget)-formaction-重写表单的action属性-formenctype-重写表单的enctype属性-formmethod-重写表单的method属性-formnovalidate-重写表单的novalidate属性-formtarget-重写表单的target属性```html<formaction=\"/example/html5/demo_form.asp\"method=\"get\"id=\"user_form\">E-mail:<inputtype=\"email\"name=\"userid\"/><br/><inputtype=\"submit\"value=\"Submit\"/><br/><inputtype=\"submit\"formaction=\"/example/html5/demo_admin.asp\"value=\"Submitasadmin\"/><br/><inputtype=\"submit\"formnovalidate=\"true\"value=\"Submitwithoutvalidation\"/><br/></form>```#####height和width>height和width属性只适用于image类型的<input>标签。```html<inputtype=\"image\"src=\"img_submit.gif\"width=\"99\"height=\"99\"/>```#####list>通过list属性实现和datalist绑定```html<formaction=\"/example/html5/demo_form.asp\"method=\"get\">Webpage:<inputtype=\"url\"list=\"url_list\"name=\"link\"/><datalistid=\"url_list\"><optionlabel=\"W3School\"value=\"http://www.w3school.com.cn\"/><optionlabel=\"Google\"value=\"http://www.google.com\"/><optionlabel=\"Microsoft\"value=\"http://www.microsoft.com\"/></datalist><inputtype=\"submit\"/></form>```#####multiple>可以选择多个文件```html<inputtype=\"file\"name=\"img\"multiple=\"multiple\"/>```#####pattern(regexp)>pattern属性规定用于验证input域的模式（pattern）。```html<inputtype=\"text\"name=\"country_code\"pattern=\"[A-z]{3}\"title=\"Threelettercountrycode\"/>```#####placeholder>提示输入值#####required>required属性规定必须在提交之前填写输入域（不能为空）。```htmlName:<inputtype=\"text\"name=\"usr_name\"required=\"required\"/>```##视频/DOM###video支持的视频格式>-Ogg=带有Theora视频编码和Vorbis音频编码的Ogg文件>-MPEG4=带有H.264视频编码和AAC音频编码的MPEG4文件>-WebM=带有VP8视频编码和Vorbis音频编码的WebM文件|属性|值|描述||:------------------------------------------------------------------|:-------|:------------------------------------------------------------------------------------------||[autoplay](https://www.w3school.com.cn/tags/att_video_autoplay.asp)|autoplay|如果出现该属性，则视频在就绪后马上播放。||[controls](https://www.w3school.com.cn/tags/att_video_controls.asp)|controls|如果出现该属性，则向用户显示控件，比如播放按钮。||[height](https://www.w3school.com.cn/tags/att_video_height.asp)|_pixels_|设置视频播放器的高度。||[loop](https://www.w3school.com.cn/tags/att_video_loop.asp)|loop|如果出现该属性，则当媒介文件完成播放后再次开始播放。||[preload](https://www.w3school.com.cn/tags/att_video_preload.asp)|preload|如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用\"autoplay\"，则忽略该属性。||[src](https://www.w3school.com.cn/tags/att_video_src.asp)|_url_|要播放的视频的URL。||[width](https://www.w3school.com.cn/tags/att_video_width.asp)|_pixels_|设置视频播放器的宽度。|```html<videowidth=\"320\"height=\"240\"controls=\"controls\"><sourcesrc=\"movie.ogg\"type=\"video/ogg\"/><sourcesrc=\"movie.mp4\"type=\"video/mp4\"/>Yourbrowserdoesnotsupportthevideotag.</video>```###Video+DOM```html<divstyle=\"text-align:center;\"><buttononclick=\"playPause()\">播放/暂停</button><buttononclick=\"makeBig()\">大</button><buttononclick=\"makeNormal()\">中</button><buttononclick=\"makeSmall()\">小</button><br/><videoid=\"video1\"width=\"420\"style=\"margin-top:15px;\"><sourcesrc=\"/example/html5/mov_bbb.mp4\"type=\"video/mp4\"/><sourcesrc=\"/example/html5/mov_bbb.ogg\"type=\"video/ogg\"/>YourbrowserdoesnotsupportHTML5video.</video></div><scripttype=\"text/javascript\">varmyVideo=document.getElementById('video1')functionplayPause(){if(myVideo.paused)myVideo.play()elsemyVideo.pause()}functionmakeBig(){myVideo.width=560}functionmakeSmall(){myVideo.width=320}functionmakeNormal(){myVideo.width=420}</script>```####HTML5<video>-方法、属性以及事件下面列出了大多数浏览器支持的视频方法、属性和事件：|方法|属性|事件||:----------|:----------|:-------------||play()|currentSrc|play||pause()|currentTime|pause||load()|videoWidth|progress||canPlayType|videoHeight|error|||duration|timeupdate|||ended|ended|||error|abort|||paused|empty|||muted|emptied|||seeking|waiting|||volume|loadedmetadata|||height||||width||**注释：**在所有属性中，只有videoWidth和videoHeight属性是立即可用的。在视频的元数据已加载后，其他属性才可用。##音频```html<audiocontrols=\"controls\"><sourcesrc=\"song.ogg\"type=\"audio/ogg\"/><sourcesrc=\"song.mp3\"type=\"audio/mpeg\"/>Yourbrowserdoesnotsupporttheaudiotag.</audio>```###<audio>标签的属性|属性|值|描述||:------------------------------------------------------------------|:-------|:------------------------------------------------------------------------------------------||[autoplay](https://www.w3school.com.cn/tags/att_audio_autoplay.asp)|autoplay|如果出现该属性，则音频在就绪后马上播放。||[controls](https://www.w3school.com.cn/tags/att_audio_controls.asp)|controls|如果出现该属性，则向用户显示控件，比如播放按钮。||[loop](https://www.w3school.com.cn/tags/att_audio_loop.asp)|loop|如果出现该属性，则每当音频结束时重新开始播放。||[preload](https://www.w3school.com.cn/tags/att_audio_preload.asp)|preload|如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用\"autoplay\"，则忽略该属性。||[src](https://www.w3school.com.cn/tags/att_audio_src.asp)|_url_|要播放的音频的URL。|##拖放>抓取对象然后拖到另一个位置```html<!DOCTYPEHTML><html><head><styletype=\"text/css\">#div1{width:198px;height:66px;padding:10px;border:1pxsolid#aaaaaa;}</style><scripttype=\"text/javascript\">functionallowDrop(ev){//消除默认动作ev.preventDefault();}functiondrag(ev){//设置拖放元素的数据类型和值//类型为\"Text\"//元素的id(\"drag1\")ev.dataTransfer.setData(\"Text\",ev.target.id);}functiondrop(ev){ev.preventDefault();vardata=ev.dataTransfer.getData(\"Text\");ev.target.appendChild(document.getElementById(data));}</script></head><body><divid=\"div1\"ondrop=\"drop(event)\"<!--放置被拖数据时，会发生drop事件-->ondragover=\"allowDrop(event)\"<!--规定拖放到的数据-->></div><imgid=\"drag1\"src=\"img_logo.gif\"draggable=\"true\"<!--是元素可以拖动-->ondragstart=\"drag(event)\"width=\"336\"height=\"69\"/></body></html>```##画布###创建Canvas```html<canvasid=\"myCanvas\"width=\"200\"height=\"100\">Yourbrowserdoesnotsupportthecanvaselemen</canvas>```###通过javaScript绘制####绘制矩形![](https://images.gitee.com/uploads/images/2020/0521/153506_a30b3390_6545143.png)```html<scripttype=\"text/javascript\">varc=document.getElementById('myCanvas')varcxt=c.getContext('2d')cxt.fillStyle='#FF0000'//设置画笔的颜色cxt.fillRect(0,0,150,75)//绘制</script>```####绘制线条![](https://images.gitee.com/uploads/images/2020/0521/153518_417dc519_6545143.png)```html<scripttype=\"text/javascript\">varc=document.getElementById('myCanvas')varcxt=c.getContext('2d')cxt.moveTo(10,10)cxt.lineTo(150,50)cxt.lineTo(10,50)cxt.stroke()</script>```####圆形![](https://images.gitee.com/uploads/images/2020/0521/153530_441f2afe_6545143.png)```html<scripttype=\"text/javascript\">varc=document.getElementById('myCanvas')varcxt=c.getContext('2d')cxt.fillStyle='#FF0000'cxt.beginPath()cxt.arc(70,18,15,0,Math.PI*2,true)cxt.closePath()cxt.fill()</script>```####渐变![](https://images.gitee.com/uploads/images/2020/0521/153702_738cd56b_6545143.png)```html<scripttype=\"text/javascript\">varc=document.getElementById('myCanvas')varcxt=c.getContext('2d')vargrd=cxt.createLinearGradient(0,0,175,50)grd.addColorStop(0,'#FF0000')grd.addColorStop(1,'#00FF00')cxt.fillStyle=grdcxt.fillRect(0,0,175,50)</script>```####图像![](https://images.gitee.com/uploads/images/2020/0521/153826_63883e4b_6545143.png)##SVG####简介>-SVG指可伸缩矢量图形(ScalableVectorGraphics)>-SVG用于定义用于网络的基于矢量的图形>-SVG使用XML格式定义图形>-SVG图像在放大或改变尺寸的情况下其图形质量不会有损失>-SVG是万维网联盟的标准####优点>与其他图像格式相比（比如JPEG和GIF），使用SVG的优势在于：>>-SVG图像可通过文本编辑器来创建和修改>-SVG图像可被搜索、索引、脚本化或压缩>-SVG是可伸缩的>-SVG图像可在任何的分辨率下被高质量地打印>-SVG可在图像质量不下降的情况下被放大```html<svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"height=\"190\"><polygonpoints=\"100,1040,180190,6010,60160,180\"style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\"/></svg>```![](https://images.gitee.com/uploads/images/2020/0521/160322_cf31cb9f_6545143.png)##画布vsSVG####SVG>SVG是一种使用XML描述2D图形的语言。>>SVG基于XML，这意味着SVGDOM中的每个元素都是可用的。您可以为某个元素附加JavaScript事件处理器。>>在SVG中，每个被绘制的图形均被视为对象。如果SVG对象的属性发生变化，那么浏览器能够自动重现图形。>-不依赖分辨率>-支持事件处理器>-最适合带有大型渲染区域的应用程序（比如谷歌地图）>-复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）>-不适合游戏应用####Canvas>Canvas通过JavaScript来绘制2D图形。>>Canvas是逐像素进行渲染的。>>在canvas中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。>-依赖分辨率>-不支持事件处理器>-弱的文本渲染能力>-能够以.png或.jpg格式保存结果图像>-最适合图像密集型的游戏，其中的许多对象会被频繁重绘##Web存储>客户端存储数据的新方法：>>-localStorage-没有时间限制的数据存储>-sessionStorage-针对一个session的数据存储####localStorage>localStorage方法存储的数据==没有时间限制==。第二天、第二周或下一年之后，数据依然可用。```html<scripttype=\"text/javascript\">localStorage.lastname='Smith'document.write(localStorage.lastname)</script>```####sessionStorage>sessionStorage方法针对一个session进行数据存储。当用户==关闭浏览器窗口后，数据会被删除==。```html<scripttype=\"text/javascript\">sessionStorage.lastname='Smith'document.write(sessionStorage.lastname)</script>```##应用缓存(ApplicationCache)>-离线浏览-用户可在应用离线时使用它们>-速度-已缓存资源加载得更快>-减少服务器负载-浏览器将只从服务器下载更新过或更改过的资源```html<!DOCTYPEhtml><htmlmanifest=\"demo.appcache\"><body>Thecontentofthedocument......</body></html>```>manifest文件需要配置*正确的MIME-type*，即\"text/cache-manifest\"。必须在web服务器上进行配置####Manifest文件>manifest文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）>>manifest文件可分为三个部分：>>-_CACHEMANIFEST_-在此标题下列出的文件将在首次下载后进行缓存>-_NETWORK_-在此标题下列出的文件需要与服务器的连接，且不会被缓存>-_FALLBACK_-在此标题下列出的文件规定当页面无法访问时的回退页面（比如404页面）#####CACHEMANIFEST(必需)>文件会被缓存```txtCACHEMANIFEST/theme.css/logo.gif/main.js```#####_NETWORK_>文件永远不会被缓存```txtNETWORK:login.asp或NETWORK:*#代表所有资源文件```#####_FALLBACK_>规定如果无法建立因特网连接，则用\"404.html\"替代/html5/目录中的所有文件：```txtFALLBACK:/html5//404.html```#####更新缓存一旦应用被缓存，它就会保持缓存直到发生下列情况：-用户清空浏览器缓存-manifest文件被修改（参阅下面的提示）-由程序来更新应用缓存#####Manifest文件```txtCACHEMANIFEST#2012-02-21v1.0.0/theme.css/logo.gif/main.jsNETWORK:login.aspFALLBACK:/html5//404.html```>**重要的提示：**以\"#\"开头的是注释行，但也可满足其他用途。应用的缓存会在其manifest文件更改时被更新。如果您编辑了一幅图片，或者修改了一个JavaScript函数，这些改变都不会被重新缓存。==更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法==。#####关于应用程序缓存的注释请留心缓存的内容。一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。为了确保浏览器更新缓存，您需要更新manifest文件。**注释：**浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点5MB）。##WebWorkers####简介>当在HTML页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。>webworker是运行在后台的JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时webworker在后台运行。demo_worker.js```jsvari=0functiontimedCount(){i=i+1postMessage(i)setTimeout('timedCount()',500)}timedCount()``````html<!DOCTYPEhtml><html><body><p>Countnumbers:<outputid=\"result\"></output></p><buttononclick=\"startWorker()\">StartWorker</button><buttononclick=\"stopWorker()\">StopWorker</button><br/><br/><script>varw;functionstartWorker(){<!--检测是否支持Worker-->if(typeof(Worker)!==\"undefined\"){if(typeof(w)==\"undefined\"){w=newWorker(\"demo_workers.js\");}w.onmessage=function(event){document.getElementById(\"result\").innerHTML=event.data;};}else{document.getElementById(\"result\").innerHTML=\"Sorry,yourbrowserdoesnotsupportWebWorkers...\";}}functionstopWorker(){w.terminate();}</script></body></html>```##服务器发送事件(**server-sentevent**)>Server-Sent事件指的是网页自动获取来自服务器的更新##检测Server-Sent事件支持```jsif(typeofEventSource!=='undefined'){//Yes!Server-senteventssupport!//Somecode.....}else{//Sorry!Noserver-senteventssupport..}```###接收Server-Sent事件通知```jsvarsource=newEventSource('demo_sse.php')source.onmessage=function(event){document.getElementById('result').innerHTML+=event.data+'<br/>'}```>-创建一个新的EventSource对象，然后规定发送更新的页面的URL（本例中是\"demo_sse.php\"）>-每接收到一次更新，就会发生onmessage事件>-当onmessage事件发生时，把已接收的数据推入id为\"result\"的元素中###EventSource对象在上面的例子中，我们使用onmessage事件来获取消息。不过还可以使用其他事件：|事件|描述||:--------|:-----------------------||onopen|当通往服务器的连接被打开||onmessage|当接收到消息||onerror|当错误发生|","HTML\\img.md":"#Img##判断src是否有效-通过onError事件来处理:-`<imgsrc='url1'onError='imageError(this)'/>``imageError是自定义的方法````jsfunctionimgerror(img){img.src='images/default.jpg'img.οnerrοr=null//控制不要一直跳动}``````jsif(pic==null){html='<imgsrc=\"images/bg_test1.jpg\"width=\"320\"height=\"157\"/>'}else{html='<imgsrc=\"'+pic+'\"width=\"320\"height=\"157\"οnerrοr=\"imgerror(this)\"/>'}functionimgerror(img){img.src='images/default.jpg'img.οnerrοr=null//控制不要一直跳动}```","HTML\\meta.md":"#htmlmeta属性（set-cookie和cache)-HTTP-EQUIV类似于HTTP的头部协议，它回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。常用的HTTP-EQUIV类型有：##Content-Type和Content-Language（显示字符集的设定）-设定页面使用的字符集，用以说明主页制作所使用的文字已经语言，浏览器会根据此来调用相应的字符集显示page内容。用法：```html<metahttp-equiv=\"Content-Type\"content=\"text/html;Charset=gb2312\"/><metahttp-equiv=\"Content-Language\"content=\"zh-CN\"/>```-注意：该META标签定义了HTML页面所使用的字符集为GB2132，就是国标汉字码。如果将其中的“charset=GB2312”替换成“BIG5”，则该页面所用的字符集就是繁体中文Big5码。当你浏览一些国外的站点时，IE浏览器会提示你要正确显示该页面需要下载xx语支持。这个功能就是通过读取HTML页面META标签的Content-Type属性而得知需要使用哪种字符集显示该页面的。如果系统里没有装相应的字符集，则IE就提示下载。其他的语言也对应不同的charset，比如日文的字符集是“iso-2022-jp”，韩文的是“ks_c_5601”。-`Content-Type`的`Content`还可以是：`text/xml`等文档类型；Charset选项：ISO-8859-1（英文）、BIG5、UTF-8、SHIFT-Jis、Euc、Koi8-2、us-ascii，x-mac-roman，iso-8859-2，x-mac-ce，iso-2022-jp，x-sjis，x-euc-jp，euc-kr，iso-2022-kr，gb2312，gb_2312-80，x-euc-tw，x-cns11643-1，x-cns11643-2等字符集；Content-Language的Content还可以是：EN、FR等语言代码。##Refresh（刷新)-让网页多长时间（秒）刷新自己，或在多长时间后让网页自动链接到其它网页。用法：```html<metahttp-equiv=\"Refresh\"content=\"30\"/><metahttp-equiv=\"Refresh\"content=\"5;Url=http://www.xia8.net\"/>```-注意：其中的5是指停留5秒钟后自动刷新到URL网址。##Expires（期限)-指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调阅。用法：```html<metahttp-equiv=\"Expires\"content=\"0\"/><metahttp-equiv=\"Expires\"content=\"Wed,26Feb199708:21:57GMT\"/>```注意：必须使用GMT的时间格式，或直接设为0（数字表示多少时间后过期）。##Pragma（cach模式）说明：禁止浏览器从本地机的缓存中调阅页面内容。用法：注意：网页不保存在缓存中，每次访问都刷新页面。这样设定，访问者将无法脱机浏览。##Set-Cookie（cookie设定）-浏览器访问某个页面时会将它存在缓存中，下次再次访问时就可从缓存中读取，以提高速度。-当你希望访问者每次都刷新你广告的图标，或每次都刷新你的计数器，就要禁用缓存了。-通常HTML文件没有必要禁用缓存，对于ASP等页面，就可以使用禁用缓存，因为每次看到的页面都是在服务器动态生成的，缓存就失去意义。如果网页过期，那么存盘的cookie将被删除。用法：```html<metahttp-equiv=\"Set-Cookie\"content=\"cookievalue=xxx;expires=Wednesday,21-Oct-9816:14:21GMT;path=/\"/>```注意：必须使用GMT的时间格式。##Window-target（显示窗口的设定）-强制页面在当前窗口以独立页面显示。用法：```html<metahttp-equiv=\"Widow-target\"content=\"_top\"/>```注意：这个属性是用来防止别人在框架里调用你的页面。Content选项：\\_blank、\\_top、\\_self、\\_parent.##Pics-label（网页RSAC等级评定）>在IE的Internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过该参数来设置的。用法：```html<metahttp-equiv=\"Pics-label\"Contect=\"(PICS－1.1'http://www.rsac.org/ratingsv01.html'Igencomment'RSACiNorthAmericaSever'by'inet@microsoft.com'for'http://www.microsoft.com'on'1997.06.30T14:21－0500'r(n0s0v0l0))\"/>```注意：不要将级别设置的太高。RSAC的评估系统提供了一种用来评价Web站点内容的标准。用户可以设置MicrosoftInternetExplorer（IE3.0以上）来排除包含有色情和暴力内容的站点。上面这个例子中的HTML取自Microsoft的主页。代码中的（n0s0v0l0）表示该站点不包含不健康内容。级别的评定是由RSAC，即美国娱乐委员会的评级机构评定的，如果你想进一步了解RSAC评估系统的等级内容，或者你需要评价自己的网站，可以访问RSAC的站点：<http://www.rsac.org/>.##Page-Enter、Page-Exit（进入与退出）-这个是页面被载入和调出时的一些特效。用法：```html<metahttp-equiv=\"Page-Enter\"content=\"blendTrans(Duration=0.5)\"/><metahttp-equiv=\"Page-Exit\"content=\"blendTrans(Duration=0.5)\"/>```","HTML\\script.md":"#script标签>1.async属性:表示立即下载脚本，但不会影响页面的其他操作。[规定脚本将被异步执行],只适合外部脚本,下载完成后立即执行>2.charset属性:规定在外部脚本把文件中使用的编码不同。>3.defer属性:表示脚本可以延迟到文档被解析和显示之后再执行。只有对外部脚本有效。立即下载,但是延迟执行>4.src属性:表示包含要执行代码的外部文件。>5.type属性:规定了脚本的MIME属性[内容属性]>6.language属性:已废弃。##异步加载```html<scriptsrc=\"...\"async><script>```##延迟加载```html<scriptsrc=\"\"defer></script>```","HTML\\svg.md":"#svg>特点:无论怎么样放大都不会失真>>[地图数据(hcharts.cn)](https://img.hcharts.cn/mapdata/index.html)>><https://img.hcharts.cn/mapdata/custom/world-robinson.geo.json>>>默认填充颜色是黑色(没有设置fill属性时)>>每一个线和图都可以分别指定class>>[SVG教程-SVG|MDN(mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial)##使用方式1.`svg`标签:`<svg>...</svg>`2.`img`标签:`<imgscr='文件名.svg'/>`3.`iframe`标签:`<iframesrc='文件名.svg'></iframe>`4.`object`标签:`<objectdata='文件名.svg'type='image/svg+xml>`5.`embed`标签:`<embedsrc='文件名.svg'type='image/svg+xml'>`##属性-宽度width-高度height-css样式style-填充色fill-边框颜色stroke-边框宽度stroke-width-边框首尾stroke-linecap-线条样式stroke-dasharray(需要填写线条宽度以及线条间隙依据顺序填写一个循环)-线条每一段的起始偏移量stroke-dashoffet-填充透明度fill-opacity-边框stroke-opacity-图形填充规则fill-rule（nonzeroevenodd）-动作transform（中心点为图像左上角,并且只支持2d变换-translate(10,10)ortranslate(1010)-rotate(20)orrotate(20,xy)x,y为旋转中心点并且只能是默认deg单位-scale(x,y)##基础语法>SVG默认:300px(宽)\\*150px(高)```html<svgwidth=\"100%\"height=\"100%\"><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle></svg>```<svgwidth='100px'height='100px'><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r='50'fill='red'></circle></svg>###viewbox指定视图>`viewbox='50505050'`:前两是**横纵坐标**,后两个数字是视图**高**和**宽**```html<svgwidth=\"100px\"height=\"100px\"viewbox=\"50505050\"><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle></svg>```<svgwidth='100px'height='100px'viewbox='50505050'><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r='50'fill='red'></circle></svg>###圆圈`circle`>画圆圈>>可以通过class指定样式>>fill:设置填充颜色>>stroke:描边颜色>>stroke-width:描边宽度```html<svgwidth=\"320\"height=\"106\"><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle><circleid=\"mycircle\"cx=\"160\"cy=\"53\"r=\"50\"fill=\"pink\"style=\"stroke:red;stroke-width:3px;\"></circle><circleid=\"mycircle\"cx=\"270\"cy=\"50\"r=\"50\"fill=\"yellow\"></circle></svg>```<svgwidth='320'height='106'><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r='50'fill='red'></circle><circleid=\"mycircle\"cx=\"160\"cy=\"53\"r='50'fill='pink'style=\"stroke:red;stroke-width:3px;\"></circle><circleid=\"mycircle\"cx=\"270\"cy=\"50\"r='50'fill='yellow'></circle></svg>###直线`line`&折线`polyline`>绘制直线>>设置两个坐标后,然后设置stroke```html<svgwidth=\"200\"height=\"83\"><linex1=\"10\"y1=\"10\"x2=\"10\"y2=\"75\"style=\"stroke:pink;stroke-width:5px;\"></line><polylinepoints=\"40,4040,80120,80\"style=\"stroke:red;stroke-width:2px;fill:none;\"></polyline></svg>```<svgwidth='200'height='83'><linex1='10'y1='10'x2='10'y2='75'style=\"stroke:pink;stroke-width:5px;\"></line><polylinepoints=\"40,4040,80120,80\"style=\"stroke:red;stroke-width:2px;fill:none;\"></polyline></svg>###矩形`rect`>指定一个坐标和宽度和高度```html<svgwidth=\"300\"height=\"180\"><rectx=\"0\"y=\"0\"height=\"180\"width=\"200\"style=\"stroke:pink;fill:none;stroke-width:3px;\"/></svg>```<svgwidth='300'height='180'><rectx='0'y='0'height='180'width='200'style=\"stroke:pink;fill:none;stroke-width:3px;\"/></svg>###椭圆ellipse>指定圆心,再指定水平宽度,和垂直宽度```html<svgwidth=\"100\"height=\"120\"><ellipsecx=\"60\"cy=\"60\"rx=\"20\"ry=\"40\"style=\"fill:none;stroke:pink;stroke-width:2px;\"></ellipse></svg>```<svgwidth='100'height='120'><ellipsecx='60'cy='60'rx='20'ry='40'style=\"fill:none;stroke:pink;stroke-width:2px;\"></ellipse></svg>###多边形`polygon`>指定多个断点的坐标```html<svgwidth=\"400\"height=\"400\"><polygonpoints=\"50,50200,180150,250100,20050,50\"style=\"fill:none;stroke:pink;stroke-width:2px;\"></polygon></svg>```<svgwidth='400'height='300'><polygonpoints=\"50,50200,180150,250100,20050,50\"style=\"fill:none;stroke:pink;stroke-width:2px;\"></polygon></svg>###绘制路径`path`>M:移动到(moveto)>>L:画直线(lineto)>>Z:闭合路径-M=moveto移动画笔-L=lineto画线-H=horizontallineto水平线-V=verticallineto垂直线-C=curveto曲线-S=smoothcurveto光滑曲线-Q=quadraticBeziercurve贝塞尔曲线-T=smoothquadraticBeziercurveto光滑贝塞尔曲线-A=ellipticalArc椭圆-Z=closepath结束路径注意：上面的命令大写表示绝对定位，小写表示相对定位```html<svgheight=\"61\"width=\"60\"><pathd=\"M18,3L46,3L46,40L61,40L32,48L3,40L18,40Z\"style=\"fill:none;stroke:pink;stroke-width:2px;\"></path></svg>```<svgheight='61'width='60'><pathd=\"M18,3L46,3L46,40L61,40L32,48L3,40L18,40Z\"style=\"fill:none;stroke:pink;stroke-width:2px;\"></path></svg>###文本`text`>绘制文本>>`x,y`指定文本基线(`baseline`)起点>>可以通过class或style来修改文字样式```html<svgwidth=\"300\"height=\"30\"><textx=\"50\"y=\"25\"fill=\"none\"stroke=\"red\"stroke-width=\"1px\"style=\"text-shadow:0020px#333\">HELLOWORLD</text></svg>```<svgwidth='300'height='30'><textx='50'y='25'fill='none'stroke='red'stroke-width='1px'style='text-shadow:0020px#333'>HELLOWORLD</text></svg>###复制`use`>use指定x,y是相对于原图形的相对位置```html<svgwidth=\"600\"height=\"200\"><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle><usehref=\"#mycircle\"x=\"50\"y=\"0\"fill=\"blue\"></use></svg>```###组`g`>将多个图形合并成一个组,方便复用```html//简单例子,只是一个思路<svgwidth=\"600\"height=\"200\"><gid=\"myg\"><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle></g><usehref=\"#myg\"x=\"50\"y=\"0\"fill=\"blue\"></use></svg>```声明`defs`>直接声明不会显示,只有引用才会显示```html<svgwidth=\"600\"height=\"200\"><defsid=\"mydefs\"><gid=\"myg\"><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle><circleid=\"mycircle\"cx=\"50\"cy=\"50\"r=\"50\"fill=\"red\"></circle></g></defs><usehref=\"#mydefs\"x=\"50\"y=\"0\"fill=\"blue\"></use><usehref=\"#myg\"x=\"50\"y=\"0\"fill=\"blue\"></use></svg>```###pattern>平铺一个区域```html<svgwidth=\"500\"height=\"500\"><defs><patternid=\"dots\"x=\"0\"y=\"0\"width=\"100\"height=\"100\"patternUnits=\"userSpaceOnUse\"><circlefill=\"#bee9e8\"cx=\"50\"cy=\"50\"r=\"35\"></circle></pattern></defs><rectx=\"0\"y=\"0\"width=\"100%\"height=\"100%\"fill=\"url(#dots)\"></rect></svg>```<imgsrc=\"https://images.gitee.com/uploads/images/2020/0914/233103_92022ed0_7984151.png\"style=\"zoom:25%;\"/>###特效`animate````html//一个方块不断往右走<svgwidth=\"500\"height=\"50\"><rectx=\"0\"y=\"0\"width=\"100\"height=\"50\"fill=\"orange\"><animateattributeName=\"x\"from=\"0\"to=\"500\"dur=\"2s\"repeatCount=\"indefinite\"></animate></rect></svg>```###`animateTransform`>`animate`不支持t`ransform`,要使用`animateTransform````html//一个方块围绕一个点旋转<svgwidth=\"5000\"height=\"5000\"><rectx=\"250\"y=\"0\"width=\"50\"height=\"50\"fill=\"orange\"><animateTransformattributeName=\"transform\"type=\"rotate\"begin=\"0s\"dur=\"10s\"from=\"0200200\"to=\"360400400\"repeatCount=\"indefinite\"></animateTransform></rect></svg>//from和to:第一个数是旋转角度,后两个是旋转中心```##拓展(js操作)##pao.svg源码```html<svgt=\"1600084741580\"class=\"icon\"viewBox=\"0023031024\"version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"p-id=\"4565\"width=\"200\"height=\"200\"><pathd=\"M59.238716644.951169l31.864078-5.365429-18.286258-98.548695-31.8640785.365428a50.04083750.040837000-40.0764758.47222650.15033650.15033600058.36272840.07647z\"fill=\"#EB3D72\"p-id=\"4566\"></path><pathd=\"M663.342217532.934152C539.061362532.934152437.9942637.724264437.9942766.494559s101.17666233.450909225.457515233.450909S888.799731895.264854888.799731766.494559s-101.067162-233.560407-225.457514-233.560407zM842.372346744.594849H713.383054l92.307278-92.416776A187.790013187.790013001842.372346744.594849zm-157.349417-28.360124V581.113514a176.402164176.40216400193.51176241.718947zm-39.966970l-94.935243-94.935243A177.059156177.059156001645.055959580.347024zm096.577721v139.501153a176.402164176.402164001-97.344211-42.375939zm39.96697138.077672V812.812446L780.505665908.842674a176.511663176.511663001-95.59223443.79942s0.109499-1.4234810.109498-1.751976zM522.417583650.207099L616.805333744.594849h-132.493246a190.198982190.19898200138.105496-94.38775zm-38.54349134.354721h132.93124l-95.9207395.92073a189.651489189.651489001-37.01051-95.92073zm323.45871793.949756l-93.949756-93.949756H843.138836a189.213495189.213495001-35.80602693.949756z\"fill=\"#684821\"p-id=\"4567\"></path><pathd=\"M1630.214414460.446112L344.263442781.276863a235.093387235.093387001-273.746376-188.118509234.764891234.764891001188.118509-273.746375l1312.121126-179.139628z\"fill=\"#44286E\"p-id=\"4568\"></path><pathd=\"M383.792418644.403676A235.421883235.421883001105.994597419.712651a233.998402233.998402000-35.696528173.445703235.093387235.093387000273.746375188.118509l1285.950973-320.830751L1607.657713339.450214z\"fill=\"#44286E\"opacity=\".4\"p-id=\"4569\"></path><pathd=\"M1531.86513159.038079m38.217356-7.103868l0.107655-0.020011q38.217356-7.10386845.32122431.113488l73.239881394.015557q7.10386838.217356-31.11348845.321224l-0.1076550.020011q-38.2173567.103868-45.321224-31.113488l-73.23988-394.015557q-7.103868-38.21735631.113487-45.321224Z\"fill=\"#EB3D72\"p-id=\"4570\"></path><pathd=\"M376.3465171023.049662H140.596138a21.8997121.899710110-42.704434H364.630172l133.369234-208.047246L386.529882259.516272a21.8997121.8997100141.828446-9.088379l113.330999521.322597A21.8997121.89971001538.732867788.394269L394.194781013.194793a21.1332221.13322001-17.8482639.854869z\"fill=\"#EB3D72\"p-id=\"4571\"></path><pathd=\"M596.6576574.215105C484.531084574.215105394.19478667.945864394.19478784.342823s90.883797210.127718203.010312210.127718S799.339416900.411286799.339416784.342823s-90.664799-210.127718-202.681816-210.127718zm0276.593338a66.4656266.4656201164.16615-66.4656265.6991365.69913001-64.1661566.46562z\"fill=\"#684821\"p-id=\"4572\"></path><pathd=\"M596.65761018.341224C472.2672471018.341224371.200085913.113118371.200085784.342823s101.067162-233.450909225.457515-233.450909225.457515104.680614225.457514233.450909S720.9384541018.341224596.65761018.341224zm0-420.255435C497.123417597.538296416.09449681.304687416.09449784.342823s81.028927186.804526180.56311186.804526S777.439706886.942964777.439706784.342823s-81.357423-186.804526-180.782106-186.804527z\"fill=\"#A56F34\"p-id=\"4573\"></path><pathd=\"M824.414584430.662506c10.183365-2.18997161.100191-21.24271950.040837-71.72155s-54.749275-39.309979-54.749275-39.30998A32.84956532.849565010834.050456383.249634s-3.3944557.445901-22.666210.949855-33.944551-11.825843-39.857472-38.433991c-5.365429-24.63717413.796817-91.321791102.600142-120.448405l-100.95766413.687318c-32.84956532.849565-47.96036574.897008-39.200481114.97347815.98678873.03553380.15293968.98408790.44580366.684617z\"fill=\"#EB3D72\"p-id=\"4574\"></path><pathd=\"M2141.134649160.639081m-145.0855790a145.085579145.085579010290.1711580145.085579145.085579010-290.1711580Z\"fill=\"#212121\"p-id=\"4575\"></path><pathd=\"M2147.704562178.377847c6.241417-4.37994235.149035-31.42608413.468321-62.195177s-47.522371-10.949855-47.52237-10.949855a24.52767524.527675000-7.00790733.83505224.63717424.63717400034.2730465.036933s05.912922-12.15433913.687319-26.1701531.53298-37.558003-14.672806-17.410269-73.58302648.507858-120.448405a78.61995978.6199590016.898408-4.27044331.86407831.864078000-36.134521-10.949855c-55.73476245.3324-71.502553109.49855-42.266441151.217498a57.26774257.26774200079.49594819.709739z\"fill=\"#3F3F3F\"p-id=\"4576\"></path><pathd=\"M1907.245746168.960971l-120.77690127.922131M1786.468845212.431896a15.54879415.548794001-3.503954-30.769093l120.448406-27.812632a15.54879415.5487940117.00790730.331099l-120.44840527.812631a13.35882313.358823001-3.5039540.437995zM1908.888224268.166658l-57.3772413.906316M1851.510984297.621768a15.54879415.548794001-3.722951-30.659594l57.486739-13.906316a15.54879415.5487940117.33640330.2216l-57.26774213.906315a15.00130115.001301001-3.8324490.437995z\"fill=\"#C6C5C4\"p-id=\"4577\"></path><pathd=\"M578.261843577.938056m14.0158150l11.9353410q14.015814014.01581514.015814l0380.945456q014.015814-14.01581514.015815l-11.9353410q-14.0158140-14.015815-14.015815l0-380.945456q0-14.01581414.015815-14.015814Z\"fill=\"#A56F34\"p-id=\"4578\"></path><pathd=\"M728.72802623.635756m9.9106779.910678l8.4395618.439561q9.9106779.910677019.821355l-269.369115269.369115q-9.9106779.910677-19.8213540l-8.439562-8.439561q-9.910677-9.9106770-19.821355l269.369115-269.369115q9.910677-9.91067719.8213550Z\"fill=\"#A56F34\"p-id=\"4579\"></path><pathd=\"M802.733871762.333614m014.015815l011.935342q014.015814-14.01581514.015814l-380.9454550q-14.0158140-14.015815-14.015814l0-11.935342q0-14.01581414.015815-14.015815l380.9454550q14.015814014.01581514.015815Z\"fill=\"#A56F34\"p-id=\"4580\"></path><pathd=\"M757.041256912.796584m-9.9106779.910677l-8.4395618.439561q-9.9106779.910677-19.8213550l-269.369115-269.369115q-9.910677-9.9106770-19.821354l8.439561-8.439562q9.910677-9.91067719.8213550l269.369115269.369115q9.9106779.910677019.821355Z\"fill=\"#A56F34\"p-id=\"4581\"></path><pathd=\"M2141.134649321.273454a160.634373160.634373011160.634373-160.634373160.85337160.85337001-160.634373160.634373zm0-290.171157a129.536785129.536785010129.427286129.536784129.755782129.755782000-129.427286-129.536784z\"fill=\"#3F3F3F\"p-id=\"4582\"></path><pathd=\"M551.3252784.342823a48.61735646.974878901093.949756048.61735646.9748789010-93.9497560Z\"fill=\"#BC7F42\"p-id=\"4583\"></path><pathd=\"M576.290869784.342823a22.77569822.009209901044.018417022.77569822.0092099010-44.0184170Z\"fill=\"#CE9663\"p-id=\"4584\"></path><pathd=\"M1612.147153491.215204a38.98148438.98148400045.44189931.20708738.87198538.87198500031.097588-45.3324l-28.031629-150.9985-75.66349818.614753z\"fill=\"#D83269\"p-id=\"4585\"></path><pathd=\"M2220.411599209.037441m-15.4392960a15.43929615.43929601030.878592015.43929615.439296010-30.8785920Z\"fill=\"#FFFFFF\"p-id=\"4586\"></path></svg>```<svgt=\"1600084741580\"class=\"icon\"viewBox=\"0023031024\"version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"p-id=\"4565\"width=\"200\"height=\"200\"><pathd=\"M59.238716644.951169l31.864078-5.365429-18.286258-98.548695-31.8640785.365428a50.04083750.040837000-40.0764758.47222650.15033650.15033600058.36272840.07647z\"fill=\"#EB3D72\"p-id=\"4566\"></path><pathd=\"M663.342217532.934152C539.061362532.934152437.9942637.724264437.9942766.494559s101.17666233.450909225.457515233.450909S888.799731895.264854888.799731766.494559s-101.067162-233.560407-225.457514-233.560407zM842.372346744.594849H713.383054l92.307278-92.416776A187.790013187.790013001842.372346744.594849zm-157.349417-28.360124V581.113514a176.402164176.40216400193.51176241.718947zm-39.966970l-94.935243-94.935243A177.059156177.059156001645.055959580.347024zm096.577721v139.501153a176.402164176.402164001-97.344211-42.375939zm39.96697138.077672V812.812446L780.505665908.842674a176.511663176.511663001-95.59223443.79942s0.109499-1.4234810.109498-1.751976zM522.417583650.207099L616.805333744.594849h-132.493246a190.198982190.19898200138.105496-94.38775zm-38.54349134.354721h132.93124l-95.9207395.92073a189.651489189.651489001-37.01051-95.92073zm323.45871793.949756l-93.949756-93.949756H843.138836a189.213495189.213495001-35.80602693.949756z\"fill=\"#684821\"p-id=\"4567\"></path><pathd=\"M1630.214414460.446112L344.263442781.276863a235.093387235.093387001-273.746376-188.118509234.764891234.764891001188.118509-273.746375l1312.121126-179.139628z\"fill=\"#44286E\"p-id=\"4568\"></path><pathd=\"M383.792418644.403676A235.421883235.421883001105.994597419.712651a233.998402233.998402000-35.696528173.445703235.093387235.093387000273.746375188.118509l1285.950973-320.830751L1607.657713339.450214z\"fill=\"#44286E\"opacity=\".4\"p-id=\"4569\"></path><pathd=\"M1531.86513159.038079m38.217356-7.103868l0.107655-0.020011q38.217356-7.10386845.32122431.113488l73.239881394.015557q7.10386838.217356-31.11348845.321224l-0.1076550.020011q-38.2173567.103868-45.321224-31.113488l-73.23988-394.015557q-7.103868-38.21735631.113487-45.321224Z\"fill=\"#EB3D72\"p-id=\"4570\"></path><pathd=\"M376.3465171023.049662H140.596138a21.8997121.899710110-42.704434H364.630172l133.369234-208.047246L386.529882259.516272a21.8997121.8997100141.828446-9.088379l113.330999521.322597A21.8997121.89971001538.732867788.394269L394.194781013.194793a21.1332221.13322001-17.8482639.854869z\"fill=\"#EB3D72\"p-id=\"4571\"></path><pathd=\"M596.6576574.215105C484.531084574.215105394.19478667.945864394.19478784.342823s90.883797210.127718203.010312210.127718S799.339416900.411286799.339416784.342823s-90.664799-210.127718-202.681816-210.127718zm0276.593338a66.4656266.4656201164.16615-66.4656265.6991365.69913001-64.1661566.46562z\"fill=\"#684821\"p-id=\"4572\"></path><pathd=\"M596.65761018.341224C472.2672471018.341224371.200085913.113118371.200085784.342823s101.067162-233.450909225.457515-233.450909225.457515104.680614225.457514233.450909S720.9384541018.341224596.65761018.341224zm0-420.255435C497.123417597.538296416.09449681.304687416.09449784.342823s81.028927186.804526180.56311186.804526S777.439706886.942964777.439706784.342823s-81.357423-186.804526-180.782106-186.804527z\"fill=\"#A56F34\"p-id=\"4573\"></path><pathd=\"M824.414584430.662506c10.183365-2.18997161.100191-21.24271950.040837-71.72155s-54.749275-39.309979-54.749275-39.30998A32.84956532.849565010834.050456383.249634s-3.3944557.445901-22.666210.949855-33.944551-11.825843-39.857472-38.433991c-5.365429-24.63717413.796817-91.321791102.600142-120.448405l-100.95766413.687318c-32.84956532.849565-47.96036574.897008-39.200481114.97347815.98678873.03553380.15293968.98408790.44580366.684617z\"fill=\"#EB3D72\"p-id=\"4574\"></path><pathd=\"M2141.134649160.639081m-145.0855790a145.085579145.085579010290.1711580145.085579145.085579010-290.1711580Z\"fill=\"#212121\"p-id=\"4575\"></path><pathd=\"M2147.704562178.377847c6.241417-4.37994235.149035-31.42608413.468321-62.195177s-47.522371-10.949855-47.52237-10.949855a24.52767524.527675000-7.00790733.83505224.63717424.63717400034.2730465.036933s05.912922-12.15433913.687319-26.1701531.53298-37.558003-14.672806-17.410269-73.58302648.507858-120.448405a78.61995978.6199590016.898408-4.27044331.86407831.864078000-36.134521-10.949855c-55.73476245.3324-71.502553109.49855-42.266441151.217498a57.26774257.26774200079.49594819.709739z\"fill=\"#3F3F3F\"p-id=\"4576\"></path><pathd=\"M1907.245746168.960971l-120.77690127.922131M1786.468845212.431896a15.54879415.548794001-3.503954-30.769093l120.448406-27.812632a15.54879415.5487940117.00790730.331099l-120.44840527.812631a13.35882313.358823001-3.5039540.437995zM1908.888224268.166658l-57.3772413.906316M1851.510984297.621768a15.54879415.548794001-3.722951-30.659594l57.486739-13.906316a15.54879415.5487940117.33640330.2216l-57.26774213.906315a15.00130115.001301001-3.8324490.437995z\"fill=\"#C6C5C4\"p-id=\"4577\"></path><pathd=\"M578.261843577.938056m14.0158150l11.9353410q14.015814014.01581514.015814l0380.945456q014.015814-14.01581514.015815l-11.9353410q-14.0158140-14.015815-14.015815l0-380.945456q0-14.01581414.015815-14.015814Z\"fill=\"#A56F34\"p-id=\"4578\"></path><pathd=\"M728.72802623.635756m9.9106779.910678l8.4395618.439561q9.9106779.910677019.821355l-269.369115269.369115q-9.9106779.910677-19.8213540l-8.439562-8.439561q-9.910677-9.9106770-19.821355l269.369115-269.369115q9.910677-9.91067719.8213550Z\"fill=\"#A56F34\"p-id=\"4579\"></path><pathd=\"M802.733871762.333614m014.015815l011.935342q014.015814-14.01581514.015814l-380.9454550q-14.0158140-14.015815-14.015814l0-11.935342q0-14.01581414.015815-14.015815l380.9454550q14.015814014.01581514.015815Z\"fill=\"#A56F34\"p-id=\"4580\"></path><pathd=\"M757.041256912.796584m-9.9106779.910677l-8.4395618.439561q-9.9106779.910677-19.8213550l-269.369115-269.369115q-9.910677-9.9106770-19.821354l8.439561-8.439562q9.910677-9.91067719.8213550l269.369115269.369115q9.9106779.910677019.821355Z\"fill=\"#A56F34\"p-id=\"4581\"></path><pathd=\"M2141.134649321.273454a160.634373160.634373011160.634373-160.634373160.85337160.85337001-160.634373160.634373zm0-290.171157a129.536785129.536785010129.427286129.536784129.755782129.755782000-129.427286-129.536784z\"fill=\"#3F3F3F\"p-id=\"4582\"></path><pathd=\"M551.3252784.342823a48.61735646.974878901093.949756048.61735646.9748789010-93.9497560Z\"fill=\"#BC7F42\"p-id=\"4583\"></path><pathd=\"M576.290869784.342823a22.77569822.009209901044.018417022.77569822.0092099010-44.0184170Z\"fill=\"#CE9663\"p-id=\"4584\"></path><pathd=\"M1612.147153491.215204a38.98148438.98148400045.44189931.20708738.87198538.87198500031.097588-45.3324l-28.031629-150.9985-75.66349818.614753z\"fill=\"#D83269\"p-id=\"4585\"></path><pathd=\"M2220.411599209.037441m-15.4392960a15.43929615.43929601030.878592015.43929615.439296010-30.8785920Z\"fill=\"#FFFFFF\"p-id=\"4586\"></path></svg>","HTML\\temp.md":"#tempnote##允许链接跨域`<metaname=\"referrer\"content=\"no-referrer\"/>`","HTML\\textArea.md":"#textArea-其他常用设置:-去除右下角的三角形的图标:`resize:none`|属性|值|描述||-----------|---------|----------------------------------------||cols|number|文本区的可见宽度||rows|number|文本可见行数||readonly|readonly|规定文本区为只读||disabled|disabled|禁用该文本区||form|form_id|规定文本区域所属一个活多个表单||maxlength|number|文本区域的最大字符数||placeholder|text|提示文字||required|required|文本域是必填||autofocus|autofocus|页面加载后文本域自动获得焦点||wrap|hardsorf|规定表单提交时,文本区域中的文本如何换行|-wrap属性-wrap:文本区会包含一行文本，用户必须将光标移动到右边才能看到全部文本，这时将把一行文本传送给服务器。-virtual:文本区会包含两行文本，并在单词\"makes\"后面换行。但是只有一行文本被传送到服务器：没有嵌入新行字符。-physical:文本区会包含两行文本，并在单词\"makes\"后面换行，这时发送给服务器两行文本，单词\"makes\"后的新行字符将分隔这两行文本。","HTML\\video.md":"#video>https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video>>[使用JS获取视频Codec(jackpu.com)](https://jackpu.com/shi-yong-js-huo-qu-shi-pin-codec/)>>素材[DownloadSampleVideos/DummyVideosForDemoUse(sample-videos.com)](https://sample-videos.com/index.php#sample-mp4-video)##使用```html<videowidth=\"320\"height=\"240\"controls><sourcesrc=\"movie.mp4\"type=\"video/mp4\"/><sourcesrc=\"movie.ogg\"type=\"video/ogg\"/>您的浏览器不支持video标签。</video>```##自带属性&方法|属性/方法|desc||----------------|-------------------------------------||currentTime|当前视频播放时间(s)||duration|当前视频播放时长(s)||volume|声音[0-1]||paused|暂停||ended|结束||play()|播放||pause()|暂停||loadedmetadata()|视频加载获取数据(获取duration)||timeupdate()|视频变化事件,(获取实时的currentTime)||ended()|视频播放结束事件||volumechange()|视频声音事件|","HTML\\邮件模板\\index.md":"#邮件模板>邮件模板是outlook等邮件系统支持html解析格式的条件下，利用前端技术通过编写HTML文件生成期望的邮件页面，从而辅助编写邮件的邮件编辑方式。>>就是像写网页一样去写邮件。目前我们在163等邮箱中收到-知乎等网站推送的订阅期刊-京东等购物网站的流程通知-51JOB等招聘网站的职位推送-LinkedIn等社交网站的人脉拓展这些都是通过邮件模板的方式实现的。当然邮件模板的使用分为-手动改写（适用于固定内容群发）-后台系统自动编辑分发（适用于即使反馈、内容随不同用户而变化的）-...等多种方式![](./.assets/邮件模板-2022-12-01-16-32-28.png)##优势>1.适用于排版复杂>2.可复月>3.兼容性好>4.样式鱼内容分分离开##问题###OutLook-发送HTML邮件![](./.assets/邮件模板-2022-12-01-17-11-44.png)>无法直接编辑HTML邮件,要通过添加插件才可以发`HTML`的邮件-插件获取>获取加载项>搜索框输入`HTML`>选择下图的插件![](./.assets/邮件模板-2022-12-01-17-13-42.png)-通过插件发送HTML邮箱:![](./.assets/邮件模板-2022-12-01-17-14-40.png)-输入HTMl![](./.assets/邮件模板-2022-12-01-17-15-05.png)>问题:当前方法发送的HTML邮件,转发后,邮件样式会丢失","HTML\\邮件模板\\垃圾邮件.md":"#垃圾邮件##垃圾邮件特征的范畴-来自收件人从未发送过邮件的地址第一次发出的邮件，以及在该邮件未被收件人自定义为正常邮件的情况下随后从同一地址发送给收件人的其他邮件；-来自被拒绝过接收邮件的地址所发给收件人的其他邮件；-来自被收件人列入黑名单的邮件地址的邮件；-内容包含可被反垃圾装置或可被邮件过滤器定义、归类为垃圾邮件的关键字段的邮件；-带虚假、无效邮件头的邮件，带虚假、无效域名的邮件，经过技术处理的不显示任何邮件来源信息的邮件。带欺骗性地址信息的邮件；-未经同意而使用、中继或通过第三方的互联网设备所发送的邮件；-主题行或内容包含错误、误导或虚假信息的邮件；-主题或内容带敏感字眼的、违反国家法律法规或QQ邮箱服务条款的邮件。##如何避免邮件被当成垃圾邮件-邮件标题带有敏感字可能被当作内容违规邮件（内容中避开使用敏感词、合理布局图文结构）-触发式邮件容易被认定为垃圾广告或者钓鱼邮件-如果是订阅邮件，在邮件中添加退订链接;（提醒收件方将你添加至白名单，及时处理退信）-发送邮件所在的服务器的IP也很关键，可能会影响邮件服务提供商对你所发邮件的判断。-当发送大量邮件时，有计划地少量多批次发送；有一些技术手段可以防止非垃圾邮件被认为是垃圾邮件。比如配置SPF,DKIM记录;","JavaScript\\api\\Buffer.md":"#Buffer>buffer即缓存，是对二进制数据处理的一种方式##Uint\\*Array/ArrayBuffer>ArrayBuffer:基础的二进制对象,对固定长度的连续内存控件的引用>视图:`Uint8Array`,`Uint16Array`,`Uint32Array`-Uint8Array将ArrayBuffer中的每个字节视为一个单位。每个单位是0到255之间的数字。之所以是255，是因为每个单位最多是8位，即2^8次方。-Uint16Array将ArrayBuffer中每2个字节视为一个单位。每个单位是0到65535之间的整数。原理同上。-Uint32Array将ArrayBuffer中每4个字节视为一个单位。每个单位是0到4294967295之间的整数。原理同上。```js//通过BYTES_PER_ELEMENT静态属性来得之视图单位的大小constbuf8=newUint8Array()constbuf16=newUint16Array()constbuf32=newUint32Array()console.log(buf8.BYTES_PER_ELEMENT)//1console.log(buf16.BYTES_PER_ELEMENT)//2console.log(buf32.BYTES_PER_ELEMENT)//4```##Blob>浏览器环境一种承载原始数据的二进制对象,可以与`ArrayBuffer`相互转化##DataView>一种底层,更灵活读取`ArrayBuffer`的视图```jsconstbuffer=newArrayBuffer(16)//分配一个内存空间constview=newDataView(buffer)//创建DataView视图view.setUint32(0,4294967295)//从第0个空间开始，以32位的形式写入数据//有时候我想以8位的形式“翻译”这个内存空间，从偏移量0开始翻译console.log(view.getUint8(0))//255//今天心情好，想以16位的形式“翻译”这个内存空间，从偏移量0开始读console.log(view.getUint16(0))//65535//今天心情超好，想以32位的形式“翻译”这个内存空间，从偏移量0开始读console.log(view.getUint32(0))//4294967295```##Node中Buffer><http://nodejs.cn/api/buffer.html>","JavaScript\\api\\console.md":"#console-<https://developer.mozilla.org/zh-CN/docs/Web/API/Console_API>##trace-输出一个堆栈跟踪```jsfunctionfoo(){functionbar(){console.trace()}bar()}foo()```![](./.assets/console-2022-07-11-16-43-10.png)##table-`console.table({...})`![](./.assets/console-2022-07-15-14-33-25.png)##error-`console.err(“Thisiserror”)`![](./.assets/console-2022-07-15-14-33-40.png)##warn-`console.warn()`![](./.assets/console-2022-07-15-14-34-00.png)##Time&timelog&timeEnd-`console.time()、console.timeLog()、console.timeEnd()`:用来进行程序计时![](./.assets/console-2022-07-15-14-34-11.png)##assert-`console.assert(assert_statement,message)`:设定断言,如果assert_statement为false显示message消息-只有`assert_statement`为true的时候才会打印出来![](./.assets/console-2022-07-15-14-34-19.png)##count&countReset-`console.count()`:统计参数标签计数-`console.countReset()`:重置对应标签的计数![](./.assets/console-2022-07-15-14-34-27.png)###group&groupEnd-给log用缩进进行分组```jsleti=9console.group()while(i--){console.log(i)if(i%3===0){console.groupEnd()console.group()}}```![](./.assets/console-2022-07-11-16-47-56.png)##groupCollapsed&groupEnd-`groupCollapsed`和group类似,默认分组是关闭的```jsleti=9console.groupCollapsed('group')while(i--){console.log({i})if(i%3===0){console.groupEnd()console.groupCollapsed('group')}}```![](./.assets/console-2022-07-11-16-52-39.png)##info&log-控制台打印信息-log:打印日志-info:打印信息###拓展###CSS样式格式化打印-仅浏览器支持`console.log('123%c456','font-size:36px;color:red;');`![](./.assets/console-2022-07-11-16-41-28.png)###编码指定样式打印-可以使用[rh-color](https://www.npmjs.com/package/rh-color)包来体验-浏览器和终端均支持-代码样例`console.log('\\033[42;30mDONE\\033[40;32mCompiledsuccessfullyin19987ms\\033[0m')`-输出结果![](./.assets/console-2022-07-11-16-55-55.png)-解释-用绿底（42）黑字（30）显示“DONE”-然后使用黑底（40）绿字（32）显示余下的信息，最后还原属性（`\\033[0m`）####示例#####指定底色字体颜色-`console.log('\\033[42;30mDONE\\033[44;33mCompiledsuccessfullyin19987ms\\033[0m')`-等同:`console.log('\\033[42;30mDONE\\033[44;37mCompiledsuccessfullyin%dms\\033[0m',19987)`![](./.assets/console-2022-07-13-10-23-47.png)###常用属性-`\\033[42;30m`=>`\\033[背景色编号;字色编号m`-字色编号：30黑，31红，32绿，33黄，34蓝，35紫，36深绿，37白色-背景编号：40黑，41红，42绿，43黄，44蓝，45紫，46深绿，47白色|编码|描述||:----------|:---------------------||`\\033[0m`|关闭所有属性||`\\033[1m`|设置高亮度||`\\033[4m`|下划线||`\\033[5m`|闪烁||`\\033[7m`|反显||`\\033[8m`|消隐||`\\033[nA`|光标上移n行||`\\033[nB`|光标下移n行||`\\033[nC`|光标右移n列||`\\033[nD`|光标左移n列||`\\033[y;xH`|设置光标位置（y列x行）||`\\033[2J`|清屏||`\\033[K`|清除从光标到行尾的内容|###占位符|占位符|描述||-------|----------||`%s`|字符串||`%d%i`|整数||`%f`|浮点数||`%o`|DOM元素||`%O`|object对象||`%c`|css样式|","JavaScript\\api\\Cookie.md":"#Cookie>Cookie是服务端发送到用户浏览器并且保存到本地的一小块数据，它会在浏览器下次向同一服务器发起请求时，被携带到服务器上>作用:>>-经常用来做一些用户会话状态管理、个性化设置等等>-前端可以通过document.cookie来访问cookie>-cookie是跨域的，也就是在不同的域名中，访问的cookie的时候，只能访问对应的域名的cookie>特性:>-http:会自动懈怠Cookie>-携带的Cookie,还是请求所在域名的Cookie```jsexportconstsetCookie=functionsetCookie(name,value){//varDays=30;varexp=newDate()exp.setTime(exp.getTime()+120*60*1000)document.cookie=name+'='+escape(value)+';expires='+exp.toGMTString()+';path=/'}//读取cookiesexportconstgetCookie=functiongetCookie(name){vararr,reg=newRegExp('(^|)'+name+'=([^;]*)(;|$)')if((arr=document.cookie.match(reg)))returnunescape(arr[2])elsereturnnull}//删除cookiesexportconstdelCookie=functiondelCookie(name){varexp=newDate()exp.setTime(exp.getTime()-1)varcval=getCookie(name)if(cval!=null)document.cookie=name+'='+cval+';expires='+exp.toGMTString()+';path=/brand'document.cookie=name+'='+cval+';expires='+exp.toGMTString()+';path=/'}//使用示例//setCookie(\"name\",\"hayden\");//alert(getCookie(\"name\"));```##Cookie和CSRFCSRF，中文名叫跨站请求伪造，发生的场景就是，用户登陆了a网站，然后跳转到b网站，b网站直接发送一个a网站的请求，进行一些危险操作，就发生了CSRF攻击！这时候，懂得这个CSRF了吗？我认为一部分同学依然不懂，因为我看过太多这样的描述了！因为有这么一些疑惑，为什么在b网站可以仿造a网站的请求？Cookie不是跨域的吗？什么条件下，什么场景下，会发生这样的事情？这时候，我们要注意上面我对cookie的定义，在发送一个http请求的时候，携带的cookie是这个http请求域的地址的cookie。也就是我在b网站，发送a网站的一个请求，携带的是a网站域名下的cookie！很多同学的误解，就是觉得cookie是跨域的，b网站发送任何一个请求，我只能携带b网站域名下的cookie。当然，我们在b网站下，读取cookie的时候，只能读取b网站域名下的cookie，这是cookie的跨域限制。所以要记住，不要把http请求携带的cookie，和当前域名的访问权限的cookie混淆在一起。还要理解一个点：CSRF攻击，仅仅是利用了http携带cookie的特性进行攻击的，但是攻击站点还是无法得到被攻击站点的cookie。这个和XSS不同，XSS是直接通过拿到Cookie等信息进行攻击的。###应对CSRF攻击####方案一：放弃Cookie、使用Token由于CSRF是通过Cookie伪造请求的方式，欺骗服务器，来达到自己的目的。那么我们采取的策略就是，不使用Cookie的方式来验证用户身份，我们使用Token！Token的策略，一般就是登陆的时候，服务端在response中，返回一个token字段，然后以后所有的通信，前端就把这个token添加到http请求的头部。这是当前，最常用的防御CSRF攻击的策略。####方案二：SameSiteCookies前端在发展，Cookie也在进化，Cookie有一个新的属性——SateSite。能够解决CSRF攻击的问题。它表示，只能当前域名的网站发出的http请求，携带这个Cookie。当然，由于这是新的cookie属性，在兼容性上肯定会有问题。####方案三：服务端Referer验证我们发送的http请求中，header中会带有Referer字段，这个字段代表的是当前域的域名，服务端可以通过这个字段来判断，是不是“真正”的用户请求。也就是说，如果b网站伪造a网站的请求，Referer字段还是表明，这个请求是b网站的。也就能辨认这个请求的真伪了。不过，目前这种方案，使用的人比较少。可能存在的问题就是，如果连Referer字段都能伪造，怎么办？##XSSXSS是由于不安全的数据引起的，有可能是表单提交的数据，有可能是页面路径的参数问题。CSRF是通过伪造http请求，来达到自己的攻击目的。但是XSS是通过盗取用户的敏感信息而达到攻击的目的。比如本地存储、用户密码、cookie等等。比如这个不安全的数据，是一个script标签，那这个script就可以链接任意的js文件，浏览器本地就会执行这个js，那通过js我们能做的东西就太多了：比如document.cookie，获取用户信息。比如通过localStorage，获取本地存储的敏感信息（token）。然后只要是这个页面展示的任何信息，我都可以获取。###应对XSS攻击####方案一：http-onlyCookie有一个http-only属性，表示只能被http请求携带。假如你的网站遭受到XSS攻击，攻击者就无法通过document.cookie得到你的cookie信息。####方案二：正则校验我们了解到，XSS是由于不安全的数据引起的，这些数据的来源，一个重要的渠道就是提交表单，注入到数据库。所以针对前端，我们需要把表单数据进行正则验证，通过验证之后，才能提交数据。对于服务端，也应该对接受的数据，进行规则校验，不符合规则的数据不应该入库。从接口层面，保证数据安全。####方案三：数据转义如果无法保证数据库的数据都是安全的，前端能做的事情就是，把所有需要展示到页面的数据，进行转义，比如遇到script标签，直接replace处理。或者遇到标签标识‘<’以及‘>’这类特殊字符，添加‘\\’进行处理##Token1、cookie可以引起csrf攻击，token在保持用户会话的时候好一点。2、由于http请求携带cookie，当cookie过大的时候，会增大http请求的带宽。3、cookie的特性，导致了cookie面对CSRF攻击的时候，很不安全。","JavaScript\\api\\Math.md":"#Math##**Math扩展**-Math.trunc()方法用于去除一个数的小数部分，返回整数部分。```jsconsole.log(Math.trunc(5.5))//5console.log(Math.trunc(-5.5))//-5console.log(Math.trunc(true))//1console.log(Math.trunc(false))//0console.log(Math.trunc(NaN))//NaNconsole.log(Math.trunc(undefined))//NaNconsole.log(Math.trunc())//NaN```-Math.sign()方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。它会返回五种值。-参数为正数，返回+1-参数为负数，返回-1-参数为0，返回0-参数为-0，返回-0-其他值，返回NaN```jsconsole.log(Math.sign(5))//1console.log(Math.sign(-5))//-1console.log(Math.sign(0))//0console.log(Math.sign(NaN))//NaNconsole.log(Math.sign(true))//1console.log(Math.sign(false))//0```-Math.cbrt()方法用于计算一个数的立方根。```jsconsole.log(Math.cbrt(8))//2console.log(Math.cbrt('xx'))//NaN```","JavaScript\\api\\Reflect.md":"#Reflect><https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect>>>-拦截js操作的方法>-与proxy相同>-不是函数对象,不可以构造>-不可通过new运算符来调用>-方法与Object相同##apply>`Reflect.apply(target,thisArgument,argumentsList)`>>-target:目标函数>-thisArgument:target函数调用同事绑定的this对象>-argumentsList:实参列表>与`Function.prototype.apply()`方法类似```jsconsole.log(Reflect.apply(Math.floor,undefined,[1.75]))//expectedoutput:1​console.log(Reflect.apply(String.fromCharCode,undefined,[104,101,108,108,111]),)//expectedoutput:\"hello\"console.log(Reflect.apply(RegExp.prototype.exec,/ab/,['confabulation']).index)//expectedoutput:4console.log(Reflect.apply(''.charAt,'ponies',[3]))//expectedoutput:\"i\"```##construct>行为有点像new操作符构造函数，相当于运行newtarget(...args).>`Reflect.construct(target,argumentsList[,newTarget])`>target被运行的目标构造函数>argumentsList类数组，目标构造函数调用时的参数。>newTarget?作为新创建对象的原型对象的constructor属性，参考new.target操作符，默认值为target。>return以target（如果newTarget存在，则为newTarget）函数为构造函数，argumentList为其初始化参数的对象实例```jsvard=Reflect.construct(Date,[1776,6,4])dinstanceofDate//trued.getFullYear()//1776```##defineProperty>`Reflect.defineProperty(target,propertyKey,attributes)`>>-target目标对象>-propertyKey要定义或修改的属性的名称>-attributes要定义或修改的属性的描述>returnBoolean属性是否被成功定义。```jsletobj={}Reflect.defineProperty(obj,'x',{value:7})//trueobj.x//检查属性是否被重新定义if(Reflect.defineProperty(target,property,attributes)){//成功}else{//失败}```##deleteProperty>-静态方法Reflect.deleteProperty()允许用于删除属性>-很像deleteoperator，但它是一个函数>>`Reflect.deleteProperty(target,propertyKey)`>>-参数target删除属性的目标对象>-propertyKey需要删除的属性的名称>returnBoolean值表明该属性是否被成功删除```jsvarobj={x:1,y:2}Reflect.deleteProperty(obj,'x')//trueobj//{y:2}vararr=[1,2,3,4,5]Reflect.deleteProperty(arr,'3')//truearr//[1,2,3,,5]//如果属性不存在，返回trueReflect.deleteProperty({},'foo')//true//如果属性不可配置，返回falseReflect.deleteProperty(Object.freeze({foo:1}),'foo')//false```##get>对象(target[propertyKey])中读取属性类似，但它是通过一个函数执行来操作的>`Reflect.get(target,propertyKey[,receiver])`>>-target需要取值的目标对象>-propertyKey需要获取的值的键值>-receiver如果target对象中指定了getter，receiver则为getter调用时的this值。>returnany属性的值```js//Objectvarobj={x:1,y:2}Reflect.get(obj,'x')//1//ArrayReflect.get(['zero','one'],1)//\"one\"//Proxywithagethandlervarx={p:1}varobj=newProxy(x,{get(t,k,r){returnk+'bar'},})Reflect.get(obj,'foo')//\"foobar\"```##getOwnPropertyDescriptor>-静态方法`Reflect.getOwnPropertyDescriptor()`与`Object.getOwnPropertyDescriptor()`方法相似>-如果在对象中存在，则返回给定的属性的属性描述符。否则返回undefined。>`Reflect.getOwnPropertyDescriptor(target,propertyKey)`>-target需要寻找属性的目标对象>-propertyKey获取自己的属性描述符的属性的名称>returnany如果属性存在于给定的目标对象中，则返回属性描述符；否则，返回undefined```jsReflect.getOwnPropertyDescriptor({x:'hello'},'x')//{value:\"hello\",writable:true,enumerable:true,configurable:true}Reflect.getOwnPropertyDescriptor({x:'hello'},'y')//undefinedReflect.getOwnPropertyDescriptor([],'length')//{value:0,writable:true,enumerable:false,configurable:false}```###与Object.getOwnPropertyDescriptor()的不同点>如果该方法的第一个参数不是一个对象（一个原始值），那么将造成TypeError错误>而对于Object.getOwnPropertyDescriptor，非对象的第一个参数将被强制转换为一个对象处理```jsReflect.getOwnPropertyDescriptor('foo',0)//TypeError:\"foo\"isnotnon-nullobjectObject.getOwnPropertyDescriptor('foo',0)//{value:\"f\",writable:false,enumerable:true,configurable:false}```##getPrototypeOf>-静态方法Reflect.getPrototypeOf()与Object.getPrototypeOf()方法几乎是一样的>-都是返回指定对象的原型（即内部的[[Prototype]]属性的值）>`Reflect.getPrototypeOf(target)`>-target获取原型的目标对象>-return给定对象的原型。如果给定对象没有继承的属性，则返回null```jsReflect.getPrototypeOf({})//Object.prototypeReflect.getPrototypeOf(Object.prototype)//nullReflect.getPrototypeOf(Object.create(null))//null```###与object.getPrototypeOf比较```js//如果参数为Object，返回结果相同Object.getPrototypeOf({})//Object.prototypeReflect.getPrototypeOf({})//Object.prototype//在ES5规范下，对于非Object，抛异常Object.getPrototypeOf('foo')//ThrowsTypeErrorReflect.getPrototypeOf('foo')//ThrowsTypeError//在ES2015规范下，Reflect抛异常,Object强制转换非ObjectObject.getPrototypeOf('foo')//String.prototypeReflect.getPrototypeOf('foo')//ThrowsTypeError//如果想要模拟Object在ES2015规范下的表现，需要强制类型转换Reflect.getPrototypeOf(Object('foo'))//String.prototype```##has>静态方法Reflect.has()作用与in操作符相同>>`Reflect.has(target,propertyKey)`>>target目标对象>propertyKey属性名，需要检查目标对象是否存在此属性>returnBoolean是否存在此属性```jsReflect.has({x:0},'x')//trueReflect.has({x:0},'y')//false//如果该属性存在于原型链中，返回trueReflect.has({x:0},'toString')//Proxy对象的.has()句柄方法obj=newProxy({},{has(t,k){returnk.startsWith('door')},},)Reflect.has(obj,'doorbell')//trueReflect.has(obj,'dormitory')//false```##isExtensible>静态方法Reflect.isExtensible()判断一个对象是否可扩展（即是否能够添加新的属性）>与它Object.isExtensible()>`Reflect.isExtensible(target)`>>-target检查是否可扩展的目标对象。>returnBoolean是否可扩展。```js//Newobjectsareextensible.varempty={}Reflect.isExtensible(empty)//===true//...butthatcanbechanged.Reflect.preventExtensions(empty)Reflect.isExtensible(empty)//===false//Sealedobjectsarebydefinitionnon-extensible.varsealed=Object.seal({})Reflect.isExtensible(sealed)//===false//Frozenobjectsarealsobydefinitionnon-extensible.varfrozen=Object.freeze({})Reflect.isExtensible(frozen)//===false```##与Object.isExtensible()的不同点>如果该方法的第一个参数不是一个对象（原始值），那么将造成一个TypeError异常>对于Object.isExtensible()，非对象的第一个参数会被强制转换为一个对象```jsReflect.isExtensible(1)//TypeError:1isnotanobjectObject.isExtensible(1)//false```##ownKeys>`Reflect.ownKeys(target)`>静态方法`Reflect.ownKeys()`返回一个由目标对象自身的属性键组成的数组。```jsReflect.ownKeys({z:3,y:2,x:1})//[\"z\",\"y\",\"x\"]Reflect.ownKeys([])//[\"length\"]varsym=Symbol.for('comet')varsym2=Symbol.for('meteor')varobj={[sym]:0,str:0,773:0,0:0,[sym2]:0,'-1':0,8:0,'secondstr':0,}Reflect.ownKeys(obj)//[\"0\",\"8\",\"773\",\"str\",\"-1\",\"secondstr\",Symbol(comet),Symbol(meteor)]//Indexesinnumericorder,//stringsininsertionorder,//symbolsininsertionorder```##preventExtensions>`Reflect.preventExtensions(target)`>>-target:阻止的目标对象>-returnboolean是否可以拓展>-阻止新属性添加到对象(例如：防止将来对对象的扩展被添加到对象中)>-与`Object.preventExtensions()`相似```js//Objectsareextensiblebydefault.varempty={}Reflect.isExtensible(empty)//===true//...butthatcanbechanged.Reflect.preventExtensions(empty)Reflect.isExtensible(empty)//===falseReflect.preventExtensions(1)//TypeError:1isnotanobjectObject.preventExtensions(1)//1```##set>-在一个对象上设置一个属性>-静态方法>>`Reflect.set(target,propertyKey,value[,receiver])`>>-target:设置属性的目标对象>-propertyKey:设置属性的名称>-value:设置的值>-receiver?如果有setter,receiver则为setter调用时的this值>returnboolean是否设置成功```js//Objectvarobj={}Reflect.set(obj,'prop','value')//trueobj.prop//\"value\"//Arrayvararr=['duck','duck','duck']Reflect.set(arr,2,'goose')//truearr[2]//\"goose\"//Itcantruncateanarray.Reflect.set(arr,'length',1)//truearr//[\"duck\"];//Withjustoneargument,propertyKeyandvalueare\"undefined\".varobj={}Reflect.set(obj)//trueReflect.getOwnPropertyDescriptor(obj,'undefined')//{value:undefined,writable:true,enumerable:true,configurable:true}```##setPrototypeOf>除了返回类型以外，静态方法Reflect.setPrototypeOf()与Object.setPrototypeOf()方法是一样的。>它可设置对象的原型（即内部的[[Prototype]]属性）为另一个对象或null，>如果操作成功返回true，否则返回false。>>`Reflect.setPrototypeOf(target,prototype)`>>-target:设置原型的目标对象>-prototype:对象的新原型（一个对象或null）>returnboolean是否成功设置```jsReflect.setPrototypeOf({},Object.prototype)//true//Itcanchangeanobject's[[Prototype]]tonull.Reflect.setPrototypeOf({},null)//true//Returnsfalseiftargetisnotextensible.Reflect.setPrototypeOf(Object.freeze({}),null)//false//Returnsfalseifitcauseaprototypechaincycle.vartarget={}varproto=Object.create(target)Reflect.setPrototypeOf(target,proto)//false```","JavaScript\\api\\window\\getSelection.md":"#getSelection>用户选择范围或光标的当前位置-与`Document.getSelection()`等价-值得注意的是，目前在Firefox,Edge(非Chromium版本)及InternetExplorer中，`getSelection()`对`<textarea>`及`<input>`元素不起作用。`HTMLInputElement.setSelectionRange()`或`selectionStart`及`selectionEnd`属性可用于解决此问题-还要注意选择不同于焦点（详见Selection及输入焦点）。可使用`Document.activeElement`来返回当前的焦点元素```jsletselObj=window.getSelection()console.log(selObj)letselRange=selObj.getRangeAt(0)```![](./.assets/getSelection-2022-10-24-16-34-36.png)##术语-锚点（anchor）>锚指的是一个选区的起始点。当我们使用鼠标选择一个区域的时候，锚点就是我们鼠标按下瞬间的那个点。在用户拖动鼠标时，锚点是不会变的。-焦点（focus）选区的焦点是该选区的终点，当您用鼠标框选一个选区的时候，焦点是你的鼠标松开瞬间所记录的那个点。随着用户拖动鼠标，焦点的位置会随着改变。-范围（range）范围指的是文档中连续的一部分。一个范围包括整个节点，也可以包含节点的一部分，例如文本节点的一部分。用户通常下只能选择一个范围。“范围”会被作为range对象返回。Range对象也能通过DOM创建、增加、删减。##属性-`anchorNode`:返回该选区起点所在的节点-`anchorOffset`:-返回一个数字，表示该选区起点在anchorNode中的位置偏移量-如果anchorNode是文字节点，那么返回的就是从该文字节点的第一个字开始，直到被选中的第一个字之间的字数（如果第一个字就被选中，那么偏移量为零）-如果anchorNode是一个元素，那么返回的就是在选区第一个节点之前的同级节点总数。(这些节点都是anchorNode的子节点)-`focusNode`:返回该选区终点所在的节点-`focusOffset`:-返回一个数字，表示该选区终点在focusNode中的位置偏移量-如果focusNode是文字节点，那么选区末尾未被选中的第一个字，在该文字节点中是第几个字（从0开始计），就返回它。-如果focusNode是一个元素，那么返回的就是在选区末尾之后第一个节点之前的同级节点总数-`isCollapsed`:返回一个布尔值，用于判断选区的起始点和终点是否在同一位置-`rangeCount`:返回一个数字，表示该选区所包含的连续范围的数量。一般为1，因为通常情况下用户只能选择一个范围##方法-`getRangeAt`:-返回选区开始的节点（Node）-因为通常情况下用户只能选择一个范围，所以只有一个选区（range），此方法一般为getRangeAt(0)-`collapse`(光标落在的目标节点,offset):将当前的选区折叠为一个点-`extend`:将选区的焦点移动到一个特定的位置。-`modify`:修改当前的选区-`collapseToStart`:将当前的选区折叠到起始点-`collapseToEnd`:将当前的选区折叠到最末尾的一个点-`selectAllChildren`:将某一指定节点的子节点框入选区-`addRange`:一个区域（Range）对象将被加入选区-`removeRange`:从选区中移除一个区域-`removeAllRanges`:将所有的区域都从选区中移除-`deleteFromDocument`:从页面中删除选区中的内容-`selectionLanguageChange`:当键盘的朝向发生改变后修改指针的Bidi优先级-`toString`:返回当前选区的纯文本内容-`containsNode`:判断某一个node是否为当前选区的一部分##拓展###替换选中-待测试```js//替换选中文本内容，参数text为要替换的内容functionrepaceSelectionText(text){//非IE浏览器if(window.getSelection){varsel=window.getSelection()alert(sel.rangeCount)//选区个数,通常为1.sel.deleteFromDocument()//清除选择的内容varr=sel.getRangeAt(0)//即使已经执行了deleteFromDocument(),这个函数仍然返回一个有效对象.varselFrag=r.cloneContents()//克隆选择的内容varfrag=selFrag.childNodes//如果执行了deleteFromDocument(),这个数组长度将会是0for(vari=0;i<frag.length;i++){alert(frag[i].nodeName)//枚举选择的对象}varh1=document.createElement('H1')//生成一个插入对象h1.innerHTML=text//设置这个对象的内容r.insertNode(h1)//把对象插入到选区,这个操作不会替换选择的内容,而是追加到选区的后面,所以如果需要普通粘贴的替换效果,之前执行deleteFromDocument()函数.}elseif(document.selection&&document.selection.createRange){//IE浏览器varsel=document.selection.createRange()//获得选区对象alert(sel.htmlText)//选择区的html文本.sel.pasteHTML('<h1>标题</h1>')//粘贴到选区的html内容,会替换选择的内容.}}```###插入文字-待测试```jsfunctioninsertSelectionText(html){if(document.selection&&document.selection.createRange){/****这里需要解决IE丢失光标位置的问题，详见核心代码四**************/document.selection.createRange().pasteHTML(html)}else{varselection=document.getSelection()varrangeif(selection){range=selection.getRangeAt(0)}else{range=iframeDocument.createRange()}varoFragment=range.createContextualFragment(html),oLastNode=oFragment.lastChildrange.insertNode(oFragment)range.setEndAfter(oLastNode)range.setStartAfter(oLastNode)selection.removeAllRanges()//清除选择selection.addRange(range)}}```","JavaScript\\api\\特殊标记.md":"#特殊符号##⇠箭头类|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||⇠|&#8672|u21E0|21E0|⇢|&#8674|u21E2|21E2||⇡|&#8673|u21E1|21E1|⇣|&#8675|u21E3|21E3||↞|&#8606|u219E|219E|↠|&#8608|u21A0|21A0||↟|&#8607|u219F|219F|↡|&#8609|u21A1|21A1||←|&#8592|u2190|2190|→|&#8594|u2192|2192||↑|&#8593|u2191|2191|↓|&#8595|u2193|2193||↔|&#8596|u2194|2194|↕|&#8597|u2195|2195||⇄|&#8644|u21C4|21C4|⇅|&#8645|u21C5|21C5||↢|&#8610|u21A2|21A2|↣|&#8611|u21A3|21A3||⇞|&#8670|u21DE|21DE|⇟|&#8671|u21DF|21DF||↫|&#8619|u21AB|21AB|↬|&#8620|u21AC|21AC||⇜|&#8668|u21DC|21DC|⇝|&#8669|u21DD|21DD||↚|&#8602|u219A|219A|↛|&#8603|u219B|219B||↮|&#8622|u21AE|21AE|↭|&#8621|u21AD|21AD||⇦|&#8678|u21E6|21E6|⇨|&#8680|u21E8|21E8||⇧|&#8679|u21E7|21E7|⇩|&#8681|u21E9|21E9||▲|&#9650|u25B2|25B2|►|&#9658|u25BA|25BA||▼|&#9660|u25BC|25BC|◄|&#9668|u25C4|25C4||➔|&#10132|u2794|2794|➙|&#10137|u2799|2799||➨|&#10152|u27A8|27A8|➲|&#10162|u27B2|27B2||➜|&#10140|u279C|279C|➞|&#10142|u279E|279E||➟|&#10143|u279F|279F|➠|&#10144|u27A0|27A0||➤|&#10148|u27A4|27A4|➥|&#10149|u27A5|27A5||➦|&#10150|u27A6|27A6|➧|&#10151|u27A7|27A7||➵|&#10165|u27B5|27B5|➸|&#10168|u27B8|27B8||➼|&#10172|u27BC|27BC|➽|&#10173|u27BD|27BD||➺|&#10170|u27BA|27BA|➳|&#10163|u27B3|27B3||↷|&#8631|u21B7|21B7|↶|&#8630|u21B6|21B6||↻|&#8635|u21BB|21BB|↺|&#8634|u21BA|21BA||↵|&#8629|u21B5|21B5|↯|&#8623|u21AF|21AF||➾|&#10174|u27BE|27BE|##❤基本形状类|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:-----------|:----|:---|:---|:------|:----|:---||❤|&#10084|u2764|2764|✈|&#9992|u2708|2708||★|&#9733|u2605|2605|✦|&#10022|u2726|2726||☀|&#9728|u2600|2600|◆|&#9670|u25C6|25C6||◈|&#9672u25C8|25C8|▣|&#|9635|u25A3|25A3||☻|&#9787|u263B|263B|☺|&#9786|u263A|263A||☹|&#9785|u2639|2639|✉|&#9993|u2709|2709||☎|&#9742|u260E|260E|☏|&#9743|u260F|260F||✆|&#9990|u2706|2706|�|&#65533|uFFFD|FFFD||☁|&#9729|u2601|2601|☂|&#9730|u2602|2602||❄|&#10052|u2744|2744|☃|&#9731|u2603|2603||❈|&#10056|u2748|2748|✿|&#10047|u273F|273F||❀|&#10048|u2740|2740|❁|&#10049|u2741|2741||☘|&#9752|u2618|2618|❦|&#10086|u2766|2766||☕|&#9749|u9749|9749|❂|&#10050|u2742|2742||☥|&#9765|u2625|2625|☮|&#9774|u262E|262E||☯|&#9775|u262F|262F|☪|&#9770|u262A|262A||☤|&#9764|u2624|2624|✄|&#9988|u2704|2704||✂|&#9986|u2702|2702|☸|&#9784|u2638|2638||⚓|&#9875|u2693|2693|☣|&#9763|u2623|2623||⚠|&#9888|u26A0|26A0|⚡|&#9889|u26A1|26A1||☢|&#9762|u2622|2622|♻|&#9851|u267B|267B||♿|&#9855|u267F|267F|☠|&#9760|u2620|2620|##¥货币类|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:----||$|&#36|u0024|�024|¢|&#162|u00A2|\\c0A2||£|&#163|u00A3|�0A3|¤|&#164|u00A4|�0A4||€|&#8364|u20AC|20AC|¥|&#165|u00A5|�0A5||₱|&#8369|u20B1|20B1|₹|&#8377|u20B9|20B9|##½数学类|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||½|&#189|u00BD|�0BD|¼|&#188|u00BC|�0BC||¾|&#190|u00BE|�0BE|⅓|&#8531|u2153|2153||⅔|&#8532|u2154|2154|⅛|&#8539|u215B|215B||⅜|&#8540|u215C|215C|⅝|&#8541|u215D|215D||‰|&#8240|u2030|2030|%|&#37|u0025|�025||<|&#60|u003C|�03C|>|&#62|u003E|�03E|##♫音乐符号类|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||♩|&#9833|u2669|2669|♪|&#9834|u266A|266A||♫|&#9835|u266B|266B|♬|&#9836|u266C|266C||♭|&#9837|u266D|266D|♯|&#9839|u266F|266F|##✖对错号|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:-----|:----|:---|:------|:----|:---|||&#160|u00A0|�0A0|☐|&#9744|u2610|2610||☑|&#9745|u2611|2611|☒|&#9746|u2612|2612||✓|&#10003|u2713|2713|✔|&#10004|u2714|2714||✕|&#10005|u10005|10005|✖|&#10006|u2716|2716||✗|&#10007|u2717|2717|✘|&#10008|u2718|2718|##★全都是星星|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||★|&#9733|u2605|2605|✭|&#10029|u272D|272D||✮|&#10030|u272E|272E|☆|&#9734|u2606|2606||✪|&#10026|u272A|272A|✡|&#10017|u2721|2721||✯|&#10031|u272F|272F|✵|&#10037|u2735|2735||✶|&#10038|u2736|2736|✸|&#10040|u2738|2738||✹|&#10041|u2739|2739|✺|&#10042|u273A|273A||✱|&#10033|u2731|2731|✲|&#10034|u2732|2732||✴|&#10036|u2734|2734|✳|&#10035|u2733|2733||✻|&#10043|u273B|273B|✽|&#10045|u273D|273D||❋|&#10059|u274B|274B|❆|&#10054|u2746|2746||❄|&#10052|u2744|2744|❅|&#10053|u2745|2745|##♒星座类|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||♈|&#9800|u2648|2648|♉|&#9801|u2649|2649||♊|&#9802|u264A|264A|♋|&#9803|u264B|264B||♌|&#9804|u264C|264C|♍|&#9805|u264D|264D||♎|&#9806|u264E|264E|♏|&#9807|u264F|264F||♐|&#9808|u2650|2650|♑|&#9809|u2651|2651||♒|&#9810|u2652|2652|♓|&#9811|u2653|2653|##♚国际象棋类|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||♚|&#9818|u265A|265A|♛|&#9819|u265B|265B||♜|&#9820|u265C|265C|♝|&#9821|u265D|265D||♞|&#9822|u265E|265E|♟|&#9823|u265F|265F||♔|&#9812|u2654|2654|♕|&#9813|u2655|2655||♖|&#9814|u2656|2656|♗|&#9815|u2657|2657||♘|&#9816|u2658|2658|♙|&#9817|u2659|2659|##♣扑克牌类|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||♠|&#9824|u2660|2660|♣|&#9827|u2663|2663||♥|&#9829|u2665|2665|♦|&#9830|u2666|2666||♤|&#9828|u2664|2664|♧|&#9831|u2667|2667||♡|&#9825|u2661|2661|♢|&#9826|u2662|2662|##Ω希腊字母|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||Α|&#913|u0391|�391|Β|&#914|u0392|�392||Γ|&#915|u0393|�393|Δ|&#916|u0394|�394||Ε|&#917|u0395|�395|Ζ|&#918|u0396|�396||Η|&#919|u0397|�397|Θ|&#920|u0398|�398||Ι|&#921|u0399|�399|Κ|&#922|u039A|�39A||Λ|&#923|u039B|�39B|Μ|&#924|u039C|�39C||Ν|&#925|u039D|�39D|Ξ|&#926|u039E|�39E||Ο|&#927|u039F|�39F|Π|&#928|u03A0|�3A0||Ρ|&#929|u03A1|�3A1|Σ|&#931|u03A3|�3A3||Τ|&#932|u03A4|�3A4|Υ|&#933|u03A5|�3A5||Φ|&#934|u03A6|�3A6|Χ|&#935|u03A7|�3A7||Ψ|&#936|u03A8|�3A8|Ω|&#937|u03A9|�3A9|##☩十字|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||☨|&#9768|u2628|2628|☩|&#9769|u2629|2629||✝|&#10013|u271D|271D|✞|&#10014|u271E|271E||✟|&#10015|u271F|271F|✠|&#10016|u2720|2720||✚|&#10010|u271A|271A|†|&#8224|u2020|2020||✢|&#10018|u2722|2722|✤|&#10020|u2724|2724||✣|&#10019|u2723|2723|✥|&#10021|u2725|2725|##©法律符号|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||®|&#174|u00AE|�0AE|©|&#169|u00A9|�0A9||℗|&#8471|u2117|2117|™|&#153|u0099|�099||℠|&#8480|u2120|2120|##@标点和符号|符号|UNICODE|JS|CSS|符号|UNICODE|JS|CSS||:---|:------|:----|:---|:---|:------|:----|:---||«|&#171|u00AB|�0AB|»|&#187|u00BB|�0BB||‹|&#139|u008B|�08B|›|&#155|u009B|�09B||“|&#8220|u201C|201C|”|&#8221|u201D|201D||‘|&#8216|u2018|2018|’|&#8217|u2019|2019||•|&#8226|u2022|2022|◦|&#9702|u25E6|25E6||¡|&#161|u00A1|�0A1|¿|&#191|u00BF|�0BF||℅|&#8453|u2105|2105|№|&#8470|u2116|2116||&|&#38|u0026|�026|@|&#64|u0040|�040||℞|&#8478|u211E|211E|℃|&#8451|u2103|2103||℉|&#8457|u2109|2109|°|&#176|u00B0|�0B0|||&#124|u007C|�07C|¦|&#166|u00A6|�0A6||–|&#8211|u2013|2013|—|&#8212|u2014|2014||…|&#8230|u2026|2026|¶|&#182|u00B6|�0B6||∼|&#8764|u223C|223C|≠|&#8800|u2260|2260|总结归类：##特别|符号|code|desc||:---|:---------|:-----------------------------------------------------||©|`&copy;`|©版权标志||·|`&middot;`|·圆点，有时被用来作为菜单分隔符||↑|`&uarr;`|↑上箭头，常用作网页“返回页面顶部”标识||€|`&euro;`|€欧元标识||²|`&sup2;`|²上标2，数学中的平方，在数字处理中常用到，例如：1000²||½|`&frac12;`|½二分之一||♥|`&hearts;`|♥心型，用来表达你的心|||`&nbsp;`|空格||&|`&amp;`|&and符号，与||“|`&quot;`|“引号||©|`&copy;`|©版权标志||®|`&reg;`|»注册标志||™|`&trade;`|™商标标志||“|`&ldquo;`|“左双引号||”|`&rdquo;`|”右双引号||‘|`&lsquo;`|‘做单引号||’|`&rsquo;`|’右单引号||«|`&laquo;`|«左三角双引号||»|`&raquo;`|»右三角双引号||‹|`&lsaquo;`|‹左三角单引号||›|`&rsaquo;`|›右三角单引号||§|`&sect;`|§章节标志||¶|`&para;`|¶段落标志||•|`&bull;`|•列表圆点（大）||·|`&middot;`|·列表圆点（中）||…|`&hellip;`|…省略号||¦|`&brvbar;`|¦断的竖线||–|`&ndash;`|–短破折号||—|`&mdash;`|—长破折号||¤|`&curren;`|¤一般货币符号||¢|`&cent;`|¢分||£|`&pound;`|£英镑||¥|`&yen;`|¥日元||€|`&euro;`|€欧元||<|`&lt;`|<小于号||>|`&gt;`|>大于号||≤|`&le;`|≤小于等于号||≥|`&ge;`|≥大于等于号||×|`&times;`|×乘号||÷|`&divide;`|÷除号||−|`&minus;`|−减号||±|`&plusmn;`|±加/减号||≠|`&ne;`|≠不等于号||¹|`&sup1;`|¹上标1||²|`&sup2;`|²上标2||³|`&sup3;`|³上标3||½|`&frac12;`|½二分之一||¼|`&frac14;`|¼四分之一||¾|`&frac34;`|¾四分之三||‰|`&permil;`|‰千分率||°|`&deg;`|°度||√|`&radic;`|√平方根||∞|`&infin;`|∞无限大||←|`&larr;`|←左箭头||↑|`&uarr;`|↑上箭头||→|`&rarr;`|→右箭头||↓|`&darr;`|↓下箭头||↔|`&harr;`|↔左右箭头||↵|`&crarr;`|↵回车箭头||⌈|`&lceil;`|⌈左上限||⌉|`&rceil;`|⌉右上限||⌊|`&lfloor;`|⌊左下限||⌋|`&rfloor;`|⌋右下限||♠|`&spades;`|♠黑桃||♣|`&clubs;`|♣梅花||♥|`&hearts;`|♥红桃，心||♦|`&diams;`|♦方块牌||◊|`&loz;`|◊菱形||†|`&dagger;`|†匕首||‡|`&Dagger;`|‡双剑号||¡|`&iexcl;`|¡反向感叹号||¿|`&iquest;`|¿反向问号|","JavaScript\\api\\电池.md":"#[`电池`]()##获取电池的信息```js//请求电池信息navigator.getBattery().then(function(battery){//后续代码})```##监听电池状态变化```jsnavigator.getBattery().then(function(battery){//添加事件，当设备电量改变时触发battery.addEventListener('levelchange',function(){console.log('电量改变:'+battery.level)})//添加事件，当设备充电状态改变时触发battery.addEventListener('chargingchange',function(){console.log('充电状态改变:'+battery.charging)})//添加事件，当设备完全充电需要时间改变时触发battery.addEventListener('chargingtimechange',function(){console.log('完全充电需要时间:'+battery.chargingTime)})//添加事件，当设备完全放电需要时间改变时触发battery.addEventListener('dischargingtimechange',function(){console.log('完全放电需要时间:'+battery.dischargingTime)})})```","JavaScript\\Class\\index.md":"#Class##声明类```jsclassAnimal{constructor(type){this.type=type}walk(){console.log(`Iamwalking`)}}letdog=newAnimal('dog')letmonkey=newAnimal('monkey')```##Setters&Getters>可以直接在`constructor`中通过this直接定义,还可以直接在类的顶层来定义```jsclassAnimal{constructor(type,age){this.type=typethis._age=age}getage(){returnthis._age}setage(val){this._age=val}}```##静态方法```jsclassAnimal{constructor(type){this.type=type}walk(){console.log(`Iamwalking`)}staticeat(){console.log(`Iameating`)}}```##继承```jsclassAnimal{constructor(type){this.type=type}walk(){console.log(`Iamwalking`)}staticeat(){console.log(`Iameating`)}}classDogextendsAnimal{constructor(){super('dog')}run(){console.log('Icanrun')}}```","JavaScript\\Element\\getBoundingClientRect.md":"#[`getBoundingClientRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)>-返回[DOMRect](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect)对象,>-提供元素大小,相对视图的位置>-`box-sizing`:`border-box`:`width`和`height`和元素的相等>-`box-sizing`:`content-box`:`width`和`height`会加上`padding`he`border-width`>-`Fullsupport`","JavaScript\\es6.md":"#es6##数据类型>前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）symbol(ES6新增)##letconst###let>-块级作用域:类似于局部变量,只在所处的代码块有效>-不可以重复声明>-不存在变量提升```js{leta=10varb=1}a//ReferenceError:aisnotdefined.b//1```>var变量声明window.variable===variable>>```js>varage=14>console.log(window.age)//14>```>>这样会造成全局变量污染demo```js//生成十个按钮,每次点击的时候弹出对应的数字//传统方法vari=0for(i=1;i<=10;i++){;(function(i){varbtn=document.createElement('button')btn.innerText=ibtn.onclick=function(){alert(i)}document.body.appendChild(btn)})(i)}//使用let方法for(let=1;i<=10;i++){varbtn=document.createElement('button')btn.innerText=ibtn.onclick=function(){alert(i)}document.body.appendChild(btn)}```###const>-声明一个只读的常量,常量的值不可以改变>-一定要赋初值>-对于符合类型的变量,变量不指向数据,而是指向数据所在的地址```js//使变量不可以更改varCST={value:'张三'}Object.defineProperty(CST,'value',{writable:false,})Object.seal(CST)//CST也不可以挂载任何变量/或拓展constPI=3.1415PI//3.1415PI=3//TypeError:Assignmenttoconstantvariable.```>cost变量还是可以赋值的```jsconstfoo={}foo.prop=123foo.prop//123consta=[]a.push('Hello')//可执行a.length=0//可执行a=['Dave']//报错```##变量的解构赋值###基本用法```jsvara=1varb=2varc=3//可以写成var[a,b,c]=[1,2,3]//set结构let[x,y,z]=newSet(['a','b','c'])//默认值;[x,y='b']=['a']//x='a',y='b';[x,y='b']=['a',undefined]//x='a',y='b'//对象var{bar,foo}={foo:'aaa',bar:'bbb'}foo//\"aaa\"bar//\"bbb\"//字符串const[a,b,c,d,e]='hello'a//\"h\"b//\"e\"c//\"l\"d//\"l\"e//\"o\"let{length:len}='hello'len//5```###遍历map结构```jsvarmap=newMap();map.set('first','hello');map.set('second','world');for(let[key,value]ofmap){console.log(key+\"is\"+value);}//获取键名for(let[key]ofmap){...}//获取键值for(let[,value]ofmap){...}```###输入模块的指定方法```jsconst{SourceMapConsumer,SourceNode}=require('source-map')```##字符串拓展###字符的Unicode表示法>`\\u0000`——`\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表达```js'\\uD842\\uDFB7'//\"𠮷\"'\\u20BB7'//\"7\"(这里js理解为\"\\u20BB+7\"=>空格+7)//放进化括号可以解决以上问题'\\u{1F680}'==='\\uD83D\\uDE80'//true```####六种方式表示一个字符```js'\\z'==='z'//true'\\172'==='z'//true'\\x7A'==='z'//true'\\u007A'==='z'//true'\\u{7A}'==='z'//true```###codePointAt()>普通字符:2个字符(UTF-16格式)>>特殊字符:4个字符(Unicode格式[Unicode码点>0xFFFF])```jsvars='𠮷'//0xD8420xDFB7s.length//2s.charAt(0)//''s.charAt(1)//''s.charCodeAt(0)//55362s.charCodeAt(1)//57271```###at()```js'abc'.charAt(0)//\"a\"'𠮷'.charAt(0)//\"\\uD842\"'abc'.at(0)//\"a\"'𠮷'.at(0)//\"𠮷\"```###字符串遍历器>for...of可以遍历大于0xFFFF的码点```jsfor(letcodePointof'foo'){console.log(codePoint)}//\"f\"//\"o\"//\"o\"```###includes(),startsWith(),endsWith()>-indexOf():用来确定一个字符串是否包含在另一个字符串中。>-**includes()**：返回布尔值，表示是否找到了参数字符串。>-**startsWith()**：返回布尔值，表示参数字符串是否在源字符串的头部。>-**endsWith()**：返回布尔值，表示参数字符串是否在源字符串的尾部。```jsvars='Helloworld!'s.startsWith('Hello')//trues.endsWith('!')//trues.includes('o')//trues.startsWith('world',6)//trues.endsWith('Hello',5)//trues.includes('Hello',6)//false```repest()>返回一个字符重复n次的新字符```js'x'.repeat(3)//\"xxx\"```###模板字符串```js//字符串中嵌入变量varname='Bob',time='today';`Hello${name},howareyou${time}?`//标签模板alert`123`//等同于alert(123)```##symbol>-通过Symbol函数生成>-原来就有的字符串>-新增的Symbol类型>-每一个symbol都是不相等的>-```jslets=Symbol()typeofs//\"symbol\"varmySymbol=Symbol()vara={}a[mySymbol]='Hello!'```##set和Map数据结构###Set>-每一个成员都是唯一,没有重复的值>-遍历操作>-keys():返回键名的遍历器>-values():返回键值的遍历器>-entries():返回键值对的遍历器>-forEach():使用回调函数遍历每一个成员```jsvars=newSet();[2,3,5,4,5,2,2].map((x)=>s.add(x))for(letiofs){console.log(i)}//2354//例一varset=newSet([1,2,3,4,4]);[...set]//[1,2,3,4]//例二varitems=newSet([1,2,3,4,5,5,5,5])items.size//5//例三functiondivs(){return[...document.querySelectorAll('div')]}varset=newSet(divs())set.size//56//类似于divs().forEach((div)=>set.add(div))set.size//56```###Map>-只能使用字符串当做键>-set(key,value):赋值>-get(key):获取```jsvardata={}varelement=document.getElementById('myDiv')data[element]='metadata'data['[objectHTMLDivElement]']//\"metadata\"``````javascriptvarm=newMap()varo={p:'HelloWorld'}m.set(o,'content')m.get(o)//\"content\"m.has(o)//truem.delete(o)//truem.has(o)//false```##Proxy和Reflect###Proxy>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（metaprogramming），即对编程语言进行编程。>>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。>>```javascript>varproxy=newProxy(target,handler)>target:拦截目标>handler:拦截行为>``````jsvarobj=newProxy({},{get:function(target,key,receiver){console.log(`getting${key}!`)returnReflect.get(target,key,receiver)},set:function(target,key,value,receiver){console.log(`setting${key}!`)returnReflect.set(target,key,value,receiver)},},)obj.count=1//settingcount!++obj.count//gettingcount!//settingcount!//2```>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。>>**（1）get(target,propKey,receiver)**>>拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。>>最后一个参数`receiver`是一个对象，可选，参见下面`Reflect.get`的部分。>>```js>varperson={>name:'张三',>}>>varproxy=newProxy(person,{>get:function(target,property){>if(propertyintarget){>returntarget[property]>}else{>thrownewReferenceError('Property\"'+property+'\"doesnotexist.')>}>},>})>>proxy.name//\"张三\">proxy.age//抛出一个错误>```>>**（2）set(target,propKey,value,receiver)**>>拦截对象属性的设置，比如`proxy.foo=v`或`proxy['foo']=v`，返回一个布尔值。>>```js>letvalidator={>set:function(obj,prop,value){>if(prop==='age'){>if(!Number.isInteger(value)){>thrownewTypeError('Theageisnotaninteger')>}>if(value>200){>thrownewRangeError('Theageseemsinvalid')>}>}>>//对于age以外的属性，直接保存>obj[prop]=value>},>}>>letperson=newProxy({},validator)>>person.age=100>>person.age//100>person.age='young'//报错>person.age=300//报错>```>>**（3）has(target,propKey)**>>拦截`propKeyinproxy`的操作，以及对象的`hasOwnProperty`方法，返回一个布尔值。>>**（4）deleteProperty(target,propKey)**>>拦截`deleteproxy[propKey]`的操作，返回一个布尔值。>>**（5）ownKeys(target)**>>拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`，返回一个数组。该方法返回对象所有自身的属性，而`Object.keys()`仅返回对象可遍历的属性。>>**（6）getOwnPropertyDescriptor(target,propKey)**>>拦截`Object.getOwnPropertyDescriptor(proxy,propKey)`，返回属性的描述对象。>>**（7）defineProperty(target,propKey,propDesc)**>>拦截`Object.defineProperty(proxy,propKey,propDesc）`、`Object.defineProperties(proxy,propDescs)`，返回一个布尔值。>>**（8）preventExtensions(target)**>>拦截`Object.preventExtensions(proxy)`，返回一个布尔值。>>**（9）getPrototypeOf(target)**>>拦截`Object.getPrototypeOf(proxy)`，返回一个对象。>>**（10）isExtensible(target)**>>拦截`Object.isExtensible(proxy)`，返回一个布尔值。>>**（11）setPrototypeOf(target,proto)**>>拦截`Object.setPrototypeOf(proxy,proto)`，返回一个布尔值。>>如果目标对象是函数，那么还有两种额外操作可以拦截。>>**（12）apply(target,object,args)**>>拦截Proxy实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object,...args)`、`proxy.apply(...)`。>>**（13）construct(target,args)**>>拦截Proxy实例作为构造函数调用的操作，比如`newproxy(...args)`。###Reflect>`Reflect`对象与`Proxy`对象一样，也是ES6为了操作对象而提供的新API。`Reflect`对象的设计目的有这样几个。>>（1）将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。>>（2）修改某些Object方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj,name,desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj,name,desc)`则会返回`false`。>>-Reflect.apply(target,thisArg,args)>-Reflect.construct(target,args)>-Reflect.get(target,name,receiver)>>```js>varobj={>getfoo(){returnthis.bar();},>bar:function(){...}>};>>//下面语句会让this.bar()>//变成调用wrapper.bar()>Reflect.get(obj,\"foo\",wrapper);>```>>-Reflect.set(target,name,value,receiver)>-Reflect.defineProperty(target,name,desc)>-Reflect.deleteProperty(target,name)>-Reflect.has(target,name)>-Reflect.ownKeys(target)>-Reflect.isExtensible(target)>-Reflect.preventExtensions(target)>-Reflect.getOwnPropertyDescriptor(target,name)>-Reflect.getPrototypeOf(target)>-Reflect.setPrototypeOf(target,prototype)##Generator>-提供异步变成解决方案>-状态机:封装多个内部状态>-特征>-function:关键词和函数名之间有一个星号(没有规定位置,只要在这之间都可以)>-内部使用yield(产出)语句[定义状态]```jsfunction*helloWorldGenerator(){yield'hello'yield'world'return'ending'//结束}/*建立后并不执行,返回也不是函数运行结果而是一个指向内部状态指针对象(遍历对象IteratorObject)*/varhw=helloWorldGenerator()//done:false;表示对象遍历没有结束hw.next()//{value:'hello',done:false}hw.next()//{value:'world',done:false}hw.next()//{value:'ending',done:true}hw.next()//{value:undefined,done:true}//表示遍历结束```##代理Proxy###语法```jsletp=newProxy(target,handler)```>`target`:一个目标对象(可以是任何类型对象,包括数组函数等,甚至另一个代理)用Proxy来封装>>`handler`:一个对象,其属性是执行一个操作时定义代理的行为函数###代理使用```jsconstobj={a:10,}lethandler={get:function(target,name){console.log('test:',target,name)//test:{\"a\":10}a//test:{\"a\":10}breturnnameintarget?target[name]:37},}letp=newProxy(obj,handler)console.log(p.a,p.b)//1037```##Object.assign()##基本用法`-Object.assign`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。```dartconsttarget={a:1};constsource1={b:2};constsource2={c:3};Object.assign(target,source1,source2);target//{a:1,b:2,c:3}````Object.assign`方法的第一个参数是目标对象，后面的参数都是源对象。注意，如果目标对象与源对象有同名属性，或多个源对象有**同名属性，则后面的属性会覆盖前面的属性。**```dartconsttarget={a:1,b:1};constsource1={b:2,c:2};constsource2={c:3};Object.assign(target,source1,source2);target//{a:1,b:2,c:3}```如果只有一个参数，`Object.assign`会直接返回该参数。```dartconstobj={a:1};Object.assign(obj)===obj//true```如果该参数不是对象，则会先转成对象，然后返回。```jsxtypeofObject.assign(2)//\"object\"```由于`undefined`和`null`无法转成对象，所以如果它们作为参数，就会报错。```jsxObject.assign(undefined)//报错Object.assign(null)//报错```如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果`undefined`和`null`不在首参数，就不会报错。```jsxletobj={a:1}Object.assign(obj,undefined)===obj//trueObject.assign(obj,null)===obj//true```其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。```jsxconstv1='abc'constv2=trueconstv3=10constobj=Object.assign({},v1,v2,v3)console.log(obj)//{\"0\":\"a\",\"1\":\"b\",\"2\":\"c\"}```上面代码中，`v1`、`v2`、`v3`分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。```dartObject(true)//{[[PrimitiveValue]]:true}Object(10)//{[[PrimitiveValue]]:10}Object('abc')//{0:\"a\",1:\"b\",2:\"c\",length:3,[[PrimitiveValue]]:\"abc\"}```上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性`[[PrimitiveValue]]`上面，这个属性是不会被`Object.assign`拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。`Object.assign`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable:false`）。```dartObject.assign({b:'c'},Object.defineProperty({},'invisible',{enumerable:false,value:'hello'}))//{b:'c'}```上面代码中，`Object.assign`要拷贝的对象只有一个不可枚举属性`invisible`，这个属性并没有被拷贝进去。属性名为Symbol值的属性，也会被`Object.assign`拷贝。```dartObject.assign({a:'b'},{[Symbol('c')]:'d'})//{a:'b',Symbol(c):'d'}```---###注意点####（1）浅拷贝`Object.assign`方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。```dartconstobj1={a:{b:1}};constobj2=Object.assign({},obj1);obj1.a.b=2;obj2.a.b//2```上面代码中，源对象`obj1`的`a`属性的值是一个对象，`Object.assign`拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。####（2）同名属性的替换对于这种嵌套的对象，一旦遇到同名属性，`Object.assign`的处理方法是替换，而不是添加。```dartconsttarget={a:{b:'c',d:'e'}}constsource={a:{b:'hello'}}Object.assign(target,source)//{a:{b:'hello'}}```上面代码中，`target`对象的`a`属性被`source`对象的`a`属性整个替换掉了，而不会得到`{a:{b:'hello',d:'e'}}`的结果。这通常不是开发者想要的，需要特别小心。一些函数库提供`Object.assign`的定制版本（比如Lodash的`_.defaultsDeep`方法），可以得到深拷贝的合并。####（3）数组的处理`Object.assign`可以用来处理数组，但是会把数组视为对象。```dartObject.assign([1,2,3],[4,5])//[4,5,3]```上面代码中，`Object.assign`把数组视为属性名为0、1、2的对象，因此源数组的0号属性`4`覆盖了目标数组的0号属性`1`。####（4）取值函数的处理`Object.assign`只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。```jsxconstsource={getfoo(){return1},}consttarget={}Object.assign(target,source)//{foo:1}```上面代码中，`source`对象的`foo`属性是一个取值函数，`Object.assign`不会复制这个取值函数，只会拿到值以后，将这个值复制过去。##常见用途`Object.assign`方法有很多用处。###（1）为对象添加属性```jsxclassPoint{constructor(x,y){Object.assign(this,{x,y})}}```上面方法通过`Object.assign`方法，将`x`属性和`y`属性添加到`Point`类的对象实例。###（2）为对象添加方法```jsxObject.assign(SomeClass.prototype,{someMethod(arg1,arg2){···},anotherMethod(){···}});//等同于下面的写法SomeClass.prototype.someMethod=function(arg1,arg2){···};SomeClass.prototype.anotherMethod=function(){···};```上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用`assign`方法添加到`SomeClass.prototype`之中。###（3）克隆对象```jsxfunctionclone(origin){returnObject.assign({},origin)}```上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。```jsxfunctionclone(origin){letoriginProto=Object.getPrototypeOf(origin)returnObject.assign(Object.create(originProto),origin)}```###（4）合并多个对象将多个对象合并到某个对象。```jsxconstmerge=(target,...sources)=>Object.assign(target,...sources)```如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。```jsxconstmerge=(...sources)=>Object.assign({},...sources)```###（5）为属性指定默认值```jsxconstDEFAULTS={logLevel:0,outputFormat:'html',}functionprocessContent(options){options=Object.assign({},DEFAULTS,options)console.log(options)//...}```上面代码中，`DEFAULTS`对象是默认值，`options`对象是用户提供的参数。`Object.assign`方法将`DEFAULTS`和`options`合并成一个新对象，如果两者有同名属性，则`option`的属性值会覆盖`DEFAULTS`的属性值。注意，由于存在浅拷贝的问题，`DEFAULTS`对象和`options`对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，`DEFAULTS`对象的该属性很可能不起作用。```csharpconstDEFAULTS={url:{host:'example.com',port:7070},};processContent({url:{port:8000}})//{//url:{port:8000}//}```上面代码的原意是将`url.port`改成8000，`url.host`不变。实际结果却是`options.url`覆盖掉`DEFAULTS.url`，所以`url.host`就不存在了。##function```js//传统functionPoint(x,y){this.x=xthis.y=y}Point.prototype.toString=function(){return'('+this.x+','+this.y+')'}varp=newPoint(1,2)//ES6classPoint{constructor(x,y){//类似于java的构造函数this.x=xthis.y=y}//私有方法_bar(baz){return(this.snaf=baz)}toString(){return'('+this.x+','+this.y+')'}}```","JavaScript\\ESMAScript.md":"#ESMAScript##变量的解构赋值ES6允许我们，通过数组或者对象的方式，对一组变量进行赋值，这被称为解构。解构赋值在实际开发中可以大量减少我们的代码量，并且让程序结构更清晰。###数组的解构赋值**举例：**通常情况下，我们在为一组变量赋值时，一般是这样写：```javascriptleta=0letb=1letc=2```现在我们可以通过数组解构的方式进行赋值：```javascriptlet[a,b,c]=[1,2,3]```二者的效果是一样的。**解构的默认值：**在解构赋值时，是允许使用默认值的。举例如下：```javascript{//一个变量时let[foo=true]=[]console.log(foo)//输出结果：true}{//两个变量时let[a,b]=['生命壹号']//a赋值为：生命壹号。b没有赋值console.log(a+','+b)//输出结果：生命壹号,undefined}{//两个变量时let[a,b='smyhvae']=['生命壹号']//a赋值为：生命壹号。b采用默认值smyhvaeconsole.log(a+','+b)//输出结果：生命壹号,smyhvae}````undefined`和`null`的区别：如果我们在赋值时，采用的是`undefined`或者`null`，那会有什么区别呢？```javascript{let[a,b='smyhvae']=['生命壹号',undefined]//b虽然被赋值为undefined，但是b会采用默认值console.log(a+','+b)//输出结果：生命壹号,smyhvae}{let[a,b='smyhvae']=['生命壹号',null]//b被赋值为nullconsole.log(a+','+b)//输出结果：生命壹号,null}```上方代码分析：-undefined：相当于什么都没有，此时b采用默认值。-null：相当于有值，但值为null。###对象的解构赋值通常情况下，我们从接口拿到json数据后，一般这么赋值：```javascriptvara=json.a;varb=json.b;barc=json.c;```**举例如下：**```jslet{foo,bar}={bar:'我是bar的值',foo:'我是foo的值'}console.log(foo+','+bar)//输出结果：我是键foo的值,我是键bar的值```上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：**数组**的元素是按次序排列的，变量的取值由它的**位置**决定；而**对象的属性没有次序**，是**根据键来取值**的。**圆括号的使用**：如果变量foo在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错：```javascriptletfoo='haha';{foo}={foo:'smyhvae'};console.log(foo);```要解决报错，只要在解构的语句外边，加一个圆括号即可：```javascriptletfoo='haha';({foo}={foo:'smyhvae'})console.log(foo)//输出结果：smyhvae```###字符串解构字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下：```javascriptconst[a,b,c,d]='smyhvae'console.log(a)console.log(b)console.log(c)console.log(d)console.log(typeofa)//输出结果：string```输出结果：![](http://img.smyhvae.com/20180304_1626.png)##for...of循环ES6中，如果我们要遍历一个数组，可以这样做：```letarr1=[1,2,3,4,5];for(letvalueofarr1){console.log(value);}```输出结果：![](http://img.smyhvae.com/20180304_2016.png)for…of的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for…of循环。注意，上面的数组中，`for...of`获取的是数组里的值；`for...in`获取的是index索引值。###Map对象的遍历`for...of`既可以遍历数组，也可以遍历Map对象。##模板字符串我们以前让字符串进行拼接的时候，是这样做的：（传统写法的字符串拼接）```javascriptvarname='smyhvae'varage='26'console.log('name:'+name+',age:'+age)//传统写法```这种写法，比较繁琐，而且容易出错。现在有了ES6语法，字符串拼接可以这样写：```javascriptvarname='smyhvae'varage='26'console.log('name:'+name+',age:'+age)//传统写法console.log(`name:${name},age:${age}`)//ES6写法```**注意**，上方代码中，倒数第二行用的符号是单引号，最后一行用的符号是反引号（在tab键的上方）。##函数拓展ES6在**函数扩展**方面，新增了很多特性。例如：-箭头函数-参数默认值-参数结构赋值-扩展运算符-rest参数-this绑定-尾调用###箭头函数定义和调用函数：（传统写法）```javascriptfunctionfn1(a,b){returna+b}console.log(fn1(1,2))//输出结果：3```定义和调用函数：（ES6中的写法）```javascriptvarfn2=(a,b)=>a+bconsole.log(fn2(1,2))//输出结果：3```二者的效果是一样的。在箭头函数中，如果方法体内有两句话，那就需要在方法体外边加上{}括号。如下：```javascriptvarfn2=(a,b)=>{console.log('haha')returna+b}console.log(fn2(1,2))//输出结果：3```从上面的箭头函数中，我们可以很清晰地找到函数名、参数名、方法体。上方代码中：-如果有且仅有1个参数，则`()`可以省略-如果方法体内有且仅有1条语句，则`{}`可以省略，但前提是，这条语句必须是return。###this的指向>箭头函数只是为了让函数写起来更优雅吗？当然不是，还有一个很大的作用是与this的指向有关。ES5中，this指向的是函数被调用的对象；而ES6的箭头函数中，this指向的是函数被定义时。简单来说，箭头函数中的this，是不会变的，是永远绑定在当前的环境下。###参数默认值**传统写法**：```javascriptfunctionfn(param){letp=param||'hello'console.log(p)}```上方代码中，函数体内的写法是：如果param不存在，就用`hello`字符串做兜底。这样写比较啰嗦。**ES6写法**：（参数默认值的写法，很简洁）```javascriptfunctionfn(param='hello'){console.log(param)}```在ES6中定义方法时，我们可以给方法里的参数加一个**默认值**（缺省值）：-方法被调用时，如果没有给参数赋值，那就是用默认值；-方法被调用时，如果给参数赋值了新的值，那就用新的值。如下：```javascriptvarfn2=(a,b=5)=>{console.log('haha')returna+b}console.log(fn2(1))//第二个参数使用默认值5。输出结果：6console.log(fn2(1,8))//输出结果：9```**提醒1**：默认值的后面，不能再有**没有默认值的变量**。比如`(a,b,c)`这三个参数，如果我给b设置了默认值，那么就一定要给c设置默认值。**提醒2**：我们来看下面这段代码：```javascriptletx='smyh'functionfn(x,y=x){console.log(x,y)}fn('vae')```注意第二行代码，我们给y赋值为`x`，这里的`x`是括号里的第一个参数，并不是第一行代码里定义的`x`。打印结果：`vaevae`。如果我把第一个参数改一下，改成：```javascriptletx='smyh'functionfn(z,y=x){console.log(z,y)}fn('vae')```此时打印结果是：`vaesmyh`。###扩展运算符注意区分：-扩展运算符的格式为`...`-rest运算符的格式为`...变量名`有了ES6，当我们在定义一个方法，但是不确定其参数的个数时，我们就可以用**扩展运算符**作为参数。以前，我们在定义方法时，参数要确定个数，如下：（程序会报错）```javascriptfunctionfn(a,b,c){console.log(a)console.log(b)console.log(c)console.log(d)}fn(1,2,3)```上方代码中，因为方法的参数是三个，但使用时是用到了四个参数，所以会报错：![](http://img.smyhvae.com/20180304_1638.png)现在，我们有了扩展运算符，就不用担心报错的问题了。代码可以这样写：```javascriptfunctionfn(...arg){//当不确定方法的参数时，可以使用扩展运算符console.log(arg[0])console.log(arg[1])console.log(arg[2])console.log(arg[3])}fn(1,2,3)//方法中定义了四个参数，但只引用了三个参数，ES6中并不会报错。```![](http://img.smyhvae.com/20180304_1650.png)上方代码中注意，arg参数之后，不能再加别的参数，否则编译报错。**举例：**数组赋值的问题我们来分析一段代码：（将数组arr1赋值给arr2）```javascriptletarr1=['www','smyhvae','com']letarr2=arr1//将arr1赋值给arr2，其实是让arr2指向arr1的内存地址console.log('arr1:'+arr1)console.log('arr2:'+arr2)console.log('---------------------')arr2.push('你懂得')//往arr2里添加一部分内容console.log('arr1:'+arr1)console.log('arr2:'+arr2)```运行结果：![](http://img.smyhvae.com/20180304_1950.png)上方代码中，我们往往arr2里添加了`你懂的`，却发现，arr1里也有这个内容。原因是：`letarr2=arr1;`其实是让arr2指向arr1的地址。也就是说，二者指向的是同一个内存地址。如果不想让arr1和arr2指向同一个内存地址，我们可以借助扩展运算符来做：```javascriptletarr1=['www','smyhvae','com']letarr2=[...arr1]//arr2会重新开辟内存地址console.log('arr1:'+arr1)console.log('arr2:'+arr2)console.log('---------------------')arr2.push('你懂得')//往arr2里添加一部分内容console.log('arr1:'+arr1)console.log('arr2:'+arr2)```运行结果：![](http://img.smyhvae.com/20180304_1951.png)我们明白了这个例子，就可以避免开发中的很多业务逻辑上的bug。###`rest`运算符`rest`在英文中指的是**剩余部分**（不是指休息）。我们来举个例子，理解剩余部分的含义：```javascriptfunctionfn(first,second,...arg){console.log(arg.length)}fn(0,1,2,3,4,5,6)//调用函数后，输出结果为5```上方代码的输出结果为5。调用`fn()`时，里面有七个参数，而`arg`指的是剩下的部分（因为除去了`first`和`second`）。从上方例子中可以看出，`rest`运算符适用于：知道前面的一部分参数的数量，但对于后面剩余的参数数量未知的情况。##promise,async,Symbol###Promise####概述Promise对象:代表了未来某个将要发生的事件(通常是一个异步操作)。ES6中的promise对象,可以**将异步操作以同步的流程表达出来，**很好地解决了**回调地狱**的问题（避免了层层嵌套的回调函数）。在使用ES5的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发。###回调地狱的举例假设买菜、做饭、洗碗都是异步的。现在的流程是：买菜成功之后，才能开始做饭。做饭成功后，才能开始洗碗。这里面就涉及到了回调的嵌套。ES6的Promise是一个构造函数,用来生成promise实例。###promise对象的3个状态-初始化状态（等待状态）：pending-成功状态：fullfilled-失败状态：rejected###promise方法Promise.prototype.then()Promise.prototype.catch():捕获错误Promise.all():循环处理数组,对象,集合等Promise.race():输出最先出的结果,不用等到所有操作都得出结果Promise.resolve()Promise.reject()###使用promise的基本步骤（1）创建promise对象（2）调用promise的**回调函数**then()代码格式如下：```javascriptletpromise=newPromise((resolve,reject)=>{//进来之后，状态为pendingconsole.log('111')//这一行代码是同步的//开始执行异步操作（这里开始，写异步的代码，比如ajax请求or开启定时器）if(异步的ajax请求成功){console.log('333')resolve()//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled}else{reject()//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected}})console.log('222')//调用promise的then()promise.then(()=>{//如果promise的状态为fullfilled，则执行这里的代码console.log('成功了')},()=>{//如果promise的状态为rejected，则执行这里的代码console.log('失败了')},)```代码解释：（1）当newPromise()执行之后，promise对象的状态会被初始化为`pending`，这个状态是初始化状态。`newPromise()`这行代码，括号里的内容是同步执行的。括号里定义一个function，function有两个参数：resolve和reject。如下：-如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled。-如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected（2）promise.then()方法，括号里面有两个参数，分别代表两个函数function1和function2：-如果promise的状态为fullfilled（意思是：如果请求成功），则执行function1里的内容-如果promise的状态为rejected（意思是，如果请求失败），则执行function2里的内容另外，resolve()和reject()这两个方法，是可以给promise.then()传递参数的。如下：```javascriptletpromise=newPromise((resolve,reject)=>{//进来之后，状态为pendingconsole.log('111')//这行代码是同步的//开始执行异步操作（这里开始，写异步的代码，比如ajax请求or开启定时器）if(异步的ajax请求成功){console.log('333')resolve('haha')//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled}else{reject('555')//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected}})console.log('222')//调用promise的then()promise.then((successMsg)=>{//如果promise的状态为fullfilled，则执行这里的代码console.log(successMsg,'成功了')},(errorMsg)=>{//如果promise的状态为rejected，则执行这里的代码console.log(errorMsg,'失败了')},)```P###ajax请求的举例（涉及到嵌套的回调）```javascript//定义一个请求news的方法functiongetNews(url){//创建一个promise对象letpromise=newPromise((resolve,reject)=>{//初始化promise状态为pending//启动异步任务letrequest=newXMLHttpRequest()request.onreadystatechange=function(){if(request.readyState===4){if(request.status===200){letnews=request.responseresolve(news)}else{reject('请求失败了。。。')}}}request.responseType='json'//设置返回的数据类型request.open('GET',url)//规定请求的方法，创建链接request.send()//发送})returnpromise}getNews('http://localhost:3000/news?id=2').then((news)=>{console.log(news)document.write(JSON.stringify(news))console.log('http://localhost:3000'+news.commentsUrl)returngetNews('http://localhost:3000'+news.commentsUrl)},(error)=>{alert(error)},).then((comments)=>{console.log(comments)document.write('<br><br><br><br><br>'+JSON.stringify(comments))},(error)=>{alert(error)},)```###Symbol####概述背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。**概念**：ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。**特点：**-Symbol属性对应的值是唯一的，解决**命名冲突问题**-Symbol值不能与其他数据进行计算，包括同字符串拼串-forin、forof遍历时不会遍历Symbol属性。####创建Symbol属性值Symbol是函数，但并不是构造函数。创建一个Symbol数据类型：```javascriptletmySymbol=Symbol()console.log(typeofmySymbol)//打印结果：symbolconsole.log(mySymbol)//打印结果：Symbol()```打印结果：![](http://img.smyhvae.com/20180317_1134.png)下面来讲一下Symbol的使用。####将Symbol作为对象的属性值```javascriptletmySymbol=Symbol()letobj={name:'smyhvae',age:26,}//obj.mySymbol='male';//错误：不能用.这个符号给对象添加Symbol属性。obj[mySymbol]='hello'//正确：通过**属性选择器**给对象添加Symbol属性。后面的属性值随便写。console.log(obj)```上面的代码中，我们尝试给obj添加一个Symbol类型的属性值，但是添加的时候，不能采用`.`这个符号，而是应该用`属性选择器`的方式。打印结果：![](http://img.smyhvae.com/20180317_1134.png)现在我们用forin尝试对上面的obj进行遍历：```javascriptletmySymbol=Symbol()letobj={name:'smyhvae',age:26,}obj[mySymbol]='hello'console.log(obj)//遍历objfor(letiinobj){console.log(i)}```打印结果：![](http://img.smyhvae.com/20180317_1134.png)从打印结果中可以看到：forin、forof遍历时不会遍历Symbol属性。####创建Symbol属性值时，传参作为标识如果我通过Symbol()函数创建了两个值，这两个值是不一样的：```javascriptletmySymbol1=Symbol()letmySymbol2=Symbol()console.log(mySymbol1==mySymbol2)//打印结果：falseconsole.log(mySymbol1)//打印结果：Symbol()console.log(mySymbol2)//打印结果：Symbol()```![](http://img.smyhvae.com/20180317_1134.png)上面代码中，倒数第三行的打印结果也就表明了，二者的值确实是不相等的。最后两行的打印结果却发现，二者的打印输出，肉眼看到的却相同。那该怎么区分它们呢？既然Symbol()是函数，函数就可以传入参数，我们可以通过参数的不同来作为**标识**。比如：```javascript//在括号里加入参数，来标识不同的SymbolletmySymbol1=Symbol('one')letmySymbol2=Symbol('two')console.log(mySymbol1==mySymbol2)//打印结果：falseconsole.log(mySymbol1)//打印结果：Symbol(one)console.log(mySymbol2)//打印结果：Symbol(two)。颜色为红色。console.log(mySymbol2.toString())//打印结果：Symbol(two)。颜色为黑色。```打印结果：![](http://img.smyhvae.com/20180317_1134.png)####定义常量Symbol可以用来定义常量：```javascriptconstMY_NAME=Symbol('my_name')```###async函数（异步函数）概念：真正意义上去解决异步回调的问题，同步流程表达异步操作。本质：Generator的语法糖。async比之前的Promise、Generator要好用一些。语法：```javascriptasyncfunctionfoo(){await异步操作;await异步操作；}```我们在普通的函数前面加上async关键字，就成了async函数。###async、Promise、Generator的对比（async的特点）1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行。2、async返回的总是Promise对象，可以用then方法进行下一步操作。3、async取代Generator函数的星号\\*，await取代Generator的yield。4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用。##字符串的扩展ES6中的字符串扩展，用得少，而且逻辑相对简单。如下：-`includes(str)`：判断是否包含指定的字符串-`startsWith(str)`：判断是否以指定字符串开头-`endsWith(str)`：判断是否以指定字符串结尾-`repeat(count)`：重复指定次数举例如下：```javascriptletstr='abcdefg'console.log(str.includes('a'))//trueconsole.log(str.includes('h'))//false//startsWith(str):判断是否以指定字符串开头console.log(str.startsWith('a'))//trueconsole.log(str.startsWith('d'))//false//endsWith(str):判断是否以指定字符串结尾console.log(str.endsWith('g'))//trueconsole.log(str.endsWith('d'))//false//repeat(count):重复指定次数aconsole.log(str.repeat(5))```打印结果：![](http://img.smyhvae.com/20180402_1050.png)##Number的扩展-二进制与八进制数值表示法:二进制用`0b`,八进制用`0o`。举例：```javascriptconsole.log(0b1010)//10console.log(0o56)//46```-`Number.isFinite(i)`：判断是否为有限大的数。比如`Infinity`这种无穷大的数，返回的就是false。-`Number.isNaN(i)`：判断是否为NaN。-`Number.isInteger(i)`：判断是否为整数。-`Number.parseInt(str)`：将字符串转换为对应的数值。-`Math.trunc(i)`：去除小数部分。举例：```javascript//Number.isFinite(i):判断是否是有限大的数console.log(Number.isFinite(NaN))//falseconsole.log(Number.isFinite(5))//trueconsole.log(Number.isFinite(Infinity))//false//Number.isNaN(i):判断是否是NaNconsole.log(Number.isNaN(NaN))//trueconsole.log(Number.isNaN(5))//falsse//Number.isInteger(i):判断是否是整数console.log(Number.isInteger(5.23))//falseconsole.log(Number.isInteger(5.0))//trueconsole.log(Number.isInteger(5))//true//Number.parseInt(str):将字符串转换为对应的数值console.log(Number.parseInt('123abc'))//123console.log(Number.parseInt('a123abc'))//NaN//Math.trunc(i):直接去除小数部分console.log(Math.trunc(13.123))//13```##数组的扩展>下面提到的数组的几个方法，更详细的内容，可以看《04-JavaScript基础/17-数组的常见方法.md》。###扩展1：Array.from()```javascriptArray.from(伪数组/可遍历的对象)```**作用**：将**伪数组**或可遍历对象转换为**真数组**。###扩展2：Array.of()```javascriptArray.of(value1,value2,value3)```**作用**：将一系列值转换成数组。###扩展3：find()和findIndex()**方法1**：```javascriptfind(function(item,index,arr){returntrue})```**作用**：找出**第一个**满足「指定条件返回true」的元素。**方法2**：```javascriptfindIndex(function(item,index,arr){returntrue})```**作用**：找出第一个满足「指定条件返回true」的元素的index。##对象的扩展###扩展1```javascriptObject.is(v1,v2)```**作用：**判断两个数据是否完全相等。底层是通过**字符串**来判断的。我们先来看下面这两行代码的打印结果：```javascriptconsole.log(0==-0)console.log(NaN==NaN)```打印结果：```truefalse```上方代码中，第一行代码的打印结果为true，这个很好理解。第二行代码的打印结果为false，因为NaN和任何值都不相等。但是，如果换成下面这种方式来比较：```javascriptconsole.log(Object.is(0,-0))console.log(Object.is(NaN,NaN))```打印结果却是：```falsetrue```代码解释：还是刚刚说的那样，`Object.is(v1,v2)`比较的是字符串是否相等。###扩展2（重要）```javascriptObject.assign(目标对象,源对象1,源对象2...)```**作用：**将源对象的属性追加到目标对象上。如果对象里属性名相同，会被覆盖。其实可以理解成：将多个对象**合并**为一个新的对象。举例：```javascriptletobj1={name:'smyhvae',age:26}letobj2={city:'shenzhen'}letobj3={}Object.assign(obj3,obj1,obj2)console.log(obj3)```打印结果：![](http://img.smyhvae.com/20180404_2240.png)上图显示，成功将obj1和obj2的属性复制给了obj3。###扩展3：`__proto__`属性举例：```javascriptletobj1={name:'smyhvae'}letobj2={}obj2.__proto__=obj1console.log(obj1)console.log(obj2)console.log(obj2.name)```打印结果：![](http://img.smyhvae.com/20180404_2251.png)上方代码中，obj2本身是没有属性的，但是通过`__proto__`属性和obj1产生关联，于是就可以获得obj1里的属性。##迭代器（Iterator）####ES5实现迭代器迭代器是什么？遇到这种新的概念，莫慌张。**迭代器是一种特殊对象，每一个迭代器对象都有一个next()，该方法返回一个对象，包括value和done属性。****ES5实现迭代器的代码如下：**```js//实现一个返回迭代器对象的函数，注意该函数不是迭代器，返回结果才叫做迭代器。functioncreateIterator(items){vari=0return{next(){vardone=i>=items.length//判断i是否小于遍历的对象长度。varvalue=!done?items[i++]:undefined//如果done为false，设置value为当前遍历的值。return{done,value,}},}}consta=createIterator([1,2,3])//该方法返回的最终是一个对象，包含value、done属性。console.log(a.next())//{value:1,done:false}console.log(a.next())//{value:2,done:false}console.log(a.next())//{value:3,done:false}console.log(a.next())//{value:undefined,done:true}```###生成器（Generator）**生成器是函数：用来返回迭代器。**这个概念有2个关键点，一个是函数、一个是返回迭代器。这个函数不是上面ES5中创建迭代器的函数，而是ES6中特有的，一个带有\\*（星号）的函数，同时你也需要使用到yield。```js//生成器函数，ES6内部实现了迭代器功能，你要做的只是使用yield来迭代输出。function*createIterator(){yield1yield2yield3}consta=createIterator()console.log(a.next())//{value:1,done:false}console.log(a.next())//{value:2,done:false}console.log(a.next())//{value:3,done:false}console.log(a.next())//{value:undefined,done:true}```生成器的yield关键字有个神奇的功能，就是当你执行一次next()，那么只会执行一个yield后面的内容，然后语句终止运行。####在for循环中使用迭代器即使你是在for循环中使用yield关键字，也会暂停循环。```jsfunction*createIterator(items){for(leti=0;i<items.length;i++){yielditems[i]}}consta=createIterator([1,2,3])console.log(a.next())//{value:1,done:false}```####yield使用限制yield只可以在生成器函数内部使用，如果在非生成器函数内部使用，则会报错。```jsfunction*createIterator(items){//你应该在这里使用yielditems.map((value,key)=>{yieldvalue//语法错误，在map的回调函数里面使用了yield})}consta=createIterator([1,2,3]);console.log(a.next());//无输出```####生成器函数表达式函数表达式很简单，就是下面这种写法，也叫匿名函数，不用纠结。```jsconstcreateIterator=function*(){yield1yield2}consta=createIterator()console.log(a.next())```####在对象中添加生成器函数一个对象长这样：```constobj={}```我们可以在obj中添加一个生成器，也就是添加一个带星号的方法：```jsconstobj={a:1,*createIterator(){yieldthis.a},}consta=obj.createIterator()console.log(a.next())//{value:1,done:false}```####可迭代对象和forof循环再次默读一遍，迭代器是对象，生成器是返回迭代器的函数。凡是通过生成器生成的迭代器，都是可以迭代的对象(可迭代对象具有Symbol.iterator属性)，也就是可以通过forof将value遍历出来。```jsfunction*createIterator(){yield1yield2yield3}consta=createIterator()for(letvalueofa){console.log(value)}//123```上面的例子告诉我们生成器函数返回的迭代器是一个可以迭代的对象。其实我们这里要研究的是Symbol.iterator的用法。```jsfunction*createIterator(){yield1yield2yield3}consta=createIterator()//a是一个迭代器consts=a[Symbol.iterator]()//使用Symbol.iterator访问迭代器console.log(s.next())//{value:1,done:false}```Symbol.iterator还可以用来检测一个对象是否可迭代：```typeofobj[Symbol.iterator]===\"function\"```####创建可迭代对象**在ES6中，数组、Set、Map、字符串都是可迭代对象。****默认情况下定义的对象（object）是不可迭代的，但是可以通过Symbol.iterator创建迭代器。**```jsconstobj={items:[],}obj.items.push(1)//这样子虽然向数组添加了新元素，但是obj不可迭代for(letxofobj){console.log(x)//_iterator[Symbol.iterator]isnotafunction}//接下来给obj添加一个生成器，使obj成为一个可以迭代的对象。constobj={items:[],*[Symbol.iterator](){for(letitemofthis.items){yielditem}},}obj.items.push(1)//现在可以通过forof迭代obj了。for(letxofobj){console.log(x)}```####内建迭代器上面提到了，数组、Set、Map都是可迭代对象，即它们内部实现了迭代器，并且提供了3种迭代器函数调用。**1、entries()返回迭代器**：返回键值对```js//数组constarr=['a','b','c']for(letvofarr.entries()){console.log(v)}//[0,'a'][1,'b'][2,'c']//Setconstarr=newSet(['a','b','c'])for(letvofarr.entries()){console.log(v)}//['a','a']['b','b']['c','c']//Mapconstarr=newMap()arr.set('a','a')arr.set('b','b')for(letvofarr.entries()){console.log(v)}//['a','a']['b','b']```**2、values()返回迭代器**：返回键值对的value```js//数组constarr=['a','b','c']for(letvofarr.values()){console.log(v)}//'a''b''c'//Setconstarr=newSet(['a','b','c'])for(letvofarr.values()){console.log(v)}//'a''b''c'//Mapconstarr=newMap()arr.set('a','a')arr.set('b','b')for(letvofarr.values()){console.log(v)}//'a''b'```**3、keys()返回迭代器**：返回键值对的key```js//数组constarr=['a','b','c']for(letvofarr.keys()){console.log(v)}//012//Setconstarr=newSet(['a','b','c'])for(letvofarr.keys()){console.log(v)}//'a''b''c'//Mapconstarr=newMap()arr.set('a','a')arr.set('b','b')for(letvofarr.keys()){console.log(v)}//'a''b'```虽然上面列举了3种内建的迭代器方法，但是不同集合的类型还有自己默认的迭代器，在forof中，数组和Set的默认迭代器是values()，Map的默认迭代器是entries()。####forof循环解构对象本身不支持迭代，但是我们可以自己添加一个生成器，返回一个key，value的迭代器，然后使用forof循环解构key和value。```jsconstobj={a:1,b:2,*[Symbol.iterator](){for(letiinobj){yield[i,obj[i]]}},}for(let[key,value]ofobj){console.log(key,value)}//'a'1,'b'2```####字符串迭代器```conststr='abc';for(letvofstr){console.log(v)}//'a''b''c'```####NodeList迭代器迭代器真是无处不在啊，dom节点的迭代器你应该已经用过了。```jsconstdivs=document.getElementByTagName('div')for(letdofdivs){console.log(d)}```####展开运算符和迭代器```jsconsta=[1,2,3]constb=[4,5,6]constc=[...a,...b]console.log(c)//[1,2,3,4,5,6]```####高级迭代器功能你说什么？上面讲了一堆废话都是基础功能？还有高级功能没讲？高级功能不复杂，就是传参、抛出异常、生成器返回语句、委托生成器。1、传参生成器里面有2个yield，当执行第一个next()的时候，返回value为1，然后给第二个next()传入参数10，传递的参数会替代掉上一个next()的yield返回值。在下面的例子中就是first。```jsfunction*createIterator(){letfirst=yield1yieldfirst+2}leti=createIterator()console.log(i.next())//{value:1,done:false}console.log(i.next(10))//{value:12,done:false}```2、在迭代器中抛出错误```jsfunction*createIterator(){letfirst=yield1yieldfirst+2}leti=createIterator()console.log(i.next())//{value:1,done:false}console.log(i.throw(newError('error')))//errorconsole.log(i.next())//不再执行```3、生成器返回语句生成器中添加return表示退出操作。```jsfunction*createIterator(){letfirst=yield1returnyieldfirst+2}leti=createIterator()console.log(i.next())//{value:1,done:false}console.log(i.next())//{value:undefined,done:true}```4、委托生成器生成器嵌套生成器```jsfunction*aIterator(){yield1}function*bIterator(){yield2}function*cIterator(){yield*aIterator()yield*bIterator()}leti=cIterator()console.log(i.next())//{value:1,done:false}console.log(i.next())//{value:2,done:false}```###异步任务执行器ES6之前，我们使用异步的操作方式是调用函数并执行回调函数。书上举的例子挺好的，在nodejs中，有一个读取文件的操作，使用的就是回调函数的方式。```jsvarfs=require('fs')fs.readFile('xx.json',function(err,contents){//在回调函数中做一些事情})```那么任务执行器是什么呢？**任务执行器是一个函数，用来循环执行生成器，因为我们知道生成器需要执行N次next()方法，才能运行完，所以我们需要一个自动任务执行器帮我们做这些事情，这就是任务执行器的作用。**下面我们编写一个异步任务执行器。```js//taskDef是一个生成器函数，run是异步任务执行器functionrun(taskDef){lettask=taskDef()//调用生成器letresult=task.next()//执行生成器的第一个next()，返回resultfunctionstep(){if(!result.done){//如果done为false，则继续执行next()，并且循环step，直到done为true退出。result=task.next(result.value)step()}}step()//开始执行step()}```测试一下我们编写的run方法，我们不再需要console.logN个next了，因为run执行器已经帮我们做了循环执行操作：```jsrun(function*(){letvalue=yield1value=yieldvalue+20console.log(value)//21})```##代理Proxy![clipboard.png](https://segmentfault.com/img/bVR5W5?w=710&h=182)####语法```letp=newProxy(target,handler);```target：一个目标对象(可以是任何类型的对象，包括本机数组，函数，甚至另一个代理)用Proxy来包装。handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。####代理的使用**基础demo：**Proxy的demo有很多，我们只分析基础demo，主要看newProxy({},handler)的操作，指定目标obj对象，然后handler对象执行get()操作，get()返回值的判断是，如果name是target目标对象的属性，则返回target[name]的值，否则返回37，最后测试的时候，p.a是对象p的key，所以返回a的value，而p.b不存在，返回37。```jsconstobj={a:10,}lethandler={get:function(target,name){console.log('test:',target,name)//test:{\"a\":10}a//test:{\"a\":10}breturnnameintarget?target[name]:37},}letp=newProxy(obj,handler)console.log(p.a,p.b)//1037```这个例子的作用是拦截目标对象obj，当执行obj的读写操作时，进入handler函数进行判断，如果读取的key不存在，则返回默认值。##模块的定义模块是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。模块可以是函数、数据、类，需要指定导出的模块名，才能被其他模块访问。```js//数据模块constobj={a:1}//函数模块constsum=(a,b)=>{returna+b}//类模块classMyextendsReact.Components{}```###模块的导出给数据、函数、类添加一个export，就能导出模块。一个配置型的JavaScript文件中，你可能会封装多种函数，然后给每个函数加上一个export关键字，就能在其他文件访问到。```js//数据模块exportconstobj={a:1}//函数模块exportconstsum=(a,b)=>{returna+b}//类模块exportclassMyextendsReact.Components{}``````json//module.jsletvariable=[]//选择导出的变量module.exports={variable:variable//可以写多个}//使用letmodule=require('./module')console.log(module.varibale)```###模块的引用在另外的js文件中，我们可以引用上面定义的模块。使用import关键字，导入分2种情况，一种是导入指定的模块，另外一种是导入全部模块。1、导入指定的模块。```js//导入obj数据，My类import{obj,My}from'./xx.js'//使用console.log(obj,My)```2、导入全部模块```//导入全部模块import*asallfrom'./xx.js'//使用console.log(all.obj,all.sun(1,2),all.My)```###默认模块的使用如果给我们的模块加上default关键字，那么该js文件默认只导出该模块，你还需要把大括号去掉。```js//默认模块的定义functionsum(a,b){returna+b}exportdefaultsum//导入默认模块importsumfrom'./xx.js'```###模块的使用限制不能在语句和函数之内使用export关键字，只能在模块顶部使用，作为react和vue开发者的你，这个限制你应该很熟悉了。**在react中，模块顶部导入其他模块。**```jsimportreactfrom'react'```**在vue中，模块顶部导入其他模块。**```js<script>importsumfrom'./xx.js'</script>```###修改模块导入和导出名有2种修改方式，一种是模块导出时修改，一种是导入模块时修改。1、导出时修改：```jsfunctionsum(a,b){returna+b}export{sumasadd}import{add}from'./xx.js'add(1,2)```2、导入时修改：```functionsum(a,b){returna+b}exportsumimport{sumasadd}from'./xx.js'add(1,2)```###无绑定导入当你的模块没有可导出模块，全都是定义的全局变量的时候，你可以使用无绑定导入。模块：```jsleta=1constPI=3.1314```无绑定导入：```jsimport'./xx.js'console.log(a,PI)```###浏览器加载模块有用过webpack打包js模块的同学可能有经验，使用webpack打包了多个js文件，然后放到HTML使用script加载时，如果加载顺序不对，就会出现找不到模块的错误。这是因为模块之间是有依赖关系的，就像你使用jQuery的时候，必须先加载jQuery的代码，才能使用jQuery提供的方法。**加载模块的方法，总是先加载模块1，再加载模块2，因为module类型默认使用defer属性。**```html<scripttype=\"module\"src=\"module1.js\"></script><scripttype=\"module\"src=\"module2.js\"></script>```###总结模块还有很多有意思的特性，对react和vue开发有一定经验的人对这些基本知识应该了如指掌，新手不了解也不用太心急，写几个module.js做一下尝试。如果浏览器报错，不能识别export模块，你可能需要先加载babel的js插件来编译它。","JavaScript\\Number\\index.md":"#Number##BigInt>在ES10增加了新的原始数据类型：BigInt，表示一个任意精度的整数，可以表示超长数据，可以超出2的53次方。Js中Number类型只能安全的表示-(2^53-1)至2^53-1范的值```console.log(2**53)//es7幂运算符console.log(Number.MAX_SAFE_INTEGER)//最大值-1```**使用BigInt有两种方式：**-方式一：数字后面增加n```constbigInt=9007199254740993nconsole.log(bigInt)console.log(typeofbigInt)//bigintconsole.log(1n==1)//trueconsole.log(1n===1)//false```-方式二：使用BigInt函数```constbigIntNum=BigInt(9007199254740993n)console.log(bigIntNum)```###Promise.allSettled()>学习了ES新特性，我们都知道Promise.all()具有并发执行异步任务的能力。但它的最大问题就是如果其中某个任务出现异常(reject)，所有任务都会挂掉，Promise直接进入reject状态。而Promise.allSettled返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果。```Promise.allSettled([Promise.reject({code:500,msg:'服务异常'}),Promise.resolve({code:200,data:['1','2','3']}),Promise.resolve({code:200,data:['4','5','6']})]).then(res=>{console.log(res)//console.log('成功')constdata=res.filter(item=>item.status==='fulfilled')console.log(data)}).catch(err=>{console.log(err)console.log('失败')})```##幂运算符求幂运算```console.log(2**10)//1024```##**二进制与八进制**-JS中如何把十进制转化为二进制？```consta=5//101console.log(a.toString(2))```-如何把八进制转化为二进制？```constb=101console.log(parseInt(b,2))```ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。```consta=0B0101console.log(a)constb=0O777console.log(b)```**2.新增方法**-Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。```Number.isFinite(15)//trueNumber.isFinite(0.8)//trueNumber.isFinite(NaN)//falseNumber.isFinite(Infinity)//falseNumber.isFinite(-Infinity)//falseNumber.isFinite('foo')//falseNumber.isFinite('15')//falseNumber.isFinite(true)//false```-Number.isNaN()用来检查一个值是否为NaN。```Number.isNaN(NaN)//trueNumber.isNaN(15)//falseNumber.isNaN('15')//falseNumber.isNaN(true)//falseNumber.isNaN(9/NaN)//trueNumber.isNaN('true'/0)//trueNumber.isNaN('true'/'true')//true```-Number.parseInt()ES6将全局方法parseInt()移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。```//ES5的写法parseInt('12.34')//12//ES6的写法Number.parseInt('12.34')//12```-Number.parseFloat()ES6将全局方法parseFloat()移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。```//ES5的写法parseFloat('123.45#')//123.45//ES6的写法Number.parseFloat('123.45#')//123.45```-Number.isInteger()用来判断一个数值是否为整数。```Number.isInteger(25)//trueNumber.isInteger(25.1)//falseNumber.isInteger()//falseNumber.isInteger(null)//falseNumber.isInteger('15')//falseNumber.isInteger(true)//false```-Number.MAX_SAFE_INTEGER```Number.MAX_SAFE_INTEGER===Math.pow(2,53)-1//trueNumber.MAX_SAFE_INTEGER===9007199254740991//true```-Number.MIN_SAFE_INTEGER```Number.MIN_SAFE_INTEGER===-Number.MAX_SAFE_INTEGER//trueNumber.MIN_SAFE_INTEGER===-9007199254740991//true```-Number.isSafeInteger()JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。```Math.pow(2,53)//9007199254740992Math.pow(2,53)===Math.pow(2,53)+1//true```","JavaScript\\String\\index.md":"#字符串###查找方法####字符方法>-charAt([要查询下标])根据下标查找指定字符,超出范围返回空字符串>-charCodeAt([要查询下标])返回Unicode编码超出范围返回NaN>-fromCharCode()根据字符编码创建字符串####位置方法>-根据指定字符串查找下标>-没有找到返回-1>-indexOf():首次出现的下标>-lastIndexOf():最后一次出现的下标####匹配方法>-match()>>-找到一个或多个正则表达式的匹配>-参数:>-要进行模式匹配的正则表达式>-非正则表达式将其传递给RegExp()构造函数,并转换为正则表达式对象>-返回值>-存放匹配结果的数组>-有全局标记g>-无全局标记g(执行一次匹配)>>-search()>>-功能:检索字符串分钟与正则雕大师匹配的字串>-参数:要进行模式匹配的正则表达式>-返回值:>-找到:第一个个匹配的起始位置>-未找到:-1>-特性:忽略全局标记g和lastIndex()属性>>-replace()>>-替换一个与正则表达式匹配的字串>-参数>>-参数1:需要进行替换正则表达式或字符串>-参数2:替换文本或替换函数>>-特性:>>-要想全局替换要加全局标记g>-如果参数2位字符串这可使用特殊字符序列>-```js>$$$>$&匹配整个模式的子字符串>$'匹配子字符串之前的子字符串>$`匹配子字符串之后的子字符串>$n匹配第n个捕获组的子字符串n=1~9>$nn匹配第nn个捕获组的子字符串nn=1~~99>```>>-split():切割>>-必须:指定分隔符>-可选:指定数组的长度###操作方法####拼接方法>-concat()和\"+\"功能相同>-string.concat()>-可以连接一个或多个值####截取方法>-根据下标截取字符串>-slice()>-substring()>-根据长度截取字符串>-substr()####空格处理>-trim()清除前后的空格>-trimLeft()清除前置空格>-trimRight()清除后缀空格####填充处理>-padStart:长度不够在前面填充>-padEnd:长度不够就在后面填充>>```javascript>'x'.padstart(5,'ab')//ababx>'x'.padstart(4,'ab')//abax>'x'.padEnd(5,'ab')//xabab>'x'.padEnd(4,'ab')//xaba>```####比较方法>localeCompare()>>-用本地特定顺序比较两个字符串###编码方法>-字符串常规编码与解码>-escape()>-unescape()>-URI字符串编码与解码>-encodeURI()>-decodeURI()>-URI组件编码与解码>-encodeURIComponent()>-decodeURIComponent()###转换方法>-大小写转换:>-转为大写>-toUpperCase()>-toLocaleUpperCase()>-转为小写>-toLowerCase()>-toLocaleLowerCase()","JavaScript\\String\\字符串\\index.md":"#字符串##模板字符串```js;`string`leta='123'`string${a}`//string123```##Unicode表示法ES6加强了对Unicode的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点。```js'\\u0061'//\"a\"```但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。```js'\\uD842\\uDFB7'//\"𠮷\"'\\u20BB7'//\"7\"```上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。```js'\\u{20BB7}'//\"𠮷\"```有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。```js'\\z'==='z'//true'\\172'==='z'//true'\\x7A'==='z'//true'\\u007A'==='z'//true'\\u{7A}'==='z'//true```##拓展方法###String.prototype.fromCodePoint()```js//ES5console.log(String.fromCharCode(0x20bb7))//ஷ//ES6console.log(String.fromCodePoint(0x20bb7))//𠮷```###String.prototype.includes()>`indexOf`:判断一个字符是否存在>>`includes`:判断一个字符串是否存在###String.prototype.startsWith()>判断字符串是否在头部###String.prototype.endsWith()>判断字符串是否在尾部###String.prototype.repeat()>返回一个新字符串,参数表示重复的次数```jsconststr='isxxx'constnewStr=str.repeat(10)console.log(newStr)//isxxxisxxxisxxxisxxxisxxxisxxxisxxxisxxxisxxxisxxx```","JavaScript\\TypeScript\\error_code.md":"#typescriptTS错误码大全|code|类型|英文描述&中文描述||:----|:---|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||1002|错误|Unterminatedstringliteral.未终止的字符串文本。||1003|错误|Identifierexpected.应为标识符。||1005|错误|'{0}'expected.应为“{0}”。||1006|错误|Afilecannothaveareferencetoitself.文件不能引用自身。||1009|错误|Trailingcommanotallowed.不允许使用尾随逗号。||1010|错误|'_/'expected.应为\"_/\"。||1012|错误|Unexpectedtoken.意外的标记。||1014|错误|Arestparametermustbelastinaparameterlist.rest参数必须是参数列表中的最后一个参数。||1015|错误|Parametercannothavequestionmarkandinitializer.参数不能包含问号和初始化表达式。||1016|错误|Arequiredparametercannotfollowanoptionalparameter.必选参数不能位于可选参数后。||1017|错误|Anindexsignaturecannothavearestparameter.索引签名不能包含rest参数。||1018|错误|Anindexsignatureparametercannothaveanaccessibilitymodifier.索引签名参数不能具有可访问性修饰符。||1019|错误|Anindexsignatureparametercannothaveaquestionmark.索引签名参数不能包含问号。||1020|错误|Anindexsignatureparametercannothaveaninitializer.索引签名参数不能具有初始化表达式。||1021|错误|Anindexsignaturemusthaveatypeannotation.索引签名必须具有类型批注。||1022|错误|Anindexsignatureparametermusthaveatypeannotation.索引签名参数必须具有类型批注。||1023|错误|Anindexsignatureparametertypemustbe'string'or'number'.索引签名参数类型必须为\"string\"或\"number\"。||1024|错误|'readonly'modifiercanonlyappearonapropertydeclarationorindexsignature.||1028|错误|Accessibilitymodifieralreadyseen.已看到可访问性修饰符。||1029|错误|'{0}'modifiermustprecede'{1}'modifier.“{0}”修饰符必须位于“{1}”修饰符之前。||1030|错误|'{0}'modifieralreadyseen.已看到“{0}”修饰符。||1031|错误|'{0}'modifiercannotappearonaclasselement.“{0}”修饰符不能出现在类元素上。||1034|错误|'super'mustbefollowedbyanargumentlistormemberaccess.\"super\"后面必须是参数列表或成员访问。||1035|错误|Onlyambientmodulescanusequotednames.仅环境模块可使用带引号的名称。||1036|错误|Statementsarenotallowedinambientcontexts.不允许在环境上下文中使用语句。||1038|错误|A'declare'modifiercannotbeusedinanalreadyambientcontext.不能在已有的环境上下文中使用\"declare\"修饰符。||1039|错误|Initializersarenotallowedinambientcontexts.不允许在环境上下文中使用初始化表达式。||1040|错误|'{0}'modifiercannotbeusedinanambientcontext.“{0}”修饰符不能在环境上下文中使用。||1041|错误|'{0}'modifiercannotbeusedwithaclassdeclaration.“{0}”修饰符不能与类声明一起使用。||1042|错误|'{0}'modifiercannotbeusedhere.“{0}”修饰符不能在此处使用。||1043|错误|'{0}'modifiercannotappearonadataproperty.“{0}”修饰符不能出现在数据属性上。||1044|错误|'{0}'modifiercannotappearonamoduleornamespaceelement.“{0}”修饰符不能出现在模块元素上。||1045|错误|A'{0}'modifiercannotbeusedwithaninterfacedeclaration.“{0}”修饰符不能与接口声明一起使用。||1046|错误|A'declare'modifierisrequiredforatopleveldeclarationina.d.tsfile.在.d.ts文件中的顶层声明需要\"declare\"修饰符。||1047|错误|Arestparametercannotbeoptional.rest参数不能为可选参数。||1048|错误|Arestparametercannothaveaninitializer.rest参数不能具有初始化表达式。||1049|错误|A'set'accessormusthaveexactlyoneparameter.\"set\"访问器必须正好具有一个参数。||1051|错误|A'set'accessorcannothaveanoptionalparameter.\"set\"访问器不能具有可选参数。||1052|错误|A'set'accessorparametercannothaveaninitializer.\"set\"访问器参数不能包含初始化表达式。||1053|错误|A'set'accessorcannothaverestparameter.\"set\"访问器不能具有rest参数。||1054|错误|A'get'accessorcannothaveparameters.\"get\"访问器不能具有参数。||1055|错误|Type'{0}'isnotavalidasyncfunctionreturntypeinES5/ES3becauseitdoesnotrefertoaPromise-compatibleconstructorvalue.类型“{0}”不是有效的异步函数返回类型。||1056|错误|AccessorsareonlyavailablewhentargetingECMAScript5andhigher.访问器仅在面向ECMAScript5和更高版本时可用。||1057|错误|Anasyncfunctionormethodmusthaveavalidawaitablereturntype.异步函数或方法必须具有有效的可等待返回类型。||1058|错误|Operandfor'await'doesnothaveavalidcallable'then'member.\"await\"的操作数不具有有效的可调用\"then\"成员。||1059|错误|Returnexpressioninasyncfunctiondoesnothaveavalidcallable'then'member.异步函数中的返回表达式不具有有效的可调用\"then\"成员。||1060|错误|Expressionbodyforasyncarrowfunctiondoesnothaveavalidcallable'then'member.异步箭头函数的表达式主体不具有有效的可调用\"then\"成员。||1061|错误|Enummembermusthaveinitializer.枚举成员必须具有初始化表达式。||1062|错误|{0}isreferenceddirectlyorindirectlyinthefulfillmentcallbackofitsown'then'method.{0}在其自身的\"then\"方法的fulfillment回调中得到直接或间接引用。||1063|错误|Anexportassignmentcannotbeusedinanamespace.不能在命名空间中使用导出分配。||1064|错误|ThereturntypeofanasyncfunctionormethodmustbetheglobalPromisetype.ThereturntypeofanasyncfunctionormethodmustbetheglobalPromisetype.||1066|错误|Inambientenumdeclarationsmemberinitializermustbeconstantexpression.在环境枚举声明中，成员初始化表达式必须是常数表达式。||1068|错误|Unexpectedtoken.Aconstructor,method,accessor,orpropertywasexpected.意外的标记。应为构造函数、方法、访问器或属性。||1070|错误|'{0}'modifiercannotappearonatypemember.||1071|错误|'{0}'modifiercannotappearonanindexsignature.||1079|错误|A'{0}'modifiercannotbeusedwithanimportdeclaration.“{0}”修饰符不能与导入声明一起使用。||1084|错误|Invalid'reference'directivesyntax.\"reference\"指令语法无效。||1085|错误|OctalliteralsarenotavailablewhentargetingECMAScript5andhigher.Usethesyntax'{0}'.面向ECMAScript5和更高版本时，八进制文本不可用。||1086|错误|Anaccessorcannotbedeclaredinanambientcontext.不能在环境上下文中声明访问器。||1089|错误|'{0}'modifiercannotappearonaconstructordeclaration.“{0}”修饰符不能出现在构造函数声明中。||1090|错误|'{0}'modifiercannotappearonaparameter.“{0}”修饰符不能出现在参数中。||1091|错误|Onlyasinglevariabledeclarationisallowedina'for...in'statement.\"for...in\"语句中只允许单个变量声明。||1092|错误|Typeparameterscannotappearonaconstructordeclaration.类型参数不能出现在构造函数声明中。||1093|错误|Typeannotationcannotappearonaconstructordeclaration.类型批注不能出现在构造函数声明中。||1094|错误|Anaccessorcannothavetypeparameters.访问器不能具有类型参数。||1095|错误|A'set'accessorcannothaveareturntypeannotation.\"set\"访问器不能具有返回类型批注。||1096|错误|Anindexsignaturemusthaveexactlyoneparameter.索引签名必须正好具有一个参数。||1097|错误|'{0}'listcannotbeempty.“{0}”列表不能为空。||1098|错误|Typeparameterlistcannotbeempty.类型参数列表不能为空。||1099|错误|Typeargumentlistcannotbeempty.类型参数列表不能为空。||1100|错误|Invaliduseof'{0}'instrictmode.严格模式下“{0}”的使用无效。||1101|错误|'with'statementsarenotallowedinstrictmode.严格模式下不允许使用\"with\"语句。||1102|错误|'delete'cannotbecalledonanidentifierinstrictmode.在严格模式下，无法对标识符调用\"delete\"。||1104|错误|A'continue'statementcanonlybeusedwithinanenclosingiterationstatement.\"continue\"语句只能在封闭迭代语句内使用。||1105|错误|A'break'statementcanonlybeusedwithinanenclosingiterationorswitchstatement.\"break\"语句只能在封闭迭代或switch语句内使用。||1107|错误|Jumptargetcannotcrossfunctionboundary.跳转目标不能跨越函数边界。||1108|错误|A'return'statementcanonlybeusedwithinafunctionbody.\"return\"语句只能在函数体中使用。||1109|错误|Expressionexpected.应为表达式。||1110|错误|Typeexpected.应为类型。||1113|错误|A'default'clausecannotappearmorethanonceina'switch'statement.\"default\"子句在\"switch\"语句中只能出现一次。||1114|错误|Duplicatelabel'{0}'标签“{0}”重复||1115|错误|A'continue'statementcanonlyjumptoalabelofanenclosingiterationstatement.\"continue\"语句只能跳转到封闭迭代语句的标签。||1116|错误|A'break'statementcanonlyjumptoalabelofanenclosingstatement.\"break\"语句只能跳转到封闭语句的标签。||1117|错误|Anobjectliteralcannothavemultiplepropertieswiththesamenameinstrictmode.严格模式下，对象文字不能包含多个具有相同名称的属性。||1118|错误|Anobjectliteralcannothavemultipleget/setaccessorswiththesamename.对象文字不能具有多个具有相同名称的get/set访问器。||1119|错误|Anobjectliteralcannothavepropertyandaccessorwiththesamename.对象文字不能包含具有相同名称的属性和访问器。||1120|错误|Anexportassignmentcannothavemodifiers.导出分配不能具有修饰符。||1121|错误|Octalliteralsarenotallowedinstrictmode.严格模式下不允许使用八进制文本。||1122|错误|Atupletypeelementlistcannotbeempty.元组类型元素列表不能为空。||1123|错误|Variabledeclarationlistcannotbeempty.变量声明列表不能为空。||1124|错误|Digitexpected.应为数字。||1125|错误|Hexadecimaldigitexpected.应为十六进制数字。||1126|错误|Unexpectedendoftext.文本意外结束。||1127|错误|Invalidcharacter.无效的字符。||1128|错误|Declarationorstatementexpected.应为声明或语句。||1129|错误|Statementexpected.应为语句。||1130|错误|'case'or'default'expected.应为\"case\"或\"default\"。||1131|错误|Propertyorsignatureexpected.应为属性或签名。||1132|错误|Enummemberexpected.应为枚举成员。||1134|错误|Variabledeclarationexpected.应为变量声明。||1135|错误|Argumentexpressionexpected.应为参数表达式。||1136|错误|Propertyassignmentexpected.应为属性分配。||1137|错误|Expressionorcommaexpected.应为表达式或逗号。||1138|错误|Parameterdeclarationexpected.应为参数声明。||1139|错误|Typeparameterdeclarationexpected.应为类型参数声明。||1140|错误|Typeargumentexpected.应为类型参数。||1141|错误|Stringliteralexpected.应为字符串文本。||1142|错误|Linebreaknotpermittedhere.不允许在此处换行。||1144|错误|'{'or';'expected.应为\"{\"或\";\"。||1146|错误|Declarationexpected.应为声明。||1147|错误|Importdeclarationsinanamespacecannotreferenceamodule.命名空间中的导入声明不能引用模块。||1148|错误|Cannotuseimports,exports,ormoduleaugmentationswhen'--module'is'none'.Cannotcompilemodulesunlessthe'--module'flagisprovidedwithavalidmoduletype.Considersettingthe'module'compileroptionina'tsconfig.json'file.||1149|错误|Filename'{0}'differsfromalreadyincludedfilename'{1}'onlyincasing文件名“{0}”仅在大小写方面与包含的文件名“{1}”不同||1150|错误|'newT[]'cannotbeusedtocreateanarray.Use'newArray()'instead.\"newT[]\"不能用于创建数组。请改用\"newArray()\"。||1155|错误|'const'declarationsmustbeinitialized必须初始化\"const\"声明||1156|错误|'const'declarationscanonlybedeclaredinsideablock.\"const\"声明只能在块的内部声明。||1157|错误|'let'declarationscanonlybedeclaredinsideablock.\"let\"声明只能在块的内部声明。||1160|错误|Unterminatedtemplateliteral.未终止的模板文本。||1161|错误|Unterminatedregularexpressionliteral.未终止的正则表达式文本。||1162|错误|Anobjectmembercannotbedeclaredoptional.对象成员无法声明为可选。||1163|错误|A'yield'expressionisonlyallowedinageneratorbody.只允许在生成器正文中使用\"yield\"表达式。||1164|错误|Computedpropertynamesarenotallowedinenums.枚举中不允许计算属性名。||1165|错误|Acomputedpropertynameinanambientcontextmustdirectlyrefertoabuilt-insymbol.环境上下文中的计算属性名必须直接引用内置符号。||1166|错误|Acomputedpropertynameinaclasspropertydeclarationmustdirectlyrefertoabuilt-insymbol.类属性声明中的计算属性名必须直接引用内置符号。||1168|错误|Acomputedpropertynameinamethodoverloadmustdirectlyrefertoabuilt-insymbol.方法重载中的计算属性名必须直接引用内置符号。||1169|错误|Acomputedpropertynameinaninterfacemustdirectlyrefertoabuilt-insymbol.接口中的计算属性名必须直接引用内置符号。||1170|错误|Acomputedpropertynameinatypeliteralmustdirectlyrefertoabuilt-insymbol.类型文本中的计算属性名必须直接引用内置符号。||1171|错误|Acommaexpressionisnotallowedinacomputedpropertyname.计算属性名中不允许逗号表达式。||1172|错误|'extends'clausealreadyseen.已看到\"extends\"子句。||1173|错误|'extends'clausemustprecede'implements'clause.\"extends\"子句必须位于\"implements\"子句之前。||1174|错误|Classescanonlyextendasingleclass.类只能扩展一个类。||1175|错误|'implements'clausealreadyseen.已看到\"implements\"子句。||1176|错误|Interfacedeclarationcannothave'implements'clause.接口声明不能有\"implements\"子句。||1177|错误|Binarydigitexpected.需要二进制数字。||1178|错误|Octaldigitexpected.需要八进制数字。||1179|错误|Unexpectedtoken.'{'expected.意外标记。应为\"{\"。||1180|错误|Propertydestructuringpatternexpected.应为属性析构模式。||1181|错误|Arrayelementdestructuringpatternexpected.应为数组元素析构模式。||1182|错误|Adestructuringdeclarationmusthaveaninitializer.析构声明必须具有初始化表达式。||1183|错误|Animplementationcannotbedeclaredinambientcontexts.不能在环境上下文中声明实现。||1184|错误|Modifierscannotappearhere.修饰符不能出现在此处。||1185|错误|Mergeconflictmarkerencountered.遇到合并冲突标记。||1186|错误|Arestelementcannothaveaninitializer.rest元素不能具有初始化表达式。||1187|错误|Aparameterpropertymaynotbedeclaredusingabindingpattern.参数属性不能为绑定模式。||1188|错误|Onlyasinglevariabledeclarationisallowedina'for...of'statement.\"for...of\"语句中只允许单个变量声明。||1189|错误|Thevariabledeclarationofa'for...in'statementcannothaveaninitializer.\"for...in\"语句的变量声明不能有初始化表达式。||1190|错误|Thevariabledeclarationofa'for...of'statementcannothaveaninitializer.\"for...of\"语句的变量声明不能有初始化表达式。||1191|错误|Animportdeclarationcannothavemodifiers.导入声明不能有修饰符。||1192|错误|Module'{0}'hasnodefaultexport.模块“{0}”没有默认导出。||1193|错误|Anexportdeclarationcannothavemodifiers.导出声明不能有修饰符。||1194|错误|Exportdeclarationsarenotpermittedinanamespace.命名空间中不允许有导出声明。||1196|错误|Catchclausevariablecannothaveatypeannotation.Catch子句变量不能有类型批注。||1197|错误|Catchclausevariablecannothaveaninitializer.Catch子句变量不能有初始化表达式。||1198|错误|AnextendedUnicodeescapevaluemustbebetween0x0and0x10FFFFinclusive.扩展的Unicode转义值必须介于(含)0x0和0x10FFFF之间。||1199|错误|UnterminatedUnicodeescapesequence.未终止的Unicode转义序列。||1200|错误|Lineterminatornotpermittedbeforearrow.箭头前不允许有行终止符。||1202|错误|ImportassignmentcannotbeusedwhentargetingECMAScript2015modules.Considerusing'import_asnsfrom\"mod\"','import{a}from\"mod\"','importdfrom\"mod\"',oranothermoduleformatinstead.当面向ECMAScript6模块时，不能使用导入分配。请考虑改用\"import_asnsfrom\"mod\"\"、\"import{a}from\"mod\"\"或\"importdfrom\"mod\"\"或其他模块格式。||1203|错误|ExportassignmentcannotbeusedwhentargetingECMAScript2015modules.Considerusing'exportdefault'oranothermoduleformatinstead.当面向ECMAScript6模块时，不能使用导出分配。请考虑改用“导出默认”或其他模块格式。||1206|错误|Decoratorsarenotvalidhere.修饰器在此处无效。||1207|错误|Decoratorscannotbeappliedtomultipleget/setaccessorsofthesamename.不能向多个同名的get/set访问器应用修饰器。||1208|错误|Cannotcompilenamespaceswhenthe'--isolatedModules'flagisprovided.提供\"--isolatedModules\"标志时无法编译命名空间。||1209|错误|Ambientconstenumsarenotallowedwhenthe'--isolatedModules'flagisprovided.提供\"--isolatedModules\"标志的情况下不允许使用环境常数枚举。||1210|错误|Invaliduseof'{0}'.Classdefinitionsareautomaticallyinstrictmode.“{0}”的使用无效。类定义自动处于严格模式。||1211|错误|Aclassdeclarationwithoutthe'default'modifiermusthaveaname不带\"default\"修饰符的类声明必须具有名称||1212|错误|Identifierexpected.'{0}'isareservedwordinstrictmode应为标识符。“{0}”在严格模式下是保留字||1213|错误|Identifierexpected.'{0}'isareservedwordinstrictmode.Classdefinitionsareautomaticallyinstrictmode.应为标识符。“{0}”在严格模式下是保留字。类定义自动处于严格模式。||1214|错误|Identifierexpected.'{0}'isareservedwordinstrictmode.Modulesareautomaticallyinstrictmode.应为标识符。“{0}”是严格模式下的保留字。模块自动处于严格模式。||1215|错误|Invaliduseof'{0}'.Modulesareautomaticallyinstrictmode.“{0}”的使用无效。模块自动处于严格模式。||1218|错误|Exportassignmentisnotsupportedwhen'--module'flagis'system'.当\"--module\"标志是\"system\"时不支持导出分配。||1219|错误|Experimentalsupportfordecoratorsisafeaturethatissubjecttochangeinafuturerelease.Setthe'experimentalDecorators'optiontoremovethiswarning.Experimentalsupportfordecoratorsisafeaturethatissubjecttochangeinafuturerelease.Setthe'experimentalDecorators'optiontoremovethiswarning.||1220|错误|GeneratorsareonlyavailablewhentargetingECMAScript2015orhigher.仅当面向ECMAScript6或更高版本时，生成器才可用。||1221|错误|Generatorsarenotallowedinanambientcontext.不允许在环境上下文中使用生成器。||1222|错误|Anoverloadsignaturecannotbedeclaredasagenerator.重载签名无法声明为生成器。||1223|错误|'{0}'tagalreadyspecified.已指定“{0}”标记。||1224|错误|Signature'{0}'musthaveatypepredicate.签名“{0}”必须具有类型谓词。||1225|错误|Cannotfindparameter'{0}'.找不到参数“{0}”。||1226|错误|Typepredicate'{0}'isnotassignableto'{1}'.类型谓词“{0}”不可分配给“{1}”。||1227|错误|Parameter'{0}'isnotinthesamepositionasparameter'{1}'.参数“{0}”和参数“{1}”的位置不一样。||1228|错误|Atypepredicateisonlyallowedinreturntypepositionforfunctionsandmethods.只允许在函数和方法的返回类型位置使用类型谓词。||1229|错误|Atypepredicatecannotreferencearestparameter.类型谓词无法引用rest参数||1230|错误|Atypepredicatecannotreferenceelement'{0}'inabindingpattern.类型谓词无法在绑定模式中引用元素“{0}”。||1231|错误|Anexportassignmentcanonlybeusedinamodule.导出分配只能在模块中使用。||1232|错误|Animportdeclarationcanonlybeusedinanamespaceormodule.导入声明只能在命名空间或模块中使用。||1233|错误|Anexportdeclarationcanonlybeusedinamodule.导出声明只能在模块中使用。||1234|错误|Anambientmoduledeclarationisonlyallowedatthetoplevelinafile.只允许在文件的顶层中使用环境模块声明。||1235|错误|Anamespacedeclarationisonlyallowedinanamespaceormodule.只允许在命名空间或模块中使用命名空间声明。||1236|错误|Thereturntypeofapropertydecoratorfunctionmustbeeither'void'or'any'.属性修饰器函数的返回类型必须为\"void\"或\"any\"。||1237|错误|Thereturntypeofaparameterdecoratorfunctionmustbeeither'void'or'any'.参数修饰器函数的返回类型必须为\"void\"或\"any\"。||1238|错误|Unabletoresolvesignatureofclassdecoratorwhencalledasanexpression.作为表达式调用时，无法解析类修饰器的签名。||1239|错误|Unabletoresolvesignatureofparameterdecoratorwhencalledasanexpression.作为表达式调用时，无法解析参数修饰器的签名。||1240|错误|Unabletoresolvesignatureofpropertydecoratorwhencalledasanexpression.作为表达式调用时，无法解析属性修饰器的签名。||1241|错误|Unabletoresolvesignatureofmethoddecoratorwhencalledasanexpression.作为表达式调用时，无法解析方法修饰器的签名。||1242|错误|'abstract'modifiercanonlyappearonaclass,method,orpropertydeclaration.\"abstract\"修饰符只能出现在类声明或方法声明中。||1243|错误|'{0}'modifiercannotbeusedwith'{1}'modifier.“{0}”修饰符不能与“{1}”修饰符一起使用。||1244|错误|Abstractmethodscanonlyappearwithinanabstractclass.抽象方法只能出现在抽象类中。||1245|错误|Method'{0}'cannothaveanimplementationbecauseitismarkedabstract.方法“{0}”不能具有实现，因为它标记为抽象。||1246|错误|Aninterfacepropertycannothaveaninitializer.接口函数不能具有初始化表达式。||1247|错误|Atypeliteralpropertycannothaveaninitializer.类型文字数据不可具有初始化表达式。||1248|错误|Aclassmembercannothavethe'{0}'keyword.Aclassmembercannothavethe'{0}'keyword.||1249|错误|Adecoratorcanonlydecorateamethodimplementation,notanoverload.Adecoratorcanonlydecorateamethodimplementation,notanoverload.||1250|错误|Functiondeclarationsarenotallowedinsideblocksinstrictmodewhentargeting'ES3'or'ES5'.||1251|错误|Functiondeclarationsarenotallowedinsideblocksinstrictmodewhentargeting'ES3'or'ES5'.Classdefinitionsareautomaticallyinstrictmode.||1252|错误|Functiondeclarationsarenotallowedinsideblocksinstrictmodewhentargeting'ES3'or'ES5'.Modulesareautomaticallyinstrictmode.||1253|错误|'{0}'tagcannotbeusedindependentlyasatoplevelJSDoctag.||1254|错误|A'const'initializerinanambientcontextmustbeastringornumericliteral.||1300|错误|'with'statementsarenotallowedinanasyncfunctionblock.不允许在异步函数块中使用\"with\"语句。||1308|错误|'await'expressionisonlyallowedwithinanasyncfunction.只允许在异步函数中使用\"await\"表达式。||1312|错误|'='canonlybeusedinanobjectliteralpropertyinsideadestructuringassignment.\"=\"只可在重构赋值内部的对象文字属性中使用。||1313|错误|Thebodyofan'if'statementcannotbetheemptystatement.\"if\"语句的正文不能为空语句。||1314|错误|Globalmoduleexportsmayonlyappearinmodulefiles.||1315|错误|Globalmoduleexportsmayonlyappearindeclarationfiles.||1316|错误|Globalmoduleexportsmayonlyappearattoplevel.||1317|错误|Aparameterpropertycannotbedeclaredusingarestparameter.||1318|错误|Anabstractaccessorcannothaveanimplementation.||1319|错误|AdefaultexportcanonlybeusedinanECMAScript-stylemodule.||2300|错误|Duplicateidentifier'{0}'.标识符“{0}”重复。||2301|错误|Initializerofinstancemembervariable'{0}'cannotreferenceidentifier'{1}'declaredintheconstructor.实例成员变量“{0}”的初始化表达式不能引用构造函数中声明的标识符“{1}”。||2302|错误|Staticmemberscannotreferenceclasstypeparameters.静态成员不能引用类类型参数。||2303|错误|Circulardefinitionofimportalias'{0}'.导入别名“{0}”的循环定义。||2304|错误|Cannotfindname'{0}'.找不到名称“{0}”。||2305|错误|Module'{0}'hasnoexportedmember'{1}'.模块“{0}”没有导出的成员“{1}”。||2306|错误|File'{0}'isnotamodule.文件“{0}”不是模块。||2307|错误|Cannotfindmodule'{0}'.找不到模块“{0}”。||2308|错误|Module{0}hasalreadyexportedamembernamed'{1}'.Considerexplicitlyre-exportingtoresolvetheambiguity.模块{0}已导出一个名为“{1}”的成员。请考虑重新显式导出以解决歧义。||2309|错误|Anexportassignmentcannotbeusedinamodulewithotherexportedelements.不能在具有其他导出元素的模块中使用导出分配。||2310|错误|Type'{0}'recursivelyreferencesitselfasabasetype.类型“{0}”以递归方式将自身引用为基类。||2311|错误|Aclassmayonlyextendanotherclass.类只能扩展其他类。||2312|错误|Aninterfacemayonlyextendaclassoranotherinterface.接口只能扩展类或其他接口。||2313|错误|Typeparameter'{0}'hasacircularconstraint.Typeparameter'{0}'hasacircularconstraint.||2314|错误|Generictype'{0}'requires{1}typeargument(s).泛型类型“{0}”需要{1}个类型参数。||2315|错误|Type'{0}'isnotgeneric.类型“{0}”不是泛型类型。||2316|错误|Globaltype'{0}'mustbeaclassorinterfacetype.全局类型“{0}”必须为类或接口类型。||2317|错误|Globaltype'{0}'musthave{1}typeparameter(s).全局类型“{0}”必须具有{1}个类型参数。||2318|错误|Cannotfindglobaltype'{0}'.找不到全局类型“{0}”。||2319|错误|Namedproperty'{0}'oftypes'{1}'and'{2}'arenotidentical.“{1}”和“{2}”类型的命名属性“{0}”不完全相同。||2320|错误|Interface'{0}'cannotsimultaneouslyextendtypes'{1}'and'{2}'.接口“{0}”不能同时扩展类型“{1}”和“{2}”。||2321|错误|Excessivestackdepthcomparingtypes'{0}'and'{1}'.与类型“{0}”和“{1}”相比，堆栈深度过高。||2322|错误|Type'{0}'isnotassignabletotype'{1}'.不能将类型“{0}”分配给类型“{1}”。||2323|错误|Cannotredeclareexportedvariable'{0}'.无法重新声明导出的变量“{0}”。||2324|错误|Property'{0}'ismissingintype'{1}'.类型“{1}”中缺少属性“{0}”。||2325|错误|Property'{0}'isprivateintype'{1}'butnotintype'{2}'.属性“{0}”在类型“{1}”中是私有属性，但在类型“{2}”中不是。||2326|错误|Typesofproperty'{0}'areincompatible.属性“{0}”的类型不兼容。||2327|错误|Property'{0}'isoptionalintype'{1}'butrequiredintype'{2}'.属性“{0}”在类型“{1}”中为可选，但在类型“{2}”中为必选。||2328|错误|Typesofparameters'{0}'and'{1}'areincompatible.参数“{0}”和“{1}”的类型不兼容。||2329|错误|Indexsignatureismissingintype'{0}'.类型“{0}”中缺少索引签名。||2330|错误|Indexsignaturesareincompatible.索引签名不兼容。||2331|错误|'this'cannotbereferencedinamoduleornamespacebody.不能在模块或命名空间体中引用\"this\"。||2332|错误|'this'cannotbereferencedincurrentlocation.不能在当前位置引用\"this\"。||2333|错误|'this'cannotbereferencedinconstructorarguments.不能在构造函数参数中引用\"this\"。||2334|错误|'this'cannotbereferencedinastaticpropertyinitializer.不能在静态属性初始化表达式中引用\"this\"。||2335|错误|'super'canonlybereferencedinaderivedclass.只能在派生类中引用\"super\"。||2336|错误|'super'cannotbereferencedinconstructorarguments.不能在构造函数参数中引用\"super\"。||2337|错误|Supercallsarenotpermittedoutsideconstructorsorinnestedfunctionsinsideconstructors.不允许在构造函数外部或在构造函数内的嵌套函数中进行Super调用。||2338|错误|'super'propertyaccessispermittedonlyinaconstructor,memberfunction,ormemberaccessorofaderivedclass.只有构造函数、成员函数或派生类的成员访问器中才允许\"super\"属性访问。||2339|错误|Property'{0}'doesnotexistontype'{1}'.类型“{1}”上不存在属性“{0}”。||2340|错误|Onlypublicandprotectedmethodsofthebaseclassareaccessibleviathe'super'keyword.通过\"super\"关键字只能访问基类的公共方法和受保护方法。||2341|错误|Property'{0}'isprivateandonlyaccessiblewithinclass'{1}'.属性“{0}”为私有属性，只能在类“{1}”中访问。||2342|错误|Anindexexpressionargumentmustbeoftype'string','number','symbol',or'any'.索引表达式参数必须为\"string\"、\"number\"、\"symbol\"或\"any\"类型。||2343|错误|Thissyntaxrequiresanimportedhelpernamed'{1}',butmodule'{0}'hasnoexportedmember'{1}'.||2344|错误|Type'{0}'doesnotsatisfytheconstraint'{1}'.类型“{0}”不满足约束“{1}”。||2345|错误|Argumentoftype'{0}'isnotassignabletoparameteroftype'{1}'.类型“{0}”的参数不能赋给类型“{1}”的参数。||2346|错误|Suppliedparametersdonotmatchanysignatureofcalltarget.提供的参数与调用目标的任何签名都不匹配。||2347|错误|Untypedfunctioncallsmaynotaccepttypearguments.非类型化函数调用不能接受类型参数。||2348|错误|Valueoftype'{0}'isnotcallable.Didyoumeantoinclude'new'?类型“{0}”的值不可调用。是否希望包括\"new\"?||2349|错误|Cannotinvokeanexpressionwhosetypelacksacallsignature.Type'{0}'hasnocompatiblecallsignatures.无法调用其类型缺少调用签名的表达式。||2350|错误|Onlyavoidfunctioncanbecalledwiththe'new'keyword.使用\"new\"关键字只能调用void函数。||2351|错误|Cannotuse'new'withanexpressionwhosetypelacksacallorconstructsignature.其类型缺少调用或构造签名的表达式无法使用\"new\"。||2352|错误|Type'{0}'cannotbeconvertedtotype'{1}'.类型“{0}”和类型“{1}”均不能赋给对方。||2353|错误|Objectliteralmayonlyspecifyknownproperties,and'{0}'doesnotexistintype'{1}'.对象文字可以只指定已知属性，并且“{0}”不在类型“{1}”中。||2354|错误|Thissyntaxrequiresanimportedhelperbutmodule'{0}'cannotbefound.返回表达式中不存在最佳通用类型。||2355|错误|Afunctionwhosedeclaredtypeisneither'void'nor'any'mustreturnavalue.其声明类型不为\"void\"或\"any\"的函数必须返回值。||2356|错误|Anarithmeticoperandmustbeoftype'any','number'oranenumtype.算术操作数必须为类型\"any\"、\"number\"或枚举类型。||2357|错误|Theoperandofanincrementordecrementoperatormustbeavariableorapropertyaccess.增量或减量运算符的操作数必须为变量、属性或索引器。||2358|错误|Theleft-handsideofan'instanceof'expressionmustbeoftype'any',anobjecttypeoratypeparameter.\"instanceof\"表达式左侧必须是\"any\"类型、对象类型或类型参数。||2359|错误|Theright-handsideofan'instanceof'expressionmustbeoftype'any'orofatypeassignabletothe'Function'interfacetype.\"instanceof\"表达式的右侧必须属于类型\"any\"，或属于可分配给\"Function\"接口类型的类型。||2360|错误|Theleft-handsideofan'in'expressionmustbeoftype'any','string','number',or'symbol'.\"in\"表达式左侧的类型必须为\"any\"、\"string\"、\"number\"或\"symbol\"。||2361|错误|Theright-handsideofan'in'expressionmustbeoftype'any',anobjecttypeoratypeparameter\"in\"表达式的右侧必须是\"any\"类型、对象类型或类型参数||2362|错误|Theleft-handsideofanarithmeticoperationmustbeoftype'any','number'oranenumtype.算术运算左侧必须是\"any\"、\"number\"或枚举类型。||2363|错误|Theright-handsideofanarithmeticoperationmustbeoftype'any','number'oranenumtype.算术运算右侧必须是\"any\"、\"number\"或枚举类型。||2364|错误|Theleft-handsideofanassignmentexpressionmustbeavariableorapropertyaccess.赋值表达式左侧无效。||2365|错误|Operator'{0}'cannotbeappliedtotypes'{1}'and'{2}'.运算符“{0}”不能应用于类型“{1}”和“{2}”。||2366|错误|Functionlacksendingreturnstatementandreturntypedoesnotinclude'undefined'.||2368|错误|Typeparameternamecannotbe'{0}'类型参数名称不能为“{0}”||2369|错误|Aparameterpropertyisonlyallowedinaconstructorimplementation.只允许在构造函数实现中使用参数属性。||2370|错误|Arestparametermustbeofanarraytype.rest参数必须是数组类型。||2371|错误|Aparameterinitializerisonlyallowedinafunctionorconstructorimplementation.只允许在函数或构造函数实现中使用参数初始化表达式。||2372|错误|Parameter'{0}'cannotbereferencedinitsinitializer.参数“{0}”的初始化表达式中不能引用该参数自身。||2373|错误|Initializerofparameter'{0}'cannotreferenceidentifier'{1}'declaredafterit.参数“{0}”的初始化表达式不能引用在它之后声明的标识符“{1}”。||2374|错误|Duplicatestringindexsignature.字符串索引签名重复。||2375|错误|Duplicatenumberindexsignature.数字索引签名重复。||2376|错误|A'super'callmustbethefirststatementintheconstructorwhenaclasscontainsinitializedpropertiesorhasparameterproperties.当类包含初始化的属性或参数属性时，\"super\"调用必须是构造函数中的第一个语句。||2377|错误|Constructorsforderivedclassesmustcontaina'super'call.派生类的构造函数必须包含\"super\"调用。||2378|错误|A'get'accessormustreturnavalue.\"get\"访问器必须返回值。||2379|错误|Getterandsetteraccessorsdonotagreeinvisibility.Getter和setter访问器在可见性上不一致。||2380|错误|'get'and'set'accessormusthavethesametype.\"get\"和\"set\"访问器必须属于同一类型。||2381|错误|Asignaturewithanimplementationcannotuseastringliteraltype.具有实现的签名不能使用字符串文本类型。||2382|错误|Specializedoverloadsignatureisnotassignabletoanynon-specializedsignature.指定的重载签名不可分配给任何非专用化签名。||2383|错误|Overloadsignaturesmustallbeexportedornon-exported.重载签名必须全部导出或全部不导出。||2384|错误|Overloadsignaturesmustallbeambientornon-ambient.重载签名必须全部为环境签名或非环境签名。||2385|错误|Overloadsignaturesmustallbepublic,privateorprotected.重载签名必须全部是公共签名、私有签名或受保护签名。||2386|错误|Overloadsignaturesmustallbeoptionalorrequired.重载签名必须全部为可选签名或必需签名。||2387|错误|Functionoverloadmustbestatic.函数重载必须为静态。||2388|错误|Functionoverloadmustnotbestatic.函数重载不能为静态。||2389|错误|Functionimplementationnamemustbe'{0}'.函数实现名称必须为“{0}”。||2390|错误|Constructorimplementationismissing.缺少构造函数实现。||2391|错误|Functionimplementationismissingornotimmediatelyfollowingthedeclaration.函数实现缺失或未立即出现在声明之后。||2392|错误|Multipleconstructorimplementationsarenotallowed.不允许存在多个构造函数实现。||2393|错误|Duplicatefunctionimplementation.函数实现重复。||2394|错误|Overloadsignatureisnotcompatiblewithfunctionimplementation.重载签名与函数实现不兼容。||2395|错误|Individualdeclarationsinmergeddeclaration'{0}'mustbeallexportedoralllocal.合并声明“{0}”中的单独声明必须全为导出或全为局部声明。||2396|错误|Duplicateidentifier'arguments'.Compileruses'arguments'toinitializerestparameters.标识符\"arguments\"重复。编译器使用\"arguments\"初始化rest参数。||2397|错误|Declarationnameconflictswithbuilt-inglobalidentifier'{0}'.Declarationnameconflictswithbuilt-inglobalidentifier'{0}'.||2399|错误|Duplicateidentifier'\\_this'.Compilerusesvariabledeclaration'\\_this'tocapture'this'reference.标识符\"\\_this\"重复。编译器使用变量声明\"\\_this\"来捕获\"this\"引用。||2400|错误|Expressionresolvestovariabledeclaration'\\_this'thatcompilerusestocapture'this'reference.表达式解析为编译器用于捕获\"this\"引用的变量声明\"\\_this\"。||2401|错误|Duplicateidentifier'\\_super'.Compileruses'\\_super'tocapturebaseclassreference.标识符\"\\_super\"重复。编译器使用\"\\_super\"获取基类引用。||2402|错误|Expressionresolvesto'\\_super'thatcompilerusestocapturebaseclassreference.表达式解析为\"\\_super\"，编译器使用\"\\_super\"获取基类引用。||2403|错误|Subsequentvariabledeclarationsmusthavethesametype.Variable'{0}'mustbeoftype'{1}',butherehastype'{2}'.后续变量声明必须属于同一类型。变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。||2404|错误|Theleft-handsideofa'for...in'statementcannotuseatypeannotation.\"for...in\"语句的左侧不能使用类型批注。||2405|错误|Theleft-handsideofa'for...in'statementmustbeoftype'string'or'any'.\"for...in\"语句的左侧必须是\"string\"或\"any\"类型。||2406|错误|Theleft-handsideofa'for...in'statementmustbeavariableorapropertyaccess.\"for...in\"语句左侧无效。||2407|错误|Theright-handsideofa'for...in'statementmustbeoftype'any',anobjecttypeoratypeparameter.\"for...in\"语句右侧必须是\"any\"类型、对象类型或类型参数。||2408|错误|Setterscannotreturnavalue.Setter不能返回值。||2409|错误|Returntypeofconstructorsignaturemustbeassignabletotheinstancetypeoftheclass构造函数签名的返回类型必须可赋给类的实例类型||2410|错误|The'with'statementisnotsupported.Allsymbolsina'with'blockwillhavetype'any'.\"with\"块内的所有符号都将被解析为\"any\"。||2411|错误|Property'{0}'oftype'{1}'isnotassignabletostringindextype'{2}'.类型“{1}”的属性“{0}”不能赋给字符串索引类型“{2}”。||2412|错误|Property'{0}'oftype'{1}'isnotassignabletonumericindextype'{2}'.类型“{1}”的属性“{0}”不能赋给数值索引类型“{2}”。||2413|错误|Numericindextype'{0}'isnotassignabletostringindextype'{1}'.数字索引类型“{0}”不能赋给字符串索引类型“{1}”。||2414|错误|Classnamecannotbe'{0}'类名不能为“{0}”||2415|错误|Class'{0}'incorrectlyextendsbaseclass'{1}'.类“{0}”错误扩展基类“{1}”。||2417|错误|Classstaticside'{0}'incorrectlyextendsbaseclassstaticside'{1}'.类静态侧“{0}”错误扩展基类静态侧“{1}”。||2420|错误|Class'{0}'incorrectlyimplementsinterface'{1}'.类“{0}”错误实现接口“{1}”。||2422|错误|Aclassmayonlyimplementanotherclassorinterface.类只能实现其他类或接口。||2423|错误|Class'{0}'definesinstancememberfunction'{1}',butextendedclass'{2}'definesitasinstancememberaccessor.类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。||2424|错误|Class'{0}'definesinstancememberfunction'{1}',butextendedclass'{2}'definesitasinstancememberproperty.类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员属性。||2425|错误|Class'{0}'definesinstancememberproperty'{1}',butextendedclass'{2}'definesitasinstancememberfunction.类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。||2426|错误|Class'{0}'definesinstancememberaccessor'{1}',butextendedclass'{2}'definesitasinstancememberfunction.类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。||2427|错误|Interfacenamecannotbe'{0}'接口名不能为“{0}”||2428|错误|Alldeclarationsof'{0}'musthaveidenticaltypeparameters.接口的所有声明必须具有相同的类型参数。||2430|错误|Interface'{0}'incorrectlyextendsinterface'{1}'.接口“{0}”错误扩展接口“{1}”。||2431|错误|Enumnamecannotbe'{0}'枚举名不能为“{0}”||2432|错误|Inanenumwithmultipledeclarations,onlyonedeclarationcanomitaninitializerforitsfirstenumelement.在包含多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始化表达式。||2433|错误|Anamespacedeclarationcannotbeinadifferentfilefromaclassorfunctionwithwhichitismerged命名空间声明不能位于与之合并的类或函数中的其他文件内||2434|错误|Anamespacedeclarationcannotbelocatedpriortoaclassorfunctionwithwhichitismerged命名空间声明不能位于与之合并的类或函数前||2435|错误|Ambientmodulescannotbenestedinothermodulesornamespaces.环境模块不能嵌套在其他模块或命名空间中。||2436|错误|Ambientmoduledeclarationcannotspecifyrelativemodulename.环境模块声明无法指定相对模块名。||2437|错误|Module'{0}'ishiddenbyalocaldeclarationwiththesamename模块“{0}”被具有相同名称的局部声明隐藏||2438|错误|Importnamecannotbe'{0}'导入名称不能为“{0}”||2439|错误|Importorexportdeclarationinanambientmoduledeclarationcannotreferencemodulethroughrelativemodulename.环境模块声明中的导入或导出声明不能通过相对模块名引用模块。||2440|错误|Importdeclarationconflictswithlocaldeclarationof'{0}'导入声明与“{0}”的局部声明冲突||2441|错误|Duplicateidentifier'{0}'.Compilerreservesname'{1}'intoplevelscopeofamodule.标识符“{0}”重复。编译器在模块的顶层范围中保留名称“{1}”。||2442|错误|Typeshaveseparatedeclarationsofaprivateproperty'{0}'.类型具有私有属性“{0}”的单独声明。||2443|错误|Property'{0}'isprotectedbuttype'{1}'isnotaclassderivedfrom'{2}'.属性“{0}”受保护，但类型“{1}”并不是从“{2}”派生的类。||2444|错误|Property'{0}'isprotectedintype'{1}'butpublicintype'{2}'.属性“{0}”在类型“{1}”中受保护，但在类型“{2}”中为公共属性。||2445|错误|Property'{0}'isprotectedandonlyaccessiblewithinclass'{1}'anditssubclasses.属性“{0}”受保护，只能在类“{1}”及其子类中访问。||2446|错误|Property'{0}'isprotectedandonlyaccessiblethroughaninstanceofclass'{1}'.属性“{0}”受保护，只能通过类“{1}”的实例访问。||2447|错误|The'{0}'operatorisnotallowedforbooleantypes.Considerusing'{1}'instead.“{0}”运算符不允许用于布尔类型。请考虑改用“{1}”。||2448|错误|Block-scopedvariable'{0}'usedbeforeitsdeclaration.声明之前已使用的块范围变量“{0}”。||2451|错误|Cannotredeclareblock-scopedvariable'{0}'.无法重新声明块范围变量“{0}”。||2452|错误|Anenummembercannothaveanumericname.枚举成员不能具有数值名。||2453|错误|Thetypeargumentfortypeparameter'{0}'cannotbeinferredfromtheusage.Considerspecifyingthetypeargumentsexplicitly.无法从用法推断类型形参“{0}”的类型实参。可以考虑显式指定类型实参。||2454|错误|Variable'{0}'isusedbeforebeingassigned.||2455|错误|Typeargumentcandidate'{1}'isnotavalidtypeargumentbecauseitisnotasupertypeofcandidate'{0}'.候选类型参数“{1}”不是有效的类型参数，因为它不是候选“{0}”的超类型。||2456|错误|Typealias'{0}'circularlyreferencesitself.类型别名“{0}”循环引用自身。||2457|错误|Typealiasnamecannotbe'{0}'类型别名不能为“{0}”||2458|错误|AnAMDmodulecannothavemultiplenameassignments.AMD模块无法拥有多个名称分配。||2459|错误|Type'{0}'hasnoproperty'{1}'andnostringindexsignature.类型“{0}”不具有属性“{1}”和字符串索引签名。||2460|错误|Type'{0}'hasnoproperty'{1}'.类型“{0}”不具有属性“{1}”。||2461|错误|Type'{0}'isnotanarraytype.类型“{0}”不是数组类型。||2462|错误|Arestelementmustbelastinadestructuringpatternrest元素必须在数组析构模式中位于最末||2463|错误|Abindingpatternparametercannotbeoptionalinanimplementationsignature.绑定模式参数在实现签名中不能为可选参数。||2464|错误|Acomputedpropertynamemustbeoftype'string','number','symbol',or'any'.计算属性名的类型必须为\"string\"、\"number\"、\"symbol\"或\"any\"。||2465|错误|'this'cannotbereferencedinacomputedpropertyname.不能在计算属性名中引用\"this\"。||2466|错误|'super'cannotbereferencedinacomputedpropertyname.不能在计算属性名中引用\"super\"。||2467|错误|Acomputedpropertynamecannotreferenceatypeparameterfromitscontainingtype.计算属性名无法从其包含的类型引用类型参数。||2468|错误|Cannotfindglobalvalue'{0}'.找不到全局值“{0}”。||2469|错误|The'{0}'operatorcannotbeappliedtotype'symbol'.“{0}”运算符不能应用于类型\"symbol\"。||2470|错误|'Symbol'referencedoesnotrefertotheglobalSymbolconstructorobject.\"Symbol\"引用不是指全局符号构造函数对象。||2471|错误|Acomputedpropertynameoftheform'{0}'mustbeoftype'symbol'.窗体“{0}”的计算属性名必须是\"symbol\"类型。||2472|错误|Spreadoperatorin'new'expressionsisonlyavailablewhentargetingECMAScript5andhigher.仅当面向ECMAScript5和更高版本时，\"new\"表达式中的展开运算符才可用。||2473|错误|Enumdeclarationsmustallbeconstornon-const.枚举声明必须全为常数或非常数。||2474|错误|In'const'enumdeclarationsmemberinitializermustbeconstantexpression.在\"const\"枚举声明中，成员初始化表达式必须是常数表达式。||2475|错误|'const'enumscanonlybeusedinpropertyorindexaccessexpressionsortherighthandsideofanimportdeclarationorexportassignment.\"const\"枚举仅可在属性、索引访问表达式、导入声明的右侧或导出分配中使用。||2476|错误|Aconstenummembercanonlybeaccessedusingastringliteral.只有使用字符串文本才能访问常数枚举成员。||2477|错误|'const'enummemberinitializerwasevaluatedtoanon-finitevalue.\"const\"枚举成员初始化表达式的求值结果为非有限值。||2478|错误|'const'enummemberinitializerwasevaluatedtodisallowedvalue'NaN'.\"const\"枚举成员初始化表达式的求值结果为不允许使用的值\"NaN\"。||2479|错误|Property'{0}'doesnotexiston'const'enum'{1}'.\"const\"枚举“{1}”上不存在属性“{0}”。||2480|错误|'let'isnotallowedtobeusedasanamein'let'or'const'declarations.\"let\"不能用作\"let\"或\"const\"声明中的名称。||2481|错误|Cannotinitializeouterscopedvariable'{0}'inthesamescopeasblockscopeddeclaration'{1}'.无法在块范围声明“{1}”所在的范围内初始化外部范围变量“{0}”。||2483|错误|Theleft-handsideofa'for...of'statementcannotuseatypeannotation.\"for...of\"语句的左侧不能使用类型批注。||2484|错误|Exportdeclarationconflictswithexporteddeclarationof'{0}'导出声明与“{0}”的导出声明冲突||2487|错误|Theleft-handsideofa'for...of'statementmustbeavariableorapropertyaccess.\"for...of\"语句左侧无效。||2488|错误|Typemusthavea'Symbol.iterator'methodthatreturnsaniterator.类型必须具有返回迭代器的\"Symbol.iterator\"方法。||2489|错误|Aniteratormusthavea'next()'method.迭代器必须具有\"next()\"方法。||2490|错误|Thetypereturnedbythe'next()'methodofaniteratormusthavea'value'property.迭代器的\"next()\"方法返回的类型必须具有\"value\"属性。||2491|错误|Theleft-handsideofa'for...in'statementcannotbeadestructuringpattern.\"for...in\"语句的左侧不能为析构模式。||2492|错误|Cannotredeclareidentifier'{0}'incatchclause无法在catch子句中重新声明标识符“{0}”||2493|错误|Tupletype'{0}'withlength'{1}'cannotbeassignedtotuplewithlength'{2}'.不能将长度为“{1}”的元组类型“{0}”分配给长度为“{2}”的元组。||2494|错误|Usingastringina'for...of'statementisonlysupportedinECMAScript5andhigher.仅ECMAScript5和更高版本支持在\"for...of\"语句中使用字符串。||2495|错误|Type'{0}'isnotanarraytypeorastringtype.类型“{0}”不是数组类型或字符串类型。||2496|错误|The'arguments'objectcannotbereferencedinanarrowfunctioninES3andES5.Considerusingastandardfunctionexpression.ES3和ES5中的箭头函数不能引用\"arguments\"对象。请考虑使用标准函数表达式。||2497|错误|Module'{0}'resolvestoanon-moduleentityandcannotbeimportedusingthisconstruct.模块“{0}”解析为非模块实体，且不能使用此构造导入。||2498|错误|Module'{0}'uses'export='andcannotbeusedwith'export_'.模块“{0}”使用\"export=\"且无法与\"export_\"一起使用。||2499|错误|Aninterfacecanonlyextendanidentifier/qualified-namewithoptionaltypearguments.接口只能扩展具有可选类型参数的标识符/限定名称。||2500|错误|Aclasscanonlyimplementanidentifier/qualified-namewithoptionaltypearguments.类只能实现具有可选类型参数的标识符/限定名称。||2501|错误|Arestelementcannotcontainabindingpattern.rest元素不能包含绑定模式。||2502|错误|'{0}'isreferenceddirectlyorindirectlyinitsowntypeannotation.“{0}”在其自身的类型批注中得到直接或间接引用。||2503|错误|Cannotfindnamespace'{0}'.找不到命名空间“{0}”。||2505|错误|Ageneratorcannothavea'void'typeannotation.生成器不能具有\"void\"类型批注。||2506|错误|'{0}'isreferenceddirectlyorindirectlyinitsownbaseexpression.“{0}”在其自身的基表达式中得到直接或间接引用。||2507|错误|Type'{0}'isnotaconstructorfunctiontype.类型“{0}”不是构造函数类型。||2508|错误|Nobaseconstructorhasthespecifiednumberoftypearguments.没有任何基构造函数具有指定数量的类型参数。||2509|错误|Baseconstructorreturntype'{0}'isnotaclassorinterfacetype.基构造函数返回类型“{0}”不是类或接口类型。||2510|错误|Baseconstructorsmustallhavethesamereturntype.所有的基构造函数必须具有相同的返回类型。||2511|错误|Cannotcreateaninstanceoftheabstractclass'{0}'.无法创建抽象类“{0}”的实例。||2512|错误|Overloadsignaturesmustallbeabstractornon-abstract.重载签名必须全部为抽象签名或非抽象签名。||2513|错误|Abstractmethod'{0}'inclass'{1}'cannotbeaccessedviasuperexpression.无法通过super表达式访问“{1}”类中的“{0}”抽象方法。||2514|错误|Classescontainingabstractmethodsmustbemarkedabstract.包含抽象方法的类必须标记为抽象。||2515|错误|Non-abstractclass'{0}'doesnotimplementinheritedabstractmember'{1}'fromclass'{2}'.非抽象类“{0}”不会实现继承自“{2}”类的抽象成员“{1}”。||2516|错误|Alldeclarationsofanabstractmethodmustbeconsecutive.抽象方法的所有声明必须是连续的。||2517|错误|Cannotassignanabstractconstructortypetoanon-abstractconstructortype.无法将抽象构造函数类型分配给非抽象构造函数类型。||2518|错误|A'this'-basedtypeguardisnotcompatiblewithaparameter-basedtypeguard.A'this'-basedtypeguardisnotcompatiblewithaparameter-basedtypeguard.||2520|错误|Duplicateidentifier'{0}'.Compilerusesdeclaration'{1}'tosupportasyncfunctions.标识符“{0}”重复。编译器使用“{1}”声明来支持异步函数。||2521|错误|Expressionresolvestovariabledeclaration'{0}'thatcompilerusestosupportasyncfunctions.表达式解析为编译器用于支持异步函数的变量声明“{0}”。||2522|错误|The'arguments'objectcannotbereferencedinanasyncfunctionormethodinES3andES5.Considerusingastandardfunctionormethod.无法在异步箭头函数中引用\"arguments\"对象。请考虑使用标准的异步函数表达式。||2523|错误|'yield'expressionscannotbeusedinaparameterinitializer.不能在参数初始化表达式中使用\"yield\"表达式。||2524|错误|'await'expressionscannotbeusedinaparameterinitializer.不能在参数初始化表达式中使用\"await\"表达式。||2525|错误|Initializerprovidesnovalueforthisbindingelementandthebindingelementhasnodefaultvalue.初始化表达式没有为此绑定元素提供此任何值，且该绑定元素没有默认值。||2526|错误|A'this'typeisavailableonlyinanon-staticmemberofaclassorinterface.\"this\"类型仅在类或接口的非静态成员中可用。||2527|错误|Theinferredtypeof'{0}'referencesaninaccessible'this'type.Atypeannotationisnecessary.“{0}”的推断类型引用不可访问的\"this\"类型。需要类型批注。||2528|错误|Amodulecannothavemultipledefaultexports.一个模块不能具有多个默认导出。||2529|错误|Duplicateidentifier'{0}'.Compilerreservesname'{1}'intoplevelscopeofamodulecontainingasyncfunctions.Duplicateidentifier'{0}'.Compilerreservesname'{1}'intoplevelscopeofamodulecontainingasyncfunctions.||2530|错误|Property'{0}'isincompatiblewithindexsignature.||2531|错误|Objectispossibly'null'.||2532|错误|Objectispossibly'undefined'.||2533|错误|Objectispossibly'null'or'undefined'.||2534|错误|Afunctionreturning'never'cannothaveareachableendpoint.||2535|错误|Enumtype'{0}'hasmemberswithinitializersthatarenotliterals.||2536|错误|Type'{0}'cannotbeusedtoindextype'{1}'.||2537|错误|Type'{0}'hasnomatchingindexsignaturefortype'{1}'.||2538|错误|Type'{0}'cannotbeusedasanindextype.||2539|错误|Cannotassignto'{0}'becauseitisnotavariable.||2540|错误|Cannotassignto'{0}'becauseitisaconstantoraread-onlyproperty.||2541|错误|Thetargetofanassignmentmustbeavariableorapropertyaccess.||2542|错误|Indexsignatureintype'{0}'onlypermitsreading.||2543|错误|Duplicateidentifier'\\_newTarget'.Compilerusesvariabledeclaration'\\_newTarget'tocapture'new.target'meta-propertyreference.||2544|错误|Expressionresolvestovariabledeclaration'\\_newTarget'thatcompilerusestocapture'new.target'meta-propertyreference.||2600|错误|JSXelementattributestype'{0}'maynotbeauniontype.JSXelementattributestype'{0}'maynotbeauniontype.||2601|错误|ThereturntypeofaJSXelementconstructormustreturnanobjecttype.JSX元素构造函数的返回类型必须返回对象类型。||2602|错误|JSXelementimplicitlyhastype'any'becausetheglobaltype'JSX.Element'doesnotexist.JSX元素隐式具有类型\"any\"，因为不存在全局类型\"JSX.Element\"。||2603|错误|Property'{0}'intype'{1}'isnotassignabletotype'{2}'类型“{1}”中的属性“{0}”不可分配给类型“{2}”||2604|错误|JSXelementtype'{0}'doesnothaveanyconstructorcallsignatures.JSX元素类型“{0}”不具有任何构造签名或调用签名。||2605|错误|JSXelementtype'{0}'isnotaconstructorfunctionforJSXelements.JSX元素类型“{0}”不是JSX元素的构造函数。||2606|错误|Property'{0}'ofJSXspreadattributeisnotassignabletotargetproperty.JSX展开特性的“{0}”属性不能分配给目标属性。||2607|错误|JSXelementclassdoesnotsupportattributesbecauseitdoesnothavea'{0}'propertyJSX元素类不支持特性，因为它不具有“{0}”属性||2608|错误|Theglobaltype'JSX.{0}'maynothavemorethanoneproperty全局类型“JSX.{0}”不可以具有多个属性||2609|错误|JSXspreadchildmustbeanarraytype.||2650|错误|CannotemitnamespacedJSXelementsinReact无法发出React中带命名空间的JSX元素||2651|错误|Amemberinitializerinaenumdeclarationcannotreferencemembersdeclaredafterit,includingmembersdefinedinotherenums.枚举声明中的成员初始化表达式不能引用在其后声明的成员(包括在其他枚举中定义的成员)。||2652|错误|Mergeddeclaration'{0}'cannotincludeadefaultexportdeclaration.Consideraddingaseparate'exportdefault{0}'declarationinstead.合并声明“{0}”不能包含默认导出声明。请考虑改为添加一个独立的“导出默认{0}”声明。||2653|错误|Non-abstractclassexpressiondoesnotimplementinheritedabstractmember'{0}'fromclass'{1}'.非抽象类表达式不会实现继承自“{1}”类的抽象成员“{0}”。||2654|错误|Exportedexternalpackagetypingsfilecannotcontaintripleslashreferences.Pleasecontactthepackageauthortoupdatethepackagedefinition.导出的外部包键入文件不能包含三斜线引用。请与包作者联系或更新包定义。||2656|错误|Exportedexternalpackagetypingsfile'{0}'isnotamodule.Pleasecontactthepackageauthortoupdatethepackagedefinition.导出的外部包键入文件“{0}”不是一个模块。请与包作者联系或更新包定义。||2657|错误|JSXexpressionsmusthaveoneparentelementJSX表达式必须具有一个父元素||2658|错误|Type'{0}'providesnomatchforthesignature'{1}'类型“{0}”提供程序与签名“{1}”不匹配||2659|错误|'super'isonlyallowedinmembersofobjectliteralexpressionswhenoption'target'is'ES2015'orhigher.'super'isonlyallowedinmembersofobjectliteralexpressionswhenoption'target'is'ES2015'orhigher.||2660|错误|'super'canonlybereferencedinmembersofderivedclassesorobjectliteralexpressions.'super'canonlybereferencedinmembersofderivedclassesorobjectliteralexpressions.||2661|错误|Cannotexport'{0}'.Onlylocaldeclarationscanbeexportedfromamodule.Cannotre-exportnamethatisnotdefinedinthemodule.||2662|错误|Cannotfindname'{0}'.Didyoumeanthestaticmember'{1}.{0}'?Cannotfindname'{0}'.Didyoumeanthestaticmember'{1}.{0}'?||2663|错误|Cannotfindname'{0}'.Didyoumeantheinstancemember'this.{0}'?Cannotfindname'{0}'.Didyoumeantheinstancemember'this.{0}'?||2664|错误|Invalidmodulenameinaugmentation,module'{0}'cannotbefound.Invalidmodulenameinaugmentation,module'{0}'cannotbefound.||2665|错误|Invalidmodulenameinaugmentation.Module'{0}'resolvestoanuntypedmoduleat'{1}',whichcannotbeaugmented.Moduleaugmentationcannotintroducenewnamesinthetoplevelscope.||2666|错误|Exportsandexportassignmentsarenotpermittedinmoduleaugmentations.Exportsandexportassignmentsarenotpermittedinmoduleaugmentations.||2667|错误|Importsarenotpermittedinmoduleaugmentations.Considermovingthemtotheenclosingexternalmodule.Importsarenotpermittedinmoduleaugmentations.Considermovingthemtotheenclosingexternalmodule.||2668|错误|'export'modifiercannotbeappliedtoambientmodulesandmoduleaugmentationssincetheyarealwaysvisible.'export'modifiercannotbeappliedtoambientmodulesandmoduleaugmentationssincetheyarealwaysvisible.||2669|错误|Augmentationsfortheglobalscopecanonlybedirectlynestedinexternalmodulesorambientmoduledeclarations.Augmentationsfortheglobalscopecanonlybedirectlynestedinexternalmodulesorambientmoduledeclarations.||2670|错误|Augmentationsfortheglobalscopeshouldhave'declare'modifierunlesstheyappearinalreadyambientcontext.Augmentationsfortheglobalscopeshouldhave'declare'modifierunlesstheyappearinalreadyambientcontext.||2671|错误|Cannotaugmentmodule'{0}'becauseitresolvestoanon-moduleentity.Cannotaugmentmodule'{0}'becauseitresolvestoanon-moduleentity.||2672|错误|Cannotassigna'{0}'constructortypetoa'{1}'constructortype.||2673|错误|Constructorofclass'{0}'isprivateandonlyaccessiblewithintheclassdeclaration.||2674|错误|Constructorofclass'{0}'isprotectedandonlyaccessiblewithintheclassdeclaration.||2675|错误|Cannotextendaclass'{0}'.Classconstructorismarkedasprivate.||2676|错误|Accessorsmustbothbeabstractornon-abstract.||2677|错误|Atypepredicate'stypemustbeassignabletoitsparameter'stype.||2678|错误|Type'{0}'isnotcomparabletotype'{1}'.||2679|错误|Afunctionthatiscalledwiththe'new'keywordcannothavea'this'typethatis'void'.||2680|错误|A'this'parametermustbethefirstparameter.||2681|错误|Aconstructorcannothavea'this'parameter.||2682|错误|'get'and'set'accessormusthavethesame'this'type.||2683|错误|'this'implicitlyhastype'any'becauseitdoesnothaveatypeannotation.||2684|错误|The'this'contextoftype'{0}'isnotassignabletomethod's'this'oftype'{1}'.||2685|错误|The'this'typesofeachsignatureareincompatible.||2686|错误|'{0}'referstoaUMDglobal,butthecurrentfileisamodule.Consideraddinganimportinstead.||2687|错误|Alldeclarationsof'{0}'musthaveidenticalmodifiers.||2688|错误|Cannotfindtypedefinitionfilefor'{0}'.||2689|错误|Cannotextendaninterface'{0}'.Didyoumean'implements'?||2690|错误|Aclassmustbedeclaredafteritsbaseclass.||2691|错误|Animportpathcannotendwitha'{0}'extension.Considerimporting'{1}'instead.||2692|错误|'{0}'isaprimitive,but'{1}'isawrapperobject.Preferusing'{0}'whenpossible.||2693|错误|'{0}'onlyreferstoatype,butisbeingusedasavaluehere.||2694|错误|Namespace'{0}'hasnoexportedmember'{1}'.||2695|错误|Leftsideofcommaoperatorisunusedandhasnosideeffects.||2696|错误|The'Object'typeisassignabletoveryfewothertypes.Didyoumeantousethe'any'typeinstead?||2697|错误|Anasyncfunctionormethodmustreturna'Promise'.Makesureyouhaveadeclarationfor'Promise'orinclude'ES2015'inyour--liboption.||2698|错误|Spreadtypesmayonlybecreatedfromobjecttypes.||2700|错误|Resttypesmayonlybecreatedfromobjecttypes.||2701|错误|Thetargetofanobjectrestassignmentmustbeavariableorapropertyaccess.||2702|错误|'{0}'onlyreferstoatype,butisbeingusedasanamespacehere.||2703|错误|Theoperandofadeleteoperatormustbeapropertyreference||2704|错误|Theoperandofadeleteoperatorcannotbearead-onlyproperty||4000|错误|Importdeclaration'{0}'isusingprivatename'{1}'.导入声明“{0}”使用的是专用名称“{1}”。||4002|错误|Typeparameter'{0}'ofexportedclasshasorisusingprivatename'{1}'.导出类的类型参数“{0}”具有或正在使用专用名称“{1}”。||4004|错误|Typeparameter'{0}'ofexportedinterfacehasorisusingprivatename'{1}'.导出接口的类型参数“{0}”具有或正在使用专用名称“{1}”。||4006|错误|Typeparameter'{0}'ofconstructorsignaturefromexportedinterfacehasorisusingprivatename'{1}'.导出接口中的构造函数签名的类型参数“{0}”具有或正在使用专用名称“{1}”。||4008|错误|Typeparameter'{0}'ofcallsignaturefromexportedinterfacehasorisusingprivatename'{1}'.导出接口中的调用签名的类型参数“{0}”具有或正在使用专用名称“{1}”。||4010|错误|Typeparameter'{0}'ofpublicstaticmethodfromexportedclasshasorisusingprivatename'{1}'.导出类中的公共静态方法的类型参数“{0}”具有或正在使用专用名称“{1}”。||4012|错误|Typeparameter'{0}'ofpublicmethodfromexportedclasshasorisusingprivatename'{1}'.导出类中的公共方法的类型参数“{0}”具有或正在使用专用名称“{1}”。||4014|错误|Typeparameter'{0}'ofmethodfromexportedinterfacehasorisusingprivatename'{1}'.导出接口中的方法的类型参数“{0}”具有或正在使用专用名称“{1}”。||4016|错误|Typeparameter'{0}'ofexportedfunctionhasorisusingprivatename'{1}'.导出函数的类型参数“{0}”具有或正在使用专用名称“{1}”。||4019|错误|Implementsclauseofexportedclass'{0}'hasorisusingprivatename'{1}'.导出的类“{0}”的Implements子句具有或正在使用专用名称“{1}”。||4020|错误|Extendsclauseofexportedclass'{0}'hasorisusingprivatename'{1}'.导出的类“{0}”的extends子句具有或正在使用专用名称“{1}”。||4022|错误|Extendsclauseofexportedinterface'{0}'hasorisusingprivatename'{1}'.导出接口“{0}”的extends子句具有或正在使用专用名称“{1}”。||4023|错误|Exportedvariable'{0}'hasorisusingname'{1}'fromexternalmodule{2}butcannotbenamed.导出的变量“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。||4024|错误|Exportedvariable'{0}'hasorisusingname'{1}'fromprivatemodule'{2}'.导出的变量“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4025|错误|Exportedvariable'{0}'hasorisusingprivatename'{1}'.导出的变量“{0}”具有或正在使用专用名称“{1}”。||4026|错误|Publicstaticproperty'{0}'ofexportedclasshasorisusingname'{1}'fromexternalmodule{2}butcannotbenamed.导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。||4027|错误|Publicstaticproperty'{0}'ofexportedclasshasorisusingname'{1}'fromprivatemodule'{2}'.导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”。||4028|错误|Publicstaticproperty'{0}'ofexportedclasshasorisusingprivatename'{1}'.导出类的公共静态属性“{0}”具有或正在使用专用名称“{1}”。||4029|错误|Publicproperty'{0}'ofexportedclasshasorisusingname'{1}'fromexternalmodule{2}butcannotbenamed.导出类的公共属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。||4030|错误|Publicproperty'{0}'ofexportedclasshasorisusingname'{1}'fromprivatemodule'{2}'.导出类的公共属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4031|错误|Publicproperty'{0}'ofexportedclasshasorisusingprivatename'{1}'.导出类的公共属性“{0}”具有或正在使用专用名称“{1}”。||4032|错误|Property'{0}'ofexportedinterfacehasorisusingname'{1}'fromprivatemodule'{2}'.导出接口的属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4033|错误|Property'{0}'ofexportedinterfacehasorisusingprivatename'{1}'.导出接口的属性“{0}”具有或正在使用专用名称“{1}”。||4034|错误|Parameter'{0}'ofpublicstaticpropertysetterfromexportedclasshasorisusingname'{1}'fromprivatemodule'{2}'.导出类中的公共静态属性setter的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4035|错误|Parameter'{0}'ofpublicstaticpropertysetterfromexportedclasshasorisusingprivatename'{1}'.导出类中的公共静态属性setter的参数“{0}”具有或正在使用专用名称“{1}”。||4036|错误|Parameter'{0}'ofpublicpropertysetterfromexportedclasshasorisusingname'{1}'fromprivatemodule'{2}'.导出类中的公共属性setter的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4037|错误|Parameter'{0}'ofpublicpropertysetterfromexportedclasshasorisusingprivatename'{1}'.导出类中的公共属性setter的参数“{0}”具有或正在使用专用名称“{1}”。||4038|错误|Returntypeofpublicstaticpropertygetterfromexportedclasshasorisusingname'{0}'fromexternalmodule{1}butcannotbenamed.导出类中的公共静态属性getter的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。||4039|错误|Returntypeofpublicstaticpropertygetterfromexportedclasshasorisusingname'{0}'fromprivatemodule'{1}'.导出类中的公共静态属性getter的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4040|错误|Returntypeofpublicstaticpropertygetterfromexportedclasshasorisusingprivatename'{0}'.导出类中的公共静态属性getter的返回类型具有或正在使用专用名称“{0}”。||4041|错误|Returntypeofpublicpropertygetterfromexportedclasshasorisusingname'{0}'fromexternalmodule{1}butcannotbenamed.导出类中的公共属性getter的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。||4042|错误|Returntypeofpublicpropertygetterfromexportedclasshasorisusingname'{0}'fromprivatemodule'{1}'.导出类中的公共属性getter的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4043|错误|Returntypeofpublicpropertygetterfromexportedclasshasorisusingprivatename'{0}'.导出类中的公共属性getter的返回类型具有或正在使用专用名称“{0}”。||4044|错误|Returntypeofconstructorsignaturefromexportedinterfacehasorisusingname'{0}'fromprivatemodule'{1}'.导出接口中的构造函数签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4045|错误|Returntypeofconstructorsignaturefromexportedinterfacehasorisusingprivatename'{0}'.导出接口中的构造函数签名的返回类型具有或正在使用专用名称“{0}”。||4046|错误|Returntypeofcallsignaturefromexportedinterfacehasorisusingname'{0}'fromprivatemodule'{1}'.导出接口中的调用签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4047|错误|Returntypeofcallsignaturefromexportedinterfacehasorisusingprivatename'{0}'.导出接口中的调用签名的返回类型具有或正在使用专用名称“{0}”。||4048|错误|Returntypeofindexsignaturefromexportedinterfacehasorisusingname'{0}'fromprivatemodule'{1}'.导出接口中的索引签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4049|错误|Returntypeofindexsignaturefromexportedinterfacehasorisusingprivatename'{0}'.导出接口中的索引签名的返回类型具有或正在使用专用名称“{0}”。||4050|错误|Returntypeofpublicstaticmethodfromexportedclasshasorisusingname'{0}'fromexternalmodule{1}butcannotbenamed.导出类中的公共静态方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。||4051|错误|Returntypeofpublicstaticmethodfromexportedclasshasorisusingname'{0}'fromprivatemodule'{1}'.导出类中的公共静态方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4052|错误|Returntypeofpublicstaticmethodfromexportedclasshasorisusingprivatename'{0}'.导出类中的公共静态方法的返回类型具有或正在使用专用名称“{0}”。||4053|错误|Returntypeofpublicmethodfromexportedclasshasorisusingname'{0}'fromexternalmodule{1}butcannotbenamed.导出类中的公共方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。||4054|错误|Returntypeofpublicmethodfromexportedclasshasorisusingname'{0}'fromprivatemodule'{1}'.导出类中的公共方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4055|错误|Returntypeofpublicmethodfromexportedclasshasorisusingprivatename'{0}'.导出类中的公共方法的返回类型具有或正在使用专用名称“{0}”。||4056|错误|Returntypeofmethodfromexportedinterfacehasorisusingname'{0}'fromprivatemodule'{1}'.导出接口中的方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4057|错误|Returntypeofmethodfromexportedinterfacehasorisusingprivatename'{0}'.导出接口中的方法的返回类型具有或正在使用专用名称“{0}”。||4058|错误|Returntypeofexportedfunctionhasorisusingname'{0}'fromexternalmodule{1}butcannotbenamed.导出函数的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。||4059|错误|Returntypeofexportedfunctionhasorisusingname'{0}'fromprivatemodule'{1}'.导出函数的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。||4060|错误|Returntypeofexportedfunctionhasorisusingprivatename'{0}'.导出函数的返回类型具有或正在使用专用名称“{0}”。||4061|错误|Parameter'{0}'ofconstructorfromexportedclasshasorisusingname'{1}'fromexternalmodule{2}butcannotbenamed.导出类中的构造函数的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。||4062|错误|Parameter'{0}'ofconstructorfromexportedclasshasorisusingname'{1}'fromprivatemodule'{2}'.导出类中的构造函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4063|错误|Parameter'{0}'ofconstructorfromexportedclasshasorisusingprivatename'{1}'.导出类中的构造函数的参数“{0}”具有或正在使用专用名称“{1}”。||4064|错误|Parameter'{0}'ofconstructorsignaturefromexportedinterfacehasorisusingname'{1}'fromprivatemodule'{2}'.导出接口中的构造函数签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4065|错误|Parameter'{0}'ofconstructorsignaturefromexportedinterfacehasorisusingprivatename'{1}'.导出接口中的构造函数签名的参数“{0}”具有或正在使用专用名称“{1}”。||4066|错误|Parameter'{0}'ofcallsignaturefromexportedinterfacehasorisusingname'{1}'fromprivatemodule'{2}'.导出接口中的调用签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4067|错误|Parameter'{0}'ofcallsignaturefromexportedinterfacehasorisusingprivatename'{1}'.导出接口中的调用签名的参数“{0}”具有或正在使用专用名称“{1}”。||4068|错误|Parameter'{0}'ofpublicstaticmethodfromexportedclasshasorisusingname'{1}'fromexternalmodule{2}butcannotbenamed.导出类中的公共静态方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。||4069|错误|Parameter'{0}'ofpublicstaticmethodfromexportedclasshasorisusingname'{1}'fromprivatemodule'{2}'.导出类中的公共静态方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4070|错误|Parameter'{0}'ofpublicstaticmethodfromexportedclasshasorisusingprivatename'{1}'.导出类中的公共静态方法的参数“{0}”具有或正在使用专用名称“{1}”。||4071|错误|Parameter'{0}'ofpublicmethodfromexportedclasshasorisusingname'{1}'fromexternalmodule{2}butcannotbenamed.导出类中的公共方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。||4072|错误|Parameter'{0}'ofpublicmethodfromexportedclasshasorisusingname'{1}'fromprivatemodule'{2}'.导出类中的公共方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4073|错误|Parameter'{0}'ofpublicmethodfromexportedclasshasorisusingprivatename'{1}'.导出类中的公共方法的参数“{0}”具有或正在使用专用名称“{1}”。||4074|错误|Parameter'{0}'ofmethodfromexportedinterfacehasorisusingname'{1}'fromprivatemodule'{2}'.导出接口中的方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4075|错误|Parameter'{0}'ofmethodfromexportedinterfacehasorisusingprivatename'{1}'.导出接口中的方法的参数“{0}”具有或正在使用专用名称“{1}”。||4076|错误|Parameter'{0}'ofexportedfunctionhasorisusingname'{1}'fromexternalmodule{2}butcannotbenamed.导出函数的参数“{0}”具有或正在使用外部模块{2}中的名称“{1}”，但不能为其命名。||4077|错误|Parameter'{0}'ofexportedfunctionhasorisusingname'{1}'fromprivatemodule'{2}'.导出函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。||4078|错误|Parameter'{0}'ofexportedfunctionhasorisusingprivatename'{1}'.导出函数的参数“{0}”具有或正在使用专用名称“{1}”。||4081|错误|Exportedtypealias'{0}'hasorisusingprivatename'{1}'.导出的类型别名“{0}”已经或正在使用专用名称“{1}”。||4082|错误|Defaultexportofthemodulehasorisusingprivatename'{0}'.模块的默认导出具有或正在使用专用名称“{0}”。||4083|错误|Typeparameter'{0}'ofexportedtypealiashasorisusingprivatename'{1}'.||4090|信息|Conflictingdefinitionsfor'{0}'foundat'{1}'and'{2}'.Considerinstallingaspecificversionofthislibrarytoresolvetheconflict.||4091|错误|Parameter'{0}'ofindexsignaturefromexportedinterfacehasorisusingname'{1}'fromprivatemodule'{2}'.||4092|错误|Parameter'{0}'ofindexsignaturefromexportedinterfacehasorisusingprivatename'{1}'.||5001|错误|Thecurrenthostdoesnotsupportthe'{0}'option.当前主机不支持“{0}”选项。||5009|错误|Cannotfindthecommonsubdirectorypathfortheinputfiles.找不到输入文件的公共子目录路径。||5010|错误|Filespecificationcannotendinarecursivedirectorywildcard('\\*\\*'):'{0}'.||5011|错误|Filespecificationcannotcontainmultiplerecursivedirectorywildcards('\\*\\*'):'{0}'.||5012|错误|Cannotreadfile'{0}':{1}无法读取文件“{0}”:{1}||5013|错误|Unsupportedfileencoding.文件编码不受支持。||5014|错误|Failedtoparsefile'{0}':{1}.未能分析文件“{0}”:{1}。||5023|错误|Unknowncompileroption'{0}'.未知的编译器选项“{0}”。||5024|错误|Compileroption'{0}'requiresavalueoftype{1}.编译器选项“{0}”需要类型{1}的值。||5033|错误|Couldnotwritefile'{0}':{1}无法写入文件“{0}”:{1}||5042|错误|Option'project'cannotbemixedwithsourcefilesonacommandline.选项\"project\"在命令行上不能与源文件混合使用。||5047|错误|Option'isolatedModules'canonlybeusedwheneitheroption'--module'isprovidedoroption'target'is'ES2015'orhigher.选项\"isolatedModules\"只可在提供了选项\"--module\"或者选项\"target\"是\"ES2015\"或更高版本时使用。||5051|错误|Option'{0}canonlybeusedwheneitheroption'--inlineSourceMap'oroption'--sourceMap'isprovided.仅当提供了选项\"--inlineSources\"或选项\"--sourceMap\"时，才能使用选项\"inlineSources\"。||5052|错误|Option'{0}'cannotbespecifiedwithoutspecifyingoption'{1}'.无法在不指定选项“{1}”的情况下指定选项“{0}”。||5053|错误|Option'{0}'cannotbespecifiedwithoption'{1}'.选项“{0}”不能与选项“{1}”同时指定。||5054|错误|A'tsconfig.json'fileisalreadydefinedat:'{0}'.已在“{0}”中定义了\"tsconfig.json\"文件。||5055|错误|Cannotwritefile'{0}'becauseitwouldoverwriteinputfile.无法写入文件“{0}”，因为它会覆盖输入文件。||5056|错误|Cannotwritefile'{0}'becauseitwouldbeoverwrittenbymultipleinputfiles.无法写入文件“{0}”，因为它会被多个输入文件覆盖。||5057|错误|Cannotfindatsconfig.jsonfileatthespecifieddirectory:'{0}'无法在指定目录找到tsconfig.json文件:“{0}”||5058|错误|Thespecifiedpathdoesnotexist:'{0}'指定的路径不存在:“{0}”||5059|错误|Invalidvaluefor'--reactNamespace'.'{0}'isnotavalididentifier.Invalidevaluefor'--reactNamespace'.'{0}'isnotavalididentifier.||5060|错误|Option'paths'cannotbeusedwithoutspecifying'--baseUrl'option.||5061|错误|Pattern'{0}'canhaveatmostone'\\*'character||5062|错误|Substitution'{0}'inpattern'{1}'incanhaveatmostone'\\*'character||5063|错误|Substitutionsforpattern'{0}'shouldbeanarray.||5064|错误|Substitution'{0}'forpattern'{1}'hasincorrecttype,expected'string',got'{2}'.||5065|错误|Filespecificationcannotcontainaparentdirectory('..')thatappearsafterarecursivedirectorywildcard('\\*\\*'):'{0}'.||5066|错误|Substitutionsforpattern'{0}'shouldn'tbeanemptyarray.||5067|错误|Invalidvaluefor'jsxFactory'.'{0}'isnotavalididentifierorqualified-name.||6001|信息|Concatenateandemitoutputtosinglefile.连接输出并将其发出到单个文件。||6002|信息|Generatescorresponding'.d.ts'file.生成相应的\".d.ts\"文件。||6003|信息|Specifythelocationwheredebuggershouldlocatemapfilesinsteadofgeneratedlocations.指定调试程序应放置映射文件的位置而不是生成的位置。||6004|信息|SpecifythelocationwheredebuggershouldlocateTypeScriptfilesinsteadofsourcelocations.指定调试程序应放置TypeScript文件的位置而不是源位置。||6005|信息|Watchinputfiles.监视输入文件。||6006|信息|Redirectoutputstructuretothedirectory.将输出结构重定向到目录。||6007|信息|Donoteraseconstenumdeclarationsingeneratedcode.请勿清除生成代码中的常数枚举声明。||6008|信息|Donotemitoutputsifanyerrorswerereported.如果报告了任何错误，请不要发出输出。||6009|信息|Donotemitcommentstooutput.请勿将注释发出到输出。||6010|信息|Donotemitoutputs.请勿发出输出。||6011|信息|Allowdefaultimportsfrommoduleswithnodefaultexport.Thisdoesnotaffectcodeemit,justtypechecking.允许从不带默认输出的模块中默认输入。这不会影响代码发出，只是类型检查。||6012|信息|Skiptypecheckingofdeclarationfiles.||6015|信息|SpecifyECMAScripttargetversion:'ES3'(default),'ES5','ES2015','ES2016','ES2017',or'ESNEXT'指定ECMAScript目标版本:\"ES3\"(默认)、\"ES5\"或\"ES2015\"(实验)||6016|信息|Specifymodulecodegeneration:'commonjs','amd','system','umd'or'es2015'指定模块代码生成:\"commonjs\"、\"amd\"、\"system\"、\"umd\"或\"es2015\"||6017|信息|Printthismessage.打印此消息。||6019|信息|Printthecompiler'sversion.打印编译器的版本。||6020|信息|Compiletheprojectinthegivendirectory.在指定目录中编译项目。||6023|信息|Syntax:{0}语法:{0}||6024|信息|options选项||6025|信息|file文件||6026|信息|Examples:{0}示例:{0}||6027|信息|Options:选项:||6029|信息|Version{0}版本{0}||6030|信息|Insertcommandlineoptionsandfilesfromafile.从文件插入命令行选项和文件。||6032|信息|Filechangedetected.Startingincrementalcompilation...检测到文件更改。正在启动增量编译...||6034|信息|KIND种类||6035|信息|FILE文件||6036|信息|VERSION版本||6037|信息|LOCATION位置||6038|信息|DIRECTORY目录||6039|信息|STRATEGY||6042|信息|Compilationcomplete.Watchingforfilechanges.编译完成。查看文件更改。||6043|信息|Generatescorresponding'.map'file.生成相应的\".map\"文件。||6044|错误|Compileroption'{0}'expectsanargument.编译器选项“{0}”需要参数。||6045|错误|Unterminatedquotedstringinresponsefile'{0}'.响应文件“{0}”中引号不配对。||6046|错误|Argumentfor'{0}'optionmustbe:{1}Argumentfor'--module'optionmustbe'commonjs','amd','system','umd','es2015',or'none'.||6048|错误|Localemustbeoftheformor-.Forexample'{0}'or'{1}'.区域设置必须采用<语言>或<语言>-<区域>形式。例如“{0}”或“{1}”。||6049|错误|Unsupportedlocale'{0}'.区域设置“{0}”不受支持。||6050|错误|Unabletoopenfile'{0}'.无法打开文件“{0}”。||6051|错误|Corruptedlocalefile{0}.区域设置文件{0}已损坏。||6052|信息|Raiseerroronexpressionsanddeclarationswithanimplied'any'type.对具有隐式\"any\"类型的表达式和声明引发错误。||6053|错误|File'{0}'notfound.找不到文件“{0}”。||6054|错误|File'{0}'hasunsupportedextension.Theonlysupportedextensionsare{1}.不支持文件“{0}”的扩展名。唯一支持的扩展名为{1}。||6055|信息|SuppressnoImplicitAnyerrorsforindexingobjectslackingindexsignatures.抑制缺少索引签名的索引对象的noImplicitAny错误。||6056|信息|Donotemitdeclarationsforcodethathasan'@internal'annotation.请勿对具有\"@internal\"注释的代码发出声明。||6058|信息|Specifytherootdirectoryofinputfiles.Usetocontroltheoutputdirectorystructurewith--outDir.指定输入文件的根目录。与--outDir一起用于控制输出目录结构。||6059|错误|File'{0}'isnotunder'rootDir''{1}'.'rootDir'isexpectedtocontainallsourcefiles.文件“{0}”不在\"rootDir\"“{1}”下。\"rootDir\"应包含所有源文件。||6060|信息|Specifytheendoflinesequencetobeusedwhenemittingfiles:'CRLF'(dos)or'LF'(unix).指定发出文件时要使用的行序列结尾:\"CRLF\"(dos)或\"LF\"(unix)。||6061|信息|NEWLINE换行符||6064|错误|Option'{0}'canonlybespecifiedin'tsconfig.json'file.||6065|信息|EnablesexperimentalsupportforES7decorators.对ES7修饰器启用实验支持。||6066|信息|Enablesexperimentalsupportforemittingtypemetadatafordecorators.对发出修饰器的类型元数据启用实验支持。||6068|信息|EnablesexperimentalsupportforES7asyncfunctions.对ES7异步函数启用实验支持。||6069|信息|Specifymoduleresolutionstrategy:'node'(Node.js)or'classic'(TypeScriptpre-1.6).指定模块解决策略:\"node\"(Node.js)或\"classic\"(TypeScriptpre-1.6)。||6070|信息|InitializesaTypeScriptprojectandcreatesatsconfig.jsonfile.初始化TypeScript项目并创建tsconfig.json文件。||6071|信息|Successfullycreatedatsconfig.jsonfile.已成功创建tsconfig.json文件。||6072|信息|Suppressexcesspropertychecksforobjectliterals.取消对象文字的多余属性检查。||6073|信息|Stylizeerrorsandmessagesusingcolorandcontext.(experimental)使用颜色和上下文风格化错误和消息。(实验)||6074|信息|Donotreporterrorsonunusedlabels.不报告有关未使用的标签的错误。||6075|信息|Reporterrorwhennotallcodepathsinfunctionreturnavalue.在函数中的所有代码路径并非都返回值时报告错误。||6076|信息|Reporterrorsforfallthroughcasesinswitchstatement.报告switch语句中遇到fallthrough情况的错误。||6077|信息|Donotreporterrorsonunreachablecode.不报告有关不可访问的代码的错误。||6078|信息|Disallowinconsistently-casedreferencestothesamefile.不允许对同一文件采用大小不一致的引用。||6079|信息|Specifylibraryfilestobeincludedinthecompilation:||6080|信息|SpecifyJSXcodegeneration:'preserve'or'react'指定JSX代码生成:\"preserve\"或\"react\"||6081|信息|File'{0}'hasanunsupportedextension,soskippingit.\"--jsx\"的参数必须为\"preserve\"或\"react\"。||6082|错误|Only'amd'and'system'modulesaresupportedalongside--{0}.--{0}旁仅支持\"amd\"和\"system\"模块。||6083|信息|Basedirectorytoresolvenon-absolutemodulenames.允许编译JavaScript文件。||6084|信息|SpecifytheobjectinvokedforcreateElementand**spreadwhentargeting'react'JSXemitSpecifiestheobjectinvokedforcreateElementand**spreadwhentargeting'react'JSXemit||6085|信息|Enabletracingofthenameresolutionprocess.||6086|信息|========Resolvingmodule'{0}'from'{1}'.========||6087|信息|Explicitlyspecifiedmoduleresolutionkind:'{0}'.||6088|信息|Moduleresolutionkindisnotspecified,using'{0}'.||6089|信息|========Modulename'{0}'wassuccessfullyresolvedto'{1}'.========||6090|信息|========Modulename'{0}'wasnotresolved.========||6091|信息|'paths'optionisspecified,lookingforapatterntomatchmodulename'{0}'.||6092|信息|Modulename'{0}',matchedpattern'{1}'.||6093|信息|Tryingsubstitution'{0}',candidatemodulelocation:'{1}'.||6094|信息|Resolvingmodulename'{0}'relativetobaseurl'{1}'-'{2}'.||6095|信息|Loadingmoduleasfile/folder,candidatemodulelocation'{0}',targetfiletype'{1}'.||6096|信息|File'{0}'doesnotexist.||6097|信息|File'{0}'exist-useitasanameresolutionresult.||6098|信息|Loadingmodule'{0}'from'node_modules'folder,targetfiletype'{1}'.||6099|信息|Found'package.json'at'{0}'.||6100|信息|'package.json'doesnothavea'types'or'main'field.||6101|信息|'package.json'has'{0}'field'{1}'thatreferences'{2}'.||6102|信息|Allowjavascriptfilestobecompiled.||6103|错误|Option'{0}'shouldhavearrayofstringsasavalue.Option'{0}'shouldhavearrayofstringsasavalue.||6104|信息|Checkingif'{0}'isthelongestmatchingprefixfor'{1}'-'{2}'.||6105|信息|Expectedtypeof'{0}'fieldin'package.json'tobe'string',got'{1}'.||6106|信息|'baseUrl'optionissetto'{0}',usingthisvaluetoresolvenon-relativemodulename'{1}'||6107|信息|'rootDirs'optionisset,usingittoresolverelativemodulename'{0}'||6108|信息|Longestmatchingprefixfor'{0}'is'{1}'||6109|信息|Loading'{0}'fromtherootdir'{1}',candidatelocation'{2}'||6110|信息|Tryingotherentriesin'rootDirs'||6111|信息|Moduleresolutionusing'rootDirs'hasfailed||6112|信息|Donotemit'usestrict'directivesinmoduleoutput.Donotemit'usestrict'directivesinmoduleoutput.||6113|信息|Enablestrictnullchecks.||6114|错误|Unknownoption'excludes'.Didyoumean'exclude'?||6115|信息|Raiseerroron'this'expressionswithanimplied'any'type.||6116|信息|========Resolvingtypereferencedirective'{0}',containingfile'{1}',rootdirectory'{2}'.========||6117|信息|Resolvingusingprimarysearchpaths...||6118|信息|Resolvingfromnode_modulesfolder...||6119|信息|========Typereferencedirective'{0}'wassuccessfullyresolvedto'{1}',primary:{2}.========||6120|信息|========Typereferencedirective'{0}'wasnotresolved.========||6121|信息|Resolvingwithprimarysearchpath'{0}'||6122|信息|Rootdirectorycannotbedetermined,skippingprimarysearchpaths.||6123|信息|========Resolvingtypereferencedirective'{0}',containingfile'{1}',rootdirectorynotset.========||6124|信息|Typedeclarationfilestobeincludedincompilation.||6125|信息|Lookingupin'node_modules'folder,initiallocation'{0}'||6126|信息|Containingfileisnotspecifiedandrootdirectorycannotbedetermined,skippinglookupin'node_modules'folder.||6127|信息|========Resolvingtypereferencedirective'{0}',containingfilenotset,rootdirectory'{1}'.========||6128|信息|========Resolvingtypereferencedirective'{0}',containingfilenotset,rootdirectorynotset.========||6129|错误|Theconfigfile'{0}'founddoesn'tcontainanysourcefiles.||6130|信息|Resolvingrealpathfor'{0}',result'{1}'||6131|错误|Cannotcompilemodulesusingoption'{0}'unlessthe'--module'flagis'amd'or'system'.||6132|信息|Filename'{0}'hasa'{1}'extension-strippingit||6133|错误|'{0}'isdeclaredbutneverused.||6134|信息|Reporterrorsonunusedlocals.||6135|信息|Reporterrorsonunusedparameters.||6136|信息|Themaximumdependencydepthtosearchundernode_modulesandloadJavaScriptfiles||6137|信息|Notypesspecifiedin'package.json',soreturning'main'valueof'{0}'||6138|错误|Property'{0}'isdeclaredbutneverused.||6139|信息|Importemithelpersfrom'tslib'.||6140|错误|Autodiscoveryfortypingsisenabledinproject'{0}'.Runningextraresolutionpassformodule'{1}'usingcachelocation'{2}'.||6141|信息|Parseinstrictmodeandemit\"usestrict\"foreachsourcefile||6142|错误|Module'{0}'wasresolvedto'{1}',but'--jsx'isnotset.||6143|错误|Module'{0}'wasresolvedto'{1}',but'--allowJs'isnotset.||6144|信息|Module'{0}'wasresolvedaslocallydeclaredambientmoduleinfile'{1}'.||6145|信息|Module'{0}'wasresolvedasambientmoduledeclaredin'{1}'sincethisfilewasnotmodified.||6146|信息|SpecifytheJSXfactoryfunctiontousewhentargeting'react'JSXemit,e.g.'React.createElement'or'h'.||6147|信息|Resolutionformodule'{0}'wasfoundincache.||6148|信息|Directory'{0}'doesnotexist,skippingalllookupsinit.||7005|错误|Variable'{0}'implicitlyhasan'{1}'type.变量“{0}”隐式具有“{1}”类型。||7006|错误|Parameter'{0}'implicitlyhasan'{1}'type.参数“{0}”隐式具有“{1}”类型。||7008|错误|Member'{0}'implicitlyhasan'{1}'type.成员“{0}”隐式包含类型“{1}”。||7009|错误|'new'expression,whosetargetlacksaconstructsignature,implicitlyhasan'any'type.其目标缺少构造签名的\"new\"表达式隐式具有\"any\"类型。||7010|错误|'{0}',whichlacksreturn-typeannotation,implicitlyhasan'{1}'returntype.缺少返回类型批注的“{0}”隐式具有“{1}”返回类型。||7011|错误|Functionexpression,whichlacksreturn-typeannotation,implicitlyhasan'{0}'returntype.缺少返回类型批注的函数表达式隐式具有“{0}”返回类型。||7013|错误|Constructsignature,whichlacksreturn-typeannotation,implicitlyhasan'any'returntype.缺少返回类型批注的构造签名隐式具有返回类型\"any\"。||7015|错误|Elementimplicitlyhasan'any'typebecauseindexexpressionisnotoftype'number'.Elementimplicitlyhasan'any'typebecauseindexexpressionisnotoftype'number'.||7016|错误|Couldnotfindadeclarationfileformodule'{0}'.'{1}'implicitlyhasan'any'type.属性“{0}”隐式具有类型\"any\"，因为其\"set\"访问器缺少类型批注。||7017|错误|Elementimplicitlyhasan'any'typebecausetype'{0}'hasnoindexsignature.对象类型的索引签名隐式地含有\"any\"类型。||7018|错误|Objectliteral'sproperty'{0}'implicitlyhasan'{1}'type.对象文字的属性“{0}”隐式含有“{1}”类型。||7019|错误|Restparameter'{0}'implicitlyhasan'any[]'type.Rest参数“{0}”隐式具有\"any[]\"类型。||7020|错误|Callsignature,whichlacksreturn-typeannotation,implicitlyhasan'any'returntype.缺少返回类型批注的调用签名隐式具有返回类型\"any\"。||7022|错误|'{0}'implicitlyhastype'any'becauseitdoesnothaveatypeannotationandisreferenceddirectlyorindirectlyinitsowninitializer.“{0}”隐式具有类型\"any\"，因为它不具有类型批注，且在其自身的初始化表达式中得到直接或间接引用。||7023|错误|'{0}'implicitlyhasreturntype'any'becauseitdoesnothaveareturntypeannotationandisreferenceddirectlyorindirectlyinoneofitsreturnexpressions.由于“{0}'”不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型\"any\"。||7024|错误|Functionimplicitlyhasreturntype'any'becauseitdoesnothaveareturntypeannotationandisreferenceddirectlyorindirectlyinoneofitsreturnexpressions.由于函数不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型\"any\"。||7025|错误|Generatorimplicitlyhastype'{0}'becauseitdoesnotyieldanyvalues.Considersupplyingareturntype.生成器隐式具有类型“{0}”，因为它不生成任何值。请考虑提供一个返回类型。||7026|错误|JSXelementimplicitlyhastype'any'becausenointerface'JSX.{0}'existsJSX元素隐式具有类型\"any\"，因为不存在接口“JSX.{0}”||7027|错误|Unreachablecodedetected.检测到无法访问的代码。||7028|错误|Unusedlabel.未使用的标签。||7029|错误|Fallthroughcaseinswitch.switch语句中的Fallthrough情况。||7030|错误|Notallcodepathsreturnavalue.并非所有代码路径都返回值。||7031|错误|Bindingelement'{0}'implicitlyhasan'{1}'type.||7032|错误|Property'{0}'implicitlyhastype'any',becauseitssetaccessorlacksaparametertypeannotation.||7033|错误|Property'{0}'implicitlyhastype'any',becauseitsgetaccessorlacksareturntypeannotation.||7034|错误|Variable'{0}'implicitlyhastype'{1}'insomelocationswhereitstypecannotbedetermined.||8000|错误|Youcannotrenamethiselement.无法重命名此元素。||8001|错误|YoucannotrenameelementsthataredefinedinthestandardTypeScriptlibrary.不能重命名标准TypeScript库中定义的元素。||8002|错误|'import...='canonlybeusedina.tsfile.\"import...=\"只能在.ts文件中使用。||8003|错误|'export='canonlybeusedina.tsfile.\"export=\"只能在.ts文件中使用。||8004|错误|'typeparameterdeclarations'canonlybeusedina.tsfile.\"typeparameterdeclarations\"只能在.ts文件中使用。||8005|错误|'implementsclauses'canonlybeusedina.tsfile.\"implementsclauses\"只能在.ts文件中使用。||8006|错误|'interfacedeclarations'canonlybeusedina.tsfile.\"interfacedeclarations\"只能在.ts文件中使用。||8007|错误|'moduledeclarations'canonlybeusedina.tsfile.\"moduledeclarations\"只能在.ts文件中使用。||8008|错误|'typealiases'canonlybeusedina.tsfile.\"typealiases\"只能在.ts文件中使用。||8009|错误|'{0}'canonlybeusedina.tsfile.“{0}”只能在.ts文件中使用。||8010|错误|'types'canonlybeusedina.tsfile.\"types\"只能在.ts文件中使用。||8011|错误|'typearguments'canonlybeusedina.tsfile.\"typearguments\"只能在.ts文件中使用。||8012|错误|'parametermodifiers'canonlybeusedina.tsfile.\"parametermodifiers\"只能在.ts文件中使用。||8015|错误|'enumdeclarations'canonlybeusedina.tsfile.\"enumdeclarations\"只能在.ts文件中使用。||8016|错误|'typeassertionexpressions'canonlybeusedina.tsfile.\"typeassertionexpressions\"只能在.ts文件中使用。||9002|错误|Onlyidentifiers/qualified-nameswithoptionaltypeargumentsarecurrentlysupportedinaclass'extends'clauses.类\"extends\"子句当前只支持具有可选类型参数的标识符/限定名称。||9003|错误|'class'expressionsarenotcurrentlysupported.当前不支持\"class\"表达式。||9004|错误|Languageserviceisdisabled.||17000|错误|JSXattributesmustonlybeassignedanon-empty'expression'.只能为JSX属性分配非空“表达式”。||17001|错误|JSXelementscannothavemultipleattributeswiththesamename.JSX元素不能具有多个名称相同的特性。||17002|错误|ExpectedcorrespondingJSXclosingtagfor'{0}'.“{0}”预期的相应JSX结束标记。||17003|错误|JSXattributeexpected.需要JSX属性。||17004|错误|CannotuseJSXunlessthe'--jsx'flagisprovided.无法使用JSX，除非提供了\"--jsx\"标志。||17005|错误|Aconstructorcannotcontaina'super'callwhenitsclassextends'null'当构造函数的类扩展\"null\"时，它不能包含\"super\"调用。||17006|错误|Anunaryexpressionwiththe'{0}'operatorisnotallowedintheleft-handsideofanexponentiationexpression.Considerenclosingtheexpressioninparentheses.乘方表达式的左侧不允许存在具有“{0}”运算符的一元表达式。请考虑用括号将表达式括起。||17007|错误|Atypeassertionexpressionisnotallowedintheleft-handsideofanexponentiationexpression.Considerenclosingtheexpressioninparentheses.乘方表达式的左侧不允许出现类型断言表达式。请考虑用括号将表达式括起。||17008|错误|JSXelement'{0}'hasnocorrespondingclosingtag.JSXelement'{0}'hasnocorrespondingclosingtag.||17009|错误|'super'mustbecalledbeforeaccessing'this'intheconstructorofaderivedclass.'super'mustbecalledbeforeaccessing'this'intheconstructorofaderivedclass.||17010|错误|Unknowntypeacquisitionoption'{0}'.Unknowntypingoption'{0}'.||17011|错误|'super'mustbecalledbeforeaccessingapropertyof'super'intheconstructorofaderivedclass.||17012|错误|'{0}'isnotavalidmeta-propertyforkeyword'{1}'.Didyoumean'{0}'?ToomanyJavaScriptfilesintheproject.Considerspecifyingthe'exclude'settinginprojectconfigurationtolimitincludedsourcefolders.Thelikelyfoldertoexcludeis'{0}'.Todisabletheprojectsizelimit,setthe'disableSizeLimit'compileroptionto'true'.||17013|错误|Meta-property'{0}'isonlyallowedinthebodyofafunctiondeclaration,functionexpression,orconstructor.||18000|错误|Circularitydetectedwhileresolvingconfiguration:{0}||18001|错误|Apathinan'extends'optionmustberelativeorrooted,but'{0}'isnot.||18002|错误|The'files'listinconfigfile'{0}'isempty.||18003|错误|Noinputswerefoundinconfigfile'{0}'.Specified'include'pathswere'{1}'and'exclude'pathswere'{2}'.||90001|信息|Addmissing'super()'call.||90002|信息|Make'super()'callthefirststatementintheconstructor.||90003|信息|Change'extends'to'implements'.||90004|信息|Removeunusedidentifiers.||90006|信息|Implementinterface'{0}'.||90007|信息|Implementinheritedabstractclass.||90009|错误|Addingatsconfig.jsonfilewillhelporganizeprojectsthatcontainbothTypeScriptandJavaScriptfiles.Learnmoreat<https://aka.ms/tsconfig>||90010|错误|Type'{0}'isnotassignabletotype'{1}'.Twodifferenttypeswiththisnameexist,buttheyareunrelated.||90013|信息|Import{0}from{1}||90014|信息|Change{0}to{1}||90015|信息|Add{0}toexistingimportdeclarationfrom{1}||8017|错误|OctalliteraltypesmustuseES2015syntax.Usethesyntax'{0}'.||8018|错误|Octalliteralsarenotallowedinenumsmembersinitializer.Usethesyntax'{0}'.|","JavaScript\\TypeScript\\ts.md":"#TypeScript>-[JSX·TypeScript中文网·TypeScript——JavaScript的超集(tslang.cn)](https://www.tslang.cn/docs/handbook/jsx.html)>-[lib.d.ts|深入理解TypeScript(jkchao.github.io)](https://jkchao.github.io/typescript-book-chinese/typings/lib.html#使用例子)>-是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。>-提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件。下图显示了TypeScript与ES5、ES2015和ES2016之间的关系：##获取TypeScript>命令行的TypeScript编译器可以使用Node.js包来安装。###1.安装TypeScript>`$npminstall-gtypescript`###2.编译TypeScript文件$tschelloworld.tshelloworld.ts=>helloworld.jsTypeScript在线平台Playground：www.typescriptlang.org/play/##TypeScript基础类型```tsBoolean类型letisDone:boolean=false;//ES5：varisDone=false;Number类型letcount:number=10;//ES5：varcount=10;String类型letname:string=\"Ruihuag\";//ES5：varname='Ruihuag';Array类型letlist:number[]=[1,2,3];//ES5：varlist=[1,2,3];letlist:Array<number>=[1,2,3];//Array<number>泛型语法//ES5：varlist=[1,2,3];```##Enum类型使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。TypeScript支持数字的和基于字符串的枚举。###数字枚举```tsenumDirection{NORTH,SOUTH,EAST,WEST,}letdir:Direction=Direction.NORTH```>默认情况下，NORTH的初始值为0，其余的成员会从1开始自动增长。>>换句话说，Direction.SOUTH的值为1，Direction.EAST的值为2，Direction.WEST的值为3。上面的枚举示例代码经过编译后会生成以下代码：```ts\"usestrict\";varDirection;(function(Direction){Direction[(Direction[\"NORTH\"]=0)]=\"NORTH\";Direction[(Direction[\"SOUTH\"]=1)]=\"SOUTH\";Direction[(Direction[\"EAST\"]=2)]=\"EAST\";Direction[(Direction[\"WEST\"]=3)]=\"WEST\";})(Direction||(Direction={}));vardir=Direction.NORTH;当然我们也可以设置NORTH的初始值，比如：enumDirection{NORTH=3,SOUTH,EAST,WEST,}```###字符串枚举```JS在TypeScript2.4版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。enumDirection{NORTH=\"NORTH\",SOUTH=\"SOUTH\",EAST=\"EAST\",WEST=\"WEST\",}以上代码对于的ES5代码如下：\"usestrict\";varDirection;(function(Direction){Direction[\"NORTH\"]=\"NORTH\";Direction[\"SOUTH\"]=\"SOUTH\";Direction[\"EAST\"]=\"EAST\";Direction[\"WEST\"]=\"WEST\";})(Direction||(Direction={}));```###异构枚举```JS异构枚举的成员值是数字和字符串的混合：enumEnum{A,B,C=\"C\",D=\"D\",E=8,F,}以上代码对于的ES5代码如下：\"usestrict\";varEnum;(function(Enum){Enum[Enum[\"A\"]=0]=\"A\";Enum[Enum[\"B\"]=1]=\"B\";Enum[\"C\"]=\"C\";Enum[\"D\"]=\"D\";Enum[Enum[\"E\"]=8]=\"E\";Enum[Enum[\"F\"]=9]=\"F\";})(Enum||(Enum={}));通过观察上述生成的ES5代码，我们可以发现数字枚举相对字符串枚举多了“反向映射”：console.log(Enum.A)//输出：0console.log(Enum[0])//输出：A2.6Any类型在TypeScript中，任何类型都可以被归为any类型。这让any类型成为了类型系统的顶级类型（也被称作全局超级类型）。letnotSure:any=666;notSure=\"Ruihuag\";notSure=false;any类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript允许我们对any类型的值执行任何操作，而无需事先执行任何形式的检查。比如：letvalue:any;value.foo.bar;//OKvalue.trim();//OKvalue();//OKnewvalue();//OKvalue[0][1];//OK在许多场景下，这太宽松了。使用any类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用any类型，就无法使用TypeScript提供的大量的保护机制。为了解决any带来的问题，TypeScript3.0引入了unknown类型。2.7Unknown类型就像所有类型都可以赋值给any，所有类型也都可以赋值给unknown。这使得unknown成为TypeScript类型系统的另一种顶级类型（另一种是any）。下面我们来看一下unknown类型的使用示例：letvalue:unknown;value=true;//OKvalue=42;//OKvalue=\"HelloWorld\";//OKvalue=[];//OKvalue={};//OKvalue=Math.random;//OKvalue=null;//OKvalue=undefined;//OKvalue=newTypeError();//OKvalue=Symbol(\"type\");//OK对value变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为unknown的值赋值给其他类型的变量时会发生什么？letvalue:unknown;letvalue1:unknown=value;//OKletvalue2:any=value;//OKletvalue3:boolean=value;//Errorletvalue4:number=value;//Errorletvalue5:string=value;//Errorletvalue6:object=value;//Errorletvalue7:any[]=value;//Errorletvalue8:Function=value;//Errorunknown类型只能被赋值给any类型和unknown类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存unknown类型的值。毕竟我们不知道变量value中存储了什么类型的值。现在让我们看看当我们尝试对类型为unknown的值执行操作时会发生什么。以下是我们在之前any章节看过的相同操作：letvalue:unknown;value.foo.bar;//Errorvalue.trim();//Errorvalue();//Errornewvalue();//Errorvalue[0][1];//Error将value变量类型设置为unknown后，这些操作都不再被认为是类型正确的。通过将any类型改变为unknown类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。2.8Tuple类型众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在JavaScript中是没有元组的，元组是TypeScript中特有的类型，其工作方式类似于数组。元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：lettupleType:[string,boolean];tupleType=[\"Ruihuag\",true];在上面代码中，我们定义了一个名为tupleType的变量，它的类型是一个类型数组[string,boolean]，然后我们按照正确的类型依次初始化tupleType变量。与数组一样，我们可以通过下标来访问元组中的元素：console.log(tupleType[0]);//Ruihuagconsole.log(tupleType[1]);//true在元组初始化的时候，如果出现类型不匹配的话，比如：tupleType=[true,\"Ruihuag\"];此时，TypeScript编译器会提示以下错误信息：[0]:Type'true'isnotassignabletotype'string'.[1]:Type'string'isnotassignabletotype'boolean'.很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误，比如：tupleType=[\"Ruihuag\"];此时，TypeScript编译器会提示以下错误信息：Property'1'ismissingintype'[string]'butrequiredintype'[string,boolean]'.2.9Void类型某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是void：//声明函数返回值为voidfunctionwarnUser():void{console.log(\"Thisismywarningmessage\");}以上代码编译生成的ES5代码如下：\"usestrict\";functionwarnUser(){console.log(\"Thisismywarningmessage\");}需要注意的是，声明一个void类型的变量没有什么作用，因为它的值只能为undefined或null：letunusable:void=undefined;2.10Null和Undefined类型TypeScript里，undefined和null两者有各自的类型分别为undefined和null。letu:undefined=undefined;letn:null=null;默认情况下null和undefined是所有类型的子类型。就是说你可以把null和undefined赋值给number类型的变量。然而，如果你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自的类型。2.11Never类型never类型表示的是那些永不存在的值的类型。例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。//返回never的函数必须存在无法达到的终点functionerror(message:string):never{thrownewError(message);}functioninfiniteLoop():never{while(true){}}在TypeScript中，可以利用never类型的特性来实现全面性检查，具体示例如下：typeFoo=string|number;functioncontrolFlowAnalysisWithNever(foo:Foo){if(typeoffoo===\"string\"){//这里foo被收窄为string类型}elseif(typeoffoo===\"number\"){//这里foo被收窄为number类型}else{//foo在这里是neverconstcheck:never=foo;}}注意在else分支里面，我们把收窄为never的foo赋值给一个显示声明的never变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了Foo的类型：typeFoo=string|number|boolean;然而他忘记同时修改controlFlowAnalysisWithNever方法中的控制流程，这时候else分支的foo类型会被收窄为boolean类型，导致无法赋值给never类型，这时就会产生一个编译错误。通过这个方式，我们可以确保controlFlowAnalysisWithNever方法总是穷尽了Foo的所有可能类型。通过这个示例，我们可以得出一个结论：使用never避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。```三、TypeScript断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。类型断言有两种形式：3.1“尖括号”语法letsomeValue:any=\"thisisastring\";letstrLength:number=(<string>someValue).length;3.2as语法letsomeValue:any=\"thisisastring\";letstrLength:number=(someValueasstring).length;复四、类型守卫Atypeguardissomeexpressionthatperformsaruntimecheckthatguaranteesthetypeinsomescope.——TypeScript官方文档类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：4.1in关键字interfaceAdmin{name:string;privileges:string[];}interfaceEmployee{name:string;startDate:Date;}typeUnknownEmployee=Employee|Admin;functionprintEmployeeInformation(emp:UnknownEmployee){console.log(\"Name:\"+emp.name);if(\"privileges\"inemp){console.log(\"Privileges:\"+emp.privileges);}if(\"startDate\"inemp){console.log(\"StartDate:\"+emp.startDate);}}4.2typeof关键字functionpadLeft(value:string,padding:string|number){if(typeofpadding===\"number\"){returnArray(padding+1).join(\"\")+value;}if(typeofpadding===\"string\"){returnpadding+value;}thrownewError(`Expectedstringornumber,got'${padding}'.`);}typeof类型保护只支持两种形式：typeofv===\"typename\"和typeofv!==typename，\"typename\"必须是\"number\"，\"string\"，\"boolean\"或\"symbol\"。但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。4.3instanceof关键字interfacePadder{getPaddingString():string;}classSpaceRepeatingPadderimplementsPadder{constructor(privatenumSpaces:number){}getPaddingString(){returnArray(this.numSpaces+1).join(\"\");}}classStringPadderimplementsPadder{constructor(privatevalue:string){}getPaddingString(){returnthis.value;}}letpadder:Padder=newSpaceRepeatingPadder(6);if(padderinstanceofSpaceRepeatingPadder){//padder的类型收窄为'SpaceRepeatingPadder'}4.4自定义类型保护的类型谓词functionisNumber(x:any):xisnumber{returntypeofx===\"number\";}functionisString(x:any):xisstring{returntypeofx===\"string\";}五、联合类型和类型别名5.1联合类型联合类型通常与null或undefined一起使用：constsayHello=(name:string|undefined)=>{/_..._/};例如，这里name的类型是string|undefined意味着可以将string或undefined的值传递给sayHello函数。sayHello(\"Ruihuag\");sayHello(undefined);通过这个示例，你可以凭直觉知道类型A和类型B联合后的类型是同时接受A和B值的类型。5.2可辨识联合TypeScript可辨识联合（DiscriminatedUnions）类型，也称为代数数据类型或标签联合类型。它包含3个要点：可辨识、联合类型和类型守卫。这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。1.可辨识可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：enumCarTransmission{Automatic=200,Manual=300}interfaceMotorcycle{vType:\"motorcycle\";//discriminantmake:number;//year}interfaceCar{vType:\"car\";//discriminanttransmission:CarTransmission}interfaceTruck{vType:\"truck\";//discriminantcapacity:number;//intons}在上述代码中，我们分别定义了Motorcycle、Car和Truck三个接口，在这些接口中都包含一个vType属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。2.联合类型基于前面定义了三个接口，我们可以创建一个Vehicle联合类型：typeVehicle=Motorcycle|Car|Truck;现在我们就可以开始使用Vehicle联合类型，对于Vehicle类型的变量，它可以表示不同类型的车辆。3.类型守卫下面我们来定义一个evaluatePrice方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：constEVALUATION_FACTOR=Math.PI;functionevaluatePrice(vehicle:Vehicle){returnvehicle.capacity\\*EVALUATION_FACTOR;}constmyTruck:Truck={vType:\"truck\",capacity:9.5};evaluatePrice(myTruck);对于以上代码，TypeScript编译器将会提示以下错误信息：Property'capacity'doesnotexistontype'Vehicle'.Property'capacity'doesnotexistontype'Motorcycle'.原因是在Motorcycle接口中，并不存在capacity属性，而对于Car接口来说，它也不存在capacity属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的evaluatePrice方法，重构后的代码如下：functionevaluatePrice(vehicle:Vehicle){switch(vehicle.vType){case\"car\":returnvehicle.transmission_EVALUATION_FACTOR;case\"truck\":returnvehicle.capacity_EVALUATION_FACTOR;case\"motorcycle\":returnvehicle.make\\*EVALUATION_FACTOR;}}在以上代码中，我们使用switch和case运算符来实现类型守卫，从而确保在evaluatePrice方法中，我们可以安全地访问vehicle对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。5.3类型别名类型别名用来给一个类型起个新名字。typeMessage=string|string[];letgreet=(message:Message)=>{//...};六、交叉类型TypeScript交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。interfaceIPerson{id:string;age:number;}interfaceIWorker{companyId:string;}typeIStaff=IPerson&IWorker;conststaff:IStaff={id:'E1006',age:33,companyId:'EFT'};console.dir(staff)在上面示例中，我们首先为IPerson和IWorker类型定义了不同的成员，然后通过&运算符定义了IStaff交叉类型，所以该类型同时拥有IPerson和IWorker这两种类型的成员。七、TypeScript函数7.1TypeScript函数与JavaScript函数的区别TypeScriptJavaScript含有类型无类型箭头函数箭头函数（ES2015）函数类型无函数类型必填和可选参数所有参数都是可选的默认参数默认参数剩余参数剩余参数函数重载无函数重载7.2箭头函数1.常见语法myBooks.forEach(()=>console.log('reading'));myBooks.forEach(title=>console.log(title));myBooks.forEach((title,idx,arr)=>console.log(idx+'-'+title););myBooks.forEach((title,idx,arr)=>{console.log(idx+'-'+title);});2.使用示例//未使用箭头函数functionBook(){letself=this;self.publishDate=2016;setInterval(function(){console.log(self.publishDate);},1000);}//使用箭头函数functionBook(){this.publishDate=2016;setInterval(()=>{console.log(this.publishDate);},1000);}7.3参数类型和返回类型functioncreateUserId(name:string,id:number):string{returnname+id;}7.4函数类型letIdGenerator:(chars:string,nums:number)=>string;functioncreateUserId(name:string,id:number):string{returnname+id;}IdGenerator=createUserId;7.5可选参数及默认参数//可选参数functioncreateUserId(name:string,id:number,age?:number):string{returnname+id;}//默认参数functioncreateUserId(name:string=\"Ruihuag\",id:number,age?:number):string{returnname+id;}在声明函数时，可以通过?号来定义可选参数，比如age?:number这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。7.6剩余参数functionpush(array,...items){items.forEach(function(item){array.push(item);});}leta=[];push(a,1,2,3);7.7函数重载函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。functionadd(a:number,b:number):number;functionadd(a:string,b:string):string;functionadd(a:string,b:number):string;functionadd(a:number,b:string):string;functionadd(a:Combinable,b:Combinable){if(typeofa===\"string\"||typeofb===\"string\"){returna.toString()+b.toString();}returna+b;}在以上代码中，我们为add函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时result变量的类型是string类型。在TypeScript中除了可以重载普通函数之外，我们还可以重载类中的成员方法。方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：classCalculator{add(a:number,b:number):number;add(a:string,b:string):string;add(a:string,b:number):string;add(a:number,b:string):string;add(a:Combinable,b:Combinable){if(typeofa===\"string\"||typeofb===\"string\"){returna.toString()+b.toString();}returna+b;}}constcalculator=newCalculator();constresult=calculator.add(\"Ruihuag\",\"Kakuqo\");这里需要注意的是，当TypeScript编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在Calculator类中，add(a:Combinable,b:Combinable){}并不是重载列表的一部分，因此对于add成员方法来说，我们只定义了四个重载方法。八、TypeScript数组8.1数组解构letx:number;lety:number;letz:number;letfive_array=[0,1,2,3,4];[x,y,z]=five_array;8.2数组展开运算符lettwo_array=[0,1];letfive_array=[...two_array,2,3,4];8.3数组遍历letcolors:string[]=[\"red\",\"green\",\"blue\"];for(letiofcolors){console.log(i);}九、TypeScript对象9.1对象解构letperson={name:\"Ruihuag\",gender:\"Male\",};let{name,gender}=person;9.2对象展开运算符letperson={name:\"Ruihuag\",gender:\"Male\",address:\"Xiamen\",};//组装对象letpersonWithAge={...person,age:33};//获取除了某些项外的其它项let{name,...rest}=person;十、TypeScript接口在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。TypeScript中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。10.1对象的形状interfacePerson{name:string;age:number;}letRuihuag:Person={name:\"Ruihuag\",age:33,};10.2可选|只读属性interfacePerson{readonlyname:string;age?:number;}只读属性用于限制只能在对象刚刚创建的时候修改其值。此外TypeScript还提供了ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。leta:number[]=[1,2,3,4];letro:ReadonlyArray<number>=a;ro[0]=12;//error!ro.push(5);//error!ro.length=100;//error!a=ro;//error!十一、TypeScript类11.1类的属性与方法在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。在TypeScript中，我们可以通过Class关键字来定义一个类：classGreeter{//静态属性staticcname:string=\"Greeter\";//成员属性greeting:string;//构造函数-执行初始化操作constructor(message:string){this.greeting=message;}//静态方法staticgetClassName(){return\"ClassnameisGreeter\";}//成员方法greet(){return\"Hello,\"+this.greeting;}}letgreeter=newGreeter(\"world\");那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的ES5代码：\"usestrict\";varGreeter=/\\*_@class_/(function(){//构造函数-执行初始化操作functionGreeter(message){this.greeting=message;}//静态方法Greeter.getClassName=function(){return\"ClassnameisGreeter\";};//成员方法Greeter.prototype.greet=function(){return\"Hello,\"+this.greeting;};//静态属性Greeter.cname=\"Greeter\";returnGreeter;}());vargreeter=newGreeter(\"world\");11.2访问器在TypeScript中，我们可以通过getter和setter方法来实现数据的封装和有效性校验，防止出现异常数据。letpasscode=\"HelloTypeScript\";classEmployee{private\\_fullName:string;getfullName():string{returnthis.\\_fullName;}setfullName(newName:string){if(passcode&&passcode==\"HelloTypeScript\"){this.\\_fullName=newName;}else{console.log(\"Error:Unauthorizedupdateofemployee!\");}}}letemployee=newEmployee();employee.fullName=\"Ruihuag\";if(employee.fullName){console.log(employee.fullName);}11.3类的继承继承(Inheritance)是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。继承是一种is-a关系：在TypeScript中，我们可以通过extends关键字来实现继承：classAnimal{name:string;constructor(theName:string){this.name=theName;}move(distanceInMeters:number=0){console.log(`${this.name}moved${distanceInMeters}m.`);}}classSnakeextendsAnimal{constructor(name:string){super(name);}move(distanceInMeters=5){console.log(\"Slithering...\");super.move(distanceInMeters);}}letsam=newSnake(\"SammythePython\");sam.move();11.4ECMAScript私有字段在TypeScript3.8版本就开始支持ECMAScript私有字段，使用方式如下：classPerson{#name:string;constructor(name:string){this.#name=name;}greet(){console.log(`Hello,mynameis${this.#name}!`);}}letRuihuag=newPerson(\"Ruihuag\");Ruihuag.#name;//~~~~~//Property'#name'isnotaccessibleoutsideclass'Person'//becauseithasaprivateidentifier.与常规属性（甚至使用private修饰符声明的属性）不同，私有字段要牢记以下规则：私有字段以#字符开头，有时我们称之为私有名称；每个私有字段名称都唯一地限定于其包含的类；不能在私有字段上使用TypeScript可访问性修饰符（如public或private）；私有字段不能在包含的类之外访问，甚至不能被检测到。十二、TypeScript泛型软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用any类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。12.1泛型接口interfaceGenericIdentityFn<T>{(arg:T):T;}12.2泛型类classGenericNumber<T>{zeroValue:T;add:(x:T,y:T)=>T;}letmyGenericNumber=newGenericNumber<number>();myGenericNumber.zeroValue=0;myGenericNumber.add=function(x,y){returnx+y;};12.3泛型变量对刚接触TypeScript泛型的小伙伴来说，看到T和E，还有K和V这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母A-Z定义的类型变量都属于泛型，把T换成A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：T（Type）：表示一个TypeScript类型K（Key）：表示对象中的键类型V（Value）：表示对象中的值类型E（Element）：表示元素类型12.4泛型工具类型为了方便开发者TypeScript内置了一些常用的工具类型，比如Partial、Required、Readonly、Record和ReturnType等。出于篇幅考虑，这里我们只简单介绍Partial工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。1.typeof在TypeScript中，typeof操作符可以用来获取一个变量声明或对象的类型。interfacePerson{name:string;age:number;}constsem:Person={name:'Ruihuag',age:30};typeSem=typeofsem;//->PersonfunctiontoArray(x:number):Array<number>{return[x];}typeFunc=typeoftoArray;//->(x:number)=>number[]2.keyofkeyof操作符可以用来一个对象中的所有key值：interfacePerson{name:string;age:number;}typeK1=keyofPerson;//\"name\"|\"age\"typeK2=keyofPerson[];//\"length\"|\"toString\"|\"pop\"|\"push\"|\"concat\"|\"join\"typeK3=keyof{[x:string]:Person};//string|number3.inin用来遍历枚举类型：typeKeys=\"a\"|\"b\"|\"c\"typeObj={}//->{a:any,b:any,c:any}4.infer在条件类型语句中，可以用infer声明一个类型变量并且对它进行使用。typeReturnType<T>=Textends(...args:any[])=>inferR?R:any;以上代码中inferR就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。5.extends有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过extends关键字添加泛型约束。interfaceILengthwise{length:number;}functionloggingIdentity<TextendsILengthwise>(arg:T):T{console.log(arg.length);returnarg;}现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：loggingIdentity(3);//Error,numberdoesn'thavea.lengthproperty这时我们需要传入符合约束类型的值，必须包含必须的属性：loggingIdentity({length:10,value:3});6.PartialPartial<T>的作用就是将某个类型里的属性全部变为可选项?。定义：/\\*\\*-node_modules/typescript/lib/lib.es5.d.ts-MakeallpropertiesinToptional\\*/typePartial<T>={[PinkeyofT]?:T[P];};在以上代码中，首先通过keyofT拿到T的所有属性名，然后使用in进行遍历，将值赋给P，最后通过T[P]取得相应的属性值。中间的?号，用于将所有属性变为可选。示例：interfaceTodo{title:string;description:string;}functionupdateTodo(todo:Todo,fieldsToUpdate:Partial<Todo>){return{...todo,...fieldsToUpdate};}consttodo1={title:\"organizedesk\",description:\"clearclutter\",};consttodo2=updateTodo(todo1,{description:\"throwouttrash\",});在上面的updateTodo方法中，我们利用Partial<T>工具类型，定义fieldsToUpdate的类型为Partial<Todo>，即：{title?:string|undefined;description?:string|undefined;}十三、TypeScript装饰器13.1装饰器是什么它是一个表达式该表达式被执行后，返回一个函数函数的入参分别为target、name和descriptor执行该函数后，可能返回descriptor对象，用于配置target对象13.2装饰器的分类类装饰器（Classdecorators）属性装饰器（Propertydecorators）方法装饰器（Methoddecorators）参数装饰器（Parameterdecorators）13.3类装饰器类装饰器声明：declaretypeClassDecorator=<TFunctionextendsFunction>(target:TFunction)=>TFunction|void;类装饰器顾名思义，就是用来装饰类的。它接收一个参数：target:TFunction-被装饰的类看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：functionGreeter(target:Function):void{target.prototype.greet=function():void{console.log(\"HelloRuihuag!\");};}@GreeterclassGreeting{constructor(){//内部实现}}letmyGreeting=newGreeting();myGreeting.greet();//consoleoutput:'HelloRuihuag!';上面的例子中，我们定义了Greeter类装饰器，同时我们使用了@Greeter语法糖，来使用装饰器。友情提示：读者可以直接复制上面的代码，在TypeScriptPlayground中运行查看结果。有的读者可能想问，例子中总是输出HelloRuihuag!，能自定义输出的问候语么？这个问题很好，答案是可以的。具体实现如下：functionGreeter(greeting:string){returnfunction(target:Function){target.prototype.greet=function():void{console.log(greeting);};};}@Greeter(\"HelloTS!\")classGreeting{constructor(){//内部实现}}letmyGreeting=newGreeting();myGreeting.greet();//consoleoutput:'HelloTS!';13.4属性装饰器属性装饰器声明：declaretypePropertyDecorator=(target:Object,propertyKey:string|symbol)=>void;属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：target:Object-被装饰的类propertyKey:string|symbol-被装饰类的属性名趁热打铁，马上来个例子热热身：functionlogProperty(target:any,key:string){deletetarget[key];constbackingField=\"\\_\"+key;Object.defineProperty(target,backingField,{writable:true,enumerable:true,configurable:true});//propertygetterconstgetter=function(this:any){constcurrVal=this[backingField];console.log(`Get:${key}=>${currVal}`);returncurrVal;};//propertysetterconstsetter=function(this:any,newVal:any){console.log(`Set:${key}=>${newVal}`);this[backingField]=newVal;};//CreatenewpropertywithgetterandsetterObject.defineProperty(target,key,{get:getter,set:setter,enumerable:true,configurable:true});}classPerson{@logPropertypublicname:string;constructor(name:string){this.name=name;}}constp1=newPerson(\"Ruihuag\");p1.name=\"kakuqo\";以上代码我们定义了一个logProperty函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：Set:name=>RuihuagSet:name=>kakuqo13.5方法装饰器方法装饰器声明：declaretypeMethodDecorator=<T>(target:Object,propertyKey:string|symbol,descriptor:TypePropertyDescript<T>)=>TypedPropertyDescriptor<T>|void;方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：target:Object-被装饰的类propertyKey:string|symbol-方法名descriptor:TypePropertyDescript-属性描述符废话不多说，直接上例子：functionLogOutput(tarage:Function,key:string,descriptor:any){letoriginalMethod=descriptor.value;letnewMethod=function(...args:any[]):any{letresult:any=originalMethod.apply(this,args);if(!this.loggedOutput){this.loggedOutput=newArray<any>();}this.loggedOutput.push({method:key,parameters:args,output:result,timestamp:newDate()});returnresult;};descriptor.value=newMethod;}classCalculator{@LogOutputdouble(num:number):number{returnnum\\*2;}}letcalc=newCalculator();calc.double(11);//consoleouput:[{method:\"double\",output:22,...}]console.log(calc.loggedOutput);下面我们来介绍一下参数装饰器。13.6参数装饰器参数装饰器声明：declaretypeParameterDecorator=(target:Object,propertyKey:string|symbol,parameterIndex:number)=>void参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：target:Object-被装饰的类propertyKey:string|symbol-方法名parameterIndex:number-方法中参数的索引值functionLog(target:Function,key:string,parameterIndex:number){letfunctionLogged=key||target.prototype.constructor.name;console.log(`Theparameterinposition${parameterIndex}at${functionLogged}hasbeendecorated`);}classGreeter{greeting:string;constructor(@Logphrase:string){this.greeting=phrase;}}//consoleoutput:Theparameterinposition0//atGreeterhasbeendecorated介绍完TypeScript入门相关的基础知识，猜测很多刚入门的小伙伴已有“从入门到放弃”的想法，最后我们来简单介绍一下编译上下文。十四、编译上下文14.1tsconfig.json的作用用于标识TypeScript项目的根路径；用于配置TypeScript编译器；用于指定编译的文件。14.2tsconfig.json重要字段files-设置要编译的文件的名称；include-设置需要进行编译的文件，支持路径模式匹配；exclude-设置无需进行编译的文件，支持路径模式匹配；compilerOptions-设置与编译流程相关的选项。14.3compilerOptions选项compilerOptions支持很多选项，常见的有baseUrl、target、baseUrl、moduleResolution和lib等。compilerOptions每个选项的详细说明如下：{\"compilerOptions\":{/*基本选项*/\"target\":\"es5\",//指定ECMAScript目标版本:'ES3'(default),'ES5','ES6'/'ES2015','ES2016','ES2017',or'ESNEXT'\"module\":\"commonjs\",//指定使用模块:'commonjs','amd','system','umd'or'es2015'\"lib\":[],//指定要包含在编译中的库文件\"allowJs\":true,//允许编译javascript文件\"checkJs\":true,//报告javascript文件中的错误\"jsx\":\"preserve\",//指定jsx代码的生成:'preserve','react-native',or'react'\"declaration\":true,//生成相应的'.d.ts'文件\"sourceMap\":true,//生成相应的'.map'文件\"outFile\":\"./\",//将输出文件合并为一个文件\"outDir\":\"./\",//指定输出目录\"rootDir\":\"./\",//用来控制输出目录结构--outDir.\"removeComments\":true,//删除编译后的所有的注释\"noEmit\":true,//不生成输出文件\"importHelpers\":true,//从tslib导入辅助工具函数\"isolatedModules\":true,//将每个文件做为单独的模块（与'ts.transpileModule'类似）./*严格的类型检查选项*/\"strict\":true,//启用所有严格类型检查选项\"noImplicitAny\":true,//在表达式和声明上有隐含的any类型时报错\"strictNullChecks\":true,//启用严格的null检查\"noImplicitThis\":true,//当this表达式值为any类型的时候，生成一个错误\"alwaysStrict\":true,//以严格模式检查每个模块，并在每个文件里加入'usestrict'/*额外的检查*/\"noUnusedLocals\":true,//有未使用的变量时，抛出错误\"noUnusedParameters\":true,//有未使用的参数时，抛出错误\"noImplicitReturns\":true,//并不是所有函数里的代码都有返回值时，抛出错误\"noFallthroughCasesInSwitch\":true,//报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿）/*模块解析选项*/\"moduleResolution\":\"node\",//选择模块解析策略：'node'(Node.js)or'classic'(TypeScriptpre-1.6)\"baseUrl\":\"./\",//用于解析非相对模块名称的基目录\"paths\":{},//模块名到基于baseUrl的路径映射的列表\"rootDirs\":[],//根文件夹列表，其组合内容表示项目运行时的结构内容\"typeRoots\":[],//包含类型声明的文件列表\"types\":[],//需要包含的类型声明文件名列表\"allowSyntheticDefaultImports\":true,//允许从没有设置默认导出的模块中默认导入。/*SourceMapOptions*/\"sourceRoot\":\"./\",//指定调试器应该找到TypeScript文件而不是源文件的位置\"mapRoot\":\"./\",//指定调试器应该找到映射文件而不是生成文件的位置\"inlineSourceMap\":true,//生成单个soucemaps文件，而不是将sourcemaps生成不同的文件\"inlineSources\":true,//将代码与sourcemaps生成到一个文件中，要求同时设置了--inlineSourceMap或--sourceMap属性/*其他选项*/\"experimentalDecorators\":true,//启用装饰器\"emitDecoratorMetadata\":true//为装饰器提供元数据的支持}}看到这里的读者都是“真爱”，如果你还意犹未尽，那就来看看本人整理的Github上1.5K+的开源项目：awesome-typescript。github.com/Ruihuag/a…十五、参考资源mariusschulz-the-unknown-type-in-typescript深入理解TypeScript-编译上下文文章分类前端文章标签JavaScriptTypeScript阿宝哥「全栈修仙之路」公众号发布了77篇专栏·获得点赞23,507·获得阅读864,088已关注安装掘金浏览器插件打开新标签页发现好内容，掘金、GitHub、Dribbble、ProductHunt等站点内容轻松获取。快来安装掘金浏览器插件获取高质量内容吧！蓝九九么得感情的切图仔感谢大佬分享19天前·删除回复阿宝哥(作者)「全栈修仙之路」公众号不客气哈，可以阅读新版1.8W字：juejin.cn19天作者：阿宝哥链接：<https://juejin.cn/post/6844904182843965453>来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","JavaScript\\TypeScript\\typescript.md":"#Typescript>-[TypeScript:TSPlayground-AnonlineeditorforexploringTypeScriptandJavaScript(typescriptlang.org)](https://www.typescriptlang.org/play?#code/PTAEHUFMBsGMHsC2lQBd5oBYoCoE8AHSAZVgCcBLA1UABWgEM8BzM+AVwDsATAGiwoBnUENANQAd0gAjQRVSQAUCEmYKsTKGYUAbpGF4OY0BoadYKdJMoL+gzAzIoz3UNEiPOofEVKVqAHSKymAAmkYI7NCuqGqcANag8ABmIjQUXrFOKBJMggBcISGgoAC0oACCoASMFmgY7p7ehCTkVOle4jUMdRLYTqCc8LEZzCZmoNJODPHFZZXVtZYYkAAeRJTInDQS8po+rf40gnjbDKv8LqD2jpbYoACqAEoAMsK7sUmxkGSCc+VVQQuaTwVb1UBrDYULY7PagbgUZLJH6QbYmJAECjuMigZEMVDsJzCFLNXxtajBBCcQQ0MwAUVWDEQNUgADVHBQGNJ3KAALygABEAAkYNAMOB4GRogLFFTBPB3AExcwABT0xnM9zsyhc9wASmCKhwDQ8ZC8iElzhB7Bo3zcZmY7AYzEg-Fg0HUiS58D0Ii8AoZTJZggFSRxAvADlQAHJhAA5SASAVBFQAeW+ZF2gldWkgx1QjgUrmkeFATgtOlGWH0KAQiBhwiudokkuiIgMHBx3RYbC43CCJSAA)>-包含了ES6和ES5的语法>-微软开发>-更像面向对象的语法>-ts>es2016>es2015>es5##js和ts区别|ts|js||--------------------------------------|------------------------------------||js的超集,用于解决大型项目的代码复杂性|脚本语言,创建动态网页||编译期间发现并纠正错误|解释型语言,只有在运行的时候发现错误||强类型,支持静态和动态类型|弱类型,没有静态类型选项||解释成js代码,使浏览器理解|可直接在浏览器运行||支持模块,泛型和接口|不支持模块,泛型或接口|##ts工作流程```mermaidgraphLRA[TSa.tsb.tsc.ts]-->|编译|B[JSa.jsb.jsc.js]B-->|打包|C[JSmain.js]C-->|部署|D[main.js]```##使用typescript```shellnpminstall-gtypescripttschelloworld.ts//helloworld.ts=>helloworld.jstsc--init//创建tsconfig.js文件```##初体验```ts//hello.tsfunctiongreet(person:string){returnperson}console.log(greet('ts'))```执行该指令,编译成`hello.js````bashtschello.ts``````js'usestrcit'functiongreet(persion){returnpersion}console.log(greet('ts'))```##基本数据类型|数据类型|栗子||------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|-----------|-----------||布尔值boolean|`letisDone:boolean=false`||数字number|`letmyNumber:number=6[十]|0xf00d[十六]|0b1010[二]|0o744[八]`||字符串string|letname:string=\"hua\";<br/>letfullName=\\`rui${name}\\`;<br/>letsen:string=\"guan\"+(number+1)+\"hua\"||数组(Array)|letlist:number[]=[1,2,3];<br/>letlist:Array<number>=[1,2,3];||元组<br>[Tuple]|letx:[string,number];<br/>x=['hello',10];<br>x[2]=2;||枚举</br>[enum]|enumColor{Red[=1(不赋值就会在0开始)],Green,Blue}<br>letc:Color=Color.Green;<br>取值:c[1],c.Red||任意值any|letnotSure:any=4;//可以避开类型检查器<br>letlist:any[]=[1,true,\"free\"]<br>//类型的顶级类型||空值null/void|functionfn():void{}<br>只能复制null和defined||Null<br/>Unfefined|letu:undefined=undefined;<br>letn:null=null;||Never|是任何类型的子类型,也可以赋值给任何类型,即使any也不可以给never赋值<br>functionerror(message:string):never{thrownewError(message);}<br>functionfail():never{returnerror(\"Somethingfailed\");<br>functioninfiniteLoop():never{while(true){}}||类型断言|letsomeValue:any=\"thisissstring\";<br>letstrLength:number=(someValueasstring).length<br>letstrLength:number=(<string>someValue>)length||Symbol|constsym=Symbol();<br>letobj={[sym]:'ts'}||Unknown|和any类似<br>letvalue:any;||||###object,Object&{}####object```ts//node_modules/typescript/lib/lib.es5.d.tsinterfaceObjectConstructor{create(o:object|null):any//...}constproto={}Object.create(proto)//OKObject.create(null)//OKObject.create(undefined)//ErrorObject.create(1337)//ErrorObject.create(true)//ErrorObject.create('oops')//Error```####ObjectOject接口定义了Object.prototype原型对象```ts//node_modules/typescript/lib/lib.es5.d.tsinterfaceObject{constructor:FunctiontoString():stringtoLocaleString():stringvalueOf():ObjecthasOwnProperty(v:PropertyKey):booleanisPrototypeOf(v:Object):booleanpropertyIsEnumerable(v:PropertyKey):boolean}```ObjectConstrucotor接口定义了Object类的属性```ts//node_modules/typescript/lib/lib.es5.d.tsinterfaceObject{constructor:FunctiontoString():stringtoLocaleString():stringvalueOf():ObjecthasOwnProperty(v:PropertyKey):booleanisPrototypeOf(v:Object):booleanpropertyIsEnumerable(v:PropertyKey):boolean}```###{}```ts//Type{}constobj={}obj.prop='123'//Error:Property'prop'doesnotexistontype'{}'obj.toString()//\"[objectobject]\"```##类型守卫>类型保护是课执行运行时检查的一种表达式用于确保类型在一定的范围内###in```tsinterfaceAdmin{name:stringprivileges:string[]}interfaceEmployee{name:stringstartDate:Date}typeUnknownEmployee=Employee|AdminfunctionprintEmployeeInformation(emp:UnknownEmployee){console.log('Name:'+emp.name)if('privileges'inemp){console.log('Privileges:'+emp.privileges)}if('startDate'inemp){console.log('StartDate:'+emp.startDate)}}```###typeof```tsfunctionpadLeft(value:string,padding:string|number){if(typeofpadding==='number'){returnArray(padding+1).join('')+value}if(typeofpadding==='string'){returnpadding+value}thrownewError(`Expectedstringornumber,got'${padding}'.`)}```###instanceof```tsinterfacePadder{getPaddingString():string}classSpaceRepeatingPadderimplementsPadder{constructor(privatenumSpaces:number){}getPaddingString(){returnArray(this.numSpaces+1).join('')}}classStringPadderimplementsPadder{constructor(privatevalue:string){}getPaddingString(){returnthis.value}}letpadder:Padder=newSpaceRepeatingPadder(6)if(padderinstanceofSpaceRepeatingPadder){//padder的类型收窄为'SpaceRepeatingPadder'}```###自定义保护的类型谓词```tsfunctionisNumber(x:any):xisnumber{returntypeofx==='number'}functionisString(x:any):xisstring{returntypeofx==='string'}```##联合类型和类型别名####联合类型联合类型通常与`null`或`undefined`一起使用：```constsayHello=(name:string|undefined)=>{/*...*/};````name`的类型是`string|undefined`意味着可以将`string`或`undefined`的值传递给`sayHello`函数。```sayHello(\"semlinker\");sayHello(undefined);``````letnum:1|2=1;typeEventNames='click'|'scroll'|'mousemove';```####交叉类型>将多个类型合并成一个类型,通过&运算符```tstypePartialPointX={x:number}typePoint=PartialPointX&{y:number}letpoint:Point={x:1,y:1,}interfaceX{c:stringd:string}interfaceY{c:numbere:string}typeXY=X&YtypeYX=Y&Xletp:XYletq:YX//这样子c的类型是never```##函数###普通函数```tsfunctioncreateUserId(name:string,id:number):string{returnname+id}```###箭头函数```tsmyBooks.forEach(()=>console.log('reading'));myBooks.forEach(title=>console.log(title));myBooks.forEach((title,idx,arr)=>console.log(idx+'-'+title););myBooks.forEach((title,idx,arr)=>{console.log(idx+'-'+title);});```###可选参数以及默认参数```ts//可选参数functioncreateUserId(name:string,id:number,age?:number):string{returnname+id}//默认参数functioncreateUserId(name:string='semlinker',id:number,age?:number,):string{returnname+id}```###函数重载```tsfunctionadd(a:number,b:number):numberfunctionadd(a:string,b:string):stringfunctionadd(a:string,b:number):stringfunctionadd(a:number,b:string):stringfunctionadd(a:Combinable,b:Combinable){//typeCombinable=string|number;if(typeofa==='string'||typeofb==='string'){returna.toString()+b.toString()}returna+b}```##接口>作用:为这些类型命名和代码或第三方代码定义契约```typescriptfunctionprintLabel(labelledObj:{label:string}){console.log(labelledObj.label)}letmyObj={size:10,label:'Size10Object'}printLabel(myObj)``````typescriptinterfaceLavelledValue{label:string}functionprintLabel(lavelledObj:LabelledValue){console.log(lavelledObj.label)}letmyObj={size:10,label:'Size10Object'}printLabel(myObj)``````typescript//?表示可选属性interfaceSquareConfig{color?:stringwidth?:number}functioncreateSquare(config:SquareConfig):{color:string;area:numner}{letnewSquare={color:'white',area:100}if(config.color){newSquare.color=config.color}if(config.width){newSquare.width=config.width*config.width}}letmySquare=createSquare({color:'black'})``````typescript//readonly只读属性[只能在对象创建的时候修改其值]interfacePoint{redonlyx:number;readonlyy:number;}//ReadonlyArray<T>数组确保数组创建后不再修改leta:number[]=[1,2,3,4];letro:ReadonlyArray<numbers>=a;a=roasnumber[];//断言重写```####Extend>接口和类型别名都能够被拓展,但语法有所不同**Interfaceextendsinterface**```tsinterfacePartialPointX{x:number}interfacePointextendsPartialPointX{y:number}```**Typealiasextendstypealias**```tstypePartialPointX={x:number}typePoint=PartialPointX&{y:number}```**Interfaceextendstypealias**```tstypePartialPointX={x:number}interfacePointextendsPartialPointX{y:number}```**Typealiasextendsinterface**```tsinterfacePartialPointX{x:number}typePoint=PartialPointX&{y:number}```implements>类可以以相同方式实现**接口**或**类型别名**,但类不能实现使用类型别名定义的联合类型```tsinterfacePoint{x:numbery:number}classSomePointimplementsPoint{x=1y=2}typePoint2={x:numbery:number}classSomePoint2implementsPoint2{x=1y=2}typePartialPoint={x:number}|{y:number}//Aclasscanonlyimplementanobjecttypeor//intersectionofobjecttypeswithstaticallyknownmembers.classSomePartialPointimplementsPartialPoint{//Errorx=1y=2}```##类###属性和方法```tsclassGreeter{//静态属性staticcname:string='Greeter'//成员属性greeting:string//构造函数-执行初始化操作constructor(message:string){this.greeting=message}//静态方法staticgetClassName(){return'ClassnameisGreeter'}//成员方法greet(){return'Hello,'+this.greeting}}letgreeter=newGreeter('world')```编译成ES5代码```ts'usestrict'varGreeter=/**@class*/(function(){//构造函数-执行初始化操作functionGreeter(message){this.greeting=message}//静态方法Greeter.getClassName=function(){return'ClassnameisGreeter'}//成员方法Greeter.prototype.greet=function(){return'Hello,'+this.greeting}//静态属性Greeter.cname='Greeter'returnGreeter})()vargreeter=newGreeter('world')```###ECMAScript私有字段>-私有字段以`#`字符开头>-每个私有字段名称都唯一地限定器包含的类>-不能在私有字段使用ts可访问修饰符(public或private等)>-私有字段不能在包含的类之外访问,甚至不能被被检测到```tsclassPerson{#name:stringconstructor(name:string){this.#name=name}greet(){console.log(`Hello,mynameis${this.#name}!`)}}letsemlinker=newPerson('Semlinker')semlinker.#name//~~~~~//Property'#name'isnotaccessibleoutsideclass'Person'//becauseithasaprivateidentifier.```###访问器>通过getter和setter方法来实现数据的封装和有效性检验,防止出现异常数据```tsletpasscode='HelloTypeScript'classEmployee{private_fullName:stringgetfullName():string{returnthis._fullName}setfullName(newName:string){if(passcode&&passcode=='HelloTypeScript'){this._fullName=newName}else{console.log('Error:Unauthorizedupdateofemployee!')}}}letemployee=newEmployee()employee.fullName='Semlinker'if(employee.fullName){console.log(employee.fullName)}```###类的继承```tsclassAnimal{name:stringconstructor(theName:string){this.name=theName}move(distanceInMeters:number=0){console.log(`${this.name}moved${distanceInMeters}m.`)}}classSnakeextendsAnimal{constructor(name:string){super(name)//调用父类的构造函数}move(distanceInMeters=5){console.log('Slithering...')super.move(distanceInMeters)}}letsam=newSnake('SammythePython')sam.move()```###抽象类>`abstract`,>>包含一个或多个抽象方法(不包含具体实现的方法)```tsabstractclassPerson{constructor(publicname:string){}//抽象方法abstractsay(words:string):void}//Cannotcreateaninstanceofanabstractclass.(2511)constlolo=newPerson()//ErrorclassDeveloperextendsPerson{constructor(name:string){super(name)}say(words:string):void{console.log(`${this.name}says${words}`)}}constlolo=newDeveloper('lolo')lolo.say('Ilovets!')//lolosaysIlovets!```###类方法重载>函数和类的方法都支持重载```tsclassProductService{getProducts():voidgetProducts(id:number):voidgetProducts(id?:number){if(typeofid==='number'){console.log(`获取id为${id}的产品信息`)}else{console.log(`获取所有的产品信息`)}}}constproductService=newProductService()productService.getProducts(666)//获取id为666的产品信息productService.getProducts()//获取所有的产品信息```##泛型>-用来创建课重用的组件,一个组件可以支持多种类型的数据,用户可使用自己的数据类型来使用组件>-范类(Generics)是允许一个函数接受不同类型参数的一种模板```tsfunctionidentity<T,U>(value:T,message:U):T{console.log(message)returnvalue}console.log(identity<Number,string>(68,'Semlinker'))```###泛型工具类####typeof>获取一个变量声明或对象的类型```tsinterfacePerson{name:stringage:number}constsem:Person={name:'semlinker',age:33}typeSem=typeofsem//->PersonfunctiontoArray(x:number):Array<number>{return[x]}typeFunc=typeoftoArray//->(x:number)=>number[]```####keyof>获取某种类型的所有键,其返回值是联合类型```tsinterfacePerson{name:stringage:number}typeK1=keyofPerson//\"name\"|\"age\"typeK2=keyofPerson[]//\"length\"|\"toString\"|\"pop\"|\"push\"|\"concat\"|\"join\"typeK3=keyof{[x:string]:Person}//string|number``````tsinterfaceStringArray{//字符串索引->keyofStringArray=>string|number[index:string]:string}//使用数字索引时,js在执行索引操作时,会先把索引转换为字符串先interfaceStringArray1{//数字索引->keyofStringArray1=>number[index:number]:string}```####in>遍历枚举类型```tstypeKeys='a'|'b'|'c'typeObj={[pinKeys]:any}//->{a:any,b:any,c:any}```####infer>声明一个类型变量,并且对它进行使用```tstypeReturnType<T>=Textends(...args:any[])=>inferR?R:any//声明一个变量类继承传入函数签名的返回值类型//渠道函数的返回值,方便之后使用```####extends```tsinterfaceLengthwise{length:number}functionloggingIdentity<TextendsLengthwise>(arg:T):T{console.log(arg.length)returnarg}loggingIdentity(3)//Error,numberdoesn'thavea.lengthpropertyloggingIdentity({length:10,value:3})```####partial>将某个类型里的属性全部变成为课选项`?````ts/***定义*node_modules/typescript/lib/lib.es5.d.ts*MakeallpropertiesinToptional*/typePartial<T>={[PinkeyofT]?:T[P]}//通过keyofT拿到T所有属性名,然后通过in进行遍历,将值赋给P,最后通过T[P]取得相应的值,?使所有属性比那层可选属性```##装饰类>实验性功能>>-类装饰器(Classdecorators)>-属性装饰器(Propertydecorators)>-方法装饰器(Methoddecorators)>-参数装饰器(Parameterdecorators)##编译上下文####tsconfig.json的作用-用于标识TypeScript项目的根路径；-用于配置TypeScript编译器；-用于指定编译的文件。####tsconfig.json重要字段-files-设置要编译的文件的名称；-include-设置需要进行编译的文件，支持路径模式匹配；-exclude-设置无需进行编译的文件，支持路径模式匹配；-compilerOptions-设置与编译流程相关的选项。####compilerOptions选项compilerOptions支持很多选项，常见的有`baseUrl`、`target`、`baseUrl`、`moduleResolution`和`lib`等。compilerOptions每个选项的详细说明如下：`tsc--init//创建tsconfig.js文件````json{\"compilerOptions\":{/*基本选项*/\"target\":\"es5\",//指定ECMAScript目标版本:'ES3'(default),'ES5','ES6'/'ES2015','ES2016','ES2017',or'ESNEXT'\"module\":\"commonjs\",//指定使用模块:'commonjs','amd','system','umd'or'es2015'\"lib\":[],//指定要包含在编译中的库文件\"allowJs\":true,//允许编译javascript文件\"checkJs\":true,//报告javascript文件中的错误\"jsx\":\"preserve\",//指定jsx代码的生成:'preserve','react-native',or'react'\"declaration\":true,//生成相应的'.d.ts'文件\"sourceMap\":true,//生成相应的'.map'文件\"outFile\":\"./\",//将输出文件合并为一个文件\"outDir\":\"./\",//指定输出目录\"rootDir\":\"./\",//用来控制输出目录结构--outDir.\"removeComments\":true,//删除编译后的所有的注释\"noEmit\":true,//不生成输出文件\"importHelpers\":true,//从tslib导入辅助工具函数\"isolatedModules\":true,//将每个文件做为单独的模块（与'ts.transpileModule'类似）./*严格的类型检查选项*/\"strict\":true,//启用所有严格类型检查选项\"noImplicitAny\":true,//在表达式和声明上有隐含的any类型时报错\"strictNullChecks\":true,//启用严格的null检查\"noImplicitThis\":true,//当this表达式值为any类型的时候，生成一个错误\"alwaysStrict\":true,//以严格模式检查每个模块，并在每个文件里加入'usestrict'/*额外的检查*/\"noUnusedLocals\":true,//有未使用的变量时，抛出错误\"noUnusedParameters\":true,//有未使用的参数时，抛出错误\"noImplicitReturns\":true,//并不是所有函数里的代码都有返回值时，抛出错误\"noFallthroughCasesInSwitch\":true,//报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿）/*模块解析选项*/\"moduleResolution\":\"node\",//选择模块解析策略：'node'(Node.js)or'classic'(TypeScriptpre-1.6)\"baseUrl\":\"./\",//用于解析非相对模块名称的基目录\"paths\":{},//模块名到基于baseUrl的路径映射的列表\"rootDirs\":[],//根文件夹列表，其组合内容表示项目运行时的结构内容\"typeRoots\":[],//包含类型声明的文件列表\"types\":[],//需要包含的类型声明文件名列表\"allowSyntheticDefaultImports\":true,//允许从没有设置默认导出的模块中默认导入。/*SourceMapOptions*/\"sourceRoot\":\"./\",//指定调试器应该找到TypeScript文件而不是源文件的位置\"mapRoot\":\"./\",//指定调试器应该找到映射文件而不是生成文件的位置\"inlineSourceMap\":true,//生成单个soucemaps文件，而不是将sourcemaps生成不同的文件\"inlineSources\":true,//将代码与sourcemaps生成到一个文件中，要求同时设置了--inlineSourceMap或--sourceMap属性/*其他选项*/\"experimentalDecorators\":true,//启用装饰器\"emitDecoratorMetadata\":true//为装饰器提供元数据的支持}}```开发辅助工具[jsontots](http://www.jsontots.com/):指定json数据生成对应的typescript[Schemats](https://github.com/SweetIQ/schemats):基于sql数据库中的schema自动生成typescript接口定义[TypeScriptASTViewer](https://ts-ast-viewer.com/):在线工具,查看指定ts代码对应的ast抽象数[TypeDoc](https://typedoc.org/):将TypeScript源代码中的注释转换为HTML文档或JSON模型[TypeScriptESLint](https://typescript-eslint.io/):规范代码质量，提高团队开发效率。","JavaScript\\TypeScript\\三斜线指令.md":"#三斜线指令>三斜线指令是包含单个XML标签的单行注释。注释的内容会做为编译器指令使用。>>三斜线指令仅可放在包含它的文件的最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。##`///<referencepath=\"...\"/>`>`///<referencepath=\"...\"/>`指令是三斜线指令中最常见的一种。它用于声明文件间的依赖。>>三斜线引用告诉编译器在编译过程中要引入的额外的文件。>>当使用--out或--outFile时，它也可以做为调整输出内容顺序的一种方法。文件在输出文件内容中的位置与经过预处理后的输入顺序一致。##预处理输入文件>编译器会对输入文件进行预处理来解析所有三斜线引用指令。在这个过程中，额外的文件会加到编译过程中。>>这个过程会以一些根文件开始；它们是在命令行中指定的文件或是在`tsconfig.json`中的`\"files\"`列表里的文件。这些根文件按指定的顺序进行预处理。在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。>>一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。###错误>引用不存在的文件会报错。一个文件用三斜线指令引用自己会报错。###使用--noResolve>如果指定了--noResolve编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。##`///<referencetypes=\"...\"/>`>与`///<referencepath=\"...\"/>`指令相似，这个指令是用来声明依赖的；一个`///<referencepath=\"...\"/>`指令声明了对@types包的一个依赖。>>在声明文件里包含`///<referencetypes=\"node\"/>`，表明这个文件使用了`@types/node/index.d.ts`里面声明的名字；并且，这个包要在编译阶段与声明文件一起被包含进来。>>解析`@types`包的名字的过程与解析import语句里模块名的过程类似。所以可以简单的把三斜线类型引用指令想像成针对包的import声明。>>仅当在你需要写一个`d.ts`文件时才使用这个指令。>>对于那些在编译阶段生成的声明文件，编译器会自动地添加`///<referencetypes=\"...\"/>`；当且仅当结果文件中使用了引用的@types包里的声明时才会在生成的声明文件里添加`///<referencetypes=\"...\"/>`语句>>若要在`.ts`文件里声明一个对@types包的依赖，使用`--types`命令行选项或在`tsconfig.json`里指定。查看在`tsconfig.json`里使用`@types`，`typeRoots`和`types`了解详情。###`///<referenceno-default-lib=\"true\"/>`>这个指令把一个文件标记成默认库。你会在`lib.d.ts`文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中不要包含这个默认库（比如，lib.d.ts）。这与在命令行上使用--noLib相似。还要注意，当传递了--skipDefaultLibCheck时，编译器只会忽略检查带有`///<referenceno-default-lib=\"true\"/>`的文件。##`///<amd-module/>`>默认情况下生成的AMD模块都是匿名的。但是，当一些工具需要处理生成的模块时会产生问题，比如r.js。amd-module指令允许给编译器传入一个可选的模块名：###`///<amd-modulename='NamedModule'/>````tsexportclassC{}```这会将NamedModule传入到AMDdefine函数里：```ts//amdModule.jsdefine('NamedModule',['require','exports'],function(require,exports){varC=(function(){functionC(){}returnC})()exports.C=C})```##`///<amd-dependency/>`>注意：这个指令被废弃了。使用import\"moduleName\";语句代替。`///<amd-dependencypath=\"x\"/>`告诉编译器有一个非TypeScript模块依赖需要被注入，做为目标模块require调用的一部分。`amd-dependency`指令也可以带一个可选的name属性；它允许我们为amd-dependency传入一个可选名字：###`///<amd-dependencypath=\"legacy/moduleA\"name=\"moduleA\"/>````tsdeclarevarmoduleA:MyTypemoduleA.callStuff()生成的JavaScript代码：define([\"require\",\"exports\",\"legacy/moduleA\"],function(require,exports,moduleA){moduleA.callStuff()});```","JavaScript\\TypeScript\\内置API\\ECMAScript.md":"#ECMAScriptAPIs>lib.es5.d.ts文件分析##特殊###NaN```tsdeclarevarNaN:number/***ReturnsaBooleanvaluethatindicateswhetheravalueisthereservedvalueNaN(notanumber).*@paramnumberAnumericvalue.*/declarefunctionisNaN(number:number):boolean```###未分类```tsdeclarevarInfinity:numberinterfaceSymbol{/**Returnsastringrepresentationofanobject.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():symbol}```##Number```ts/***Convertsastringtoaninteger.*@paramstringAstringtoconvertintoanumber.*@paramradixAvaluebetween2and36thatspecifiesthebaseofthenumberin`string`.*Ifthisargumentisnotsupplied,stringswithaprefixof'0x'areconsideredhexadecimal.*Allotherstringsareconsidereddecimal.*/declarefunctionparseInt(string:string,radix?:number):number/***Convertsastringtoafloating-pointnumber.*@paramstringAstringthatcontainsafloating-pointnumber.*/declarefunctionparseFloat(string:string):number/***Determineswhetherasuppliednumberisfinite.*@paramnumberAnynumericvalue.*/declarefunctionisFinite(number:number):booleaninterfaceNumber{/***Returnsastringrepresentationofanobject.*@paramradixSpecifiesaradixforconvertingnumericvaluestostrings.Thisvalueisonlyusedfornumbers.*/toString(radix?:number):string/***Returnsastringrepresentinganumberinfixed-pointnotation.*@paramfractionDigitsNumberofdigitsafterthedecimalpoint.Mustbeintherange0-20,inclusive.*/toFixed(fractionDigits?:number):string/***Returnsastringcontaininganumberrepresentedinexponentialnotation.*@paramfractionDigitsNumberofdigitsafterthedecimalpoint.Mustbeintherange0-20,inclusive.*/toExponential(fractionDigits?:number):string/***Returnsastringcontaininganumberrepresentedeitherinexponentialorfixed-pointnotationwithaspecifiednumberofdigits.*@paramprecisionNumberofsignificantdigits.Mustbeintherange1-21,inclusive.*/toPrecision(precision?:number):string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():number}interfaceNumberConstructor{new(value?:any):Number(value?:any):numberreadonlyprototype:Number/**ThelargestnumberthatcanberepresentedinJavaScript.Equaltoapproximately1.79E+308.*/readonlyMAX_VALUE:number/**TheclosestnumbertozerothatcanberepresentedinJavaScript.Equaltoapproximately5.00E-324.*/readonlyMIN_VALUE:number/***Avaluethatisnotanumber.*Inequalitycomparisons,NaNdoesnotequalanyvalue,includingitself.TotestwhetheravalueisequivalenttoNaN,usetheisNaNfunction.*/readonlyNaN:number/***AvaluethatislessthanthelargestnegativenumberthatcanberepresentedinJavaScript.*JavaScriptdisplaysNEGATIVE_INFINITYvaluesas-infinity.*/readonlyNEGATIVE_INFINITY:number/***AvaluegreaterthanthelargestnumberthatcanberepresentedinJavaScript.*JavaScriptdisplaysPOSITIVE_INFINITYvaluesasinfinity.*/readonlyPOSITIVE_INFINITY:number}/**Anobjectthatrepresentsanumberofanykind.AllJavaScriptnumbersare64-bitfloating-pointnumbers.*/declarevarNumber:NumberConstructor```##String```ts/***Computesanewstringinwhichcertaincharactershavebeenreplacedbyahexadecimalescapesequence.*@deprecatedAlegacyfeatureforbrowsercompatibility*@paramstringAstringvalue*/declarefunctionescape(string:string):string/***Computesanewstringinwhichhexadecimalescapesequencesarereplacedwiththecharacterthatitrepresents.*@deprecatedAlegacyfeatureforbrowsercompatibility*@paramstringAstringvalue*/declarefunctionunescape(string:string):stringinterfaceString{/**Returnsastringrepresentationofastring.*/toString():string/***Returnsthecharacteratthespecifiedindex.*@paramposThezero-basedindexofthedesiredcharacter.*/charAt(pos:number):string/***ReturnstheUnicodevalueofthecharacteratthespecifiedlocation.*@paramindexThezero-basedindexofthedesiredcharacter.Ifthereisnocharacteratthespecifiedindex,NaNisreturned.*/charCodeAt(index:number):number/***Returnsastringthatcontainstheconcatenationoftwoormorestrings.*@paramstringsThestringstoappendtotheendofthestring.*/concat(...strings:string[]):string/***Returnsthepositionofthefirstoccurrenceofasubstring.*@paramsearchStringThesubstringtosearchforinthestring*@parampositionTheindexatwhichtobeginsearchingtheStringobject.Ifomitted,searchstartsatthebeginningofthestring.*/indexOf(searchString:string,position?:number):number/***Returnsthelastoccurrenceofasubstringinthestring.*@paramsearchStringThesubstringtosearchfor.*@parampositionTheindexatwhichtobeginsearching.Ifomitted,thesearchbeginsattheendofthestring.*/lastIndexOf(searchString:string,position?:number):number/***Determineswhethertwostringsareequivalentinthecurrentlocale.*@paramthatStringtocomparetotargetstring*/localeCompare(that:string):number/***Matchesastringwitharegularexpression,andreturnsanarraycontainingtheresultsofthatsearch.*@paramregexpAvariablenameorstringliteralcontainingtheregularexpressionpatternandflags.*/match(regexp:string|RegExp):RegExpMatchArray|null/***Replacestextinastring,usingaregularexpressionorsearchstring.*@paramsearchValueAstringtosearchfor.*@paramreplaceValueAstringcontainingthetexttoreplaceforeverysuccessfulmatchofsearchValueinthisstring.*/replace(searchValue:string|RegExp,replaceValue:string):string/***Replacestextinastring,usingaregularexpressionorsearchstring.*@paramsearchValueAstringtosearchfor.*@paramreplacerAfunctionthatreturnsthereplacementtext.*/replace(searchValue:string|RegExp,replacer:(substring:string,...args:any[])=>string,):string/***Findsthefirstsubstringmatchinaregularexpressionsearch.*@paramregexpTheregularexpressionpatternandapplicableflags.*/search(regexp:string|RegExp):number/***Returnsasectionofastring.*@paramstartTheindextothebeginningofthespecifiedportionofstringObj.*@paramendTheindextotheendofthespecifiedportionofstringObj.Thesubstringincludesthecharactersupto,butnotincluding,thecharacterindicatedbyend.*Ifthisvalueisnotspecified,thesubstringcontinuestotheendofstringObj.*/slice(start?:number,end?:number):string/***Splitastringintosubstringsusingthespecifiedseparatorandreturnthemasanarray.*@paramseparatorAstringthatidentifiescharacterorcharacterstouseinseparatingthestring.Ifomitted,asingle-elementarraycontainingtheentirestringisreturned.*@paramlimitAvalueusedtolimitthenumberofelementsreturnedinthearray.*/split(separator:string|RegExp,limit?:number):string[]/***ReturnsthesubstringatthespecifiedlocationwithinaStringobject.*@paramstartThezero-basedindexnumberindicatingthebeginningofthesubstring.*@paramendZero-basedindexnumberindicatingtheendofthesubstring.Thesubstringincludesthecharactersupto,butnotincluding,thecharacterindicatedbyend.*Ifendisomitted,thecharactersfromstartthroughtheendoftheoriginalstringarereturned.*/substring(start:number,end?:number):string/**Convertsallthealphabeticcharactersinastringtolowercase.*/toLowerCase():string/**Convertsallalphabeticcharacterstolowercase,takingintoaccountthehostenvironment'scurrentlocale.*/toLocaleLowerCase(locales?:string|string[]):string/**Convertsallthealphabeticcharactersinastringtouppercase.*/toUpperCase():string/**Returnsastringwhereallalphabeticcharactershavebeenconvertedtouppercase,takingintoaccountthehostenvironment'scurrentlocale.*/toLocaleUpperCase(locales?:string|string[]):string/**Removestheleadingandtrailingwhitespaceandlineterminatorcharactersfromastring.*/trim():string/**ReturnsthelengthofaStringobject.*/readonlylength:number//IEextensions/***Getsasubstringbeginningatthespecifiedlocationandhavingthespecifiedlength.*@deprecatedAlegacyfeatureforbrowsercompatibility*@paramfromThestartingpositionofthedesiredsubstring.Theindexofthefirstcharacterinthestringiszero.*@paramlengthThenumberofcharacterstoincludeinthereturnedsubstring.*/substr(from:number,length?:number):string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():stringreadonly[index:number]:string}interfaceStringConstructor{new(value?:any):String(value?:any):stringreadonlyprototype:StringfromCharCode(...codes:number[]):string}/***Allowsmanipulationandformattingoftextstringsanddeterminationandlocationofsubstringswithinstrings.*/declarevarString:StringConstructor```##Property>状态```tsdeclaretypePropertyKey=string|number|symbolinterfacePropertyDescriptor{configurable?:booleanenumerable?:booleanvalue?:anywritable?:booleanget?():anyset?(v:any):void}interfacePropertyDescriptorMap{[key:PropertyKey]:PropertyDescriptor}```##Object```tsinterfaceObject{/**TheinitialvalueofObject.prototype.constructoristhestandardbuilt-inObjectconstructor.*/constructor:Function/**Returnsastringrepresentationofanobject.*/toString():string/**Returnsadateconvertedtoastringusingthecurrentlocale.*/toLocaleString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Object/***Determineswhetheranobjecthasapropertywiththespecifiedname.*@paramvApropertyname.*/hasOwnProperty(v:PropertyKey):boolean/***Determineswhetheranobjectexistsinanotherobject'sprototypechain.*@paramvAnotherobjectwhoseprototypechainistobechecked.*/isPrototypeOf(v:Object):boolean/***Determineswhetheraspecifiedpropertyisenumerable.*@paramvApropertyname.*/propertyIsEnumerable(v:PropertyKey):boolean}interfaceObjectConstructor{new(value?:any):Object():any(value:any):any/**Areferencetotheprototypeforaclassofobjects.*/readonlyprototype:Object/***Returnstheprototypeofanobject.*@paramoTheobjectthatreferencestheprototype.*/getPrototypeOf(o:any):any/***Getstheownpropertydescriptorofthespecifiedobject.*Anownpropertydescriptorisonethatisdefineddirectlyontheobjectandisnotinheritedfromtheobject'sprototype.*@paramoObjectthatcontainstheproperty.*@parampNameoftheproperty.*/getOwnPropertyDescriptor(o:any,p:PropertyKey,):PropertyDescriptor|undefined/***Returnsthenamesoftheownpropertiesofanobject.Theownpropertiesofanobjectarethosethataredefineddirectly*onthatobject,andarenotinheritedfromtheobject'sprototype.Thepropertiesofanobjectincludebothfields(objects)andfunctions.*@paramoObjectthatcontainstheownproperties.*/getOwnPropertyNames(o:any):string[]/***Createsanobjectthathasthespecifiedprototypeorthathasnullprototype.*@paramoObjecttouseasaprototype.Maybenull.*/create(o:object|null):any/***Createsanobjectthathasthespecifiedprototype,andthatoptionallycontainsspecifiedproperties.*@paramoObjecttouseasaprototype.Maybenull*@parampropertiesJavaScriptobjectthatcontainsoneormorepropertydescriptors.*/create(o:object|null,properties:PropertyDescriptorMap&ThisType<any>,):any/***Addsapropertytoanobject,ormodifiesattributesofanexistingproperty.*@paramoObjectonwhichtoaddormodifytheproperty.ThiscanbeanativeJavaScriptobject(thatis,auser-definedobjectorabuiltinobject)oraDOMobject.*@parampThepropertyname.*@paramattributesDescriptorfortheproperty.Itcanbeforadatapropertyoranaccessorproperty.*/defineProperty<T>(o:T,p:PropertyKey,attributes:PropertyDescriptor&ThisType<any>,):T/***Addsoneormorepropertiestoanobject,and/ormodifiesattributesofexistingproperties.*@paramoObjectonwhichtoaddormodifytheproperties.ThiscanbeanativeJavaScriptobjectoraDOMobject.*@parampropertiesJavaScriptobjectthatcontainsoneormoredescriptorobjects.Eachdescriptorobjectdescribesadatapropertyoranaccessorproperty.*/defineProperties<T>(o:T,properties:PropertyDescriptorMap&ThisType<any>,):T/***Preventsthemodificationofattributesofexistingproperties,andpreventstheadditionofnewproperties.*@paramoObjectonwhichtolocktheattributes.*/seal<T>(o:T):T/***Preventsthemodificationofexistingpropertyattributesandvalues,andpreventstheadditionofnewproperties.*@paramaObjectonwhichtolocktheattributes.*/freeze<T>(a:T[]):readonlyT[]/***Preventsthemodificationofexistingpropertyattributesandvalues,andpreventstheadditionofnewproperties.*@paramfObjectonwhichtolocktheattributes.*/freeze<TextendsFunction>(f:T):T/***Preventsthemodificationofexistingpropertyattributesandvalues,andpreventstheadditionofnewproperties.*@paramoObjectonwhichtolocktheattributes.*/freeze<T>(o:T):Readonly<T>/***Preventstheadditionofnewpropertiestoanobject.*@paramoObjecttomakenon-extensible.*/preventExtensions<T>(o:T):T/***Returnstrueifexistingpropertyattributescannotbemodifiedinanobjectandnewpropertiescannotbeaddedtotheobject.*@paramoObjecttotest.*/isSealed(o:any):boolean/***Returnstrueifexistingpropertyattributesandvaluescannotbemodifiedinanobject,andnewpropertiescannotbeaddedtotheobject.*@paramoObjecttotest.*/isFrozen(o:any):boolean/***Returnsavaluethatindicateswhethernewpropertiescanbeaddedtoanobject.*@paramoObjecttotest.*/isExtensible(o:any):boolean/***Returnsthenamesoftheenumerablestringpropertiesandmethodsofanobject.*@paramoObjectthatcontainsthepropertiesandmethods.ThiscanbeanobjectthatyoucreatedoranexistingDocumentObjectModel(DOM)object.*/keys(o:object):string[]}/***ProvidesfunctionalitycommontoallJavaScriptobjects.*/declarevarObject:ObjectConstructor```##Function```tsinterfaceFunction{/***Callsthefunction,substitutingthespecifiedobjectforthethisvalueofthefunction,andthespecifiedarrayfortheargumentsofthefunction.*@paramthisArgTheobjecttobeusedasthethisobject.*@paramargArrayAsetofargumentstobepassedtothefunction.*/apply(this:Function,thisArg:any,argArray?:any):any/***Callsamethodofanobject,substitutinganotherobjectforthecurrentobject.*@paramthisArgTheobjecttobeusedasthecurrentobject.*@paramargArrayAlistofargumentstobepassedtothemethod.*/call(this:Function,thisArg:any,...argArray:any[]):any/***Foragivenfunction,createsaboundfunctionthathasthesamebodyastheoriginalfunction.*Thethisobjectoftheboundfunctionisassociatedwiththespecifiedobject,andhasthespecifiedinitialparameters.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinsidethenewfunction.*@paramargArrayAlistofargumentstobepassedtothenewfunction.*/bind(this:Function,thisArg:any,...argArray:any[]):any/**Returnsastringrepresentationofafunction.*/toString():stringprototype:anyreadonlylength:number//Non-standardextensionsarguments:anycaller:Function}interfaceFunctionConstructor{/***Createsanewfunction.*@paramargsAlistofargumentsthefunctionaccepts.*/new(...args:string[]):Function(...args:string[]):Functionreadonlyprototype:Function}declarevarFunction:FunctionConstructor/***Extractsthetypeofthe'this'parameterofafunctiontype,or'unknown'ifthefunctiontypehasno'this'parameter.*/typeThisParameterType<T>=Textends(this:inferU,...args:never)=>any?U:unknown/***Removesthe'this'parameterfromafunctiontype.*/typeOmitThisParameter<T>=unknownextendsThisParameterType<T>?T:Textends(...args:inferA)=>inferR?(...args:A)=>R:TinterfaceCallableFunctionextendsFunction{/***Callsthefunctionwiththespecifiedobjectasthethisvalueandtheelementsofspecifiedarrayasthearguments.*@paramthisArgTheobjecttobeusedasthethisobject.*@paramargsAnarrayofargumentvaluestobepassedtothefunction.*/apply<T,R>(this:(this:T)=>R,thisArg:T):Rapply<T,Aextendsany[],R>(this:(this:T,...args:A)=>R,thisArg:T,args:A,):R/***Callsthefunctionwiththespecifiedobjectasthethisvalueandthespecifiedrestargumentsasthearguments.*@paramthisArgTheobjecttobeusedasthethisobject.*@paramargsArgumentvaluestobepassedtothefunction.*/call<T,Aextendsany[],R>(this:(this:T,...args:A)=>R,thisArg:T,...args:A):R/***Foragivenfunction,createsaboundfunctionthathasthesamebodyastheoriginalfunction.*Thethisobjectoftheboundfunctionisassociatedwiththespecifiedobject,andhasthespecifiedinitialparameters.*@paramthisArgTheobjecttobeusedasthethisobject.*@paramargsArgumentstobindtotheparametersofthefunction.*/bind<T>(this:T,thisArg:ThisParameterType<T>):OmitThisParameter<T>bind<T,A0,Aextendsany[],R>(this:(this:T,arg0:A0,...args:A)=>R,thisArg:T,arg0:A0,):(...args:A)=>Rbind<T,A0,A1,Aextendsany[],R>(this:(this:T,arg0:A0,arg1:A1,...args:A)=>R,thisArg:T,arg0:A0,arg1:A1,):(...args:A)=>Rbind<T,A0,A1,A2,Aextendsany[],R>(this:(this:T,arg0:A0,arg1:A1,arg2:A2,...args:A)=>R,thisArg:T,arg0:A0,arg1:A1,arg2:A2,):(...args:A)=>Rbind<T,A0,A1,A2,A3,Aextendsany[],R>(this:(this:T,arg0:A0,arg1:A1,arg2:A2,arg3:A3,...args:A)=>R,thisArg:T,arg0:A0,arg1:A1,arg2:A2,arg3:A3,):(...args:A)=>Rbind<T,AX,R>(this:(this:T,...args:AX[])=>R,thisArg:T,...args:AX[]):(...args:AX[])=>R}interfaceNewableFunctionextendsFunction{/***Callsthefunctionwiththespecifiedobjectasthethisvalueandtheelementsofspecifiedarrayasthearguments.*@paramthisArgTheobjecttobeusedasthethisobject.*@paramargsAnarrayofargumentvaluestobepassedtothefunction.*/apply<T>(this:new()=>T,thisArg:T):voidapply<T,Aextendsany[]>(this:new(...args:A)=>T,thisArg:T,args:A,):void/***Callsthefunctionwiththespecifiedobjectasthethisvalueandthespecifiedrestargumentsasthearguments.*@paramthisArgTheobjecttobeusedasthethisobject.*@paramargsArgumentvaluestobepassedtothefunction.*/call<T,Aextendsany[]>(this:new(...args:A)=>T,thisArg:T,...args:A):void/***Foragivenfunction,createsaboundfunctionthathasthesamebodyastheoriginalfunction.*Thethisobjectoftheboundfunctionisassociatedwiththespecifiedobject,andhasthespecifiedinitialparameters.*@paramthisArgTheobjecttobeusedasthethisobject.*@paramargsArgumentstobindtotheparametersofthefunction.*/bind<T>(this:T,thisArg:any):Tbind<A0,Aextendsany[],R>(this:new(arg0:A0,...args:A)=>R,thisArg:any,arg0:A0,):new(...args:A)=>Rbind<A0,A1,Aextendsany[],R>(this:new(arg0:A0,arg1:A1,...args:A)=>R,thisArg:any,arg0:A0,arg1:A1,):new(...args:A)=>Rbind<A0,A1,A2,Aextendsany[],R>(this:new(arg0:A0,arg1:A1,arg2:A2,...args:A)=>R,thisArg:any,arg0:A0,arg1:A1,arg2:A2,):new(...args:A)=>Rbind<A0,A1,A2,A3,Aextendsany[],R>(this:new(arg0:A0,arg1:A1,arg2:A2,arg3:A3,...args:A)=>R,thisArg:any,arg0:A0,arg1:A1,arg2:A2,arg3:A3,):new(...args:A)=>Rbind<AX,R>(this:new(...args:AX[])=>R,thisArg:any,...args:AX[]):new(...args:AX[])=>R}interfaceIArguments{[index:number]:anylength:numbercallee:Function}```##decodeURI```ts/***GetstheunencodedversionofanencodedUniformResourceIdentifier(URI).*@paramencodedURIAvaluerepresentinganencodedURI.*/declarefunctiondecodeURI(encodedURI:string):string/***GetstheunencodedversionofanencodedcomponentofaUniformResourceIdentifier(URI).*@paramencodedURIComponentAvaluerepresentinganencodedURIcomponent.*/declarefunctiondecodeURIComponent(encodedURIComponent:string):string/***EncodesatextstringasavalidUniformResourceIdentifier(URI)*@paramuriAvaluerepresentinganencodedURI.*/declarefunctionencodeURI(uri:string):string/***EncodesatextstringasavalidcomponentofaUniformResourceIdentifier(URI).*@paramuriComponentAvaluerepresentinganencodedURIcomponent.*/declarefunctionencodeURIComponent(uriComponent:string|number|boolean,):string```##方法```ts/***EvaluatesJavaScriptcodeandexecutesit.*@paramxAStringvaluethatcontainsvalidJavaScriptcode.*/declarefunctioneval(x:string):any```##Match```tsinterfaceMath{/**Themathematicalconstante.ThisisEuler'snumber,thebaseofnaturallogarithms.*/readonlyE:number/**Thenaturallogarithmof10.*/readonlyLN10:number/**Thenaturallogarithmof2.*/readonlyLN2:number/**Thebase-2logarithmofe.*/readonlyLOG2E:number/**Thebase-10logarithmofe.*/readonlyLOG10E:number/**Pi.Thisistheratioofthecircumferenceofacircletoitsdiameter.*/readonlyPI:number/**Thesquarerootof0.5,or,equivalently,onedividedbythesquarerootof2.*/readonlySQRT1_2:number/**Thesquarerootof2.*/readonlySQRT2:number/***Returnstheabsolutevalueofanumber(thevaluewithoutregardtowhetheritispositiveornegative).*Forexample,theabsolutevalueof-5isthesameastheabsolutevalueof5.*@paramxAnumericexpressionforwhichtheabsolutevalueisneeded.*/abs(x:number):number/***Returnsthearccosine(orinversecosine)ofanumber.*@paramxAnumericexpression.*/acos(x:number):number/***Returnsthearcsineofanumber.*@paramxAnumericexpression.*/asin(x:number):number/***Returnsthearctangentofanumber.*@paramxAnumericexpressionforwhichthearctangentisneeded.*/atan(x:number):number/***Returnstheangle(inradians)fromtheXaxistoapoint.*@paramyAnumericexpressionrepresentingthecartesiany-coordinate.*@paramxAnumericexpressionrepresentingthecartesianx-coordinate.*/atan2(y:number,x:number):number/***Returnsthesmallestintegergreaterthanorequaltoitsnumericargument.*@paramxAnumericexpression.*/ceil(x:number):number/***Returnsthecosineofanumber.*@paramxAnumericexpressionthatcontainsananglemeasuredinradians.*/cos(x:number):number/***Returnse(thebaseofnaturallogarithms)raisedtoapower.*@paramxAnumericexpressionrepresentingthepowerofe.*/exp(x:number):number/***Returnsthegreatestintegerlessthanorequaltoitsnumericargument.*@paramxAnumericexpression.*/floor(x:number):number/***Returnsthenaturallogarithm(basee)ofanumber.*@paramxAnumericexpression.*/log(x:number):number/***Returnsthelargerofasetofsuppliednumericexpressions.*@paramvaluesNumericexpressionstobeevaluated.*/max(...values:number[]):number/***Returnsthesmallerofasetofsuppliednumericexpressions.*@paramvaluesNumericexpressionstobeevaluated.*/min(...values:number[]):number/***Returnsthevalueofabaseexpressiontakentoaspecifiedpower.*@paramxThebasevalueoftheexpression.*@paramyTheexponentvalueoftheexpression.*/pow(x:number,y:number):number/**Returnsapseudorandomnumberbetween0and1.*/random():number/***Returnsasuppliednumericexpressionroundedtothenearestinteger.*@paramxThevaluetoberoundedtothenearestinteger.*/round(x:number):number/***Returnsthesineofanumber.*@paramxAnumericexpressionthatcontainsananglemeasuredinradians.*/sin(x:number):number/***Returnsthesquarerootofanumber.*@paramxAnumericexpression.*/sqrt(x:number):number/***Returnsthetangentofanumber.*@paramxAnumericexpressionthatcontainsananglemeasuredinradians.*/tan(x:number):number}/**Anintrinsicobjectthatprovidesbasicmathematicsfunctionalityandconstants.*/declarevarMath:Math```##Boolean```tsinterfaceBoolean{/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():boolean}interfaceBooleanConstructor{new(value?:any):Boolean<T>(value?:T):booleanreadonlyprototype:Boolean}declarevarBoolean:BooleanConstructor```##Date```ts/**Enablesbasicstorageandretrievalofdatesandtimes.*/interfaceDate{/**Returnsastringrepresentationofadate.Theformatofthestringdependsonthelocale.*/toString():string/**Returnsadateasastringvalue.*/toDateString():string/**Returnsatimeasastringvalue.*/toTimeString():string/**Returnsavalueasastringvalueappropriatetothehostenvironment'scurrentlocale.*/toLocaleString():string/**Returnsadateasastringvalueappropriatetothehostenvironment'scurrentlocale.*/toLocaleDateString():string/**Returnsatimeasastringvalueappropriatetothehostenvironment'scurrentlocale.*/toLocaleTimeString():string/**Returnsthestoredtimevalueinmillisecondssincemidnight,January1,1970UTC.*/valueOf():number/**Getsthetimevalueinmilliseconds.*/getTime():number/**Getstheyear,usinglocaltime.*/getFullYear():number/**GetstheyearusingUniversalCoordinatedTime(UTC).*/getUTCFullYear():number/**Getsthemonth,usinglocaltime.*/getMonth():number/**GetsthemonthofaDateobjectusingUniversalCoordinatedTime(UTC).*/getUTCMonth():number/**Getstheday-of-the-month,usinglocaltime.*/getDate():number/**Getstheday-of-the-month,usingUniversalCoordinatedTime(UTC).*/getUTCDate():number/**Getsthedayoftheweek,usinglocaltime.*/getDay():number/**GetsthedayoftheweekusingUniversalCoordinatedTime(UTC).*/getUTCDay():number/**Getsthehoursinadate,usinglocaltime.*/getHours():number/**GetsthehoursvalueinaDateobjectusingUniversalCoordinatedTime(UTC).*/getUTCHours():number/**GetstheminutesofaDateobject,usinglocaltime.*/getMinutes():number/**GetstheminutesofaDateobjectusingUniversalCoordinatedTime(UTC).*/getUTCMinutes():number/**GetsthesecondsofaDateobject,usinglocaltime.*/getSeconds():number/**GetsthesecondsofaDateobjectusingUniversalCoordinatedTime(UTC).*/getUTCSeconds():number/**GetsthemillisecondsofaDate,usinglocaltime.*/getMilliseconds():number/**GetsthemillisecondsofaDateobjectusingUniversalCoordinatedTime(UTC).*/getUTCMilliseconds():number/**GetsthedifferenceinminutesbetweenthetimeonthelocalcomputerandUniversalCoordinatedTime(UTC).*/getTimezoneOffset():number/***SetsthedateandtimevalueintheDateobject.*@paramtimeAnumericvaluerepresentingthenumberofelapsedmillisecondssincemidnight,January1,1970GMT.*/setTime(time:number):number/***SetsthemillisecondsvalueintheDateobjectusinglocaltime.*@parammsAnumericvalueequaltothemillisecondvalue.*/setMilliseconds(ms:number):number/***SetsthemillisecondsvalueintheDateobjectusingUniversalCoordinatedTime(UTC).*@parammsAnumericvalueequaltothemillisecondvalue.*/setUTCMilliseconds(ms:number):number/***SetsthesecondsvalueintheDateobjectusinglocaltime.*@paramsecAnumericvalueequaltothesecondsvalue.*@parammsAnumericvalueequaltothemillisecondsvalue.*/setSeconds(sec:number,ms?:number):number/***SetsthesecondsvalueintheDateobjectusingUniversalCoordinatedTime(UTC).*@paramsecAnumericvalueequaltothesecondsvalue.*@parammsAnumericvalueequaltothemillisecondsvalue.*/setUTCSeconds(sec:number,ms?:number):number/***SetstheminutesvalueintheDateobjectusinglocaltime.*@paramminAnumericvalueequaltotheminutesvalue.*@paramsecAnumericvalueequaltothesecondsvalue.*@parammsAnumericvalueequaltothemillisecondsvalue.*/setMinutes(min:number,sec?:number,ms?:number):number/***SetstheminutesvalueintheDateobjectusingUniversalCoordinatedTime(UTC).*@paramminAnumericvalueequaltotheminutesvalue.*@paramsecAnumericvalueequaltothesecondsvalue.*@parammsAnumericvalueequaltothemillisecondsvalue.*/setUTCMinutes(min:number,sec?:number,ms?:number):number/***SetsthehourvalueintheDateobjectusinglocaltime.*@paramhoursAnumericvalueequaltothehoursvalue.*@paramminAnumericvalueequaltotheminutesvalue.*@paramsecAnumericvalueequaltothesecondsvalue.*@parammsAnumericvalueequaltothemillisecondsvalue.*/setHours(hours:number,min?:number,sec?:number,ms?:number):number/***SetsthehoursvalueintheDateobjectusingUniversalCoordinatedTime(UTC).*@paramhoursAnumericvalueequaltothehoursvalue.*@paramminAnumericvalueequaltotheminutesvalue.*@paramsecAnumericvalueequaltothesecondsvalue.*@parammsAnumericvalueequaltothemillisecondsvalue.*/setUTCHours(hours:number,min?:number,sec?:number,ms?:number):number/***Setsthenumericday-of-the-monthvalueoftheDateobjectusinglocaltime.*@paramdateAnumericvalueequaltothedayofthemonth.*/setDate(date:number):number/***SetsthenumericdayofthemonthintheDateobjectusingUniversalCoordinatedTime(UTC).*@paramdateAnumericvalueequaltothedayofthemonth.*/setUTCDate(date:number):number/***SetsthemonthvalueintheDateobjectusinglocaltime.*@parammonthAnumericvalueequaltothemonth.ThevalueforJanuaryis0,andothermonthvaluesfollowconsecutively.*@paramdateAnumericvaluerepresentingthedayofthemonth.Ifthisvalueisnotsupplied,thevaluefromacalltothegetDatemethodisused.*/setMonth(month:number,date?:number):number/***SetsthemonthvalueintheDateobjectusingUniversalCoordinatedTime(UTC).*@parammonthAnumericvalueequaltothemonth.ThevalueforJanuaryis0,andothermonthvaluesfollowconsecutively.*@paramdateAnumericvaluerepresentingthedayofthemonth.Ifitisnotsupplied,thevaluefromacalltothegetUTCDatemethodisused.*/setUTCMonth(month:number,date?:number):number/***SetstheyearoftheDateobjectusinglocaltime.*@paramyearAnumericvaluefortheyear.*@parammonthAzero-basednumericvalueforthemonth(0forJanuary,11forDecember).MustbespecifiedifnumDateisspecified.*@paramdateAnumericvalueequalforthedayofthemonth.*/setFullYear(year:number,month?:number,date?:number):number/***SetstheyearvalueintheDateobjectusingUniversalCoordinatedTime(UTC).*@paramyearAnumericvalueequaltotheyear.*@parammonthAnumericvalueequaltothemonth.ThevalueforJanuaryis0,andothermonthvaluesfollowconsecutively.MustbesuppliedifnumDateissupplied.*@paramdateAnumericvalueequaltothedayofthemonth.*/setUTCFullYear(year:number,month?:number,date?:number):number/**ReturnsadateconvertedtoastringusingUniversalCoordinatedTime(UTC).*/toUTCString():string/**ReturnsadateasastringvalueinISOformat.*/toISOString():string/**UsedbytheJSON.stringifymethodtoenablethetransformationofanobject'sdataforJavaScriptObjectNotation(JSON)serialization.*/toJSON(key?:any):string}interfaceDateConstructor{new():Datenew(value:number|string):Datenew(year:number,month:number,date?:number,hours?:number,minutes?:number,seconds?:number,ms?:number,):Date():stringreadonlyprototype:Date/***Parsesastringcontainingadate,andreturnsthenumberofmillisecondsbetweenthatdateandmidnight,January1,1970.*@paramsAdatestring*/parse(s:string):number/***Returnsthenumberofmillisecondsbetweenmidnight,January1,1970UniversalCoordinatedTime(UTC)(orGMT)andthespecifieddate.*@paramyearThefullyeardesignationisrequiredforcross-centurydateaccuracy.Ifyearisbetween0and99isused,thenyearisassumedtobe1900+year.*@parammonthThemonthasanumberbetween0and11(JanuarytoDecember).*@paramdateThedateasanumberbetween1and31.*@paramhoursMustbesuppliedifminutesissupplied.Anumberfrom0to23(midnightto11pm)thatspecifiesthehour.*@paramminutesMustbesuppliedifsecondsissupplied.Anumberfrom0to59thatspecifiestheminutes.*@paramsecondsMustbesuppliedifmillisecondsissupplied.Anumberfrom0to59thatspecifiestheseconds.*@parammsAnumberfrom0to999thatspecifiesthemilliseconds.*/UTC(year:number,month:number,date?:number,hours?:number,minutes?:number,seconds?:number,ms?:number,):numbernow():number}declarevarDate:DateConstructor```##Array```tsinterfaceTemplateStringsArrayextendsReadonlyArray<string>{readonlyraw:readonlystring[]}```##Import```ts/***Thetypeof`import.meta`.**Ifyouneedtodeclarethatagivenpropertyexistson`import.meta`,*thistypemaybeaugmentedviainterfacemerging.*/interfaceImportMeta{}/***Thetypefortheoptionalsecondargumentto`import()`.**Ifyourhostenvironmentsupportsadditionaloptions,thistypemaybe*augmentedviainterfacemerging.*/interfaceImportCallOptions{assert?:ImportAssertions}/***Thetypeforthe`assert`propertyoftheoptionalsecondargumentto`import()`.*/interfaceImportAssertions{[key:string]:string}```##RegExp```tsinterfaceRegExpMatchArrayextendsArray<string>{index?:numberinput?:string}interfaceRegExpExecArrayextendsArray<string>{index:numberinput:string}interfaceRegExp{/***Executesasearchonastringusingaregularexpressionpattern,andreturnsanarraycontainingtheresultsofthatsearch.*@paramstringTheStringobjectorstringliteralonwhichtoperformthesearch.*/exec(string:string):RegExpExecArray|null/***ReturnsaBooleanvaluethatindicateswhetherornotapatternexistsinasearchedstring.*@paramstringStringonwhichtoperformthesearch.*/test(string:string):boolean/**Returnsacopyofthetextoftheregularexpressionpattern.Read-only.TheregExpargumentisaRegularexpressionobject.Itcanbeavariablenameoraliteral.*/readonlysource:string/**ReturnsaBooleanvalueindicatingthestateoftheglobalflag(g)usedwitharegularexpression.Defaultisfalse.Read-only.*/readonlyglobal:boolean/**ReturnsaBooleanvalueindicatingthestateoftheignoreCaseflag(i)usedwitharegularexpression.Defaultisfalse.Read-only.*/readonlyignoreCase:boolean/**ReturnsaBooleanvalueindicatingthestateofthemultilineflag(m)usedwitharegularexpression.Defaultisfalse.Read-only.*/readonlymultiline:booleanlastIndex:number//Non-standardextensions/**@deprecatedAlegacyfeatureforbrowsercompatibility*/compile(pattern:string,flags?:string):this}interfaceRegExpConstructor{new(pattern:RegExp|string):RegExpnew(pattern:string,flags?:string):RegExp(pattern:RegExp|string):RegExp(pattern:string,flags?:string):RegExpreadonlyprototype:RegExp//Non-standardextensions/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$1:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$2:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$3:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$4:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$5:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$6:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$7:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$8:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$9:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/input:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/$_:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/lastMatch:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/'$&':string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/lastParen:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/'$+':string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/leftContext:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/'$`':string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/rightContext:string/**@deprecatedAlegacyfeatureforbrowsercompatibility*/\"$'\":string}declarevarRegExp:RegExpConstructor```##未分类````tsinterfaceError{name:stringmessage:stringstack?:string}interfaceErrorConstructor{new(message?:string):Error(message?:string):Errorreadonlyprototype:Error}declarevarError:ErrorConstructorinterfaceEvalErrorextendsError{}interfaceEvalErrorConstructorextendsErrorConstructor{new(message?:string):EvalError(message?:string):EvalErrorreadonlyprototype:EvalError}declarevarEvalError:EvalErrorConstructorinterfaceRangeErrorextendsError{}interfaceRangeErrorConstructorextendsErrorConstructor{new(message?:string):RangeError(message?:string):RangeErrorreadonlyprototype:RangeError}declarevarRangeError:RangeErrorConstructorinterfaceReferenceErrorextendsError{}interfaceReferenceErrorConstructorextendsErrorConstructor{new(message?:string):ReferenceError(message?:string):ReferenceErrorreadonlyprototype:ReferenceError}declarevarReferenceError:ReferenceErrorConstructorinterfaceSyntaxErrorextendsError{}interfaceSyntaxErrorConstructorextendsErrorConstructor{new(message?:string):SyntaxError(message?:string):SyntaxErrorreadonlyprototype:SyntaxError}declarevarSyntaxError:SyntaxErrorConstructorinterfaceTypeErrorextendsError{}interfaceTypeErrorConstructorextendsErrorConstructor{new(message?:string):TypeError(message?:string):TypeErrorreadonlyprototype:TypeError}declarevarTypeError:TypeErrorConstructorinterfaceURIErrorextendsError{}interfaceURIErrorConstructorextendsErrorConstructor{new(message?:string):URIError(message?:string):URIErrorreadonlyprototype:URIError}declarevarURIError:URIErrorConstructorinterfaceJSON{/***ConvertsaJavaScriptObjectNotation(JSON)stringintoanobject.*@paramtextAvalidJSONstring.*@paramreviverAfunctionthattransformstheresults.Thisfunctioniscalledforeachmemberoftheobject.*Ifamembercontainsnestedobjects,thenestedobjectsaretransformedbeforetheparentobjectis.*/parse(text:string,reviver?:(this:any,key:string,value:any)=>any,):any/***ConvertsaJavaScriptvaluetoaJavaScriptObjectNotation(JSON)string.*@paramvalueAJavaScriptvalue,usuallyanobjectorarray,tobeconverted.*@paramreplacerAfunctionthattransformstheresults.*@paramspaceAddsindentation,whitespace,andlinebreakcharacterstothereturn-valueJSONtexttomakeiteasiertoread.*/stringify(value:any,replacer?:(this:any,key:string,value:any)=>any,space?:string|number,):string/***ConvertsaJavaScriptvaluetoaJavaScriptObjectNotation(JSON)string.*@paramvalueAJavaScriptvalue,usuallyanobjectorarray,tobeconverted.*@paramreplacerAnarrayofstringsandnumbersthatactsasanapprovedlistforselectingtheobjectpropertiesthatwillbestringified.*@paramspaceAddsindentation,whitespace,andlinebreakcharacterstothereturn-valueJSONtexttomakeiteasiertoread.*/stringify(value:any,replacer?:(number|string)[]|null,space?:string|number,):string}/***AnintrinsicobjectthatprovidesfunctionstoconvertJavaScriptvaluestoandfromtheJavaScriptObjectNotation(JSON)format.*/declarevarJSON:JSON////////////////////////////////ECMAScriptArrayAPI(speciallyhandledbycompiler)/////////////////////////////interfaceReadonlyArray<T>{/***Getsthelengthofthearray.Thisisanumberonehigherthanthehighestelementdefinedinanarray.*/readonlylength:number/***Returnsastringrepresentationofanarray.*/toString():string/***Returnsastringrepresentationofanarray.TheelementsareconvertedtostringusingtheirtoLocaleStringmethods.*/toLocaleString():string/***Combinestwoormorearrays.*@paramitemsAdditionalitemstoaddtotheendofarray1.*/concat(...items:ConcatArray<T>[]):T[]/***Combinestwoormorearrays.*@paramitemsAdditionalitemstoaddtotheendofarray1.*/concat(...items:(T|ConcatArray<T>)[]):T[]/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextintheresultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):T[]/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,thesearchstartsatindex0.*/indexOf(searchElement:T,fromIndex?:number):number/***Returnstheindexofthelastoccurrenceofaspecifiedvalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,thesearchstartsatthelastindexinthearray.*/lastIndexOf(searchElement:T,fromIndex?:number):number/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every<SextendsT>(predicate:(value:T,index:number,array:readonlyT[])=>valueisS,thisArg?:any,):thisisreadonlyS[]/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:T,index:number,array:readonlyT[])=>unknown,thisArg?:any,):boolean/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:T,index:number,array:readonlyT[])=>unknown,thisArg?:any,):boolean/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:T,index:number,array:readonlyT[])=>void,thisArg?:any,):void/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythatcontainstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.IfthisArgisomitted,undefinedisusedasthethisvalue.*/map<U>(callbackfn:(value:T,index:number,array:readonlyT[])=>U,thisArg?:any,):U[]/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcallsthepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter<SextendsT>(predicate:(value:T,index:number,array:readonlyT[])=>valueisS,thisArg?:any,):S[]/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcallsthepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:T,index:number,array:readonlyT[])=>unknown,thisArg?:any,):T[]/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostarttheaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargumentinsteadofanarrayvalue.*/reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:readonlyT[],)=>T,):Treduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:readonlyT[],)=>T,initialValue:T,):T/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostarttheaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargumentinsteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:T,currentIndex:number,array:readonlyT[],)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostarttheaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:readonlyT[],)=>T,):TreduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:readonlyT[],)=>T,initialValue:T,):T/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostarttheaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargumentinsteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:T,currentIndex:number,array:readonlyT[],)=>U,initialValue:U,):Ureadonly[n:number]:T}interfaceConcatArray<T>{readonlylength:numberreadonly[n:number]:Tjoin(separator?:string):stringslice(start?:number,end?:number):T[]}interfaceArray<T>{/***Getsorsetsthelengthofthearray.Thisisanumberonehigherthanthehighestindexinthearray.*/length:number/***Returnsastringrepresentationofanarray.*/toString():string/***Returnsastringrepresentationofanarray.TheelementsareconvertedtostringusingtheirtoLocaleStringmethods.*/toLocaleString():string/***Removesthelastelementfromanarrayandreturnsit.*Ifthearrayisempty,undefinedisreturnedandthearrayisnotmodified.*/pop():T|undefined/***Appendsnewelementstotheendofanarray,andreturnsthenewlengthofthearray.*@paramitemsNewelementstoaddtothearray.*/push(...items:T[]):number/***Combinestwoormorearrays.*Thismethodreturnsanewarraywithoutmodifyinganyexistingarrays.*@paramitemsAdditionalarraysand/oritemstoaddtotheendofthearray.*/concat(...items:ConcatArray<T>[]):T[]/***Combinestwoormorearrays.*Thismethodreturnsanewarraywithoutmodifyinganyexistingarrays.*@paramitemsAdditionalarraysand/oritemstoaddtotheendofthearray.*/concat(...items:(T|ConcatArray<T>)[]):T[]/***Addsalltheelementsofanarrayintoastring,separatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofthearrayfromthenextintheresultingstring.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Reversestheelementsinanarrayinplace.*Thismethodmutatesthearrayandreturnsareferencetothesamearray.*/reverse():T[]/***Removesthefirstelementfromanarrayandreturnsit.*Ifthearrayisempty,undefinedisreturnedandthearrayisnotmodified.*/shift():T|undefined/***Returnsacopyofasectionofanarray.*Forbothstartandend,anegativeindexcanbeusedtoindicateanoffsetfromtheendofthearray.*Forexample,-2referstothesecondtolastelementofthearray.*@paramstartThebeginningindexofthespecifiedportionofthearray.*Ifstartisundefined,thentheslicebeginsatindex0.*@paramendTheendindexofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*Ifendisundefined,thenthesliceextendstotheendofthearray.*/slice(start?:number,end?:number):T[]/***Sortsanarrayinplace.*Thismethodmutatesthearrayandreturnsareferencetothesamearray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueifthefirstargumentislessthanthesecondargument,zeroifthey'reequal,andapositive*valueotherwise.Ifomitted,theelementsaresortedinascending,ASCIIcharacterorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:T,b:T)=>number):this/***Removeselementsfromanarrayand,ifnecessary,insertsnewelementsintheirplace,returningthedeletedelements.*@paramstartThezero-basedlocationinthearrayfromwhichtostartremovingelements.*@paramdeleteCountThenumberofelementstoremove.*@returnsAnarraycontainingtheelementsthatweredeleted.*/splice(start:number,deleteCount?:number):T[]/***Removeselementsfromanarrayand,ifnecessary,insertsnewelementsintheirplace,returningthedeletedelements.*@paramstartThezero-basedlocationinthearrayfromwhichtostartremovingelements.*@paramdeleteCountThenumberofelementstoremove.*@paramitemsElementstoinsertintothearrayinplaceofthedeletedelements.*@returnsAnarraycontainingtheelementsthatweredeleted.*/splice(start:number,deleteCount:number,...items:T[]):T[]/***Insertsnewelementsatthestartofanarray,andreturnsthenewlengthofthearray.*@paramitemsElementstoinsertatthestartofthearray.*/unshift(...items:T[]):number/***Returnstheindexofthefirstoccurrenceofavalueinanarray,or-1ifitisnotpresent.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,thesearchstartsatindex0.*/indexOf(searchElement:T,fromIndex?:number):number/***Returnstheindexofthelastoccurrenceofaspecifiedvalueinanarray,or-1ifitisnotpresent.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginsearchingbackward.IffromIndexisomitted,thesearchstartsatthelastindexinthearray.*/lastIndexOf(searchElement:T,fromIndex?:number):number/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every<SextendsT>(predicate:(value:T,index:number,array:T[])=>valueisS,thisArg?:any,):thisisS[]/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any,):boolean/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any,):boolean/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any,):void/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythatcontainstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.IfthisArgisomitted,undefinedisusedasthethisvalue.*/map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any,):U[]/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcallsthepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter<SextendsT>(predicate:(value:T,index:number,array:T[])=>valueisS,thisArg?:any,):S[]/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcallsthepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:T,index:number,array:T[])=>unknown,thisArg?:any,):T[]/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostarttheaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargumentinsteadofanarrayvalue.*/reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[],)=>T,):Treduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[],)=>T,initialValue:T,):T/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostarttheaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargumentinsteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:T,currentIndex:number,array:T[],)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostarttheaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[],)=>T,):TreduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[],)=>T,initialValue:T,):T/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcallsthecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostarttheaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargumentinsteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:T,currentIndex:number,array:T[],)=>U,initialValue:U,):U[n:number]:T}interfaceArrayConstructor{new(arrayLength?:number):any[]new<T>(arrayLength:number):T[]new<T>(...items:T[]):T[](arrayLength?:number):any[]<T>(arrayLength:number):T[]<T>(...items:T[]):T[]isArray(arg:any):argisany[]readonlyprototype:any[]}declarevarArray:ArrayConstructorinterfaceTypedPropertyDescriptor<T>{enumerable?:booleanconfigurable?:booleanwritable?:booleanvalue?:Tget?:()=>Tset?:(value:T)=>void}declaretypeClassDecorator=<TFunctionextendsFunction>(target:TFunction,)=>TFunction|voiddeclaretypePropertyDecorator=(target:Object,propertyKey:string|symbol,)=>voiddeclaretypeMethodDecorator=<T>(target:Object,propertyKey:string|symbol,descriptor:TypedPropertyDescriptor<T>,)=>TypedPropertyDescriptor<T>|voiddeclaretypeParameterDecorator=(target:Object,propertyKey:string|symbol,parameterIndex:number,)=>voiddeclaretypePromiseConstructorLike=new<T>(executor:(resolve:(value:T|PromiseLike<T>)=>void,reject:(reason?:any)=>void,)=>void,)=>PromiseLike<T>interfacePromiseLike<T>{/***Attachescallbacksfortheresolutionand/orrejectionofthePromise.*@paramonfulfilledThecallbacktoexecutewhenthePromiseisresolved.*@paramonrejectedThecallbacktoexecutewhenthePromiseisrejected.*@returnsAPromiseforthecompletionofwhichevercallbackisexecuted.*/then<TResult1=T,TResult2=never>(onfulfilled?:|((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:|((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null,):PromiseLike<TResult1|TResult2>}/***Representsthecompletionofanasynchronousoperation*/interfacePromise<T>{/***Attachescallbacksfortheresolutionand/orrejectionofthePromise.*@paramonfulfilledThecallbacktoexecutewhenthePromiseisresolved.*@paramonrejectedThecallbacktoexecutewhenthePromiseisrejected.*@returnsAPromiseforthecompletionofwhichevercallbackisexecuted.*/then<TResult1=T,TResult2=never>(onfulfilled?:|((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:|((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null,):Promise<TResult1|TResult2>/***AttachesacallbackforonlytherejectionofthePromise.*@paramonrejectedThecallbacktoexecutewhenthePromiseisrejected.*@returnsAPromiseforthecompletionofthecallback.*/catch<TResult=never>(onrejected?:|((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null,):Promise<T|TResult>}/***Recursivelyunwrapsthe\"awaitedtype\"ofatype.Non-promise\"thenables\"shouldresolveto`never`.Thisemulatesthebehaviorof`await`.*/typeAwaited<T>=Textendsnull|undefined?T//specialcasefor`null|undefined`whennotin`--strictNullChecks`mode:Textendsobject&{then(onfulfilled:inferF):any}//`await`onlyunwrapsobjecttypeswithacallable`then`.Non-objecttypesarenotunwrapped?Fextends(value:inferV,...args:any)=>any//iftheargumentto`then`iscallable,extractsthefirstargument?Awaited<V>//recursivelyunwrapthevalue:never//theargumentto`then`wasnotcallable:T//non-objectornon-thenableinterfaceArrayLike<T>{readonlylength:numberreadonly[n:number]:T}/***MakeallpropertiesinToptional*/typePartial<T>={[PinkeyofT]?:T[P]}/***MakeallpropertiesinTrequired*/typeRequired<T>={[PinkeyofT]-?:T[P]}/***MakeallpropertiesinTreadonly*/typeReadonly<T>={readonly[PinkeyofT]:T[P]}/***FromT,pickasetofpropertieswhosekeysareintheunionK*/typePick<T,KextendskeyofT>={[PinK]:T[P]}/***ConstructatypewithasetofpropertiesKoftypeT*/typeRecord<Kextendskeyofany,T>={[PinK]:T}/***ExcludefromTthosetypesthatareassignabletoU*/typeExclude<T,U>=TextendsU?never:T/***ExtractfromTthosetypesthatareassignabletoU*/typeExtract<T,U>=TextendsU?T:never/***ConstructatypewiththepropertiesofTexceptforthoseintypeK.*/typeOmit<T,Kextendskeyofany>=Pick<T,Exclude<keyofT,K>>/***ExcludenullandundefinedfromT*/typeNonNullable<T>=Textendsnull|undefined?never:T/***Obtaintheparametersofafunctiontypeinatuple*/typeParameters<Textends(...args:any)=>any>=Textends(...args:inferP)=>any?P:never/***Obtaintheparametersofaconstructorfunctiontypeinatuple*/typeConstructorParameters<Textendsabstractnew(...args:any)=>any>=Textendsabstractnew(...args:inferP)=>any?P:never/***Obtainthereturntypeofafunctiontype*/typeReturnType<Textends(...args:any)=>any>=Textends(...args:any)=>inferR?R:any/***Obtainthereturntypeofaconstructorfunctiontype*/typeInstanceType<Textendsabstractnew(...args:any)=>any>=Textendsabstractnew(...args:any)=>inferR?R:any/***Convertstringliteraltypetouppercase*/typeUppercase<Sextendsstring>=intrinsic/***Convertstringliteraltypetolowercase*/typeLowercase<Sextendsstring>=intrinsic/***Convertfirstcharacterofstringliteraltypetouppercase*/typeCapitalize<Sextendsstring>=intrinsic/***Convertfirstcharacterofstringliteraltypetolowercase*/typeUncapitalize<Sextendsstring>=intrinsic/***Markerforcontextual'this'type*/interfaceThisType<T>{}/***Representsarawbufferofbinarydata,whichisusedtostoredataforthe*differenttypedarrays.ArrayBufferscannotbereadfromorwrittentodirectly,*butcanbepassedtoatypedarrayorDataViewObjecttointerprettheraw*bufferasneeded.*/interfaceArrayBuffer{/***Read-only.ThelengthoftheArrayBuffer(inbytes).*/readonlybyteLength:number/***ReturnsasectionofanArrayBuffer.*/slice(begin:number,end?:number):ArrayBuffer}/***AllowedArrayBuffertypesforthebufferofanArrayBufferViewandrelatedTypedArrays.*/interfaceArrayBufferTypes{ArrayBuffer:ArrayBuffer}typeArrayBufferLike=ArrayBufferTypes[keyofArrayBufferTypes]interfaceArrayBufferConstructor{readonlyprototype:ArrayBuffernew(byteLength:number):ArrayBufferisView(arg:any):argisArrayBufferView}declarevarArrayBuffer:ArrayBufferConstructorinterfaceArrayBufferView{/***TheArrayBufferinstancereferencedbythearray.*/buffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/byteLength:number/***Theoffsetinbytesofthearray.*/byteOffset:number}interfaceDataView{readonlybuffer:ArrayBufferreadonlybyteLength:numberreadonlybyteOffset:number/***GetstheFloat32valueatthespecifiedbyteoffsetfromthestartoftheview.Thereis*noalignmentconstraint;multi-bytevaluesmaybefetchedfromanyoffset.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldberetrieved.*/getFloat32(byteOffset:number,littleEndian?:boolean):number/***GetstheFloat64valueatthespecifiedbyteoffsetfromthestartoftheview.Thereis*noalignmentconstraint;multi-bytevaluesmaybefetchedfromanyoffset.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldberetrieved.*/getFloat64(byteOffset:number,littleEndian?:boolean):number/***GetstheInt8valueatthespecifiedbyteoffsetfromthestartoftheview.Thereis*noalignmentconstraint;multi-bytevaluesmaybefetchedfromanyoffset.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldberetrieved.*/getInt8(byteOffset:number):number/***GetstheInt16valueatthespecifiedbyteoffsetfromthestartoftheview.Thereis*noalignmentconstraint;multi-bytevaluesmaybefetchedfromanyoffset.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldberetrieved.*/getInt16(byteOffset:number,littleEndian?:boolean):number/***GetstheInt32valueatthespecifiedbyteoffsetfromthestartoftheview.Thereis*noalignmentconstraint;multi-bytevaluesmaybefetchedfromanyoffset.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldberetrieved.*/getInt32(byteOffset:number,littleEndian?:boolean):number/***GetstheUint8valueatthespecifiedbyteoffsetfromthestartoftheview.Thereis*noalignmentconstraint;multi-bytevaluesmaybefetchedfromanyoffset.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldberetrieved.*/getUint8(byteOffset:number):number/***GetstheUint16valueatthespecifiedbyteoffsetfromthestartoftheview.Thereis*noalignmentconstraint;multi-bytevaluesmaybefetchedfromanyoffset.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldberetrieved.*/getUint16(byteOffset:number,littleEndian?:boolean):number/***GetstheUint32valueatthespecifiedbyteoffsetfromthestartoftheview.Thereis*noalignmentconstraint;multi-bytevaluesmaybefetchedfromanyoffset.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldberetrieved.*/getUint32(byteOffset:number,littleEndian?:boolean):number/***StoresanFloat32valueatthespecifiedbyteoffsetfromthestartoftheview.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldbeset.*@paramvalueThevaluetoset.*@paramlittleEndianIffalseorundefined,abig-endianvalueshouldbewritten,*otherwisealittle-endianvalueshouldbewritten.*/setFloat32(byteOffset:number,value:number,littleEndian?:boolean):void/***StoresanFloat64valueatthespecifiedbyteoffsetfromthestartoftheview.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldbeset.*@paramvalueThevaluetoset.*@paramlittleEndianIffalseorundefined,abig-endianvalueshouldbewritten,*otherwisealittle-endianvalueshouldbewritten.*/setFloat64(byteOffset:number,value:number,littleEndian?:boolean):void/***StoresanInt8valueatthespecifiedbyteoffsetfromthestartoftheview.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldbeset.*@paramvalueThevaluetoset.*/setInt8(byteOffset:number,value:number):void/***StoresanInt16valueatthespecifiedbyteoffsetfromthestartoftheview.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldbeset.*@paramvalueThevaluetoset.*@paramlittleEndianIffalseorundefined,abig-endianvalueshouldbewritten,*otherwisealittle-endianvalueshouldbewritten.*/setInt16(byteOffset:number,value:number,littleEndian?:boolean):void/***StoresanInt32valueatthespecifiedbyteoffsetfromthestartoftheview.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldbeset.*@paramvalueThevaluetoset.*@paramlittleEndianIffalseorundefined,abig-endianvalueshouldbewritten,*otherwisealittle-endianvalueshouldbewritten.*/setInt32(byteOffset:number,value:number,littleEndian?:boolean):void/***StoresanUint8valueatthespecifiedbyteoffsetfromthestartoftheview.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldbeset.*@paramvalueThevaluetoset.*/setUint8(byteOffset:number,value:number):void/***StoresanUint16valueatthespecifiedbyteoffsetfromthestartoftheview.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldbeset.*@paramvalueThevaluetoset.*@paramlittleEndianIffalseorundefined,abig-endianvalueshouldbewritten,*otherwisealittle-endianvalueshouldbewritten.*/setUint16(byteOffset:number,value:number,littleEndian?:boolean):void/***StoresanUint32valueatthespecifiedbyteoffsetfromthestartoftheview.*@parambyteOffsetTheplaceinthebufferatwhichthevalueshouldbeset.*@paramvalueThevaluetoset.*@paramlittleEndianIffalseorundefined,abig-endianvalueshouldbewritten,*otherwisealittle-endianvalueshouldbewritten.*/setUint32(byteOffset:number,value:number,littleEndian?:boolean):void}interfaceDataViewConstructor{readonlyprototype:DataViewnew(buffer:ArrayBufferLike,byteOffset?:number,byteLength?:number,):DataView}declarevarDataView:DataViewConstructor/***Atypedarrayof8-bitintegervalues.Thecontentsareinitializedto0.Iftherequested*numberofbytescouldnotbeallocatedanexceptionisraised.*/interfaceInt8Array{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Int8Array)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Int8Array)=>any,thisArg?:any,):Int8Array/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Int8Array)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Int8Array)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Int8Array)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Int8Array)=>number,thisArg?:any,):Int8Array/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int8Array,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int8Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int8Array,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int8Array,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int8Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int8Array,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Int8Array/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Int8Array/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Int8Array)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***GetsanewInt8ArrayviewoftheArrayBufferstoreforthisarray,referencingtheelements*atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Int8Array/***Convertsanumbertoastringbyusingthecurrentlocale.*/toLocaleString():string/***Returnsastringrepresentationofanarray.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Int8Array[index:number]:number}interfaceInt8ArrayConstructor{readonlyprototype:Int8Arraynew(length:number):Int8Arraynew(array:ArrayLike<number>|ArrayBufferLike):Int8Arraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number):Int8Array/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Int8Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Int8Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Int8Array}declarevarInt8Array:Int8ArrayConstructor/***Atypedarrayof8-bitunsignedintegervalues.Thecontentsareinitializedto0.Ifthe*requestednumberofbytescouldnotbeallocatedanexceptionisraised.*/interfaceUint8Array{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Uint8Array)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Uint8Array)=>any,thisArg?:any,):Uint8Array/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Uint8Array)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Uint8Array)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Uint8Array)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Uint8Array)=>number,thisArg?:any,):Uint8Array/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8Array,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint8Array,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8Array,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint8Array,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Uint8Array/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Uint8Array/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Uint8Array)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***GetsanewUint8ArrayviewoftheArrayBufferstoreforthisarray,referencingtheelements*atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Uint8Array/***Convertsanumbertoastringbyusingthecurrentlocale.*/toLocaleString():string/***Returnsastringrepresentationofanarray.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Uint8Array[index:number]:number}interfaceUint8ArrayConstructor{readonlyprototype:Uint8Arraynew(length:number):Uint8Arraynew(array:ArrayLike<number>|ArrayBufferLike):Uint8Arraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number,):Uint8Array/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Uint8Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Uint8Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Uint8Array}declarevarUint8Array:Uint8ArrayConstructor/***Atypedarrayof8-bitunsignedinteger(clamped)values.Thecontentsareinitializedto0.*Iftherequestednumberofbytescouldnotbeallocatedanexceptionisraised.*/interfaceUint8ClampedArray{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Uint8ClampedArray,)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Uint8ClampedArray)=>any,thisArg?:any,):Uint8ClampedArray/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Uint8ClampedArray,)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Uint8ClampedArray,)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Uint8ClampedArray,)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Uint8ClampedArray,)=>number,thisArg?:any,):Uint8ClampedArray/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8ClampedArray,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8ClampedArray,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint8ClampedArray,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8ClampedArray,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8ClampedArray,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint8ClampedArray,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Uint8ClampedArray/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Uint8ClampedArray/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Uint8ClampedArray,)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***GetsanewUint8ClampedArrayviewoftheArrayBufferstoreforthisarray,referencingtheelements*atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Uint8ClampedArray/***Convertsanumbertoastringbyusingthecurrentlocale.*/toLocaleString():string/***Returnsastringrepresentationofanarray.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Uint8ClampedArray[index:number]:number}interfaceUint8ClampedArrayConstructor{readonlyprototype:Uint8ClampedArraynew(length:number):Uint8ClampedArraynew(array:ArrayLike<number>|ArrayBufferLike):Uint8ClampedArraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number,):Uint8ClampedArray/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Uint8ClampedArray/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Uint8ClampedArray/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Uint8ClampedArray}declarevarUint8ClampedArray:Uint8ClampedArrayConstructor/***Atypedarrayof16-bitsignedintegervalues.Thecontentsareinitializedto0.Ifthe*requestednumberofbytescouldnotbeallocatedanexceptionisraised.*/interfaceInt16Array{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Int16Array)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Int16Array)=>any,thisArg?:any,):Int16Array/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Int16Array)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Int16Array)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Int16Array)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Int16Array)=>number,thisArg?:any,):Int16Array/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int16Array,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int16Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int16Array,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int16Array,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int16Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int16Array,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Int16Array/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Int16Array/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Int16Array)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***GetsanewInt16ArrayviewoftheArrayBufferstoreforthisarray,referencingtheelements*atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Int16Array/***Convertsanumbertoastringbyusingthecurrentlocale.*/toLocaleString():string/***Returnsastringrepresentationofanarray.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Int16Array[index:number]:number}interfaceInt16ArrayConstructor{readonlyprototype:Int16Arraynew(length:number):Int16Arraynew(array:ArrayLike<number>|ArrayBufferLike):Int16Arraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number,):Int16Array/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Int16Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Int16Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Int16Array}declarevarInt16Array:Int16ArrayConstructor/***Atypedarrayof16-bitunsignedintegervalues.Thecontentsareinitializedto0.Ifthe*requestednumberofbytescouldnotbeallocatedanexceptionisraised.*/interfaceUint16Array{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Uint16Array)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Uint16Array)=>any,thisArg?:any,):Uint16Array/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Uint16Array)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Uint16Array)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Uint16Array)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Uint16Array)=>number,thisArg?:any,):Uint16Array/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint16Array,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint16Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint16Array,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint16Array,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint16Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint16Array,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Uint16Array/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Uint16Array/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Uint16Array)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***GetsanewUint16ArrayviewoftheArrayBufferstoreforthisarray,referencingtheelements*atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Uint16Array/***Convertsanumbertoastringbyusingthecurrentlocale.*/toLocaleString():string/***Returnsastringrepresentationofanarray.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Uint16Array[index:number]:number}interfaceUint16ArrayConstructor{readonlyprototype:Uint16Arraynew(length:number):Uint16Arraynew(array:ArrayLike<number>|ArrayBufferLike):Uint16Arraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number,):Uint16Array/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Uint16Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Uint16Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Uint16Array}declarevarUint16Array:Uint16ArrayConstructor/***Atypedarrayof32-bitsignedintegervalues.Thecontentsareinitializedto0.Ifthe*requestednumberofbytescouldnotbeallocatedanexceptionisraised.*/interfaceInt32Array{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Int32Array)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Int32Array)=>any,thisArg?:any,):Int32Array/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Int32Array)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Int32Array)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Int32Array)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Int32Array)=>number,thisArg?:any,):Int32Array/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int32Array,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int32Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int32Array,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int32Array,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int32Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int32Array,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Int32Array/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Int32Array/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Int32Array)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***GetsanewInt32ArrayviewoftheArrayBufferstoreforthisarray,referencingtheelements*atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Int32Array/***Convertsanumbertoastringbyusingthecurrentlocale.*/toLocaleString():string/***Returnsastringrepresentationofanarray.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Int32Array[index:number]:number}interfaceInt32ArrayConstructor{readonlyprototype:Int32Arraynew(length:number):Int32Arraynew(array:ArrayLike<number>|ArrayBufferLike):Int32Arraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number,):Int32Array/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Int32Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Int32Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Int32Array}declarevarInt32Array:Int32ArrayConstructor/***Atypedarrayof32-bitunsignedintegervalues.Thecontentsareinitializedto0.Ifthe*requestednumberofbytescouldnotbeallocatedanexceptionisraised.*/interfaceUint32Array{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Uint32Array)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Uint32Array)=>any,thisArg?:any,):Uint32Array/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Uint32Array)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Uint32Array)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Uint32Array)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Uint32Array)=>number,thisArg?:any,):Uint32Array/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint32Array,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint32Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint32Array,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint32Array,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint32Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint32Array,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Uint32Array/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Uint32Array/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Uint32Array)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***GetsanewUint32ArrayviewoftheArrayBufferstoreforthisarray,referencingtheelements*atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Uint32Array/***Convertsanumbertoastringbyusingthecurrentlocale.*/toLocaleString():string/***Returnsastringrepresentationofanarray.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Uint32Array[index:number]:number}interfaceUint32ArrayConstructor{readonlyprototype:Uint32Arraynew(length:number):Uint32Arraynew(array:ArrayLike<number>|ArrayBufferLike):Uint32Arraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number,):Uint32Array/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Uint32Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Uint32Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Uint32Array}declarevarUint32Array:Uint32ArrayConstructor/***Atypedarrayof32-bitfloatvalues.Thecontentsareinitializedto0.Iftherequestednumber*ofbytescouldnotbeallocatedanexceptionisraised.*/interfaceFloat32Array{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Float32Array)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Float32Array)=>any,thisArg?:any,):Float32Array/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Float32Array)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Float32Array)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Float32Array)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Float32Array)=>number,thisArg?:any,):Float32Array/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float32Array,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float32Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Float32Array,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float32Array,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float32Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Float32Array,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Float32Array/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Float32Array/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Float32Array)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***GetsanewFloat32ArrayviewoftheArrayBufferstoreforthisarray,referencingtheelements*atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Float32Array/***Convertsanumbertoastringbyusingthecurrentlocale.*/toLocaleString():string/***Returnsastringrepresentationofanarray.*/toString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Float32Array[index:number]:number}interfaceFloat32ArrayConstructor{readonlyprototype:Float32Arraynew(length:number):Float32Arraynew(array:ArrayLike<number>|ArrayBufferLike):Float32Arraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number,):Float32Array/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Float32Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Float32Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Float32Array}declarevarFloat32Array:Float32ArrayConstructor/***Atypedarrayof64-bitfloatvalues.Thecontentsareinitializedto0.Iftherequested*numberofbytescouldnotbeallocatedanexceptionisraised.*/interfaceFloat64Array{/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***TheArrayBufferinstancereferencedbythearray.*/readonlybuffer:ArrayBufferLike/***Thelengthinbytesofthearray.*/readonlybyteLength:number/***Theoffsetinbytesofthearray.*/readonlybyteOffset:number/***Returnsthethisobjectaftercopyingasectionofthearrayidentifiedbystartandend*tothesamearraystartingatpositiontarget*@paramtargetIftargetisnegative,itistreatedaslength+targetwherelengthisthe*lengthofthearray.*@paramstartIfstartisnegative,itistreatedaslength+start.Ifendisnegative,it*istreatedaslength+end.*@paramendIfnotspecified,lengthofthethisobjectisusedasitsdefaultvalue.*/copyWithin(target:number,start:number,end?:number):this/***Determineswhetherallthemembersofanarraysatisfythespecifiedtest.*@parampredicateAfunctionthatacceptsuptothreearguments.Theeverymethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluefalse,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/every(predicate:(value:number,index:number,array:Float64Array)=>unknown,thisArg?:any,):boolean/***Changesallarrayelementsfrom`start`to`end`indextoastatic`value`andreturnsthemodifiedarray*@paramvaluevaluetofillarraysectionwith*@paramstartindextostartfillingthearrayat.Ifstartisnegative,itistreatedas*length+startwherelengthisthelengthofthearray.*@paramendindextostopfillingthearrayat.Ifendisnegative,itistreatedas*length+end.*/fill(value:number,start?:number,end?:number):this/***Returnstheelementsofanarraythatmeettheconditionspecifiedinacallbackfunction.*@parampredicateAfunctionthatacceptsuptothreearguments.Thefiltermethodcalls*thepredicatefunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/filter(predicate:(value:number,index:number,array:Float64Array)=>any,thisArg?:any,):Float64Array/***Returnsthevalueofthefirstelementinthearraywherepredicateistrue,andundefined*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,find*immediatelyreturnsthatelementvalue.Otherwise,findreturnsundefined.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/find(predicate:(value:number,index:number,obj:Float64Array)=>boolean,thisArg?:any,):number|undefined/***Returnstheindexofthefirstelementinthearraywherepredicateistrue,and-1*otherwise.*@parampredicatefindcallspredicateonceforeachelementofthearray,inascending*order,untilitfindsonewherepredicatereturnstrue.Ifsuchanelementisfound,*findIndeximmediatelyreturnsthatelementindex.Otherwise,findIndexreturns-1.*@paramthisArgIfprovided,itwillbeusedasthethisvalueforeachinvocationof*predicate.Ifitisnotprovided,undefinedisusedinstead.*/findIndex(predicate:(value:number,index:number,obj:Float64Array)=>boolean,thisArg?:any,):number/***Performsthespecifiedactionforeachelementinanarray.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.forEachcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/forEach(callbackfn:(value:number,index:number,array:Float64Array)=>void,thisArg?:any,):void/***Returnstheindexofthefirstoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/indexOf(searchElement:number,fromIndex?:number):number/***Addsalltheelementsofanarrayseparatedbythespecifiedseparatorstring.*@paramseparatorAstringusedtoseparateoneelementofanarrayfromthenextinthe*resultingString.Ifomitted,thearrayelementsareseparatedwithacomma.*/join(separator?:string):string/***Returnstheindexofthelastoccurrenceofavalueinanarray.*@paramsearchElementThevaluetolocateinthearray.*@paramfromIndexThearrayindexatwhichtobeginthesearch.IffromIndexisomitted,the*searchstartsatindex0.*/lastIndexOf(searchElement:number,fromIndex?:number):number/***Thelengthofthearray.*/readonlylength:number/***Callsadefinedcallbackfunctiononeachelementofanarray,andreturnsanarraythat*containstheresults.*@paramcallbackfnAfunctionthatacceptsuptothreearguments.Themapmethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthecallbackfnfunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/map(callbackfn:(value:number,index:number,array:Float64Array)=>number,thisArg?:any,):Float64Array/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float64Array,)=>number,):numberreduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float64Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray.Thereturnvalueof*thecallbackfunctionistheaccumulatedresult,andisprovidedasanargumentinthenext*calltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.Thereducemethodcallsthe*callbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Float64Array,)=>U,initialValue:U,):U/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasan*argumentinsteadofanarrayvalue.*/reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float64Array,)=>number,):numberreduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float64Array,)=>number,initialValue:number,):number/***Callsthespecifiedcallbackfunctionforalltheelementsinanarray,indescendingorder.*Thereturnvalueofthecallbackfunctionistheaccumulatedresult,andisprovidedasan*argumentinthenextcalltothecallbackfunction.*@paramcallbackfnAfunctionthatacceptsuptofourarguments.ThereduceRightmethodcalls*thecallbackfnfunctiononetimeforeachelementinthearray.*@paraminitialValueIfinitialValueisspecified,itisusedastheinitialvaluetostart*theaccumulation.Thefirstcalltothecallbackfnfunctionprovidesthisvalueasanargument*insteadofanarrayvalue.*/reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Float64Array,)=>U,initialValue:U,):U/***ReversestheelementsinanArray.*/reverse():Float64Array/***Setsavalueoranarrayofvalues.*@paramarrayAtypedoruntypedarrayofvaluestoset.*@paramoffsetTheindexinthecurrentarrayatwhichthevaluesaretobewritten.*/set(array:ArrayLike<number>,offset?:number):void/***Returnsasectionofanarray.*@paramstartThebeginningofthespecifiedportionofthearray.*@paramendTheendofthespecifiedportionofthearray.Thisisexclusiveoftheelementattheindex'end'.*/slice(start?:number,end?:number):Float64Array/***Determineswhetherthespecifiedcallbackfunctionreturnstrueforanyelementofanarray.*@parampredicateAfunctionthatacceptsuptothreearguments.Thesomemethodcalls*thepredicatefunctionforeachelementinthearrayuntilthepredicatereturnsavalue*whichiscoercibletotheBooleanvaluetrue,oruntiltheendofthearray.*@paramthisArgAnobjecttowhichthethiskeywordcanreferinthepredicatefunction.*IfthisArgisomitted,undefinedisusedasthethisvalue.*/some(predicate:(value:number,index:number,array:Float64Array)=>unknown,thisArg?:any,):boolean/***Sortsanarray.*@paramcompareFnFunctionusedtodeterminetheorderoftheelements.Itisexpectedtoreturn*anegativevalueiffirstargumentislessthansecondargument,zeroifthey'reequalandapositive*valueotherwise.Ifomitted,theelementsaresortedinascendingorder.*```ts*[11,2,22,1].sort((a,b)=>a-b)*```*/sort(compareFn?:(a:number,b:number)=>number):this/***atbegin,inclusive,uptoend,exclusive.*@parambeginTheindexofthebeginningofthearray.*@paramendTheindexoftheendofthearray.*/subarray(begin?:number,end?:number):Float64ArraytoString():string/**Returnstheprimitivevalueofthespecifiedobject.*/valueOf():Float64Array[index:number]:number}interfaceFloat64ArrayConstructor{readonlyprototype:Float64Arraynew(length:number):Float64Arraynew(array:ArrayLike<number>|ArrayBufferLike):Float64Arraynew(buffer:ArrayBufferLike,byteOffset?:number,length?:number,):Float64Array/***Thesizeinbytesofeachelementinthearray.*/readonlyBYTES_PER_ELEMENT:number/***Returnsanewarrayfromasetofelements.*@paramitemsAsetofelementstoincludeinthenewarrayobject.*/of(...items:number[]):Float64Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*/from(arrayLike:ArrayLike<number>):Float64Array/***Createsanarrayfromanarray-likeoriterableobject.*@paramarrayLikeAnarray-likeoriterableobjecttoconverttoanarray.*@parammapfnAmappingfunctiontocalloneveryelementofthearray.*@paramthisArgValueof'this'usedtoinvokethemapfn.*/from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any,):Float64Array}declarevarFloat64Array:Float64ArrayConstructor////////////////////////////////ECMAScriptInternationalizationAPI/////////////////////////////declarenamespaceIntl{interfaceCollatorOptions{usage?:string|undefinedlocaleMatcher?:string|undefinednumeric?:boolean|undefinedcaseFirst?:string|undefinedsensitivity?:string|undefinedignorePunctuation?:boolean|undefined}interfaceResolvedCollatorOptions{locale:stringusage:stringsensitivity:stringignorePunctuation:booleancollation:stringcaseFirst:stringnumeric:boolean}interfaceCollator{compare(x:string,y:string):numberresolvedOptions():ResolvedCollatorOptions}varCollator:{new(locales?:string|string[],options?:CollatorOptions):Collator(locales?:string|string[],options?:CollatorOptions):CollatorsupportedLocalesOf(locales:string|string[],options?:CollatorOptions,):string[]}interfaceNumberFormatOptions{localeMatcher?:string|undefinedstyle?:string|undefinedcurrency?:string|undefinedcurrencySign?:string|undefineduseGrouping?:boolean|undefinedminimumIntegerDigits?:number|undefinedminimumFractionDigits?:number|undefinedmaximumFractionDigits?:number|undefinedminimumSignificantDigits?:number|undefinedmaximumSignificantDigits?:number|undefined}interfaceResolvedNumberFormatOptions{locale:stringnumberingSystem:stringstyle:stringcurrency?:stringminimumIntegerDigits:numberminimumFractionDigits:numbermaximumFractionDigits:numberminimumSignificantDigits?:numbermaximumSignificantDigits?:numberuseGrouping:boolean}interfaceNumberFormat{format(value:number):stringresolvedOptions():ResolvedNumberFormatOptions}varNumberFormat:{new(locales?:string|string[],options?:NumberFormatOptions,):NumberFormat(locales?:string|string[],options?:NumberFormatOptions):NumberFormatsupportedLocalesOf(locales:string|string[],options?:NumberFormatOptions,):string[]readonlyprototype:NumberFormat}interfaceDateTimeFormatOptions{localeMatcher?:'bestfit'|'lookup'|undefinedweekday?:'long'|'short'|'narrow'|undefinedera?:'long'|'short'|'narrow'|undefinedyear?:'numeric'|'2-digit'|undefinedmonth?:'numeric'|'2-digit'|'long'|'short'|'narrow'|undefinedday?:'numeric'|'2-digit'|undefinedhour?:'numeric'|'2-digit'|undefinedminute?:'numeric'|'2-digit'|undefinedsecond?:'numeric'|'2-digit'|undefinedtimeZoneName?:'long'|'short'|undefinedformatMatcher?:'bestfit'|'basic'|undefinedhour12?:boolean|undefinedtimeZone?:string|undefined}interfaceResolvedDateTimeFormatOptions{locale:stringcalendar:stringnumberingSystem:stringtimeZone:stringhour12?:booleanweekday?:stringera?:stringyear?:stringmonth?:stringday?:stringhour?:stringminute?:stringsecond?:stringtimeZoneName?:string}interfaceDateTimeFormat{format(date?:Date|number):stringresolvedOptions():ResolvedDateTimeFormatOptions}varDateTimeFormat:{new(locales?:string|string[],options?:DateTimeFormatOptions,):DateTimeFormat(locales?:string|string[],options?:DateTimeFormatOptions,):DateTimeFormatsupportedLocalesOf(locales:string|string[],options?:DateTimeFormatOptions,):string[]readonlyprototype:DateTimeFormat}}interfaceString{/***Determineswhethertwostringsareequivalentinthecurrentorspecifiedlocale.*@paramthatStringtocomparetotargetstring*@paramlocalesAlocalestringorarrayoflocalestringsthatcontainoneormorelanguageorlocaletags.Ifyouincludemorethanonelocalestring,listthemindescendingorderofprioritysothatthefirstentryisthepreferredlocale.Ifyouomitthisparameter,thedefaultlocaleoftheJavaScriptruntimeisused.ThisparametermustconformtoBCP47standards;seetheIntl.Collatorobjectfordetails.*@paramoptionsAnobjectthatcontainsoneormorepropertiesthatspecifycomparisonoptions.seetheIntl.Collatorobjectfordetails.*/localeCompare(that:string,locales?:string|string[],options?:Intl.CollatorOptions,):number}interfaceNumber{/***Convertsanumbertoastringbyusingthecurrentorspecifiedlocale.*@paramlocalesAlocalestringorarrayoflocalestringsthatcontainoneormorelanguageorlocaletags.Ifyouincludemorethanonelocalestring,listthemindescendingorderofprioritysothatthefirstentryisthepreferredlocale.Ifyouomitthisparameter,thedefaultlocaleoftheJavaScriptruntimeisused.*@paramoptionsAnobjectthatcontainsoneormorepropertiesthatspecifycomparisonoptions.*/toLocaleString(locales?:string|string[],options?:Intl.NumberFormatOptions,):string}interfaceDate{/***Convertsadateandtimetoastringbyusingthecurrentorspecifiedlocale.*@paramlocalesAlocalestringorarrayoflocalestringsthatcontainoneormorelanguageorlocaletags.Ifyouincludemorethanonelocalestring,listthemindescendingorderofprioritysothatthefirstentryisthepreferredlocale.Ifyouomitthisparameter,thedefaultlocaleoftheJavaScriptruntimeisused.*@paramoptionsAnobjectthatcontainsoneormorepropertiesthatspecifycomparisonoptions.*/toLocaleString(locales?:string|string[],options?:Intl.DateTimeFormatOptions,):string/***Convertsadatetoastringbyusingthecurrentorspecifiedlocale.*@paramlocalesAlocalestringorarrayoflocalestringsthatcontainoneormorelanguageorlocaletags.Ifyouincludemorethanonelocalestring,listthemindescendingorderofprioritysothatthefirstentryisthepreferredlocale.Ifyouomitthisparameter,thedefaultlocaleoftheJavaScriptruntimeisused.*@paramoptionsAnobjectthatcontainsoneormorepropertiesthatspecifycomparisonoptions.*/toLocaleDateString(locales?:string|string[],options?:Intl.DateTimeFormatOptions,):string/***Convertsatimetoastringbyusingthecurrentorspecifiedlocale.*@paramlocalesAlocalestringorarrayoflocalestringsthatcontainoneormorelanguageorlocaletags.Ifyouincludemorethanonelocalestring,listthemindescendingorderofprioritysothatthefirstentryisthepreferredlocale.Ifyouomitthisparameter,thedefaultlocaleoftheJavaScriptruntimeisused.*@paramoptionsAnobjectthatcontainsoneormorepropertiesthatspecifycomparisonoptions.*/toLocaleTimeString(locales?:string|string[],options?:Intl.DateTimeFormatOptions,):string}````","JavaScript\\TypeScript\\内置API\\index.md":"#内置```ts///<referenceno-default-lib=\"true\"/>```","JavaScript\\TypeScript\\声明文件.md":"#声明文件>`*.d.ts`的使##语法```tsdeclarevar声明全局变量declarefunction声明全局方法declareclass声明全局类declareenum声明全局枚举类型declarenamespace声明（含有子属性的）全局对象interface和type声明全局类型export导出变量exportnamespace导出（含有子属性的）对象exportdefaultES6默认导出export=commonjs导出模块exportasnamespaceUMD库声明全局变量declareglobal扩展全局变量declaremodule扩展模块`///<reference/>`三斜线指令```##模块化（CommonJS）>通过require的方式引入模块化的代码```ts//d.tsdeclaremodule\"ever\"{exporttypea:numberexportfunctionb():numberexportnamespacec{letc:string}}//引用cosntever=require('ever')ever.a=100ever.b=function(){return100+300}```##ES6的模块化方式（importexport）```tsexportdeclareleta1:1exportdeclareleta2:2//或declareleta1:1declareleta2:2export{a1,a2}```##UMD>有一种代码，既可以通过全局变量访问到，也可以通过require的方式访问到。```tsdeclarenamespace${leta:number}declaremodule'$'{export=$}```##引入其他模块```tsimport{FormProps}from'antd'export=GroupexportasnamespaceGroupAliasdeclarenamespaceGroup{interfaceFilterPropsextendsFormProps{isShowResetBtn?:boolean//是否显示重置按钮，默认显示onReset?:(values?:any)=>voidonFinishWithForm?:(params:any)=>void//需要返回form的onFinish函数refForm?:any//class组件传进来的form}}//使用GroupAlias.FilterProps就是当前写的FilterProps```##其他>有时候我们扩展了一些内置对象。给Date的内置对象扩展方法```tsinterfaceDate{format(f:string):string}```","JavaScript\\TypeScript\\忽略检查.md":"#[`忽略检查`](/)-单行忽略(添加到特定行的行前来忽略这一行的错误)```js//@ts-ignore```-跳过对某些文件的检查(添加到该文件的首行才起作用)```js//@ts-nocheck```-对某些文件的检查```js//@ts-check```","JavaScript\\TypeScript\\特性.md":"#特性##交叉类型和联合类型###交叉类型（&相当于与）代表多个类型的合并```tsinterfaceIDog{name:stringage:number}interfaceICat{love:stringage:number}//必须两个同时满足constfirstObj:IDog&ICat={name:'mini',age:24,love:'haha',}```###联合类型（｜相当于或）代表多个类型中的一个或多个```tsletsecondObj:IDog|ICat={//只需满足其中一个类型，或者两个都满足name:'mini',age:56,love:'haha',}console.log(secondObj.age)console.log(secondObj.name)//不允许```上面对象具有联合类型，且满足联合类型中多个类型的情况，此时TS无法准确推断类型，就只能访问他们之间共有的部分age，怎么解决这个问题呢？1、使用typeof或者instanceof，typeof用于基本类型，instanceof用于引用类型2、使用类型断言```tsif((secondObjasIDog).name){console.log((secondObjasIDog).name)}```3、使用类型保护，这种paramisSomeType的形式```tsfunctionisIPerson(obj:IDog|ICat):objisIDog{return(objasIDog).name!==undefined}if(isPerson(secondObj)){console.log(secondObj.name)}```##泛型>泛型使得类型可以编程，可以抽象出适用更加广泛的类型，可以与函数做类比，类型参数就像函数参数一样，可以有默认值，除此之外，还可以用extends对参数本身需要满足的条件进行限制用法：在定义一个`function`、`type`、`interface`、`class`时，名称后面加上<>表示接受类型参数```jsfunctionswap<T,K>(v1:T,v2:K){return[v2,v1];}//此时结果没有按照我们预期的被推断成[K,T]，而是被推断成了(K|T)[]，这是不符合要求的//这是因为TypeScript默认我们数组中的元素是可变的，所以它会「推断我们可能会改变元素的顺序functionswap<T,K>(v1:T,v2:K){return[v2,v1]asconst;//加上asconst来声明它为常量，严格保证顺序}functionswap1<T,K>(v1:T,v2:K):readonly[K,T]{return[v2,v1];```##nfer、extends关键字###infer>infer的作用是让TypeScript自己推断，并将推断的结果存储到一个临时名字中，且只能用于extends语句中注意⚠️：ReturnType可以获取函数返回值的类型。但要注意不要滥用这个工具类型，这个工具类型是由实现反推约定，容易出错，另外ReturnType过多也会降低代码可读性```ts//btainthereturntypeofafunctiontypetypeReturnType<Textends(...args:any)=>any>=Textends(...args:any)=>inferR?R:any//给函数的返回值类型定义为R临时变量//示例functionf(){return{a:3,b:2}}/*{a:numberb:number}*/typeFReturn=ReturnType<typeoff>```###2、extends>既可当作一个动词来扩展已有类型（接口扩展），也可当作一个形容词来对类型进行条件限定（常常用在泛型中）```jsTextendsU?T:U判断有条件类型```![img](https://pic3.zhimg.com/50/v2-26555ba7f0a83a5c8410161a45b00f35_720w.jpg?source=1940ef5c)![img](https://pic3.zhimg.com/80/v2-26555ba7f0a83a5c8410161a45b00f35_720w.jpg?source=1940ef5c)-Exclude(排除):属于T不属于U的类型联合，不存在时为never-Extract(抽取):属于T且属于U的类型联合，不存在时为neverdemo：```tstypeA=Exclude<'x'|'b','x'|'y'|'z'>constaValue:A='b'//aValue的值只能是'b'```##索引签名&索引类型###索引签名JavaScript在一个对象类型的索引签名上会隐式调用toString方法，无论哪种类型本质上都是字符串的形式存储而在TS中，索引签名的类型必须是string或者number,且强制用户必须明确的写出toString()方法（除了number类型以外）```js/写法1:索引可以是string或者numberinterfaceDemo1{[key:string]:string;}//写法2:索引只能是numberinterfaceDemo2{[key:number]:string;}constres:Demo1={0:'def'};//JS隐式调用toString()方法constres:Demo1={name:'def'};//或者{'name':'def'}constres:Demo2={name:'def'};//或者{'name':'def'}//不允许，报错```当声明一个索引签名时，所有明确的成员都必须符合索引签名```jsinterfaceBar{[key:string]:number;x:number;y:string;//Error:y属性必须为number类型}```###索引类型-keyof>**keyofinterfaceName|typeName**:获取接口或类型上的所有已知属性名的联合，跟Object.keys()有点像，但是keyof取类型的键。容易跟TS中typeof混淆，**typeof后面跟的是值变量,keyof后面是类型变量，他们的返回值都是类型变量**```tsinterfacePerson{name:stringage:number}//typekeys='name'|'age';typekeys=keyofPerson```看下如下demo，定义拿到对象中一部分键值的函数：```tsfunctionpluck<T,KextendskeyofT>(o:T,names:K[]):T[K][]{returnnames.map((n)=>o[n])}//keyofT表示'name'|'age'//KextendskeyofT表示K的取值继承自'name'|'age'//K[]表示数组中的数据类型只能为常量类型'name'｜'age'//T[K]表示Person[name]|Person[age]，也就是string|number，//因此T[K][]表示string[]|number[]或者Array<string|number>interfacePerson{name:stringage:number}letp:Person={name:'funlee',age:21,}letres=pluck(p,['name','age'])//允许```##映射类型你是如何将一个现有类型的每个属性都变为可选的或者部分可选的的？是不是像下面这样```tsinterfacePersonPartial{name?:stringage?:number}//或者interfacePersonPartial{name:stringage?:number}```将每个属性都变为只读的呢？```tsinterfaceIPersonReadonly{readonlyname:stringreadonlyage:number}```上面的用法如果参数很多的时候就不方便了。我们可以利用ts提供的映射类型简写```tstypeReadonly<T>={readonly[PinkeyofT]:T[P]}typePartial<T>={[PinkeyofT]?:T[P]}typePersonReadonly=Readonly<Person>typePersonPartial=Partial<Person>//或者//声明可选参数typePersonPartial={age:number}//声明必填参数typePerson={name:string}&Partial<PersonPartial>```通过这种映射的方式，我们可以将组件的参数进行更好的分类声明，同时也可以避免写多个？或者readonly这种声明方式同理定义可以为空的类型：```tstypeNullrable<T>={[PinkeyofT]:T[P]|null}```##类型推论&类型断言###类型推论如果变量在定义的时候没有赋值，不管之后有没有赋值，都会被推断成any类型而完全不被类型检查###类型断言```ts语法：值as类型或者<类型>值```类型断言的限制总的来说就是：若A兼容B，那么A能够被断言为B，B也能被断言为A-联合类型可以被断言为其中一个类型-父类可以被断言为子类，子类也可以被断言为父类-任何类型都可以被断言为any，any可以被断言为任何类型```tsinterfaceAnimal{name:string}interfaceCat{name:stringrun():void}//等同于interfaceAnimal{name:string}interfaceCatextendsAnimal{run():void}```","JavaScript\\TypeScript\\类型体操.md":"#类型体操-不建议开发使用-可读性很低-主要是为了锻炼ts类型的阅读&书写技巧##基础类型```tstypeatype=numberinterfacebtype{}//常用基础类型typenum=numbertypestri=stringtypefunc=()=>voidtypearr=any[]```##类型体操-前面懂了?开始造飞机!##运算###与-同真反真```tsexporttypeAnd<C1extendsboolean,C2extendsboolean>=C1extendstrue?C2extendstrue?true:false:falseexporttypeAnd3<C1extendsboolean,C2extendsboolean,C3extendsboolean,>=And<And<C1,C2>,C3>exporttypeAnd4<C1extendsboolean,C2extendsboolean,C3extendsboolean,C4extendsboolean,>=And<And3<C1,C2,C3>,C4>```###或-有真为真```tsexporttypeOr<C1extendsboolean,C2extendsboolean>=C1extendstrue?true:C2extendstrue?true:false```###非-真假反转```tsexporttypeNot<Cextendsboolean>=Cextendstrue?false:true```###并集-并集```tsexporttypeSumAggregate<T,U>=T|U```-其他的可以自行补充##`number`###可转换为`number`的类型```ts/***类number*/exporttypeNumberLike=number|`${number}````###为零```tsexporttypeCheckLeftIsExtendsRight<T,R>=TextendsR?true:falseexporttypeIsZero<NextendsNumberLike>=CheckLeftIsExtendsRight<N,0|'0'>```###大于零```tsexporttypeIsOverZero<NextendsNumberLike>=IsZero<N>extendstrue?false:Stringify<N>extends`${'-'}${inferRest}`?false:true```###小于零```tsexporttypeIsLessZero<NextendsNumberLike>=Not<IsOverZero<N>>```###数字相等```tsexporttypeCheckLeftIsExtendsRight<T,R>=TextendsR?true:falseexporttypeStringify<TextendsCanStringified>=`${T}`exporttypeIsNumberEqual<LextendsNumberLike,RextendsNumberLike,Strictextendsboolean=true,>=Strictextendstrue?CheckLeftIsExtendsRight<L,R>:CheckLeftIsExtendsRight<Stringify<L>,Stringify<R>>```###数字不相等```tsexporttypeIsNumberNotEqual<LextendsNumberLike,RextendsNumberLike,Strictextendsboolean=true,>=Not<IsNumberEqual<L,R,Strict>>```###两数相加```tsexporttypeGetTupleHelper<Lengthextendsnumber=0,Rextendsunknown[]=[],>=R['length']extendsLength?R:GetTupleHelper<Length,[...R,unknown]>//构造长度一定（Length）的元组exporttypeGetTuple<Lengthextendsnumber=0>=GetTupleHelper<Length>exporttypeIntAddSingleHepler<N1extendsnumber,N2extendsnumber>=[...GetTuple<N1>,...GetTuple<N2>,]['length']//N1和N2最大支持999exporttypeIntAddSingle<N1extendsnumber,N2extendsnumber>=IntAddSingleHepler<N1,N2>extendsnumber?IntAddSingleHepler<N1,N2>:number```###两数相减```tsexporttypePop<Textendsunknown[]>=Textends[...inferrest,inferR]?rest:neverexporttypeGetTupleHelper<Lengthextendsnumber=0,Rextendsunknown[]=[],>=R['length']extendsLength?R:GetTupleHelper<Length,[...R,unknown]>exporttypeGetTuple<Lengthextendsnumber=0>=GetTupleHelper<Length>exporttypeIntMinusSingleAbsHelper<N1extendsnumber,N2extendsnumber,T1extendsunknown[]=GetTuple<N1>,T2extendsunknown[]=GetTuple<N2>,>=IsNotEqual<N1,N2,true>extendstrue?Or<IsZero<T1['length']>,IsZero<T2['length']>>extendstrue?IsZero<T1['length']>extendstrue?T2['length']:T1['length']:IntMinusSingleAbsHelper<Pop<T1>['length'],Pop<T2>['length']>:0//由于元组长度只能为正,所以结果只能拿到绝对值exporttypeIntMinusSingleAbs<N1extendsnumber,N2extendsnumber,>=IntMinusSingleAbsHelper<N1,N2>```##`Array`###生成指定长度的数组```tstypeGetTupleHelper<Lengthextendsnumber=0,Rextendsunknown[]=[],>=R['length']extendsLength?R:GetTupleHelper<Length,[...R,unknown]>exporttypeGetTuple<Lengthextendsnumber=0>=GetTupleHelper<Length>```###Filter```tsexporttypeFilter<Textendsunknown[],C,Strictextendsboolean=false,>=FilterHelper<T,C,Strict>typeFilterHelper<Textendsunknown[],C,Strictextendsboolean,Offsetextendsnumber=0,Cacheextendsunknown[]=[],>=OffsetextendsT['length']?Cache:FilterHelper<T,C,Strict,IntAddSingle<Offset,1>,And<Strict,IsTempEqual<T[Offset],C>>extendstrue?Push<Cache,T[Offset]>:And<Not<Strict>,CheckLeftIsExtendsRight<T[Offset],C>>extendstrue?Push<Cache,T[Offset]>:Cache>```###Fill```ts/***以指定类型填充元组类型*@example*typeResult=Fill<['1','2',3,any],1>//[1,1,1,1]*/exporttypeFill<Textendsunknown[],F=undefined>=FillHelper<T,F>typeFillHelper<Textendsunknown[],F,Offsetextendsnumber=0,>=T['length']extends0?F[]:OffsetextendsT['length']?IsTempEqual<T,F[]>extendstrue/**any[]->T[]*/?T:F[]:FillHelper<Push<Shift<T>,F>,F,IntAddSingle<Offset,1>>```###Some```tstypeSomeHelper<Textendsunknown[],Check,Offsetextendsnumber=0,CacheBoolextendsboolean=false,>=T['length']extendsOffset?CacheBool:SomeHelper<T,Check,IntAddSingle<Offset,1>,Or<CheckLeftIsExtendsRight<T[Offset],Check>,CacheBool>>/***校验元组中是否有类型符合条件*@example*typeResult=Every<['1','2',3],number>//true*/exporttypeSome<Textendsunknown[],Check>=SomeHelper<T,Check>```###Every```tstypeEveryHelper<Textendsunknown[],Check,Offsetextendsnumber=0,CacheBoolextendsboolean=true,>=T['length']extendsOffset?CacheBool:EveryHelper<T,Check,IntAddSingle<Offset,1>,And<CheckLeftIsExtendsRight<T[Offset],Check>,CacheBool>>/***校验元组中每个类型是否都符合条件*@example*typeResult=Every<[1,2,3],number>//true*/exporttypeEvery<Textendsunknown[],Check>=T['length']extends0?false:EveryHelper<T,Check>```###TupleToUnion```ts/***@description从数组类型构造联合型*[number,string]=>number|string*/exporttypeTupleToUnion<Textendsunknown[]>=T[number]```###Pop```tsexporttypePop<Textendsunknown[]>=Textends[...inferrest,inferR]?rest:never```###Push```ts/***在元组最后插入一位*@example*typeResult=Push<[1,2,3],4>//[1,2,3，4]*/exporttypePush<Textendsunknown[],Item>=[...T,Item]```###Shift```ts/***去除元组最开始元素*/exporttypeShift<Textendsunknown[]>=Textends[inferR,...inferrest]?rest:never```###UnShift```ts/***在元组最开始插入元素*/exporttypeUnShift<Textendsunknown[],Item>=[Item,...T]typeSetHelper<Textendsunknown[],Indexextendsnumber,Value,Offsetextendsnumber=0,Cacheextendsunknown[]=[],>=OffsetextendsT['length']?Cache:SetHelper<T,Index,Value,IntAddSingle<Offset,1>,Push<Cache,OffsetextendsIndex?Value:T[Offset]>>```###ArraySet```ts/***更改元组中指定索引位的类型*@example*typeResult=ArraySet<[1,2,3],2,4>//[1,2,4]*/exporttypeArraySet<Textendsunknown[],Indexextendsnumber,Value,>=SetHelper<T,Index,Value>```###Concat```ts//连接两个数组exporttypeConcat<Textendsunknown[],Rextendsunknown[]>=[...T,...R]```###Join```ts/***将元组类型拼接成字符串类型*@example*typeResult=Join<[1,2,3]>//\"1,2,3\"*/exporttypeJoin<TextendsCanStringified[],SplitStrextendsCanStringified=',',>=T['length']extends0?'':Textends[inferLeft,...inferRightRest]?LeftextendsCanStringified?RightRestextendsCanStringified[]?`${Left}${T['length']extends1?'':SplitStr}${Join<RightRest,SplitStr>}`:never:never:never```##funtion```ts//任意普通functionexporttypeNoop=(...args:any[])=>anyexporttypeFunc=(...args:any[])=>anyexporttypeAsyncFunc=(...args:any[])=>any//获取异步函数的返回值exporttypeGetAsyncFunctionReturnType<FextendsNoop>=Awaited<ReturnType<F>>//获取参数长度exporttypeGetFunctionLength<FextendsNoop>=Fextends(...args:inferP)=>any?P['length']:never//获取function参数exporttypeGetParams<FuncextendsNoop>=Funcextends(...args:inferargs)=>any?args:never//获取function返回值exporttypeGetReturnType<FuncextendsNoop>=Funcextends(...args:any)=>inferReturn?Return:never```##string```tsimport{IntAddSingle}from'./number'import{Compare}from'./helper'import{Push,Or,IsEqual,And3,Join}from'./index'//将类型转为字符串有一定的限制，仅支持下面的类型exporttypeCanStringified=|string|number|bigint|boolean|null|undefined//将支持的类型转化为字符串exporttypeStringify<TextendsCanStringified>=`${T}`exporttypeToUpperCase<Sextendsstring>=Uppercase<S>//转大写exporttypeToLowerCase<Sextendsstring>=Lowercase<S>//转小写typeSubStringHelper<Sextendsstring,Startextendsnumber,Endextendsnumber,Offsetextendsnumber=0,Cacheextendsstring[]=[],>=IsEqual<Offset,End>extendstrue?Join<Cache,''>:SubStringHelper<S,Start,End,IntAddSingle<Offset,1>,And3<Or<Compare<Offset,Start>,IsEqual<Offset,Start>>,Or<Compare<End,Offset>,IsEqual<Offset,End>>,CharAt<S,Offset>extendsstring?true:false>extendstrue?Push<Cache,CharAt<S,Offset>>:Cache>/***在字符串中抽取从开始下标开始的指定数目的字符*@example*typeResult=SubStr<'123',1,3>//'23'*/exporttypeSubString<Sextendsstring,Startextendsnumber,Endextendsnumber,>=SubStringHelper<S,Start,End>exporttypeSubStr<Sextendsstring,Startextendsnumber,Lenextendsnumber,>=SubStringHelper<S,Start,IntAddSingle<Start,Len>>/***去除左空格*/exporttypeTrimLeft<strextendsstring>=strextends`${''|'\\t'|'\\n'|'\\n'}${inferrest}`?TrimLeft<rest>:str/***去除右空格*/exporttypeTrimRight<strextendsstring>=strextends`${inferrest}${''|'\\t'|'\\n'|'\\n'}`?TrimRight<rest>:str/***去除左右空格*/exporttypeTrim<strextendsstring>=TrimLeft<TrimRight<str>>typeSplitHelper<Sextendsstring,SplitStrextendsstring='',Textendsstring[]=[],>=Sextends`${inferChar}${SplitStr}${inferRest}`?SplitHelper<Rest,SplitStr,Push<T,Char>>:Sextendsstring?Sextends''?T:Push<T,S>:never/***拆分字符串变为一个元组*@example*typeResult=Split<'1,2,3',','>//[1,2,3]*/exporttypeSplit<Sextendsstring,SplitStrextendsstring=''>=SplitHelper<S,SplitStr>/***获取模板字符串类型中的字符*/exporttypeGetChars<S>=GetCharsHelper<S,never>typeGetCharsHelper<S,Acc>=Sextends`${inferChar}${inferRest}`?GetCharsHelper<Rest,Char|Acc>:Acc/***获取字符串的长度*@example*typeResult=GetStringLength<\"123\">//3*/exporttypeGetStringLength<Sextendsstring>=Split<S>['length']/***获取字符串在索引位I下的字符*@example*typeResult=CharAt<\"123\",1>//\"2\"*/exporttypeCharAt<Sextendsstring,Iextendsnumber>=Split<S>[I]/***拼接两个字符串*@example*typeResult=ConcatString<\"123\",\"456\">//\"123456\"*/exporttypeConcatString<S1extendsstring,S2extendsstring>=`${S1}${S2}`/***判断字符串是否包含子串*@example*/exporttypeIncludeString<S1extendsstring,S2extendsstring,>=S1extends`${inferLeft}${S2}${inferRight}`?true:false//eslint-disable-line/***判断字符串是否以子串为起始*@example*typeResult=StartsWith<\"123\",\"12\">//true*/exporttypeStartsWith<S1extendsstring,S2extendsstring,>=S1extends`${S2}${inferRight}`?true:false//eslint-disable-line/***判断字符串是否以子串为结束*@example*typeResult=EndsWith<\"123\",\"23\">//true*/exporttypeEndsWith<S1extendsstring,S2extendsstring,>=S1extends`${inferLeft}${S2}`?true:false//eslint-disable-linetypeIndexOfHelper<S1extendsstring,S2extendsstring,Len1extendsnumber=GetStringLength<S1>,Len2extendsnumber=GetStringLength<S2>,>=Or<Compare<Len1,Len2>,IsEqual<Len1,Len2>>extendstrue?S1extends`${inferLeft}${S2}${inferRight}`//eslint-disable-line?GetStringLength<Left>:-1:-1/***从左往右查找子串的位置*@example*typeResult=IndexOf<\"123\",\"23\">//1*/exporttypeIndexOf<S1extendsstring,S2extendsstring>=IndexOfHelper<S1,S2>/***在字符串中查找并替换一处子串*MatchStr不支持正则*@example*typeResult=Replace<\"23123\",\"23\",\"xx\">//\"xx123\"*/exporttypeReplace<Sextendsstring,MatchStrextendsstring,ReplaceStrextendsstring,>=Sextends`${inferLeft}${MatchStr}${inferRight}`?`${Left}${ReplaceStr}${Right}`:S/***在字符串中查找并替换所有子串*@example*typeResult=Replace<\"23123\",\"23\",\"xx\">//\"xx1xx\"*/exporttypeReplaceAll<Sextendsstring,MatchStrextendsstring,ReplaceStrextendsstring,>=IncludeString<S,MatchStr>extendstrue?ReplaceAll<Replace<S,MatchStr,ReplaceStr>,MatchStr,ReplaceStr>:StypeLastIndexOfHelper<S1extendsstring,S2extendsstring,Indexextendsnumber=-1/**当前从左往右匹配最大的值，匹配不到以后，上一次匹配的索引就是从右往左第一个的索引*/,AddOffsetextendsnumber=0/**每次从左往右匹配并替换成空串后，下次循序需要累加的值*/,>=S1extends`${inferLeft}${S2}${inferRight}`//eslint-disable-line?LastIndexOfHelper<Replace<S1,S2,''>,S2,IntAddSingle<GetStringLength<Left>,AddOffset>,IntAddSingle<AddOffset,GetStringLength<S2>>>:Index/***从右往左查找子串的位置*@example*typeResult=LastIndexOf<\"23123\",\"23\">//3*/exporttypeLastIndexOf<S1extendsstring,S2extendsstring,>=LastIndexOfHelper<S1,S2>typeRepeatHelper<Sextendsstring,Timesextendsnumber,OriginStrextendsstring=S,Offsetextendsnumber=1,>=Timesextends0?'':IsEqual<Times,Offset>extendstrue?S:`${OriginStr}${RepeatHelper<S,Times,OriginStr,IntAddSingle<Offset,1>>}`/***重复Times次数的字符串*@example*typeResult=Repeat<\"1\",5>//\"11111\"*/exporttypeRepeat<Sextendsstring,Timesextendsnumber=1>=RepeatHelper<S,Times>typePadHelper<Sextendsstring,Nextendsnumber=0,FillSextendsstring='',IsStartextendsboolean=true,Lenextendsnumber=GetStringLength<S>,Offsetextendsnumber=Len,>=Compare<N,Len>extendstrue?IsEqual<N,Offset>extendstrue?S:PadHelper<`${IsStartextendstrue?FillS:''}${S}${IsStartextendsfalse?FillS:''}`,N,FillS,IsStart,Len,IntAddSingle<Offset,1>>:S/***当字符串不满足给定的长度时，在字符串前面填充使其满足长度*@example*typeResult=PadStart<'0123',10>//'0123'*/exporttypePadStart<Sextendsstring,Nextendsnumber=0,FillSextendsstring='',>=PadHelper<S,N,FillS>/***当字符串不满足给定的长度时，在字符串后面填充使其满足长度*@example*typeResult=PadStart<'0123',10>//'0123'*/exporttypePadEnd<Sextendsstring,Nextendsnumber=0,FillSextendsstring='',>=PadHelper<S,N,FillS,false>```##总结-巧用泛型里面的属性可以当做临时变量使用-`infer`关键字类似正则的断言,具体的可以自己看上面栗子了解","JavaScript\\TypeScript\\类型工具.md":"#type类型工具##获取types类型的key合集```tsexporttypeClothes<source,types>={[Kinkeyofsource]:source[K]extendstypes?K:never}[keyofsource]```##挑选指定类型成为新的类型```tsexporttypePick<T,KextendskeyofT>={[PinK]:T[P]}```##过滤类型```tsexporttypeFilterType<Source,Types>=Pick<Source,{[KinkeyofSource]:Source[K]extendsTypes?K:never}[keyofSource]>```##删除类型```ts/***T:待编辑的基本类型*K:要删除的类型*/exporttypeOmit<T,Kextendskeyofany>=Pick<T,Exclude<keyofT,K>>//将属性变成可选exporttypePartial<T>={[PinkeyofT]?:T[P]}```##删除类型集合```tsexporttypeExclude<T,U>=TextendsU?never:T```##所有属性变成只读```ts!exporttypeReadonly<T>={readonly[PinkeyofT]:T[P]}```##获取函数T的返回类型```tsexporttypeReturnType<T=any>=Textends(...args:any)=>inferR?R:any```##获取函数参数数组```tsexporttypeParameters<T>=Textends(...arg:inferP)=>void?P:string```","JavaScript\\TypeScript\\类型过滤.md":"#类型过滤![](/.assets/img/2022-02-09-14-14-49.png)```tsinterfaceExample{a:string;b:number;c:number;d:string;...}```>有一个Example的接口，但是咱们现在想对这个接口做一些处理，只希望留下类型为string的属性>就可以使用咱们自己定义的FilterType```tstypenewExample=FilterType<Example,string>//{a:string;d:string;...}``````tstypeFilterType<Source,Types>=Pick<Source,{[KinkeyofSource]:Source[K]extendsTypes?K:never}[keyofSource]>```##in>in遍历枚举类型```tstypeExample='a'|'b'|'c'|'d'typeObj={[TinExample]:string//遍历Example，把每个key都赋值string类型}/*等价于typeObj={a:string;b:string;c:string;d:string;}*/```##keyof>索引类型查询操作符:获取到类型的key类似Object.keys()```tsinterfaceExample{a:stringb:stringc:numberd:boolean}typeKeys=keyofExample//等价于typeKeys='a'|'b'|'c'|'d'```##条件判断```tsinterfaceA{a:string}interfaceBextendsA{b:string}//B是否继承于A？若是，则为number类型；若不是，则为string类型typeC=BextendsA?number:string//等价于typeC=number```##索引访问接口属性```tstypeperson={name:'Angus'height:185}['name'|'height']```等价于```tstypeperson='Angus'|185``````tstypeperson={name:'Angus'height:185girlFriend:never}['name'|'height'|'girlFriend']```等价于```tstypeperson='Angus'|185```","JavaScript\\TypeScript\\错误\\2709.md":"#2709-非类型模块应该和类型模块分开导出,和使用","JavaScript\\TypeScript\\错误\\6053.md":"#rpt2:optionserrorTS6053:File'C:/XXXX/npm/mock-record/node_modules/_tsconfig@7.0.0@tsconfig/dist/tsconfig.spec.d.ts'notfound```shellrpt2:optionserrorTS6053:File'C:/XXXX/npm/mock-record/node_modules/_tsconfig@7.0.0@tsconfig/dist/tsconfig.spec.d.ts'notfound.Thefileisintheprogrambecause:Rootfilespecifiedforcompilation```解决:```ts{\"exclude\":[...,\"**/*.spec.d.ts\"]}```","JavaScript\\函数\\call&apply&bind.md":"#call&apply&bind>call,bind,apply第一参数都是this的指向对象>>call和bind的写法几乎相同,但是bind是返回的是函数>>apply只能传输一个变量```jsvarname='guanruihua'varage='23'varobj={name:'mawenliang',age:22,fn:function(){console.log(this.name+this.age)},fn2:function(fm,ft){console.log(this.name+this.age+'aa'+fm+'bb'+ft)},}varobj2={name:'haungzelin',age:21,}obj.fn.call(obj2)obj.fn.apply(obj2)obj.fn.bind(obj2)()obj.fn2.call(obj2,'成都','上海')obj.fn2.apply(obj2,['成都','上海'])obj.fn2.bind(obj2,'成都','上海')()```运行结果```jshaungzelin21haungzelin21haungzelin21haungzelin21aa成都bb上海haungzelin21aa成都bb上海haungzelin21aa成都bb上海```","JavaScript\\函数\\index.md":"#函数##**定义方法**>静态方法function函数名([参数]){}>>动态匿名var函数名=newFunction([\"虚参列表\"],\"函数体\");>>**直接变量**函数名=function([虚参列表]){函数体;}###函数声明```js//ES5function[name](){}function(){}//匿名函数//ES6()=>{}//函数体只有一行{}和return可以省略```###函数表达式```js//ES5varsum=function(){}//ES6letsum=()=>{}//函数体只有一行{}和return可以省略```###构造函数```jsconstsum=newFunction('a','b','returna+b')```###三种方法对比>1.函数声明有预解析,而且函数声明的优先级高于变量;>2.使用Function构造函数定义函数的方式是一个函数表达式,这种方式会导致解析两次代码，影响性能。>1.第一次解析常规的JavaScript代码>2.第二次解析传入构造函数的字符串---##Rest参数>rest:剩余部分```jsfunctionsum(...nums){letnum=0nums.forEach(function(item){num+=item*1})returnnum}console.log(sum(1,2,3))//6console.log(sum(1,2,3,4))//10```##name属性```jsfunctionfoo(){}foo.name//\"foo\"s```##调用>-直接调用:函数名(实参列表)>-在连接中调用:`<ahref=\"javascript:函数名()\">tap</a>`>-在事件中调用:事件类型=\"函数名()\">-递归调用###ES5>ES5函数内容的this指向和调用方法相关####调用模式>函数名()和匿名函数调用,this指向window```jsfunctiongetSum(){console.log(this)//这个属于函数名调用，this指向window}getSum()(function(){console.log(this)//匿名函数调用，this指向window})()vargetSum=function(){console.log(this)//实际上也是函数名调用，window}getSum()```####方法调用>`对象.方法名()`,this指向对象```jsvarobj={name:'methods',getSum:function(){console.log(this)//objList对象},}obj.getSum()```####构造器调用>new关键词,this指向实例化的对象;```jsfunctionPerson(){console.log(this)//是构造函数调用，指向实例化的对象personOne}varpersonOne=newPerson()```####间接调用>利用call和apply来实现,this就是call和apply对应的第一个参数,如果不传值或者第一个值为null,undefined时this指向window通过call/apply如果第一个参数是string、number、boolean，call内部会调用其相应的构造器String、Numer、Boolean将其转换为相应的实例对象```jsfunctionfoo(){console.log(this)}foo.apply('我是apply改变的this值')//我是apply改变的this值foo.call('我是call改变的this值')//我是call改变的this值```###ES6箭头函数>-==箭头函数==不可以作为构造函数使用>-不可以使用arguments对象>-this的指向定义时所在的对象,而不是调用的对象>-不可以通过new实例化对象>-调用就是调用模式```js;(()=>{console.log(this)//window})()letarrowFun=()=>{console.log(this)//window}arrowFun()letarrowObj={arrFun:function(){;(()=>{console.log(this)//this指向的是arrowObj对象})()},}arrowObj.arrFun()```##方法>-IE5之前不支持call和apply,bind是ES5出来的;>-call和apply可以调用函数,改变this,实现继承和借用别的对象的方法;>-apply:>>-将函数作为对象的方法来调用>-将参数以数组形式传递给改方法(多个参)>>-#####call>>-将函数作为对象的方法来调用>-将指定参数传递给该方法(一个参)>>-toString###call和apply>1.间接调用函数,改变作用域的this的值>2.劫持其他对象方法>3.调用方法,用一个对象替换掉另一个对象(this)>1.`对象.call(新this对象,实参1,实参2,实参3.....)`>2.`对象.apply(新this对象,[实参1,实参2,实参3.....])````jsvarfoo={name:'张三',logName:function(){console.log(this.name)},}varbar={name:'李四',}foo.logName.call(bar)//李四//实质是call改变了foo的this指向为bar,并调用该函数```####两个函数继承```jsfunctionAnimal(name){this.name=namethis.showName=function(){console.log(this.name)}}functionCat(name){Animal.call(this,name)}varcat=newCat('BlackCat')cat.showName()//BlackCat```###其他运用```jsletarr1=[1,2,3]letarr2=[4,5,6]Array.prototype.push.apply(arr1,arr2)//将arr2合并到了arr1中console.log('max:',Math.max.apply(null,arr1))//max:6console.log('arr1:',arr1)//arr1:[1,2,3,4,5,6]console.log('type:',Object.prototype.toString.call({}))//type:[ObjectObject]console.log('type:',Object.prototype.toString.call(arr1))//type:[Objectarrary]```###bind>-是`function`一个函数拓展方法>-bind以后的代码重新绑定了func内部的this指向,返回一个函数,不会调用方法>-不兼容`IE8````jsletfoo={name:'张三',logName:function(age){console.log(this.name,age)},}letfooNewBind=foo.logName.bind(foo)fooNewBind(11)//张三,11因为bind改变了fooNewBind里面的this指向```###callapplybind原理####call```js//callFunction.prototype.newCall=function(context,...parameter){if(typeofcontext==='object'||typeofcontext==='function'){context=context||window}else{context=Object.create(null)}letfn=Symbol()context[fn]=thisconstres=context[fn](...parameter)deletecontext.fnreturnres}letperson={name:'Abiel',}functionsayHi(age,sex){console.log(this.name,age,sex)}sayHi.newCall(person,25,'男')//Abiel25男```####apply```js//applyFunction.prototype.newApply=function(context,parameter){if(typeofcontext==='object'||typeofcontext==='function'){context=context||window}else{context=Object.create(null)}letfn=Symbol()context[fn]=thisconstres=context[fn](...parameter)deletecontext[fn]returnres}letperson={name:'Abiel',}functionsayHi(age,sex){console.log(this.name,age,sex)}sayHi.newApply(person,[25,'男'])//Abiel25男```####bind```js//bindFunction.prototype.bind=function(context,...innerArgs){varme=thisreturnfunction(...finnalyArgs){returnme.call(context,...innerArgs,...finnalyArgs)}}letperson={name:'Abiel',}functionsayHi(age,sex){console.log(this.name,age,sex)}letpersonSayHi=sayHi.bind(person,25)personSayHi('男')```##arguments对象>-功能:存放实参的参数列表>-特性:>-仅能在函数体内使用>-带有下标属性,当并非数组>-函数声明自动初始化>-属性:>-length>-callee当前正指向的函数>-caler抵用当前正在执行函数的函数名##指针标识>-this指向当前操作对象>-callee指向参数集合所处函数>-prototype指向函数附带的原型对象>-constructor指向创建该对象的构造函数","JavaScript\\函数\\原型链.md":"#原型链>-对象集成属性的一个链条>-原型对象默认的==constructor==属性指向构造函数<!--![图片描述](.assets/8e320268216e4c4b992a5f119c734acctplv-k3u1fbpfcp-zoom-1.image)-->```jsvarPerson=function(name){this.name=name}//person是构造函数varo3=newPerson('personTwo')//o3是实例o3//Persion{name:\"persionTwo\"}Person//f(name){this.name=name;}```<!--![image-20210603150948491](.assets/image-20210603150948491-1622704190338.png)-->##实例化方法###字面量```jsletobj={name:'grh'}```###Object构造函数创建```jsletobj=newObject()obj.name='grh'```###工厂模式创建对象```jsfunctioncreatePerson(name){letro=newObject();o.name=name;returno;}letperson1=createPerson('grh');```###使用构造函数创建对象```jsfunctionPerson(name){this.name=name}letperson=newPerson('grh')```##new运算符>1.创建一个新的对象>2.==this==指向构造函数>3.构造函数有返回,会替代new出来的对象,如果没有就是new出来的对象>4.手动封装一个new运算符##对象的原型链<!--![图片描述](.assets/8b03fb5eae9d431aaca1e73925a2b24etplv-k3u1fbpfcp-zoom-1.image)-->##继承方式###原型链继承>-将父类的实例封装作为子类的原型>-优缺点>-简单易于实现>-想为子类新增属性和方法,必须要在`newAnimal()`之后```js//定义一个动物类functionAnimal(name){//属性this.name=name||'Animal'//实例方法this.sleep=function(){console.log(this.name+'正在睡觉！')}}//原型方法Animal.prototype.eat=function(food){console.log(this.name+'正在吃：'+food)}//子类functionCat(){}Cat.prototype=newAnimal()Cat.prototype.name='cat'//TestCodevarcat=newCat()console.log(cat.name)//catconsole.log(cat.eat('fish'))//cat正在吃：fishundefinedconsole.log(cat.sleep())//cat正在睡觉！undefinedconsole.log(catinstanceofAnimal)//trueconsole.log(catinstanceofCat)//true```###构造继承>-利用call来改变Cat中的this指向>-优缺点>-可以实现多继承>-不能继承原型属性/方法```jsfunctionCat(name){Animal.call(this)this.name=name||''}```###实例继承>-为父类实例添加新特性,作为子类实例返回>-优缺点>-不限制调用方法,但不能实现多继承```jsfunctionCat(name){letinstance=newAnimal()instance.name=name||''returninstance}```###拷贝继承>-将父类属性和方法拷贝一份到子类中>-优缺点>-支持多继承>-效率低,占用内存```jsfunctionCat(name){varanimal=newAnimal()for(varpinanimal){Cat.prototype[p]=animal[p]}Cat.prototype.name=name||'Tom'}```###组合继承>-通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用```jsfunctionCat(name){Animal.call(this)this.name=name||'Tom'}Cat.prototype=newAnimal()Cat.prototype.constructor=Cat```###寄生组合继承```jsfunctionCat(name){Animal.call(this)this.name=name||'Tom'};(function(){//创建一个没有实例方法的类varSuper=function(){}Super.prototype=Animal.prototype//将实例作为子类的原型Cat.prototype=newSuper()})()```###ES6extend继承-ES6的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this```js//父类classPerson{//constructor是构造方法constructor(skin,language){this.skin=skinthis.language=language}say(){console.log('我是父类')}}//子类classChineseextendsPerson{constructor(skin,language,positon){//console.log(this);//报错super(skin,language)//super();相当于父类的构造函数//console.log(this);调用super后得到了this，不报错，this指向子类，相当于调用了父类.prototype.constructor.call(this)this.positon=positon}aboutMe(){console.log(`${this.skin}${this.language}${this.positon}`)}}//调用只能通过new的方法得到实例,再调用里面的方法letobj=newChinese('红色','中文','香港')obj.aboutMe()obj.say()```","JavaScript\\函数\\异步处理.md":"#异步处理>async和yield可以处理异步方法##asyncawait>await可以让异步函数或方法同步执行```jsconstA=()=>console.log('a')constB=()=>console.log('b')asyncfunctionasyncFn(){console.log('start')awaitA()awaitnewPromise((resolve)=>{console.log('waitresult')resolve()})constdata=awaitnewPromise((resolve)=>resolve(1))console.log(data)//1awaitB()console.log('end')}asyncFn()```##yield\\*>和next()一起使用,每次使用next都会运行一个yield```jsfunction*yieldFunc(){console.log('start')yieldA()constdata=yieldnewPromise((resolve)=>resolve(1))console.log(data)yieldB()console.log('end')}functionrunYieldFunc(){letyieldFn=yieldFunc()yieldFn.next()constdp=yieldFn.next()console.log(dp)dp.value.then((data)=>{console.log(data)//在最后输出1})yieldFn.next()yieldFn.next()}runYieldFunc()```","JavaScript\\函数\\继承.md":"#Function继承既然要实现继承，那么首先我们得有一个父类，代码如下：```js//定义一个动物类functionAnimal(name){//属性this.name=name||'Animal'//实例方法this.sleep=function(){console.log(this.name+'正在睡觉！')}}//原型方法Animal.prototype.eat=function(food){console.log(this.name+'正在吃：'+food)}```##1、原型链继承**核心：**将父类的实例作为子类的原型```jsfunctionCat(){}Cat.prototype=newAnimal()Cat.prototype.name='cat'//TestCodevarcat=newCat()console.log(cat.name)console.log(cat.eat('fish'))console.log(cat.sleep())console.log(catinstanceofAnimal)//trueconsole.log(catinstanceofCat)//true```特点：1.非常纯粹的继承关系，实例是子类的实例，也是父类的实例2.父类新增原型方法/原型属性，子类都能访问到3.简单，易于实现缺点：1.要想为子类新增属性和方法，必须要在`newAnimal()`这样的语句之后执行，不能放到构造器中2.无法实现多继承3.来自原型对象的所有属性被所有实例共享（来自原型对象的引用属性是所有实例共享的）（详细请看附录代码：示例1）4.创建子类实例时，无法向父类构造函数传参推荐指数：★★（3、4两大致命缺陷）**2017-8-1710:21:43补充：感谢[MMHS](http://home.cnblogs.com/u/1066372/)指出。缺点1中描述有误：可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在`newAnimal()`这样的语句之后执行。****2018-9-1000:03:45补充：感谢[IRVING_J](https://www.cnblogs.com/lianghaijie-ctw/)指出。缺点3中的描述不够充分。更正为：来自原型对象的所有属性被所有实例共享。**##2、构造继承**核心：**使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）```jsfunctionCat(name){Animal.call(this)this.name=name||'Tom'}//TestCodevarcat=newCat()console.log(cat.name)console.log(cat.sleep())console.log(catinstanceofAnimal)//falseconsole.log(catinstanceofCat)//true```特点：1.解决了1中，子类实例共享父类引用属性的问题2.创建子类实例时，可以向父类传递参数3.可以实现多继承（call多个父类对象）缺点：1.实例并不是父类的实例，只是子类的实例2.只能继承父类的实例属性和方法，不能继承原型属性/方法3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能推荐指数：★★（缺点3）##3、实例继承**核心：**为父类实例添加新特性，作为子类实例返回```jsfunctionCat(name){varinstance=newAnimal()instance.name=name||'Tom'returninstance}//TestCodevarcat=newCat()console.log(cat.name)console.log(cat.sleep())console.log(catinstanceofAnimal)//trueconsole.log(catinstanceofCat)//false```特点：1.不限制调用方式，不管是`new子类()`还是`子类()`,返回的对象具有相同的效果缺点：1.实例是父类的实例，不是子类的实例2.不支持多继承推荐指数：★★##4、拷贝继承```jsfunctionCat(name){varanimal=newAnimal()for(varpinanimal){Cat.prototype[p]=animal[p]}//2020年10月10日21点36分：感谢@baclt的指出，如下实现修改了原型对象，会导致单个实例修改name，会影响所有实例的name值//Cat.prototype.name=name||'Tom';错误的语句，下一句为正确的实现this.name=name||'Tom';}//TestCodevarcat=newCat()console.log(cat.name)console.log(cat.sleep())console.log(catinstanceofAnimal)//falseconsole.log(catinstanceofCat)//true```特点：1.支持多继承缺点：1.效率较低，内存占用高（因为要拷贝父类的属性）2.无法获取父类不可枚举的方法（不可枚举方法，不能使用forin访问到）推荐指数：★（缺点1）##5、组合继承**核心：**通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用```jsfunctionCat(name){Animal.call(this)this.name=name||'Tom'}Cat.prototype=newAnimal()//感谢@学无止境c的提醒，组合继承也是需要修复构造函数指向的。Cat.prototype.constructor=Cat;//TestCodevarcat=newCat()console.log(cat.name)console.log(cat.sleep())console.log(catinstanceofAnimal)//trueconsole.log(catinstanceofCat)//true```特点：1.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法2.既是子类的实例，也是父类的实例3.不存在引用属性共享问题4.可传参5.函数可复用缺点：1.调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）推荐指数：★★★★（仅仅多消耗了一点内存）##6、寄生组合继承★**核心：**通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点```tsfunctionCat(name){Animal.call(this)this.name=name||'Tom'};(function(){//创建一个没有实例方法的类varSuper=function(){}Super.prototype=Animal.prototype//将实例作为子类的原型Cat.prototype=newSuper()})()//TestCodevarcat=newCat()console.log(cat.name)console.log(cat.sleep())console.log(catinstanceofAnimal)//trueconsole.log(catinstanceofCat)//true感谢@bluedrink提醒，该实现没有修复constructor。Cat.prototype.constructor=Cat;//需要修复下构造函数```特点：1.堪称完美缺点：1.实现较为复杂推荐指数：★★★★（实现复杂，扣掉一颗星）##附录代码：示例一：```tsfunctionAnimal(name){//属性this.name=name||'Animal';//实例方法this.sleep=function(){console.log(this.name+'正在睡觉！');}//实例引用属性this.features=[];}functionCat(name){}Cat.prototype=newAnimal();vartom=newCat('Tom');varkissy=newCat('Kissy');console.log(tom.name);//\"Animal\"console.log(kissy.name);//\"Animal\"console.log(tom.features);//[]console.log(kissy.features);//[]tom.name='Tom-NewName';tom.features.push('eat');//针对父类实例值类型成员的更改，不影响console.log(tom.name);//\"Tom-NewName\"console.log(kissy.name);//\"Animal\"//针对父类实例引用类型成员的更改，会通过影响其他子类实例console.log(tom.features);//['eat']console.log(kissy.features);//['eat']原因分析：关键点：属性查找过程执行tom.features.push，首先找tom对象的实例属性（找不到），那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的features属性中插入值。在console.log(kissy.features);的时候。同上，kissy实例上没有，那么去原型上找。刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。```","JavaScript\\函数\\节流和防抖.md":"#函数节流和防抖##节流>-==高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率==>-应用:scroll,resize事件一段时间触发多次```html<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"/><metahttp-equiv=\"X-UA-Compatible\"content=\"IE=edge\"/><metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\"/><title>节流</title></head><style>*{padding:0;margin:0;}.scroll-box{width:100%;height:500px;background:blue;overflow:auto;}.scroll-item{height:1000px;width:100%;}</style><body><divclass=\"scroll-box\"><divclass=\"scroll-item\"></div></div><script>letthrottle=function(func,delay){lettimer=nullreturnfunction(){if(!timer){timer=setTimeout(()=>{func.apply(this,arguments)//或者直接func()timer=null},delay)}}}//处理函数functionhandle(){console.log(arguments)console.log(Math.random())}//测试用例document.getElementsByClassName('scroll-box')[0].addEventListener('scroll',throttle(handle,3000))</script></body></html>```##防抖>-==触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间==>-应用:sroll,resize时间触发后一段时间触发```html<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"/><metahttp-equiv=\"X-UA-Compatible\"content=\"IE=edge\"/><metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\"/><title>防抖</title></head><style>*{padding:0;margin:0;}.scroll-box{width:100%;height:500px;background:blue;overflow:auto;}.scroll-item{height:1000px;width:100%;}</style><body><divclass=\"scroll-box\"><divclass=\"scroll-item\"></div></div><script>letthrottle=function(func,delay){lettimer=nullreturnfunction(){if(!timer){timer=setTimeout(()=>{func.apply(this,arguments)//或者直接func()timer=null},delay)}}}//处理函数functionhandle(){console.log(arguments)console.log(Math.random())}//测试用例document.getElementsByClassName('scroll-box')[0].addEventListener('scroll',throttle(handle,3000))</script></body></html>```","JavaScript\\函数\\闭包.md":"#闭包##一、获取局部作用域的变量1.通过变量向外传递。```js//通过变量向外传递varb=''functionfn1(){vara='月薪10w'b=a}fn1()console.log(b)//取到函数内局部作用域的变量a的值```2.通过函数向外传递。```js//通过函数传参获取functionfn1(){vara='月薪10w'fn2(a)}functionfn2(str){console.log(str)}fn1()//月薪10w```3.条件和循环体：{}不代表作用域，在es6语法中，{}会被看做代码块，此时在{}当中声明一个函数，相当于`var`声明，尽量不要在{}当中声明函数，否则调用的时候会有问题。```js{functionfn1(){console.log(1)}}console.log(fn1())//1```####二、闭包1.js垃圾回收机制：js中的变量和函数不再使用后，会被自动js垃圾回收机制回收。2.形成闭包的条件：有函数/作用域的嵌套；内部函数引用外部函数的变量/参数。3.闭包的结果：内部函数的使用外部函数的那些变量和参数仍然会保存，使用`return`返回了此内部函数，上面的变量和参数不会被回收。4.闭包的原因：返回的函数并非孤立的函数，而是连同周围的环境（AO）打了一个包，成了一个封闭的环境包，共同返回出来---->闭包。5.我们在返回函数的时候，并不是单纯的返回了一个函数，我们把该函数连同他的AO链一起返回了。6.函数的作用域，取决于声明时而不取决于调用时。7.变量存储`function(){}`、`{}`、`[]`存储的是一个地址。```jsfunctiont1(){varage=20functiont2(){console.log(age)}returnt2}vartmp=t1()varage=1000tmp()//20//win1.AO{t1:function(){},tmp:un,age:un}//2.t11.AO{age:un,t2:fun}//2.AO{age:20,t2:fun}//AO{t1:function(){},tmp:t2,age:1000}////tmpt21.AO{}varage=10functiont1(){varage=20returnfunctiont2(){console.log(++age)}}vart3=t1()t3()//21t3()//22t3()//23console.log(age)//10varage=10functiont1(){varage=20returnfunctiont2(){console.log(++age)}}vart3=t1()vart4=t1()t3()//21t4()//21functionfoo(){vara=2functionbaz(){console.log(a)}bar(baz)}functionbar(fn){vara=3fn()}foo()//2```####三、闭包计数器使用js的命名空间，优点：变量不受污染。```html<script>varchengming={}//js的命名空间一般就是这么写chengming.inc=(function(){varcnt=0returnfunction(){return++cnt}})()console.log(chengming.inc())</script><script>varcnt=100console.log(inc())//报错，window下访问不到inc</script>```####四、循环中的闭包```js<body><inputtype=\"button\"name=\"\"value=\"按钮1\"><inputtype=\"button\"name=\"\"value=\"按钮2\"><inputtype=\"button\"name=\"\"value=\"按钮3\"></body><script>varinp=document.getElementsByTagName('input');for(vari=0;i<inp.length;i++){inp[i].onclick=function(){inp[i].style.background=\"yellow\";}}//点击按钮会报错，因为i在window全局上，for结束之后，本身的值就是3</script>//方法一用自定义属性for(vari=0;i<inp.length;i++){inp[i].i=i;inp[i].onclick=function(){inp[this.i].style.background='yellow';}}//方法一用let关键字for(leti=0;i<inp.length;i++){inp[i].onclick=function(){inp[i].style.background=\"yellow\";}}//方法三使用thisfor(vari=0;i<inp.length;i++){inp[i].onclick=function(){this.style.background=\"yellow\";}}//方法四for循环每次执行，都会立即执行一个匿名函数，并且匿名函数的作用域中传入了当时的i作为参数传递for(vari=0;i<inp.length;i++){(function(i){//AO{i:1}inp[i].onclick=function(){//AO:{}inp[i].style.background='yellow';}})(i)}//方法五for(vari=0;i<inp.length;i++){(function(){//AO{}vararg=i;inp[arg].onclick=function(){//AO:{}inp[arg].style.background='yellow';}})()}//方法六for(vari=0;i<inp.length;i++){inp[i].onclick=function(i){//AO:{i:0}returnfunction(){inp[i].style.background='yellow';}}(i)}//方法七for(vari=0;i<inp.length;i++){(inp[i].onclick=function(){inp[arguments.callee.i].style.background='yellow';}).i=i;}//方法八九基本包装类型for(vari=0;i<inp.length;i++){inp[i].onclick=newFunction(`inp[${i}].style.background='yellow';`);}for(vari=0;i<inp.length;i++){inp[i].onclick=Function(`inp[${i}].style.background='yellow';`);}```","JavaScript\\函数\\高阶函数.md":"#\\高阶函数>-函数的参数是函数或返回函数>-常见的高阶函数:map,reduce,filter,sort##柯里化>`Currying`>>-把接受多个参数的函数变换成接受一个单一参数>-并且返回接受余下的参数而且返回新函数的技术>-多化一###多参数变单一参数>将多个参数的函数变换成单一参数函数```js//正常函数functionadd(x,y){returnx+y}//Currying后functioncurryingAdd(x){returnfunction(y){returnx+y}}console.log(add(1,2),//3curryingAdd(1)(2),//3)```###函数封装>函数封装,通过传入不同参数,变成含有不同功能的函数```js//正常正则验证字符串reg.test(txt)//函数封装后functioncheck(reg,txt){returnreg.test(txt)}check(/\\d+/g,'test')//falsecheck(/[a-z]+/g,'test')//true//Currying后functioncurryingCheck(reg){returnfunction(txt){returnreg.test(txt)}}varhasNumber=curryingCheck(/\\d+/g)varhasLetter=curryingCheck(/[a-z]+/g)console.log(hasNumber('test1'),//truehasNumber('testtest'),//falsehasLetter('21212'),//false)```###柯里化实现多种传参方式>利用柯里化函数特性,可以实现不同的传参方式```jsfunctionadd2(){//第一次执行时，定义一个数组专门用来存储所有的参数var_args=Array.prototype.slice.call(arguments)//在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值var_adder=function(){_args.push(...arguments)return_adder}//利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回_adder.toString=function(){//console.log(_args);return_args.reduce(function(a,b){returna+b})}return_adder}letadd2a=add2(1)(2)(3).toString()letadd2b=add2(1,2,3).toString()console.log(add2a)``````jsfn(a,b,c,d)=>fn(a)(b)(c)(d)constcurrying=fn=>{constlen=fn.lengthreturnfunctioncurr(...args1){if(args1.length>=len){returnfn(...args1)}return(...args2)=>curr(...args1,...args2)}}```##反柯里化>-其实真正的反柯里化的作用是扩大适用范围，就是说当我们调用某个方法的时候，不需要考虑这个对象自身在设计的过程中有没有这个方法，只要这个方法适用于它，我们就可以使用；>-增加被反柯里化方法接收的参数>-一化多```js//轻提示functionToast(option){this.prompt=''}Toast.prototype={constructor:Toast,//输出提示show:function(){console.log(this.prompt)},}//新对象varobj={prompt:'新对象',}functionunCurrying(fn){returnfunction(){varargs=[].slice.call(arguments)varthat=args.shift()returnfn.apply(that,args)}}varobjShow=unCurrying(Toast.prototype.show)objShow(obj)//输出\"新对象\"```##偏函数>-和柯里化很像>-指将函数的部分参数固定化```js//入参函数functionadd(a,b){returna+b}//生产偏函数的工厂functionpartial(fn,a){returnfunction(b){returnfn(a,b)}}varparAdd=partial(add,1)//变量parAdd接受返回的新函数console.log(parAdd(2))//在调用的时候传入剩余的参数console.log(parAdd(3))//在调用的时候传入剩余的参数console.log(parAdd(4))//在调用的时候传入剩余的参数console.log(parAdd(5))//在调用的时候传入剩余的参数```","JavaScript\\动画\\index.md":"#动画##动画库><https://animista.net/>><https://www.minimamente.com/category/css/>><http://guowc.github.io/animastore/>><https://elrumordelaluz.github.io/csshake/>><https://ianlunn.github.io/Hover/>><https://angrytools.com/css/animation/>##横向滚动><https://github.com/zxuqian/html-css-examples/tree/master/38-horizontal-scrolling>","JavaScript\\动画\\requestAnimationFrame .md":"#requestAnimationFrame-帧动画```js;(()=>{letn=0functiontest(){n++console.log(`🚀🚀hello~requestAnimationFrame${n}`)if(n<11)requestAnimationFrame(test)}requestAnimationFrame(test)})()```","JavaScript\\基础\\static.md":"#static关键词>静态属性和静态方法都是通过类(构造函数)直接使用>>引用属性或调用方法的时候,没有必要首先创建类(构造函数)的对象实例##静态属性>-给Antzone添加静态属性webName>-静态属性直接由类本身引用,而不是他的对象实例```jsclassAntzone{}Antzone.webName='grh'console.log(Antzone.webName)```##静态方法>-静态方法是由类或构造函数直接调用,而不是对象实例>-```jsfunctionAntzone(){Antzone.show=function(){console.log('grh')}}Antzone.show()```使用关键词static```jsclassAntzone{staticshow(){console.log('grh')}}letant=newAntzone()Antzone.show()ant.show()//这里会报ant.shownotafunction```>1.通过关键词static定义show()>2.直接通过类调用show(),而不是对象实例调用>3.ant.show()之所以会报错,他是调用实例方法show,然而not定义修改```jsclassAntzone{staticshow(){console.log('grh')}show(){console.log('grh')}}letant=newAntzone()Antzone.show()ant.show()```>静态方法与实例化方法可以重名```jsclassAntzone{staticshow(){this.done()}staticdone(){console.log('蚂蚁部落一')}done(){console.log('蚂蚁部落二')}}letant=newAntzone()Antzone.show()```>1.使用实例对象调用方法,方法中的this指向此实例对象>2.如果使用类调用静态方法,so静态function中的this指向类本身>3.show的this指向classAntzone,sothis.done()调用的是方法##静态属性and静态方法的继承>-extends关键字,可以实现类之间的继承>-可以继承父类的实例属性and实例function,静态属性and静态方法也会被继承```jsclassF{staticfunc(){console.log('grh')}}F.address='珠海'classCextendsF{}C.func()console.log(C.address)```","JavaScript\\基础\\this相关.md":"#Question##1.this的优先级>this的优先级:new>bind>call(apply)>obj.func()>默认绑定```jsvarobj={}obj.log=console.logobj.log.call(console,this)```>this的优先级:new>bind>call(apply)>obj.func()>默认绑定>>非严格模式下js语句中\"this\"默认指向全局对象(window)>>严格模式下,普通函数内部的this不会指向window>>上面代码可以转换为`console.log.call(console,this)````js'usestrict'functionfn(){console.log(this)}fn()//undefined``````jsfunctionfn(){console.log(this)}fn()//window```##2.this诡异问题,内存地址```jsvarobj={a:1,b:function(){alert(this.a)},}varfun=obj.b//会指向b函数存储的地址//调用的时候就直接使用b,而和obj.b()的使用不相同fun()//弹出undefinedobj.b()//弹出1```-this的行为有时候会显得极其诡异，让人感到困惑，但只需要记住**this的值要等到代码真正执行时才能确定**同时this的值具体有以下几种情况：1.new调用时指的是被构造的对象2.call、apply调用，指向我们指定的对象3.对象调用，如执行obj.b()，this指向obj4.默认的，指向全局变量window(相当于执行window.fun())-这样看来，当你执行fun()的时候，以上1,2点均不满足。第3点,因为this是运行时确定的，而我们执行fun()，等同于window.fun()(**与obj没有任何关系**)，自然的this指向window，而window没有定义变量a，结果是undefined。","JavaScript\\基础\\V8编译过程.md":"#V8编译过程-主要由C++开发-三个重要的组件:解析器,解释器,编译器-特点1.函数值声明未被调用,不会被解析生成AST2.函数只被调用一次,bytecode直接被解释执行3.函数被调用多次,==可能==会被标记为热点函数,可以会被编译成机器代码4.当一个函数被定义好,不要重复调用传入不同类型的参数,会导致机械代码回退到字节码重新编译,会影响性能###编译过程1.词法分析(分词)这个过程会将代码中的字符分解成对应有意义的代码块，这些代码块被称为词法单元（token）。```jsvara=1;=>'var''a''=''1'';'```-至于空格会不会被当做词法单元（token），取决于空格在这门语言中是否有意义。2.语法分析(解析)这个过程将词法单元流转换为一个元素逐级嵌套所组成的程序语法结构的数，被称为抽象语法树(AST);3.运行阶段预解析-JavaScript引擎将语法检查正常后生成的语法树复制到当前执行的上下文环境中。（包含了函数提升、变量提升等等）。执行上下文-包含了变量对象、作用域链、this变量对象：由变量申明、函数声明、参数构成。变量对象是单例实现的。作用域链-变量对象和所有的父级作用域构成的。this-在进入上下文阶段就已经确定了一旦进入执行代码阶段阶段，this值就不会发生过改变了。##Babel###现在的V8```mermaidgraphLRA(js代码)-->|parser解析器|B(抽象语法数树AST)B-->|interpreter解释器|C(bytecode字节码)C-->|compiler编译器|D(machinecode机器代码)```###早期V8```mermaidgraphLRA-->|parser|B(AST)B-->|Full-codegen|C(机器代码)```","JavaScript\\基础\\协程.md":"#JavaScript/Node.js有协程-从Callback到Promise的.then().then()...也是在不断尝试去解决异步编程带来的回调嵌套、错误管理等问题，Promise进一步解决了这些问题-当异步链多了之后你会发现代码会变成这样.then().then()...由原来的横向变成了纵向的模式，仍就存在冗余的代码，基于我们大脑对事物的思考-我们更倾向于一种近乎“同步”的写法来表达我们的异步代码，在ES6规范中为我们提供了Generator函数进一步改善我们的代码编写方式##Generator>Generator中文翻译过来我们可以称呼它为“生成器”，它拥有函数的执行权，知道什么时候暂停、什么时候执行，这里还有一个概念协程##进程-进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。-启动一个服务、运行一个实例，就是开一个服务进程，例如Java里的JVM本身就是一个进程，Node.js里通过nodeapp.js开启一个服务进程，多进程就是进程的复制（fork），fork出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了IPC通信，进程之间才可数据共享。-Mac系统自带的监控工具“活动监视器”也可看到效果。![](./.assets/协程-2022-05-04-14-51-49.png)-Node.js中我们通过Cluster模块创建多进程时为什么要根据CPU核心数？创建更多不好吗？在一个CPU核心的任何时间内只能执行一个进程。因此，当你CPU核心数有限时，创建过多的进程，CPU也是忙不过来的。-Node.js通过单线程+事件循环解决了并发问题。而我们使用Node.js利用Cluster模块根据CPU核心数创建多进程解决的是并行问题，假设我有4CPU每个CPU分别对应一个线程并行处理A、B、C、D不同的任务，线程之间互不抢占资源。-一句话总结：进程之间数据完全隔离、由操作系统调度，自动切换上下文信息，属系统层级的构造。##线程-线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。-同一块代码，可以根据系统CPU核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不相互影响的。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等。但同一进程中的多个线程有各自的调用栈（callstack），自己的寄存器环境（registercontext），自己的线程本地存储（thread-localstorage)，线程又有单线程和多线程之分，具有代表性的JavaScript、Java语言。-线程共享进程的资源，可以由系统调度运行，可以自动完成线程切换，也许你会听到多线程编程、并发问题，首先，并发指的某个时间点多个任务队列对应到同一个CPU上运行，在任一时间点内也只会有一个任务队列在CPU上执行，这时就产生排队了。-为了解决这个问题，CPU运行时间片会被分成多个CPU时间段，每个时间段给各个任务队列执行（对应多个线程），这样解决了一个任务如果造成阻塞，不会影响到其它的任务运行，同样线程是会自动切换的。-Node.js是怎么解决的并发问题？Node.js主线程是单线程的，核心通过事件循环，每次循环时取出任务队列中的可执行任务运行，没有多线程上下文切换，资源抢占问题，达到高并发成就。-一句话总结：线程之间大多数共享数据（各自的调用栈这些信息除外），由操作系统调用，自动切换上下文，系统层级的构造。##协程-协程又称为微线程、纤程，英文Coroutine。协程类似于线程，但是协程是协作式多任务的，而线程是抢占式多任务的。协程之间的调用不需要涉及任何系统调用，是语言层级的构造，可看作一种形式的控制流，有时候我们也会称它为用户态的轻量级线程。-协程一个特点是通过关键字yield调用其它协程，接下来每次协程被调用时，从协程上次yield返回的位置接着执行，这种通过yield协作转移执行权的操作，彼此没有调用者和被调用者的关系，是彼此平等对称的一种关系。-协程与线程两者的差异，可以看出“同一时间如果有多个线程，但它们会都处于运行状态，线程是抢占式的，而协程同一时间运行的只有一个，其它的协程处于暂停状态，执行权由协程自己分配”。-协程也不是万能的，它需要配合异步I/O才能发挥最好的效果，对于操作系统而言是不知道协程的存在的，它只知道线程。需要注意，如果一个协程遇到了阻塞的I/O调用，这时会导致操作系统让线程阻塞，那么在这个线程上的其它协程也都会陷入阻塞。-一句话总结：协程共享数据，由程序控制完成上下文切换，语言层级的构造。##JavaScript有协程吗之前知乎上有个问题“Node.js真的有协程吗？”协程在很多语言中都支持，只是每个实现略有差异，下图来自维基百科展示了支持协程的编程语言，可以看到JavaScript在ECMAScript6支持，ECMAScript7之后通过await支持，Node.js做为JavaScript在服务端的运行时，只要你的Node.js版本对应支持，就是可以的。![](./.assets/协程-2022-05-04-14-52-13.png)##协程在JavaScript中的实现###生成器与协程-生成器（Generator）是协程的子集，也称为“半协程”。差异在于，生成器只能把控制权交给它的调用者，完全协程有能力控制在它让位之后哪个协程立即接续它执行。在JavaScript里我们说的Generator函数就是ES6对协程的实现。-JavaScript是一个单线程的语言，只能保持一个调用栈。在异步操作的回调函数里，一旦出错原始的调用栈早已结束，引入协程之后每个任务可以保持自己的调用栈，这样解决的一大问题是出错误时可以找到原始的调用栈。-看下生成器函数与普通函数有什么区别？首先普通函数通过栈实现的，举个例子，调用时是`A()->B()->C()`入栈，最后是`C()->B()->A()`这样一个顺序最后进入的先出栈执行。-生成器函数看似和普通函数相似，其实内部执行机制是完全不同的，生成器函数在内部执行遇到yield会交出函数的执行权给其它协程（此处类似CPU中断），转而去执行别的任务，在将来一段时间后等到执行权返回（生成器还会把控制权交给它的调用者），程序再从暂停的地方继续执行。###无堆栈协程-自ES6开始，通过`Generator`和`yield`表达式提供了无堆栈协程功能>“无栈协程的秘密在于它们只能从顶级函数中挂起自己。对于其他所有函数，它们的数据都分配在被调用者堆栈上，因此从协程调用的所有函数必须在挂起协程之前完成。协程保留其状态所需的所有数据都在堆上动态分配。这通常需要几个局部变量和参数，其大小远小于预先分配的整个堆栈”。参考coroutines-introduction栈是一块连续的内存，能够从子函数产生的协程称为栈式，它们可以记住整个调用栈，这种也称为栈式协程。在JavaScript中我们只能从生成器函数内部暂停、恢复执行生成器函数。下面示例test1()是生成器函数，但是forEach里面的匿名函数是一个普通的函数，就无法在内部使用yield关键字，运行时会抛出错误“SyntaxError:Unexpectedidentifier”```jsfunction*test1(){console.log('executionstart');['A','B'].forEach(function(item){yielditem;})}```###生成器函数示例例如，现在有两个生成器函数test1()、test2()，还有co这个工具可以帮助我们自动的执行生成器函数。```jsconstco=require('co')function*test1(){console.log('execution1')console.log(yieldPromise.resolve(1))console.log('execution2')console.log(yieldPromise.resolve(2))}function*test2(){console.log('executiona')console.log(yieldPromise.resolve('a'))console.log('executionb')console.log(yieldPromise.resolve('b'))}co(test1)co(test2)```####看下运行结果>第一次程序执行test1()函数，先输出'execution1'遇到yield语句程序的控制权转移。>现在执行权转移到了test2()函数，执行代码输出'executiona'当遇到yield语句后交出程序的控制权。>此时test1()函数收回执行权，恢复执行输出'1'继续往下执行输出'execution2'当遇到yield语句再次交出执行权，依次类推。```jsexecution1executiona1execution2aexecutionb2b```##总结“JavaScript有协程吗？”JavaScript中是在ES6后基于生成器函数（Generator）实现的，生成器只能把程序的执行权还给它的调用者，这种方式我们称为“半协程”，而完全的协程是任何函数都可让暂停的协程执行。基于生成器函数这种写法，如果去掉yield关键字，与我们普通的函数是相似的，以一种同步的方式来表达，解决了回调嵌套的问题，另外我们还可以通过try...catch做错误捕获，只不过我们还需要借助CO这样的模块，让生成器函数自动执行，这个问题在ES7中已经得到了更好地解决，可以通过async/await轻松的实现Reference<https://en.wikipedia.org/wiki/Coroutine#Implementations_in_JavaScript><https://zhuanlan.zhihu.com/p/70256971><http://zhangchen915.com/index.php/archives/719/><https://es6.ruanyifeng.com/#docs/generator>","JavaScript\\基础\\注册事件.md":"#注册事件>addEventListener:主流浏览器都适用>>attachEvent():IE事件模型适用该方法##addEventListener`element.addEventListener(Stringtype,Functionlistener,booleanuseCaptrue);`-type:注册事件类型名[没有on前缀]-listener:监听函数-useCaptrue:事件捕获-true:指定事件处理函数将在事件传播的捕获阶段触发-false:事件处理函数将在冒泡阶段触发```js<pid=\"p1\">为对象注册多个事件</p><script>varp1=document.getElementById(\"p1\");//捕获段落元素的句柄p1.addEventListener(\"mouseover\",function(){this.style.background='blue';},true);//为段落元素注册第1个事件处理函数p1.addEventListener(\"mouseout\",function(){this.style.background='blue';},true);//为段落元素注册第2个事件处理函数</script>```##attachEvent>`element.attachEvent(etype,eventName)`>>-etype:设置事件类型[这里和addEventListener不相同,需要on前缀]>-eventName:设置时间名称,也就是时间处理函数```js<pid=\"p1\">为对象注册多个事件</p><script>varp1=document.getElementById(\"p1\");//捕获段落元素p1.attachEvent(\"onmouseover\",function(){this.style.background='blue';});//注册mouseover事件p1.attachEvent(\"onmouseout\",function(){this.style.background='red';});//注册mouseout事件</script>```","JavaScript\\基础\\流程&基础遍历.md":"#流程控制###循环语句>`while([条件表达式]){}`>>`do-while([条件表达式])`:至少执行一次>>`for(;循环条件;){}`>>`for(声明变量in对象){}`:枚举对象属性(对象不可以为null,undefined)>>```js>for(letitemof'grh'){>console.log(item)>}>//grh>```###跳转控制语句>return>>break>>continue###选择语句>```js>if([条件表达式]){>...>}elseif[条件表达式]){>...>}else{>...>}>```>>```js>switch([条件表达式]){>case标签1:>代码片段1;>break;>...>default:>代码片段n;>}>```###异常处理语句>throw:主动抛出异常>>try:指明需要处理的代码段>>catch:捕获异常>>finally:后期处理","JavaScript\\对象\\BOM.md":"##Window对象BOM>浏览器对象模型:BOM(BrowserObjectModel)###Window尺寸&获取元素的相对位置InternetExplorer、Chrome、Firefox、Opera以及Safari：-window.innerHeight-浏览器窗口的内部高度-window.innerWidth-浏览器窗口的内部宽度InternetExplorer8、7、6、5：-document.documentElement.clientHeight-document.documentElement.clientWidth或者-document.body.clientHeight-document.body.clientWidth|js代码|描述||---------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||element.clientWidth/clientHeight|内高度/宽度:margin+content||element.offsetWidth/offsetHeight|外高度/宽度:border+padding+content||element.clientTop/clientLeft|上/左边框||element.getBoundingClientRect()|x\\y:元素的左上角和父元素左上角的距离<br>width/height:边框+内边距+内容框<br/>top:元素的上边界和父元素上边界的距离<br/>left:元素的左边界和父元素左边界的距离<br/>right:元素的右边界和父元素的左边界的距离<br/>bottom:元素的下边界和父元素上边界的距离||element.offsetTop/element.offsetLeft|上边/左边的偏移量||document.documentElement.clientWidth/clientHeight|可视区域的大小||document.documentElement.scrollWidth/scrollHeight|页面的实际大小||window.screenX/screenY|窗口左上角与屏幕左上角的距离||window.screen.width/height|屏幕可用宽高(去除任务栏)||window.innerWidth/innerHeight|窗口的内高度/宽度||window.outerWidth/outerHeight|窗口的外高度/宽度||||###Window对象####属性>-状态栏>-defaultStatus改变浏览器状态栏的默认显示>-status临时改变浏览器状态栏的显示>-窗口位置>-IE>-screenLeft声明窗口的左上角的X坐标>-screenTop声明窗口的左上角的Y坐标>-声明当前文档向右滚动的像素数>-document.body.scrollLeft>-document.documentElement.scrollLeft>-声明当前文档向下滚动过的像素数>-document.body.scrollTop>-document.documentElemnet.scrollTop>-!IE>-screeenX声明窗口左上角的==X==坐标>-screenY声明窗口左上角的==Y==坐标>-pageXOffset声明当前文档向右滚动过的像素数>-pageYOffset声明当前文档向下滚动过的像素数>-FF>-innerHeight返回窗口的文档显示区的高度>-innerWidth返回当前的文档显示区的宽度>-outerHeight返回窗口的外部高度>-outerWidth返回窗口的外部宽度>-其他属性####navigator(导航器对象)>-appCodeName返回浏览器的代码名>-appName返回浏览器的名称>-appVersion返回浏览器的平台和版本信息>-cookieEnabled返回指明浏览器中是否启动cookie的布尔值>-platform返回浏览器的操作系统平台>-userAgent返回客户机发送服务器的user-agent头部的值####screen(显示器对象)>-avaiHeight返回显示器的可用高度>-avaiWidth返回显示屏幕的可用宽度>-height返回屏幕高度的像素数>-width返回屏幕宽度的像素数>-colorDepth返回屏幕颜色的位数####history(历史对象)>-back()返回前一个URL>-forward()返回下一个URL>-go()返回某个具体页面>-添加和修改历史记录中的条目>-pushState()添加>-replaceState()修改>-popstate```js//history向后跳转window.history.back()=>window.history.go(-1)window.history.forward();=>window.history.go(1)letnumberOfEntries=window.history.length//获取堆栈中页面的数量letstateObj={foo:'bar'}history.pushState(stateObj,\"page2\",\"bar.html\");history.replaceState(stateObj,\"page3\",\"bar2.html\");window.onpopstate=function(event){console.log(\"location:\"+document.location+\",state:\"+JSON.stringify(event.state));};//绑定事件处理函数.history.pushState({page:1},\"title1\",\"?page=1\");//添加并激活一个历史记录条目http://example.com/example.html?page=1,条目索引为1history.pushState({page:2},\"title2\",\"?page=2\");//添加并激活一个历史记录条目http://example.com/example.html?page=2,条目索引为2history.replaceState({page:3},\"title3\",\"?page=3\");//修改当前激活的历史记录条目http://ex..?page=2变为http://ex..?page=3,条目索引为3history.back();//弹出\"location:http://example.com/example.html?page=1,state:{\"page\":1}\"history.back();//弹出\"location:http://example.com/example.html,state:nullhistory.go(2);//弹出\"location:http://example.com/example.html?page=3,state:{\"page\":3}```####location(位置对象)>-属性>-hash设置或返回从#号开始的URL>-host设置或返回主机名或当前URL的端口号>-hostname设置或返回当前URL的主机名>-href设置或返回完整的URL>-pathname设置或返回当前URL的路径部分>-port设置或返回当前URL的端口号>-protocol设置或返回当前URL的端口号>-search设置或返回?开始的URL>-方法>-assign(URL)加载新的文档>-reload()重现加载当前页面>-replace(newURl)用新的完蛋替换当前文档####document(文档对象)#####集合>-anchors[]锚点对象数组>-images[]图片对象数组>-links[]连接对象数组>-forms[]表单对象数组#####属性>-cookie设置或返回与当前文档有关所有cookie>-domain返回当前文档的域名>-referrer返回载入当前文档的文档的URL>-title返回当前文档的标题>-URL返回当前文档的URL#####方法>-open()打开一个新的文档,并查处旧文档内容>-close()关闭文档输出流>-write()向当前文档追加写入文本>-writeIn()与wtite()相同,在<pre>中追加换行####窗口控制-moveBy:-moveBy(水平位移量,垂直位移量)-按照指定像素移动指定窗口-moveTo:-moveTo(x,y)-将窗口移动到指定坐标(x,y)-resizeBy:-resizeBy(x,y)-将当前窗口改变指定的大小(x,y)-当x,y的值大于0时为扩大-当x,y的值小于0时为缩小-resizeTo-resizeTo(x,y)-将当前窗口改编成(x,y)大小,x,y分别为宽度和高度-scrollBy-scrollBy(x,y)-将窗口中的内容给定的唯一量滚动-参数为正数,正向滚动,反之,反向-scrollTo-scrollTo(x,y)-将窗口内容滚动到指定位置####焦点控制>-focus得到焦点>-blur移出焦点####打开关闭窗口>-open>-open(\"URL\",\"窗口名称\",\"窗口风格\")>-打开一个新的窗口,并在窗口中转载指定URL地址的网页>-窗口风格:>-height数值窗口高度不能小于100>-width数值窗口宽度不能小于100>-left数值窗口左坐标不能为负值>-top数值窗口上坐标不能为负值>-location是否显示地址栏>-menubar是否显示菜单栏>-resizable是否可以改变窗口大小>-scrollbars是否允许出现滚动栏>-status是否显示状态栏>-toolbar是否显示工具栏>-close>-close()>-自动关闭浏览器窗口####定时器>-setTimeout(将执行代码,毫秒):定时器>-到了指定时间后执行代码>-clearTimeout(定时器)>-取消由setTimeout设置的定时器>-setInterval(重复执行的代码,毫秒):时间间隔器>-指定周期重复执行功能代码>-clearInterval(时间间隔器)>-取消由setInterval()设置的时间间隔期####对话框>-alert(\"提示字符串\")>-confirm(\"提示字符串\")>-确认=>返回true,反之false>-prompt(\"提示字符串\",\"缺省文本\")>-返回输入的字符串>-点击取消返回null","JavaScript\\对象\\cookie.md":"#Cookie>用户存储一些数据,存储与电脑上的文本文件中>>当web服务器向浏览器发送web页面时，在连接关闭后，服务端不会记录用户的信息。>>Cookie的作用就是用于解决\"如何记录客户端的用户信息\":>>-当用户访问web页面时，他的名字可以记录在cookie中。>-在用户下一次访问该页面时，可以在cookie中读取用户访问记录##使用cookie>-`expires`:过期时间>-`path`:cookie的路径```jsdocument.cookie='username=JohnSmith;expires=Thu,18Dec204312:00:00GMT;path=/'document.cookie='username2=JohnSmith2;expires=Thu,18Dec204312:00:00GMT;path=/'getCookie('username')//JohnSmithgetCookie('username2')//JohnSmith2document.cookie//可以返回全部cookie```","JavaScript\\对象\\DOM.md":"##DOM事件###事件级别>DOM0:element.onclick=function(){}>>DOM2:element.addEventListener('click',function(){},false)>>DOM3:element.addEventListener('keyup',function(){},false)>>没有DOM1,因为DOM1标准制定的时候没有涉及DOM事件>>DOM3比DOM2添加了一些事件类型###DOM事件捕获的具体流程>捕获流程:window->document->html->body->...->目标元素>>冒泡流程:目标元素->...->body->html->document->window##DOM操作###EventListener()方法>-添加事件监听器>-语法:`element.addEventListener(*event,function,useCapture*);`>-参数1:事件类型(不要使用\"on\"前缀,例如\"click\",而不是\"onclick\")>-参数2:时间出发调用函数>-参数3:是个布尔值(false:冒泡,true:捕获[可选])>-eg:`document.getElementById(\"btn\").addEventListener(\"click\",myFunction);`>-移除事件监听器>-eg:`element*.removeEventLister(\"mousemove\",myFunction);`###获取节点>-document>-getElementById([元素ID])>-getElementByName([元素name属性])>-getElementsByTagName([元素标签])>-节点指针>-父节点.firstChild:获取元素的首个节点>-父节点.lastChild:获取元素最后一个节点>-父节点.childNodes:获取元素的==子节点列表==>-兄弟节点.previousSibling:获取已知节点的前一个节点>-兄弟节点.nextSibling:获取已知节点后一个节点>-子节点.parentNode:获取已知节点的父节点###节点操作>-创建节点:>-createElement>-document.createElement>-创建元素节点>-createAttibute>-document.createAttibute>-创建属性节点>-createTextNode>-document.createTextNode>-创建文本节点>-插入节点>-appendChild>-appendChild(所添加的新节点)>-向节点的子节点列表的末尾添加新的节点>-insertBefore>-insertBefore(所添加的新节点[已知子节点])>-在已知节点前插入一个新的节点>-替换节点>-replaceChild>-replaceChild(要插入的新元素,将被替换的老元素)>-将某个子节点替换成另一个>-复制节点>-cloneNode>-需要被赋值的节点.cloneNode(true/false)>-创建指定节点的副本>-true:复制当前节点以及所有的子节点>-false:仅复制当前节点>-删除节点:>-removeChild(要删除的节点)>-删除指定的节点>-删除父节点的一个子节点:document.getElementById(\"id1\").parentNode.removeNode(document.getElementById(\"id2\"))###属性操作>-获取属性:getAttribute([元素属性名])>-元素节点.getAttribute(元素属性名)>-获取元素节点指定的属性值>-设置属性:setAttribute([属性名],[属性值])>-元素节点.setAttribute(属性名,属性值)>-创建或改变元素节点的属性>-删除属性:removeAttribute([属性名])>-元素节点.removeAttribute(属性名)>-删除元素中的指定属性###文本操作>-insertData(offset,String):从offset指定位置插入string>-appedData(String):将string插入到文本节点末尾处>-deleteData(offset,count):从offset起杀出count个字符>-replaceData(off,count,string):从off将count个字符用string替代>-splitData(offset):从offset起将文本节点分成两个节点>-substring(offset,count):返回有offset起的count个节点","JavaScript\\对象\\event.md":"##Event对象###event对象常见方法>1.event.preventDefault():取消事件的默认动作>2.event.stopoPropagation():阻止事件冒泡>3.event.stopImmediatePropagation():>1.阻止剩下的事件处理程序被执行,>2.如果一个元素绑定了三个事件,其中有一个调用了该方法,其他两个事件将不会被执行","JavaScript\\对象\\Intl.md":"待整理#Intl<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl>>ECMAScript国际化API的一个命名空间，它提供了精确的字符串对比、数字格式化，和日期时间格式化。>`Collator`，`NumberFormat`和`DateTimeFormat`对象的构造函数是Intl对象的属性。本页文档内容包括了这些属性，以及国际化使用的构造器和其他语言的方法等常见的功能-locales参数:locales参数必须是一个BCP47语言标记的字符串，或者是一个包括多个语言标记的数组。如果locales参数未提供或者是undefined，便会使用运行时默认的locale。[BCP47语言标记](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry)属性Intl.Collatorcollators的构造函数，用于启用对语言敏感的字符串比较的对象。Intl.DateTimeFormat用于启用语言敏感的日期和时间格式的对象的构造函数。Intl.ListFormatConstructorforobjectsthatenablelanguage-sensitivelistformatting.Intl.NumberFormat用于启用语言敏感数字格式的对象的构造函数。Intl.PluralRules用于启用多种敏感格式和多种语言语言规则的对象的构造函数。Intl.RelativeTimeFormatConstructorforobjectsthatenablelanguage-sensitiverelativetimeformatting.","JavaScript\\对象\\Iterator.md":"-###Iterator>处理集合中的每个项是很常见的操作。JavaScript提供了许多迭代集合的方法，从简单的for循环到map()和filter()。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义for...of循环的行为。如果对MDN这个描述理解不是很到位的话，可以看下接下来这个小示例：```letauthors={allAuthors:{fiction:['AgathaChristie','J.K.Rowling','Dr.Seuss'],scienceFiction:['NealStephenson','ArthurClarke','IsaacAsimov','RobertHeinlein'],fantasy:['J.R.R.Tolkien','J.K.Rowling','TerryPratchett']}}```这个数据结构是汇总了所有作者，每个作者按创作性质进行了分类。如果我们想获取所有作者的名单，该怎么做呢？```for(letauthorofauthors){console.log(author)}```你发现这个遍历遇到了报错：UncaughtTypeError:authorsisnotiterable**1、基本语法**Iterator就是ES6中用来实现自定义遍历的接口，按照上述的示例，我们来实现下这个接口：```authors[Symbol.iterator]=function(){letallAuthors=this.allAuthorsletkeys=Reflect.ownKeys(allAuthors)letvalues=[]return{next(){if(!values.length){if(keys.length){values=allAuthors[keys[0]]keys.shift()}}return{done:!values.length,value:values.shift()}}}}```这个代码在数据结构上部署了Iterator接口，我们就可以用for...of来遍历代码了：```for(letvalueofauthors){console.log(`${value}`)}```**2、可迭代协议和迭代器协议。**-1.迭代器协议这是两个概念：可迭代协议、迭代器协议。通俗的讲，迭代器协议要求符合以下条件：-首先，它是一个对象-其次，这个对象包含一个无参函数next-最后，next返回一个对象，对象包含done和value属性。其中done表示遍历是否结束，value返回当前遍历的值。-1.可迭代协议可迭代协议允许JavaScript对象去定义或定制它们的迭代行为,例如（定义）在一个for..of结构中什么值可以被循环（得到）。一些内置类型都是内置的可迭代类型并且有默认的迭代行为,比如ArrayorMap,另一些类型则不是(比如Object)。为了变成可迭代对象，一个对象必须实现@@iterator方法,意思是这个对象（或者它原型链prototypechain上的某个对象）必须有一个名字是Symbol.iterator的属性。如果让一个对象是可遍历的，就要遵守可迭代协议，该协议要求对象要部署一个以Symbol.iterator为key的键值对，而value就是一个无参函数，这个函数返回的对象要遵守迭代器协议。**3、Generator**熟悉了Generator之后，发现它是天然满足可迭代协议的。上述的代码我们可以用Generator来实现：```authors[Symbol.iterator]=function*(){letallAuthors=this.allAuthorsletkeys=Reflect.ownKeys(allAuthors)letvalues=[]while(1){if(!values.length){if(keys.length){values=allAuthors[keys[0]]keys.shift()yieldvalues.shift()}else{returnfalse}}else{yieldvalues.shift()}}}```同一个场景，同一个数据结构，写法确实不同的，利用Generator就不再需要显示的写迭代协议了（next方法和包含done、value属性的返回对象）。","JavaScript\\对象\\Object.md":"#JavaScript中Object构造函数的方法##Object###简洁属性表示法```jsletname='xx'letage=18letobj={name,age,}```###属性名表达式```jslets='school'letobj={foo:'bar',[s]:'xx',}```##Object构造函数的方法###Object.assign()>通过复制一个或多个对象来创建一个新的对象>>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象```jsconsttarget={a:1,b:2}constsource={b:4,c:5}constreturnedTarget=Object.assign(target,source)console.log(source)//{b:4,c:5};原数据不变console.log(target)//expectedoutput:Object{a:1,b:4,c:5}console.log(returnedTarget)//expectedoutput:Object{a:1,b:4,c:5}```###Object.create()>使用指定的原型对象和属性创建一个新对象。>>创建一个新对象，使用现有的对象来提供新创建的对象的**proto**。```jsconstperson={isHuman:false,printIntroduction:function(){console.log(`Mynameis${this.name}.AmIhuman?${this.isHuman}`)},}constme=Object.create(person)me.name='Matthew'//\"name\"isapropertyseton\"me\",butnoton\"person\"me.isHuman=true//inheritedpropertiescanbeoverwrittenme.printIntroduction()//expectedoutput:\"MynameisMatthew.AmIhuman?true\"```###Object.defineProperty()>给对象添加一个属性并指定该属性的配置。>>方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。>>语法Object.defineProperties(obj,props)obj在其上定义或修改属性的对象。props要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键：configurabletrue当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。默认为falseenumerabletrue当且仅当在枚举相应对象上的属性时该属性显现。默认为falsevalue与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。默认为undefined.writabletrue当且仅当与该属性相关联的值可以用assignmentoperator改变时。默认为falseget作为该属性的getter函数，如果没有getter则为undefined。函数返回值将被用作属性的值。默认为undefinedset作为属性的setter函数，如果没有setter则为undefined。函数将仅接受参数赋值给该属性的新值。默认为undefined返回值节传递给函数的对象。>>语法Object.defineProperty(obj,prop,descriptor)obj要在其上定义属性的对象。prop要定义或修改的属性的名称。descriptor将被定义或修改的属性描述符。返回值节被传递给函数的对象。在ES6中，由于Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty是定义key为Symbol的属性的方法之一。>>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。```js```###Object.defineProperties()>给对象添加多个属性并分别指定它们的配置。```jsvarobj={}Object.defineProperties(obj,{property1:{value:true,writable:true,},property2:{value:'Hello',writable:false,},//etc.etc.})```###Object.entries()>返回给定对象自身可枚举属性的[key,value]数组。>>返回一个给定对象自身可枚举属性的键值对数组，其排列与使用for...in循环遍历该对象时返回的顺序一致（区别在于for-in循环也枚举原型链中的属性）```jsconstobject1={foo:'bar',baz:42}console.log(Object.entries(object1)[1])//expectedoutput:Array[\"baz\",42]constobject2={0:'a',1:'b',2:'c'}console.log(Object.entries(object2)[2])//expectedoutput:Array[\"2\",\"c\"]constresult=Object.entries(object2).sort((a,b)=>a-b)console.log(Object.entries(result)[1])//expectedoutput:Array[\"1\",Array[\"1\",\"b\"]]```###Object.freeze()>冻结对象：其他代码不能删除或更改任何属性。>>可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze()返回和传入的参数相同的对象。```jsconstobject1={property1:42,}constobject2=Object.freeze(object1)object2.property1=33//Throwsanerrorinstrictmodeconsole.log(object2.property1)//expectedoutput:42```###Object.is()>比较两个值是否相同。所有NaN值都相等（这与==和===不同）。>>判断两个值是否是相同的值```jsObject.is('foo','foo')//trueObject.is(window,window)//trueObject.is('foo','bar')//falseObject.is([],[])//falsevarfoo={a:1}varbar={a:1}Object.is(foo,foo)//trueObject.is(foo,bar)//falseObject.is(null,null)//true//特例Object.is(0,-0)//falseObject.is(-0,-0)//trueObject.is(NaN,0/0)//true```###Object.isExtensible()>判断对象是否可扩展。```js//使用Object.freeze是冻结一个对象最方便的方法.varfrozen={1:81};Object.isFrozen(frozen)//===falseObject.freeze(frozen);Object.isFrozen(frozen)//===true//一个冻结对象也是一个密封对象.Object.isSealed(frozen)//===true//当然,更是一个不可扩展的对象.Object.isExtensible(frozen)//===false在ES5中，如果参数不是一个对象类型，将抛出一个TypeError异常。在ES2015中，非对象参数将被视为一个冻结的普通对象，因此会返回true。Object.isFrozen(1);//TypeError:1isnotanobject(ES5code)Object.isFrozen(1);//true(ES2015code)```###Object.isFrozen()>判断对象是否已经冻结。```js//使用Object.freeze是冻结一个对象最方便的方法.varfrozen={1:81};Object.isFrozen(frozen)//===falseObject.freeze(frozen);Object.isFrozen(frozen)//===true//一个冻结对象也是一个密封对象.Object.isSealed(frozen)//===true//当然,更是一个不可扩展的对象.Object.isExtensible(frozen)//===false在ES5中，如果参数不是一个对象类型，将抛出一个TypeError异常。在ES2015中，非对象参数将被视为一个冻结的普通对象，因此会返回true。Object.isFrozen(1);//TypeError:1isnotanobject(ES5code)Object.isFrozen(1);//true(ES2015code)```###Object.isSealed()>判断对象是否已经密封。```js//使用Object.freeze是冻结一个对象最方便的方法.varfrozen={1:81};Object.isFrozen(frozen)//===falseObject.freeze(frozen);Object.isFrozen(frozen)//===true//一个冻结对象也是一个密封对象.Object.isSealed(frozen)//===true//当然,更是一个不可扩展的对象.Object.isExtensible(frozen)//===false在ES5中，如果参数不是一个对象类型，将抛出一个TypeError异常。在ES2015中，非对象参数将被视为一个冻结的普通对象，因此会返回true。Object.isFrozen(1);//TypeError:1isnotanobject(ES5code)Object.isFrozen(1);//true(ES2015code)```###Object.keys()>返回一个包含所有给定对象自身可枚举属性名称的数组。>>会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用for...in循环遍历该对象时返回的顺序一致。```js//simplearrayvararr=['a','b','c']console.log(Object.keys(arr))//console:['0','1','2']//arraylikeobjectvarobj={0:'a',1:'b',2:'c'}console.log(Object.keys(obj))//console:['0','1','2']//arraylikeobjectwithrandomkeyorderingvaranObj={100:'a',2:'b',7:'c'}console.log(Object.keys(anObj))//console:['2','7','100']//getFooisapropertywhichisn'tenumerablevarmyObj=Object.create({},{getFoo:{value:function(){returnthis.foo},},},)myObj.foo=1console.log(Object.keys(myObj))//console:['foo']```###Object.values()>返回给定对象自身可枚举值的数组。>>返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同(区别在于for-in循环枚举原型链中的属性)。```jsvarobj={foo:'bar',baz:42}console.log(Object.values(obj))//['bar',42]//arraylikeobjectvarobj={0:'a',1:'b',2:'c'}console.log(Object.values(obj))//['a','b','c']//arraylikeobjectwithrandomkeyordering//whenweusenumerickeys,thevaluereturnedinanumericalorderaccordingtothekeysvaran_obj={100:'a',2:'b',7:'c'}console.log(Object.values(an_obj))//['b','c','a']//getFooispropertywhichisn'tenumerablevarmy_obj=Object.create({},{getFoo:{value:function(){returnthis.foo},},},)my_obj.foo='bar'console.log(Object.values(my_obj))//['bar']//non-objectargumentwillbecoercedtoanobjectconsole.log(Object.values('foo'))//['f','o','o']```###Object.fromEntries()>把键值对列表转换为一个对象。```jsMap转化为Object通过Object.fromEntries，可以将Map转化为Object:constmap=newMap([['foo','bar'],['baz',42]]);constobj=Object.fromEntries(map);console.log(obj);//{foo:\"bar\",baz:42}Array转化为Object通过Object.fromEntries，可以将Array转化为Object:constarr=[['0','a'],['1','b'],['2','c']];constobj=Object.fromEntries(arr);console.log(obj);//{0:\"a\",1:\"b\",2:\"c\"}对象转换为ObjectObject.fromEntries是Object.entries()的反转函数，借用arraymanipulationmethods可以转换对象，如下：constobject1={a:1,b:2,c:3};constobject2=Object.fromEntries(Object.entries(object1).map(([key,val])=>[key,val*2]));console.log(object2);//{a:2,b:4,c:6}```##对象###对象方法####创建对象的方法```js//1.字面量varobj1={name:'soloobj1'}obj1//{name:\"soloobj1\"}//2.newObjectvarobj2=newObject({name:'soloobj2'})obj2//{name:\"soloobj2\"}//3.构造函数创建varM=function(name){this.name=name}varobj3=newM('soloobj3')obj3//{name:\"soloobj3\"}M.prototype.constructor===M//trueM.prototype===obj3.__proto__//true//4.Object.createvarp={name:'p'}varobj4=Object.create(p)obj4//{}obj4.name//\"p\"```![](https://images.gitee.com/uploads/images/2020/0920/202923_e68d1728_7984151.png)####Object.is()-在Es5中，比较两个数是否相等，使用的是相等(==)和全等(===),对两数进行比较。相等会自动转换数据类型(例如，布尔型数据类型在进行比较时，会转换为0或者1，NaN不等于NaN,)。```jsObject.is(NaN,NaN)//trueObject.is(+0,-0)//false```####Object.assign(obj1,obj2,obj3,..)-assign()方法用于对象的合并-obj1属于目标对象，后面的obj对象均为源对象。```jsvarobj={name:'zhangsan'}varobj2={age:'19'}Object.assign(obj,obj2)//{name:\"zhangsan\",age:\"19\"}```-当目标对象和源对象的属性名称出现冲突时，后面对象的属性会覆盖前面的对象的属性。```jsvarobj={name:'zhangsan'}varobj2={name:'lisi'}Object.assign(obj,obj2)//{name:\"lisi\"}```1.当assign()方法中，只有一个参数，object.assign()方法会返回参数对象。2.当assign()方法中的参数不是对象，会先转换为对象，再返回该参数。3.当assign()方法中，第一个参数为null、undefined时，因为不能转换为对象，便会报错。（只要null，undefined不是首个参数，就不会报错）_首个参数处理规则与其他的参数不同，除了首参，不能转换为对象的参数就会跳过。参数为数值、布尔型均会跳过。_####Object.assign()--深拷贝、浅拷贝例子1：```jsvarobj={name:'zhangsan'}varobj2=Object.assign({},obj)console.log(obj)//{name:\"zhangsan\"}console.log(obj2)//{name:\"zhangsan\"}obj2.name='lisi'//{name:\"lisi\"}console.log(obj2.name)//\"lisi\"console.log(obj.name)//\"zhangsan\"```例子2：```jsvarobj={name:'zhangsan',info:{age:'18'}}varobj2=Object.assign({},obj)console.log(obj)//{name:\"zhangsan\",info:{age:\"18\"}}console.log(obj2)//{name:\"zhangsan\",info:{age:\"18\"}}obj2.info.age='19'console.log(obj2.info.age)//\"19\"console.log(obj.info.age)//\"19\"```-有以上两个例子得出。-Object.assign()的第一层属性是属于深拷贝，第二层以上的属性则为浅拷贝。-第二层的会改变原数据#JavaScript中Object构造函数的方法##Object.assign()>Object构造函数的方法节>>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。```jsconsttarget={a:1,b:2}constsource={b:4,c:5}constreturnedTarget=Object.assign(target,source)console.log(target)//expectedoutput:Object{a:1,b:4,c:5}console.log(returnedTarget)//expectedoutput:Object{a:1,b:4,c:5}```##Object.create()>通过复制一个或多个对象来创建一个新的对象。>>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的**proto**。```jsconstperson={isHuman:false,printIntroduction:function(){console.log(`Mynameis${this.name}.AmIhuman?${this.isHuman}`)},}constme=Object.create(person)me.name='Matthew'//\"name\"isapropertyseton\"me\",butnoton\"person\"me.isHuman=true//inheritedpropertiescanbeoverwrittenme.printIntroduction()//expectedoutput:\"MynameisMatthew.AmIhuman?true\"```##Object.defineProperty()>使用指定的原型对象和属性创建一个新对象。>>语法Object.defineProperties(obj,props)obj在其上定义或修改属性的对象。>>Object.defineProperties()方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。>>props要定义其可枚举属性或修改的属性描述符的对象。>>对象中存在的属性描述符主要有两种：>>-数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。>-描述符具有以下键：configurabletrue当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。>-默认为falseenumerabletrue当且仅当在枚举相应对象上的属性时该属性显现。>-默认为falsevalue与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。>-默认为undefined.writabletrue当且仅当与该属性相关联的值可以用assignmentoperator改变时。>-默认为falseget作为该属性的getter函数，如果没有getter则为undefined。函数返回值将被用作属性的值。>-默认为undefinedset作为属性的setter函数，如果没有setter则为undefined。函数将仅接受参数赋值给该属性的新值。>-默认为undefined返回值节传递给函数的对象。```jsvarobj={}Object.defineProperties(obj,{property1:{value:true,writable:true,},property2:{value:'Hello',writable:false,},//etc.etc.})```##Object.defineProperties()>给对象添加一个属性并指定该属性的配置。>>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。>>语法Object.defineProperty(obj,prop,descriptor)>>-obj要在其上定义属性的对象。>-prop要定义或修改的属性的名称。>-descriptor将被定义或修改的属性描述符。>-返回值节被传递给函数的对象。在ES6中，由于Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty是定义key为Symbol的属性的方法之一。##Object.entries()>给对象添加多个属性并分别指定它们的配置。>>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用for...in循环遍历该对象时返回的顺序一致（区别在于for-in循环也枚举原型链中的属性）```jsconstobject1={foo:'bar',baz:42}console.log(Object.entries(object1)[1])//expectedoutput:Array[\"baz\",42]constobject2={0:'a',1:'b',2:'c'}console.log(Object.entries(object2)[2])//expectedoutput:Array[\"2\",\"c\"]constresult=Object.entries(object2).sort((a,b)=>a-b)console.log(Object.entries(result)[1])//expectedoutput:Array[\"1\",Array[\"1\",\"b\"]]```##Object.freeze()>返回给定对象自身可枚举属性的[key,value]数组。>>Object.freeze()方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze()返回和传入的参数相同的对象。```jsconstobject1={property1:42,}constobject2=Object.freeze(object1)object2.property1=33//Throwsanerrorinstrictmodeconsole.log(object2.property1)//expectedoutput:42```##Object.is()>冻结对象：其他代码不能删除或更改任何属性。>>Object.is()方法判断两个值是否是相同的值```jsObject.is('foo','foo')//trueObject.is(window,window)//trueObject.is('foo','bar')//falseObject.is([],[])//falsevarfoo={a:1}varbar={a:1}Object.is(foo,foo)//trueObject.is(foo,bar)//falseObject.is(null,null)//true//特例Object.is(0,-0)//falseObject.is(-0,-0)//trueObject.is(NaN,0/0)//true```##Object.isExtensible()>比较两个值是否相同。所有NaN值都相等（这与==和===不同）。##Object.isFrozen()>判断对象是否可扩展。>>Object.isFrozen()方法判断一个对象是否被冻结```js//使用Object.freeze是冻结一个对象最方便的方法.varfrozen={1:81};Object.isFrozen(frozen)//===falseObject.freeze(frozen);Object.isFrozen(frozen)//===true//一个冻结对象也是一个密封对象.Object.isSealed(frozen)//===true//当然,更是一个不可扩展的对象.Object.isExtensible(frozen)//===false在ES5中，如果参数不是一个对象类型，将抛出一个TypeError异常。在ES2015中，非对象参数将被视为一个冻结的普通对象，因此会返回true。Object.isFrozen(1);//TypeError:1isnotanobject(ES5code)Object.isFrozen(1);//true(ES2015code)```##Object.isSealed()>判断对象是否已经冻结。##Object.keys()>判断对象是否已经密封。>>Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用for...in循环遍历该对象时返回的顺序一致。```js//simplearrayvararr=['a','b','c']console.log(Object.keys(arr))//console:['0','1','2']//arraylikeobjectvarobj={0:'a',1:'b',2:'c'}console.log(Object.keys(obj))//console:['0','1','2']//arraylikeobjectwithrandomkeyorderingvaranObj={100:'a',2:'b',7:'c'}console.log(Object.keys(anObj))//console:['2','7','100']//getFooisapropertywhichisn'tenumerablevarmyObj=Object.create({},{getFoo:{value:function(){returnthis.foo},},},)myObj.foo=1console.log(Object.keys(myObj))//console:['foo']```##Object.values()>返回一个包含所有给定对象自身可枚举属性名称的数组。>>Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同(区别在于for-in循环枚举原型链中的属性)。```jsvarobj={foo:'bar',baz:42}console.log(Object.values(obj))//['bar',42]//arraylikeobjectvarobj={0:'a',1:'b',2:'c'}console.log(Object.values(obj))//['a','b','c']//arraylikeobjectwithrandomkeyordering//whenweusenumerickeys,thevaluereturnedinanumericalorderaccordingtothekeysvaran_obj={100:'a',2:'b',7:'c'}console.log(Object.values(an_obj))//['b','c','a']//getFooispropertywhichisn'tenumerablevarmy_obj=Object.create({},{getFoo:{value:function(){returnthis.foo},},},)my_obj.foo='bar'console.log(Object.values(my_obj))//['bar']//non-objectargumentwillbecoercedtoanobjectconsole.log(Object.values('foo'))//['f','o','o']```##Object.fromEntries()>把键值对列表转换为一个对象。>>Map转化为Object>通过Object.fromEntries，可以将Map转化为Object:```jsconstmap=newMap([['foo','bar'],['baz',42]]);constobj=Object.fromEntries(map);console.log(obj);//{foo:\"bar\",baz:42}Array转化为Object通过Object.fromEntries，可以将Array转化为Object:constarr=[['0','a'],['1','b'],['2','c']];constobj=Object.fromEntries(arr);console.log(obj);//{0:\"a\",1:\"b\",2:\"c\"}对象转换为ObjectObject.fromEntries是Object.entries()的反转函数，借用arraymanipulationmethods可以转换对象，如下：constobject1={a:1,b:2,c:3};constobject2=Object.fromEntries(Object.entries(object1).map(([key,val])=>[key,val*2]));console.log(object2);//{a:2,b:4,c:6}```","JavaScript\\对象\\promise\\class.md":"#Class-class相对function是后出来的，既然class出来了，显然是为了解决function在处理面向对象设计中的缺陷而来-下面通过对比，来看看class作为ES6中的重大升级之一的优势在哪里：为了更好的对比，请参见我的另外一篇博文：js面向对象设计之function类-class写法更加简洁、含义更加明确、代码结构更加清晰。-class尽管也是函数，却无法直接调用（不存在防御性代码了）。-class不存在变量提升。-class为污染window等全局变量-class函数体中的代码始终以严格模式执行-可直接使用set和get函数,而function中需要通过`Object.defineProperty`方法来设置get和set-class中的this永远都不会指向window。-class可以从javascript中的几大类中进行继承：Array、number、string...-class中有一个对象super，这个对象可以取到父类的方法、构造函数等。-class中不存在实例方法，class中定义所有方法都是原型方法。这些方法也都是不可枚举的，使用forin这种方式无法遍历到它们。-class不能使用return来返回一个实例```js/*ReferenceError:Class01isnotdefined*/try{varins01=newClass01()}catch(e){console.error(e)}classClass01{}console.log(typeofClass01)/*function*//*ClassconstructorClass01cannotbeinvokedwithout'new'*/try{Class01()}catch(e){console.error(e)}console.log(window.Class01)/*undefined*/```##set&get```js//可直接使用set和get函数,而function中需要通过`Object.defineProperty`方法来设置get和setclassClass01{constructor(){}getname(){console.log('getter')returnthis._name}setname(v){this._name=vconsole.log('setter')returnthis}}varins01=newClass01()ins01.name/*getter*/ins01.name=2/*setter*/```##classthis不会指向window```js//class中的this永远都不会指向window。classClass01{constructor(){this.a='a'}geta(){returnthis.a}}letins01=newClass01()console.log(ins01.geta())/*a*/letobj={}obj.a='objA'obj.geta=ins01.getaconsole.log(obj.geta())/*'objA'*/window.a='windowA'window.geta=ins01.geta/*Cannotreadproperty'a'ofundefined*//*若是function类此处会返回'windowA'*/try{geta()}catch(e){console.error(e)}```##class继承```js//class可以从javascript中几大类中进行继承：Array、number、string....classClass01extendsArray{}letins01=newClass01(1,2,3);/*[1,2,3]*/letarr=ins01.shift();/*[2,3]*/arrinstanceofClass01;/*false*/ins01instanceofClass01;/*true*/小tips：在mozilla的开发者指南中看到一种比较高端的东西（关于从原生类继承肯定还有话题，会继续学习）：staticget[Symbol.species](){returnArray;}参见https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes```##super对象```js//class中有一个对象super，这个对象可以取到父类的方法、构造函数等。classClass01{constructor(name){this.name=name}geta(){console.log(this.name+'父类方法.')}}classClass02extendsClass01{geta(){super.geta()console.log(this.name+'子类方法.')}}varl=newClass02('Class02')l.geta()``````js//11、class不能使用return来返回一个实例（等等，我还没有试验过，不好意思，我会马上试验一下）。//编辑验证，class的constructor可以使用return，因此class与function一样可以返回任意的内容。若不写return语句，或返回是数值、字符串等非引用类型的值，则constructor任然会返回this（实例）。return[]或return{}都会使得new关键字并不会返回class的实例说了这么多的不同点，再来说说class和function的相同之处：//1、静态方法在这点上，两者还是有相似之处的。尽管相似，显然class要更加优雅，可读性也更强，class使用static关键词指定静态方法。并且class可以在函数体内定义静态函数，而function不能，这无疑也让function写出来的代码更加的复杂。classClass01{staticgeta(){console.log('01的静态方法')}}functionClass02(){}Class02.geta=function(){console.log('02的静态方法')}Class01.geta()Class02.geta()//2、私有属性和方法两者都必须采用闭包的方式才能实现。下面给出class的私有属性和方法。varClass02=(function(){letpValfunctionsayHello(){console.log(this)/*this指向window*/console.log('欢迎访问nDos的博客')}returnclassClass01{constructor(v='初始值'){pVal=v}getval(){sayHello()returnpVal}setval(v){pVal=v}}})()letins01=newClass02()console.log(ins01.val)ins01.val='hello'console.log(ins01.val)ins01instanceofClass02/*true*/ins01.constructor.name/*\"Class01\"*///小tips：上面的代码显示ins01是Class02的实例，但ins01的构造函数name属性却是Class01。显然这在项目中不可行，会给类的使用者造成困惑。下例可解决这个问题：varClass01=(function(){returnclassClass01{}})()letins01=newClass01()ins01instanceofClass01/*true*/ins01.constructor.name/*\"Class01\"*/```","JavaScript\\对象\\promise\\Generator.md":"#GeneratorGenerators是可以用来控制迭代器的函数。它们可以暂停，然后在任何时候恢复。如果这句话不好理解，可以看下接下来的示例。1.常规循环```jsfor(leti=0;i<5;i+=1){console.log(i)}//thiswillreturnimmediately0->1->2->3->4```2.利用Generator```jsfunction*generatorForLoop(){for(leti=0;i<5;i+=1){yieldconsole.log(i)}}constgenForLoop=generatorForLoop()console.log(genForLoop.next())//firstconsole.log-0console.log(genForLoop.next())//1console.log(genForLoop.next())//2console.log(genForLoop.next())//3console.log(genForLoop.next())//4```对比下代码，常规的循环只能一次遍历完所有值，Generator可以通过调用next方法拿到依次遍历的值，让遍历的执行变得“可控”。**1、基本语法**```jsfunction*gen(){yield1yield2yield3}letg=gen()//\"Generator{}\"```这个是Generator的定义方法，有几个点值得注意：-比普通函数多一个\\*-函数内部用yield来控制程序的执行的“暂停”-函数的返回值通过调用next来“恢复”程序执行Generator函数的定义不能使用箭头函数，否则会触发SyntaxError错误```jsletgenerator=*()=>{}//SyntaxErrorletgenerator=()*=>{}//SyntaxErrorletgenerator=(*)=>{}//SyntaxError```**2、yield表达式**yield关键字用来暂停和恢复一个生成器函数-yield表达式的返回值是undefined，但是遍历器对象的next方法可以修改这个默认值。-Generator对象的next方法，遇到yield就暂停，并返回一个对象，这个对象包括两个属性：value和done。```jsfunction*gen(){letvalval=yield1console.log(`1:${val}`)//1:undefinedval=yield2console.log(`2:${val}`)//2:undefinedval=yield3console.log(`3:${val}`)//3:undefined}varg=gen()console.log(g.next())//{value:1,done:false}console.log(g.next())//{value:2,done:false}console.log(g.next())//{value:3,done:false}console.log(g.next())//{value:undefined,done:true}```**3、方法**Generator对象有几个方法，next、return、throw。-next([value])Generator对象通过next方法来获取每一次遍历的结果，这个方法返回一个对象，这个对象包含两个属性：value和done。value是指当前程序的运行结果，done表示遍历是否结束。其实next是可以接受参数的，这个参数可以让你在Generator外部给内部传递数据，而这个参数就是作为yield的返回值。```jsfunction*gen(){varval=100while(true){console.log(`before${val}`)val=yieldvalconsole.log(`return${val}`)}}varg=gen()console.log(g.next(20).value)//before100//100console.log(g.next(30).value)//return30//before30//30console.log(g.next(40).value)//return40//before40//40```-return()return方法可以让Generator遍历终止，有点类似for循环的break。```jsfunction*gen(){yield1yield2yield3}varg=gen()console.log(g.next())//{value:1,done:false}console.log(g.return())//{value:undefined,done:true}console.log(g.next())//{value:undefined,done:true}```-throw()可以通过throw方法在Generator外部控制内部执行的“终断”。```jsfunction*gen(){while(true){try{yield42}catch(e){console.log(e.message)}}}letg=gen()console.log(g.next())//{value:42,done:false}console.log(g.next())//{value:42,done:false}console.log(g.next())//{value:42,done:false}//中断操作g.throw(newError('break'))console.log(g.next())//{value:undefined,done:true}```","JavaScript\\对象\\promise\\promise_async_await.md":"#Promiseasyncawait##Promise>-特点>-链式调用>>（1）对象的状态不受外界影响。>>​`Promise`对象代表一个异步操作，有三种状态：`Pending`（进行中）、`Resolved`（已完成，又称Fulfilled）和`Rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。>>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。>>​`Promise`对象的状态改变，只有两种可能：从`Pending`变为`Resolved`和从`Pending`变为`Rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。>>有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。>>​`Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`Pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。>>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署`Promise`更好的选择。```jsvarpromise=newPromise(function(resolve,reject){//...somecodeif(/*异步操作成功*/){resolve(value);}else{reject(error);}});```###Promise.prototype.then()>-then方法返回的是一个新的Promise实例>-第一个回调函数,会将返回结果作为参数,传入第二个回调函数```jspromise.then(function(value){//success},function(error){//failure},)```###Promise.prototype.catch()>`Promise.prototype.catch`方法是`.then(null,rejection)`的别名，用于指定发生错误时的回调函数。###Promise.all()>将多个Promise实例,包装成一个新的Promise实例>>```js>varp=Promise.all([p1,p2,p3])>>/*>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，>此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，>此时第一个被reject的实例的返回值，会传递给p的回>调函数。>*/>>letp1=newPromise((resolve,reject)=>{>resolve(11)>})>letp2=newPromise((resolve,reject)=>{>resolve(12)>})>>letp3=newPromise((resolve,reject)=>{>resolve(13)>})>>letp=Promise.all([p1,p2,p3])>p.then((res)=>{>console.log('then',res)>}).catch((res)=>{>console.log('catch',res)>})>//打印>then[(11,12,13)]>```>>```js>letp1=newPromise((resolve,reject)=>{>resolve(11);>})>letp2=newPromise(((resolve,reject)=>{>resolve(12);>}))>>letp3=newPromise(((resolve,reject)=>{>reject(33)>}))>>letp=Promise.all([p1,p2,p3]);>p.then(res=>{>console.log('then',res);>}).catch(res=>{>console.log(\"catch\",res)>});>//打印>catch33>>```###Promise.race()>就是通过竞赛来比较,看谁的转态先发生改变>>```js>varp=Promise.race([p1,p2,p3])>/*>p1,p2,p3中有一个实例率先改变状态,p就会跟着改变,先改变的Promise实例的返回值,就返回给p的回调函数>*/>```###Promise.resolve()>将现有对象转换为Promise对象>>`varjsPromise=Promise.resolve($.ajax('/whatever.json'));`>是一个状态为`fulfilled`的Promise实例>>-不会触发catch，可以正常出发then>-若是该方法触发`thrownewError('error')`,可以将状态修改为`rejected`###Promise.reject()```jsvarp=Promise.reject('出错了')//等同于varp=newPromise((resolve,reject)=>reject('出错了'))p.then(null,function(s){console.log(s)})//出错了```###done()>Promise对象的回调链，不管以`then`方法或`catch`方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个`done`方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。```jsasyncFunc().then(f1).catch(r1).then(f2).done()```###finally()>不管状态,都一定会执行```jsserver.listen(0).then(function(){//runtest}).finally(server.stop)```###Promise.try()```jsPromise.try(database.users.get({id:userId})).then(...).catch(...)```###例子####promise,then,catch```jsfunctiondemo(){letpr=newPromise((resolve,reject)=>{//1.这里使用setTimeout模拟异步,可以证明promise里面还是同步执行的,这里还是触发了reject//2.promise是通过resolve或reject传递数据给下一层//3.then是通过return传输给下一层letflag=false;setTimeout(()=>{flag=true;},500);if(flag)resolve(\"true\")elsereject(\"false\")});returnpr.then(res=>{return\"thenreturndata\"}).catch(res=>{console.log('catchdata',res);return\"data\"//catch使用return也可以返回数据});}demo().then(res=>{console.log(\"showdata\",res)})//输出catchdatafalseshowdatadata//flag改为trueshowdatathenreturndata```####Promise对象实现Ajax操作的例子```jsvargetJSON=function(url){varpromise=newPromise(function(resolve,reject){varclient=newXMLHttpRequest()client.open('GET',url)client.onreadystatechange=handlerclient.responseType='json'client.setRequestHeader('Accept','application/json')client.send()functionhandler(){if(this.readyState!==4){return}if(this.status===200){resolve(this.response)}else{reject(newError(this.statusText))}}})returnpromise}getJSON('/posts.json').then(function(json){console.log('Contents:'+json)},function(error){console.error('出错了',error)},)```##async,await>异步```javascriptasyncfunctionmain(){try{varval1=awaitfirstStep()varval2=awaitsecondStep(val1)varval3=awaitthirdStep(val1,val2)console.log('Final:',val3)}catch(err){console.error(err)}}```###Promise**1、基本语法**>Promise就是为了解决“回调地狱”问题的，它可以将异步操作的处理变得很优雅。回调地狱，代码难以维护，常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据这个promise可以解决异步的问题，本身不能说promise是异步的。创建Promise实例。```constpromise=newPromise(function(resolve,reject){//...somecodeif(/*异步操作成功*/){resolve(value)}else{reject(error)}})```Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。-处理结果正常的话，调用resolve(处理结果值)，将Promise对象的状态从“未完成”变为“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去-处理结果错误的话，调用reject(Error对象)，将Promise对象的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。```promise.then(function(value){//success},function(error){//failure})```Promise内部是有状态的(pending、fulfilled、rejected)，Promise对象根据状态来确定执行哪个方法。Promise在实例化的时候状态是默认pending的，当异步操作是完成的，状态会被修改为fulfilled，如果异步操作遇到异常，状态会被修改为rejected。**2、Promise.prototype.then()**```varpromise=newPromise(function(resolve,reject){resolve('传递给then的值')})promise.then(function(value){console.log(value)},function(error){console.error(error)})```-当handler返回一个正常值的时候，这个值会传递给Promise对象的onFulfilled方法。-定义的handler中产生异常的时候，这个值则会传递给Promise对象的onRejected方法。**3、Promise.prototype.catch()**捕获异常是程序质量保障最基本的要求，可以使用Promise对象的catch方法来捕获异步操作过程中出现的任何异常```functiontest(){returnnewPromise((resolve,reject)=>{reject(newError('es'))})}test().catch((e)=>{console.log(e.message)//es})```**4、Promise.resolve()**一般情况下我们都会使用newPromise()来创建Promise对象，但是除此之外我们也可以使用其他方法。在这里，我们将会学习如何使用Promise.resolve和Promise.reject这两个方法。静态方法Promise.resolve(value)可以认为是newPromise()方法的快捷方式。比如Promise.resolve(42)可以认为是以下代码的语法糖。```newPromise(function(resolve){resolve(42)})```方法Promise.resolve(value)的返回值也是一个Promise对象，所以我们可以像下面那样接着对其返回值进行.then调用。```Promise.resolve(42).then(function(value){console.log(value)})```**5、Promise.reject()**Promise.reject(error)是和Promise.resolve(value)类似的静态方法，是newPromise()方法的快捷方式。比如Promise.reject(newError(\"出错了\"))就是下面代码的语法糖形式。```newPromise(function(resolve,reject){reject(newError('出错了'))})```这段代码的功能是调用该Promise对象通过then指定的onRejected函数，并将错误（Error）对象传递给这个onRejected函数。```Promise.reject(newError('BOOM!'))```**6、Promise.all()**```varp1=Promise.resolve(1)varp2=Promise.resolve(2)varp3=Promise.resolve(3)Promise.all([p1,p2,p3]).then(function(results){console.log(results)//[1,2,3]})```Promise.all生成并返回一个新的Promise对象，所以它可以使用Promise实例的所有方法。参数传递promise数组中所有的Promise对象都变为resolve的时候，该方法才会返回，新创建的Promise则会使用这些promise的值。如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的Promise对象。由于参数数组中的每个元素都是由Promise.resolve包装（wrap）的，所以Promise.all可以处理不同类型的Promise对象。**7、Promise.race()**```varp1=Promise.resolve(1)varp2=Promise.resolve(2)varp3=Promise.resolve(3)Promise.race([p1,p2,p3]).then(function(value){console.log(value)//1})```Promise.race生成并返回一个新的Promise对象。参数promise数组中的任何一个Promise对象如果变为resolve或者reject的话，该函数就会返回，并使用这个Promise对象的值进行resolve或者reject。","JavaScript\\对象\\promise\\promise原理模拟.md":"#Promise原理模拟##核心逻辑分析1.Promise就是一个类在执行这个类的时候需要传递一个执行器进去执行器会立即执行2.Promise中有三种状态分别为成功fulfilled失败rejected等待pending-pending->fulfilled-pending->rejected-一旦状态确定就不可更改`3.resolve和reject函数是用来更改状态的-resolve:fulfilled-reject:rejected4.then方法内部做的事情就判断状态如果状态是成功调用成功的回调函数如果状态是失败调用失败回调函数then方法是被定义在原型对象中的5.then成功回调有一个参数表示成功之后的值then失败回调有一个参数表示失败后的原因6.同一个promise对象下面的then方法是可以被调用多次的7.then方法是可以被链式调用的,后面then方法的回调函数拿到值的是上一个then方法的回调函数的返回值```jsconstPENDING='pending'//等待constFULFILLED='fulfilled'//成功constREJECTED='rejected'//失败classMyPromise{constructor(executor){executor(this.resolve,this.reject)}status=PENDING//状态value=undefined//then函数成功回调需要的参数reason=undefined//then函数失败回调需要的参数resolve=(value)=>{//如果状态不是等待阻止程序向下执行if(this.status!==PENDING)return//将状态更改为成功this.status=FULFILLED//保存成功之后的值this.value=value}reject=(reason)=>{//如果状态不是等待阻止程序向下执行if(this.status!==PENDING)return//将状态更改为失败this.status=REJECTED//保存失败后的原因this.reason=reason}then=(successCallback,failCallback)=>{//判断状态if(this.status===FULFILLED){successCallback(this.value)}elseif(this.status===REJECTED){failCallback(this.reason)}}}module.exports=MyPromise```##异步调用解决###1.场景```jsconstpromise=newMyPromise((resolve,reject)=>{setTimeout(()=>{resolve('成功')},2000)})promise.then((value)=>{console.log(value)},(reason)=>{console.log(reason)},)```###2.实现步骤分析-定时器中回调函数为异步执行代码-then函数执行时状态还是pending-即then函数中需要增加状态为pending时的执行逻辑，将成功和失败的回调存储起来在相应的resolve和reject函数中调用###3.代码实现```jsclassMyPromise{...successCallback=undefined;//成功回调failCallback=undefined;//失败回调resolve=value=>{...//成功回调存在则调用this.successCallback&&this.successCallback(value);}reject=reason=>{...//失败回调存在则调用this.failCallback&&this.failCallback(reason);}then=(successCallback,failCallback)=>{//判断状态if(this.status===FULFILLED){...}else{//等待//将成功和失败回调存储起来this.successCallback=successCallback;this.failCallback=failCallback;}}}```##then的多次调用###1.场景```jspromise.then((value)=>{console.log(value)})promise.then((value)=>{console.log(value)})promise.then((value)=>{console.log(value)})```###2.实现步骤分析-then多次调用同步代码不需要做特殊处理，而异步的是需要特殊处理的-即在then多次调用时，将每次调用的回调都存储起来-当状态变成成功或失败时，再依次去执行存储起来的回调###3.代码实现```jsclassMyPromise{...successCallback=[];//成功回调failCallback=[];//失败回调resolve=value=>{...//成功回调存在则调用//this.successCallback&&this.successCallback(value);while(this.successCallback.length)this.successCallback.shift()(this.value)}reject=reason=>{...//失败回调存在则调用//this.failCallback&&this.failCallback(reason);while(this.failCallback.length)this.failCallback.shift()(this.reason)}then=(successCallback,failCallback)=>{//判断状态if(this.status===FULFILLED){...}else{//等待//将成功和失败回调存储起来this.successCallback.push(successCallback);this.failCallback.push(failCallback);}}}```##then的链式调用###1.场景```jspromise.then((value)=>{console.log(value)return100}).then((value)=>{console.log(value)}).then((value)=>{console.log(value)})```###2.实现步骤分析-then方法的链式调用必须每一个then方法都返回一个Promise对象-把上一个then方法的返回值（需要判断这个返回值是不是Promise对象）传递给下一个then方法###3.代码实现```jsclassMyPromise{...then=(successCallback,failCallback)=>{constpromise2=newMyPromise((resolve,reject)=>{//判断状态if(this.status===FULFILLED){constx=successCallback(this.value);//判断x的值是普通值还是Promise对象//如果是普通值，直接调用resolve传参//如果是Promise对象则查看promise对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用rejectresolvePromise(x,resolve,reject);}elseif(this.status===REJECTED){failCallback(this.reason);}else{//等待//将成功和失败回调存储起来this.successCallback.push(successCallback);this.failCallback.push(failCallback);}});returnpromise2;}}functionresolvePromise(x,resolve,reject){if(xinstanceofMyPromise){//promise对象//x.then(value=>resolve(value),reason=>reject(reason));x.then(resolve,reject);}else{//普通值resolve(x);}}```##链式调用then不能传当前promise###1.场景```jsletp1=promise.then((value)=>{console.log(value)returnp1})```###2.实现步骤分析-在then方法当中不能返回当前这个then方法所返回的Promise对象###3.代码实现```jsclassMyPromise{...then=(successCallback,failCallback)=>{constpromise2=newMyPromise((resolve,reject)=>{//判断状态if(this.status===FULFILLED){setTimeout(()=>{constx=successCallback(this.value);//判断x的值是普通值还是Promise对象//如果是普通值，直接调用resolve传参//如果是Promise对象则查看promise对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用reject//由于此处拿不到当前new出来返回的promise2对象，所以需要改为异步调用，包一层setTimeoutresolvePromise(promise2,x,resolve,reject);},0);}elseif(this.status===REJECTED){...}else{...}});returnpromise2;}}functionresolvePromise(promise2,x,resolve,reject){if(promise2===x){returnreject(newTypeError(\"Chainingcycledetectedforpromise#<Promise>\"));}...}```##异常处理###1.场景>为了代码的健壮性，要在相应的位置进行适当的错误处理###2.实现步骤分析-构造函数调用执行器时-成功或失败回调执行错误时调用下一个promise的reject方法把错误信息传递下去###3.代码实现```jsclassMyPromise{constructor(executor){try{executor(this.resolve,this.reject);}catch(e){this.reject(e);}}...resolve=value=>{...while(this.successCallback.length)this.successCallback.shift()();}reject=reason=>{...while(this.failCallback.length)this.failCallback.shift()();}then=(successCallback,failCallback)=>{constpromise2=newMyPromise((resolve,reject)=>{//判断状态if(this.status===FULFILLED){setTimeout(()=>{try{constx=successCallback(this.value);//判断x的值是普通值还是Promise对象//如果是普通值，直接调用resolve传参//如果是Promise对象则查看promise对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用reject//由于此处拿不到当前new出来返回的promise2对象，所以改为异步调用，包一层setTimeoutresolvePromise(promise2,x,resolve,reject);}catch(e){//如果发生错误手动调用下一个promise的reject方法reject(e);}},0);}elseif(this.status===REJECTED){setTimeout(()=>{try{constx=failCallback(this.reason);;//判断x的值是普通值还是Promise对象//如果是普通值，直接调用resolve传参//如果是Promise对象则查看promise对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用reject//由于此处拿不到当前new出来返回的promise2对象，所以改为异步调用，包一层setTimeoutresolvePromise(promise2,x,resolve,reject);}catch(e){//如果发生错误手动调用下一个promise的reject方法reject(e);}},0);}else{//等待//将成功和失败回调存储起来this.successCallback.push(()=>{setTimeout(()=>{try{constx=successCallback(this.value);//判断x的值是普通值还是Promise对象//如果是普通值，直接调用resolve传参//如果是Promise对象则查看promise对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用reject//由于此处拿不到当前new出来返回的promise2对象，所以改为异步调用，包一层setTimeoutresolvePromise(promise2,x,resolve,reject);}catch(e){//如果发生错误手动调用下一个promise的reject方法reject(e);}},0);});this.failCallback.push(()=>{setTimeout(()=>{try{constx=failCallback(this.reason);;//判断x的值是普通值还是Promise对象//如果是普通值，直接调用resolve传参//如果是Promise对象则查看promise对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用reject//由于此处拿不到当前new出来返回的promise2对象，所以需要改为异步调用，包一层setTimeoutresolvePromise(promise2,x,resolve,reject);}catch(e){//如果发生错误手动调用下一个promise的reject方法reject(e);}},0);});}});returnpromise2;}}```##then方法参数变为可选参数###1.场景```jsconstpromise=newMyPromise((resolve,reject)=>{resolve(100)})promise.then().then().then((value)=>console.log(value),(reason)=>console.log(reason),)```###2.实现步骤分析-then方法的参数都是可选参数-如果什么都传入的话就是将值传递下去，相当于传递一个函数**value=>value**-所以在then函数中进行相应的参数判断即可###3.代码实现```jsclassMyPromise{...then=(successCallback,failCallback)=>{successCallback=successCallback?successCallback:value=>value;failCallback=failCallback?failCallback:reason=>{throwreason;};...}}```##静态方法all###1.场景```jsfunctionp1(){returnnewMyPromise(function(resolve,reject){setTimeout(function(){resolve('p1')},2000)})}functionp2(){returnnewMyPromise(function(resolve,reject){reject('失败')//resolve('成功');})}MyPromise.all(['a','b',p1(),p2(),'c']).then((result)=>{//result->['a','b','p1','p2','c']})```###2.实现步骤分析-按照传入数组的顺序，执行后返回相应顺序的执行结果-all方法返回的也是一个Promise对象，可以继续链式调用then-all方法传入的数组中有一个执行的结果是失败的则执行的结果为失败###3.代码实现```jsstaticall(array){letresult=[];letindex=0;returnnewMyPromise((resolve,reject)=>{functionaddData(key,value){result[key]=value;index++;if(index===array.length){resolve(result);}}for(leti=0;i<array.length;i++){letcurrent=array[i];if(currentinstanceofMyPromise){//promise对象current.then(value=>addData(i,value),reason=>reject(reason))}else{//普通值addData(i,array[i]);}}})}```##静态方法resolve###1.场景```jsMyPromise.resolve(100).then((value)=>console.log(value))//100```###2.实现步骤分析-将给定的值转化为一个Promise对象，即返回的就是一个Promise对象###3.代码实现```jsstaticresolve(value){if(valueinstanceofMyPromise)returnvalue;returnnewMyPromise(resolve=>resolve(value));}```##原型方法finally###1.场景###2.实现步骤分析-无论当前的promise对象最终的状态是成功还是失败，finally方法的回调都会执行-在finally方法后面可以继续的链式调用then方法拿到当前promise对象最终返回的结果###3.代码实现```jsfinally(callback){returnthis.then(value=>{returnMyPromise.resolve(callback()).then(()=>value);},reason=>{returnMyPromise.resolve(callback()).then(()=>{throwreason})})}```##十、原型方法catch###1.场景```jsfunctionp1(){returnnewPromise(function(resolve,reject){reject('hello')})}p1().then((value)=>console.log(value)).catch((reason)=>console.log(reason))```###2.实现步骤分析-用来处理当前的promise对象最终的状态为失败的情况的-当前的then方法是可以不传递失败回调的，可以在后面链式调用catch即可捕获到失败信息###3.代码实现```jscatch(failCallback){returnthis.then(undefined,failCallback)}``````js//附上完整代码constPENDING='pending'//等待constFULFILLED='fulfilled'//成功constREJECTED='rejected'//失败classMyPromise{constructor(executor){try{executor(this.resolve,this.reject)}catch(e){this.reject(e)}}//promsie状态status=PENDING//成功之后的值value=undefined//失败后的原因reason=undefined//成功回调successCallback=[]//失败回调failCallback=[]resolve=(value)=>{//如果状态不是等待阻止程序向下执行if(this.status!==PENDING)return//将状态更改为成功this.status=FULFILLED//保存成功之后的值this.value=value//判断成功回调是否存在如果存在调用//this.successCallback&&this.successCallback(this.value);while(this.successCallback.length)this.successCallback.shift()()}reject=(reason)=>{//如果状态不是等待阻止程序向下执行if(this.status!==PENDING)return//将状态更改为失败this.status=REJECTED//保存失败后的原因this.reason=reason//判断失败回调是否存在如果存在调用//this.failCallback&&this.failCallback(this.reason);while(this.failCallback.length)this.failCallback.shift()()}then(successCallback,failCallback){//参数可选successCallback=successCallback?successCallback:(value)=>value//参数可选failCallback=failCallback?failCallback:(reason)=>{throwreason}letpromsie2=newMyPromise((resolve,reject)=>{//判断状态if(this.status===FULFILLED){setTimeout(()=>{try{letx=successCallback(this.value)//判断x的值是普通值还是promise对象//如果是普通值直接调用resolve//如果是promise对象查看promsie对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用rejectresolvePromise(promsie2,x,resolve,reject)}catch(e){reject(e)}},0)}elseif(this.status===REJECTED){setTimeout(()=>{try{letx=failCallback(this.reason)//判断x的值是普通值还是promise对象//如果是普通值直接调用resolve//如果是promise对象查看promsie对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用rejectresolvePromise(promsie2,x,resolve,reject)}catch(e){reject(e)}},0)}else{//等待//将成功回调和失败回调存储起来this.successCallback.push(()=>{setTimeout(()=>{try{letx=successCallback(this.value)//判断x的值是普通值还是promise对象//如果是普通值直接调用resolve//如果是promise对象查看promsie对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用rejectresolvePromise(promsie2,x,resolve,reject)}catch(e){reject(e)}},0)})this.failCallback.push(()=>{setTimeout(()=>{try{letx=failCallback(this.reason)//判断x的值是普通值还是promise对象//如果是普通值直接调用resolve//如果是promise对象查看promsie对象返回的结果//再根据promise对象返回的结果决定调用resolve还是调用rejectresolvePromise(promsie2,x,resolve,reject)}catch(e){reject(e)}},0)})}})returnpromsie2}finally(callback){returnthis.then((value)=>{returnMyPromise.resolve(callback()).then(()=>value)},(reason)=>{returnMyPromise.resolve(callback()).then(()=>{throwreason})},)}catch(failCallback){returnthis.then(undefined,failCallback)}staticall(array){letresult=[]letindex=0returnnewMyPromise((resolve,reject)=>{functionaddData(key,value){result[key]=valueindex++if(index===array.length){resolve(result)}}for(leti=0;i<array.length;i++){letcurrent=array[i]if(currentinstanceofMyPromise){//promise对象current.then((value)=>addData(i,value),(reason)=>reject(reason),)}else{//普通值addData(i,array[i])}}})}staticresolve(value){if(valueinstanceofMyPromise)returnvaluereturnnewMyPromise((resolve)=>resolve(value))}}functionresolvePromise(promsie2,x,resolve,reject){if(promsie2===x){returnreject(newTypeError('Chainingcycledetectedforpromise#<Promise>'),)}if(xinstanceofMyPromise){//promise对象//x.then(value=>resolve(value),reason=>reject(reason));x.then(resolve,reject)}else{//普通值resolve(x)}}module.exports=MyPromise```","JavaScript\\对象\\proxy.md":"#Proxy>在ES6标准中新增的一个非常强大的功能是Proxy，它可以自定义一些常用行为如查找、赋值、枚举、函数调用等。通过Proxy这个名称也可以看出来它包含了“代理”的含义，只要有“代理”的诉求都可以考虑使用Proxy来实现。**1.基本语法**```jsletp=newProxy(target,handler)```|参数|含义|必选||-------|-----------------------------------------------------------------------------------|----||target|用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）|y||handler|一个对象，其属性是当执行一个操作时定义代理的行为的函数|y|**2.常用拦截操作**-get拦截对象属性的读取，比如proxy.foo和proxy['foo']。```jsletarr=[7,8,9]arr=newProxy(arr,{get(target,prop){//console.log(target,prop)returnpropintarget?target[prop]:'error'},})console.log(arr[1])console.log(arr[10])``````jsletdict={hello:'你好',world:'世界',}dict=newProxy(dict,{get(target,prop){returnpropintarget?target[prop]:prop},})console.log(dict['world'])console.log(dict['imooc'])```-set拦截对象属性的设置，比如proxy.foo=v或proxy['foo']=v，返回一个布尔值。```jsletarr=[]arr=newProxy(arr,{set(target,prop,val){if(typeofval==='number'){target[prop]=valreturntrue}else{returnfalse}},})arr.push(5)arr.push(6)console.log(arr[0],arr[1],arr.length)```-has拦截propKeyinproxy的操作，返回一个布尔值。```jsletrange={start:1,end:5,}range=newProxy(range,{has(target,prop){returnprop>=target.start&&prop<=target.end},})console.log(2inrange)console.log(9inrange)```-ownKeys拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。```jsletuserinfo={username:'xxx',age:18,_password:'***',}userinfo=newProxy(userinfo,{ownKeys(target){returnObject.keys(target).filter((key)=>!key.startsWith('_'))},})//for(letkeyinuserinfo){//console.log(key)//}console.log(Object.keys(userinfo))```-deleteProperty拦截deleteproxy[propKey]的操作，返回一个布尔值。```jsletuser={name:'xxx',age:18,_password:'***',}user=newProxy(user,{get(target,prop){if(prop.startsWith('_')){thrownewError('不可访问')}else{returntarget[prop]}},set(target,prop,val){if(prop.startsWith('_')){thrownewError('不可访问')}else{target[prop]=valreturntrue}},deleteProperty(target,prop){//拦截删除if(prop.startsWith('_')){thrownewError('不可删除')}else{deletetarget[prop]returntrue}},ownKeys(target){returnObject.keys(target).filter((key)=>!key.startsWith('_'))},})console.log(user.age)console.log(user._password)user.age=18console.log(user.age)try{user._password='xxx'}catch(e){console.log(e.message)}try{//deleteuser.agedeleteuser._password}catch(e){console.log(e.message)}console.log(user.age)for(letkeyinuser){console.log(key)}```-apply拦截Proxy实例作为函数调用的操作，比如proxy(...args)、proxy.call(object,...args)、proxy.apply(...)。```jsletsum=(...args)=>{letnum=0args.forEach((item)=>{num+=item})returnnum}sum=newProxy(sum,{apply(target,ctx,args){returntarget(...args)*2},})console.log(sum(1,2))console.log(sum.call(null,1,2,3))console.log(sum.apply(null,[1,2,3]))```-construct拦截Proxy实例作为构造函数调用的操作，比如newproxy(...args)。```jsletUser=class{constructor(name){this.name=name}}User=newProxy(User,{construct(target,args,newTarget){console.log('construct')returnnewtarget(...args)},})console.log(newUser('imooc'))```","JavaScript\\对象\\Reflect.md":"#ReflectReflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。**1.设计目的**-将Object属于语言内部的方法放到Reflect上```jsletobj={}letnewVal=''Reflect.defineProperty(obj,'name',{get(){returnnewVal},set(val){console.log('set')//this.name=valnewVal=val},})obj.name='es'console.log(obj.name)```-修改某些Object方法的返回结果，让其变得更合理```js//老写法try{Object.defineProperty(target,property,attributes)//success}catch(e){//failure}//新写法if(Reflect.defineProperty(target,property,attributes)){//success}else{//failure}```-让Object操作变成函数行为```js//老写法'assign'inObject//true//新写法Reflect.has(Object,'assign')//true```-Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。```jsProxy(target,{set:function(target,name,value,receiver){varsuccess=Reflect.set(target,name,value,receiver)if(success){console.log('property'+name+'on'+target+'setto'+value)}returnsuccess},})```Reflect是一个内置的对象，它提供拦截JavaScript操作的方法，这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。**2、常用方法**-Reflect.apply()>Reflect.apply(target,thisArgument,argumentsList),target为目标函数；thisArgument为target函数调用时绑定的this对象；argumentsList为target函数调用时传入的实参列表，该参数应该是一个类数组的对象```jsReflect.apply(Math.floor,undefined,[1.75])//1Reflect.apply(String.fromCharCode,undefined,[104,101,108,108,111])//\"hello\"Reflect.apply(RegExp.prototype.exec,/ab/,['confabulation']).index//4Reflect.apply(''.charAt,'ponies',[3])//\"i\"```-Reflect.construct()Reflect.construct()方法的行为有点像new操作符构造函数，相当于运行newtarget(...args)```jsvard=Reflect.construct(Date,[1776,6,4])dinstanceofDate//trued.getFullYear()//1776```-Reflect.defineProperty()静态方法Reflect.defineProperty()基本等同于Object.defineProperty()方法，唯一不同是返回Boolean值。```jsconststudent={}Reflect.defineProperty(student,'name',{value:'Mike',})//truestudent.name//\"Mike\"```-Reflect.deleteProperty()Reflect.deleteProperty允许你删除一个对象上的属性。返回一个Boolean值表示该属性是否被成功删除。它几乎与非严格的deleteoperator相同。```jsvarobj={x:1,y:2,}Reflect.deleteProperty(obj,'x')//trueobj//{y:2}vararr=[1,2,3,4,5]Reflect.deleteProperty(arr,'3')//truearr//[1,2,3,,5]//如果属性不存在，返回trueReflect.deleteProperty({},'foo')//true//如果属性不可配置，返回falseReflect.deleteProperty(Object.freeze({foo:1,}),'foo',)//false```-Reflect.get()Reflect.get()方法的工作方式，就像从object(target[propertyKey])中获取属性，但它是作为一个函数执行的。```js//Objectvarobj={x:1,y:2,}Reflect.get(obj,'x')//1//ArrayReflect.get(['zero','one'],1)//\"one\"//Proxywithagethandlervarx={p:1,}varobj=newProxy(x,{get(t,k,r){returnk+'bar'},})Reflect.get(obj,'foo')//\"foobar\"```-Reflect.getOwnPropertyDescriptor()静态方法Reflect.getOwnPropertyDescriptor()与Object.getOwnPropertyDescriptor()方法相似。如果在对象中存在，则返回给定的属性的属性描述符，否则返回undefined。```jsReflect.getOwnPropertyDescriptor({x:'hello',},'x',)//{value:\"hello\",writable:true,enumerable:true,configurable:true}Reflect.getOwnPropertyDescriptor({x:'hello',},'y',)//undefinedReflect.getOwnPropertyDescriptor([],'length')//{value:0,writable:true,enumerable:false,configurable:false}```-更多方法可以参考[Reflect](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FReflect)","JavaScript\\拓展\\深浅拷贝.md":"#深浅拷贝>引用类型在赋值的过程中其实是复制了地址,从而导致,改变一行其他的也会发生改变##问题>改变任意一方都会影响例外一方```jsleta={age:1,name:'grh',}letb=aa.age=2b.name='rh'console.log(b.age)//2希望是1console.log(b.name)//rh希望是grh```##浅拷贝-当复制的对象都不是引用类型,就可以使用浅拷贝-遍历复制,最后返回新的对象```jsfunctionshallowCopy(obj){vartemp={}for(keyinobj){if(obj.hasOwnProperty(key)){temp[key]=obj[key]}}returntemp}leta={age:1,name:{first:'grh',},}letb=shallowCopy(a)a.age=2a.name.first='rh'console.log(b.age)//1console.log(b.name.first)//rh希望拿到的是grh,这里的问题主要是name属性不是值类型,是引用类型,改方法就会失效```##深拷贝-简单说就是浅拷贝+递归-浅拷贝时候,判断是否为对象,如果是对象就进行递归操作```jsfunctioncloneDeep(source){vartarget={}for(letkeyinsource){if(Object.prototype.hasOwnProperty.call(source,key)){if(typeofsource[key]==='object'){target[key]=cloneDeep(source[key])}else{target[key]=source[key]}}}returntarget}leta={age:1,name:{first:'grh',},}letb=cloneDeep(a)a.age=2a.name.first='rh'console.log(b.age)//1console.log(b.name.first)//grh```该方法问题:1.`typeofnull==='object'`,传入null应该返回null,而不是{}2.没有考虑数组的兼容性,传入`[1,2]`会返回`{0:1,1:2}````jsfunctioncloneDeep2(source){if(!isObject(source))returnsource//非对象返回自身//if(source===null)returnnull//解决数组兼容vartarget=Array.isArray(source)?[]:{}for(varkeyinsource){if(Object.prototype.hasOwnProperty.call(source,key)){if(isObject(source[key])){target[key]=cloneDeep2(source[key])//注意这里}else{target[key]=source[key]}}}returntarget}//解决typeofnull==='object'functionisObject(obj){returntypeofobj==='object'&&obj!=null}```","JavaScript\\拖拽\\index.md":"如何改变拖动时鼠标悬浮样式H5提供了拖放（DragandDrop）事件，【drag&drop】API中DataTransfer对象，来配置拖拽行为的鼠标效果DataTransfer对象具有effectAllowed和dropEffect两个属性。effectAllowed和dropEffect最主要的作用是，用于配置拖拽操作过程中鼠标指针的类型以便提示用户后续可执行怎样的操作；其次的作用是，控制drop事件的触发与否。下面我们来看看effectAllowed和dropEffect两个属性的介绍，看看他们是如何控制鼠标指针样式的effectAllowed：1.属性作用：用于设置被拖拽元素可执行的操作。2.取值范围：copy，限定dropEffect的属性值为copy，否则会鼠标指针为禁止样式link，限定dropEffect的属性值为link，否则会鼠标指针为禁止样式move，限定dropEffect的属性值为move，否则会鼠标指针为禁止样式copyLink，限定dropEffect的属性值为copy和link，否则会鼠标指针为禁止样式copyMove，限定dropEffect的属性值为copy和move，否则会鼠标指针为禁止样式linkMove，限定dropEffect的属性值为link和move，否则会鼠标指针为禁止样式all，允许dropEffect的属性值为任意值none，鼠标指针一直为禁止样式，不管dropEffect的属性值是什么uninitialized，没有限定dropEffect属性的值，效果和all一样。3.注意：仅能在dragstart事件中设置该属性，其他事件中设置均无效。dropEffect属性1.属性作用：用于设置目标元素将执行的操作，若属性值属于effectAllowed范围内，则鼠标指针将显示对应的指针样式，否则则显示禁止的指针样式。2.取值范围：copy：被拖拽元素将被复制到目标元素内，若属于effectAllowed范围内时，则鼠标指针显示复制的样式，否则则显示禁止的指针样式。link：被拖拽元素将以超链接的形式打开资源，若属于effectAllowed范围内时，则鼠标指针显示超链接的样式，否则则显示禁止的指针样式。move：被拖拽元素将被移动到目标元素内，若属于effectAllowed范围内时，则鼠标指针显示移动的样式，否则则显示禁止的指针样式。none：被拖拽元素不能在目标元素上作任何操作，一直显示禁止的指针样式。除了文本框外其他元素的默认值均为none3.注意：1）仅能在dragover事件中设置该属性值，其他事件中设置均无效2）当显示禁止的指针样式时，将无法触发目标元素的drop事件。","JavaScript\\数据结构\\buffer.md":"#Buffer>**buffer即缓存，是对二进制数据处理的一种方式。**>>ES6推出才正式有了`ArrayBuffer`##ArrayBuffer>-最基础的二进制对象，是对固定长度的连续内存空间的引用>-`Uint8Array`，`Uint16Array`，`Uint32Array`可以理解为`ArrayBuffer`的翻译器-`Uint8Array`将`ArrayBuffer`中的每个字节视为一个单位。每个单位是0到255之间的数字。之所以是255，是因为每个单位最多是8位，即2^8次方。-`Uint16Array`将`ArrayBuffer`中每2个字节视为一个单位。每个单位是0到65535之间的整数,2^16。-`Uint32Array`将`ArrayBuffer`中每4个字节视为一个单位。每个单位是0到4294967295之间的整数。2^32。```js//我们可以通过BYTES_PER_ELEMENT静态属性来得之视图单位的大小constbuf8=newUint8Array()constbuf16=newUint16Array()constbuf32=newUint32Array()console.log(buf8.BYTES_PER_ELEMENT)//1console.log(buf16.BYTES_PER_ELEMENT)//2console.log(buf32.BYTES_PER_ELEMENT)//4```##TypedArray>`TypedArray`是`Uint8Array`，`Uint16Array`,`Uint32Array`统称,都是`TypedArray`（类型数组）的一种形式罢了。###DataView>`DataView`就是一种更灵活的视图```jsconstbuffer=newArrayBuffer(16)//分配一个内存空间constview=newDataView(buffer)//创建DataView视图view.setUint32(0,4294967295)//从第0个空间开始，以32位的形式写入数据//有时候我想以8位的形式“翻译”这个内存空间，从偏移量0开始翻译console.log(view.getUint8(0))//255//今天心情好，想以16位的形式“翻译”这个内存空间，从偏移量0开始读console.log(view.getUint16(0))//65535//今天心情超好，想以32位的形式“翻译”这个内存空间，从偏移量0开始读console.log(view.getUint32(0))//4294967295```###Node中的Buffer-`Buffer.alloc(size[,fill[,encoding]])`创建一个buffer空间，可以填充制定元素，也可以指定编码类型-```Buffer.from()```以buffer方式存储内容-`Buffer.from(array)`创建一个buffer数组buf，`buf.values()`返回一个可以迭代的对象-`Buffer.from(string[,encoding])`创建一个buffer字符串，可以指定编码类型-`Buffer.from(buffer)`拷贝一个buffer对象###前端人眼中的Buffer先从前端比较常见的说起。在Web开发中，我们可能需要对文件做一些处理。比如**导出excel，下载文件，上传头像等等。**这些操作其实都是操作二进制数据。```js//伪代码示例//Blob上传图片//fileHandler为前置工作伪代码//FileReader加载图片，cavans压缩图片等constcanvas=fileHandler()//创建Blob对象和FormDatacanvas.toBlob((blob)=>{this.imgBlob=blob},'image/jpeg')letformdata=newFormData()formdata.append('file',this.imgBlob,'img.jpeg')//上传图片axios({headers:{'Content-Type':'multipart/form-data',},method:'post',url:uploadUrl,data:formdata,}).then((res)=>{//dosomething}).catch((err)=>{//dosomething})```###大前端眼中的Buffer大前端可能就涉及一些前端工程化，脚手架，打包工具等。这时候就可以通过流式处理操作Buffer。比如**按行读取某个配置文件**，处理webpack的一些工作流，和cli交互读取和写入文件等等。```ts//伪代码示例//逐行读取配置文件，个性化配置constfs=require('fs')constreadline=require('readline')//创建可读流constrl=readline.createInterface({input:fs.createReadStream('theme.less'),})rl.on('line',(line:string)=>{if(line.trim().startsWith('configStart')){//伪代码，处理变量themeHandlerStart()}if(line.trim().startsWith('configStart')){//伪代码，处理变量themeHandlerEnd()}})```###服务端眼中的Buffer对于服务端的同学来说，buffer的应用就更广泛了比如压缩和解压缩，比如加密解密，信息脱敏等等，其实都和buffer脱不了干系此外因为buffer是操作二进制对象，所以他的性能和灵活性比常规的jsAPI会强很多-比如要求更快速的响应时，http直接传输buffer会比传输字符串的效率更高-比如日志持久化需要节省空间时，用不同的编码来压缩空间等等用Buffer能更自由灵活的去调和时间复杂度和空间复杂度之间的关系```js//伪代码示例//压缩文件const{createGzip}=require('zlib')const{pipeline}=require('stream')const{createReadStream,createWriteStream}=require('fs')constgzip=createGzip()constsource=createReadStream('./package.json')constdestination=createWriteStream('./package.json.gz')pipeline(source,gzip,destination,(err)=>{if(err){console.error('发生错误:',err)process.exitCode=1}})```","JavaScript\\数据结构\\Map\\Map.md":"#Map>-类似对象>-键值对的集合>-'键'不限于字符串##实例化```jsletmap=newMap([iterable])```>-Iterable可以是一个数组或其他的Iterable对象,其元素为键值对(两个元素的数组,eg:`[[1,'one'],[2,`'two']]`)>-`null`会被当做`undefined`##添加set```jsletkeyObj={}letkeyFunc=function(){}letkeyString='astring'//添加键map.set(keyString,\"和键'astring'关联的值\")map.set(keyObj,'和键keyObj关联的值')map.set(keyFunc,'和键keyFunc关联的值')```###删除delete&clear```js//删除指定的数据map.delete(keyObj)//删除所有数据map.clear()```###统计size```js//统计所有key-value的总数console.log(map.size)//2//判断是否有key-valueconsole.log(map.has(keyObj))//true```###查询get```jsconsole.log(map.get(keyObj))```##遍历方法>-`keys`:返回一个新的Iterator对象,(按照插入map对象的每个key值)>-`values`:返回一个新的Iterrator对象>-`entries`:返回一个新的包含`[key,value]`对的迭代(`Iterator`)对象>-`forEach`:会以插入顺序对Map对象每一个键值对执行应该参数提供回调函数>-`for...of`:直接遍历每一个成员```jsmap.forEach((value,key)=>console.log(value,key))for(let[key,value]ofmap){console.log(key,value)}for(letkeyofmap.keys()){console.log(key)}for(letvalueofmap.values()){console.log(value)}for(let[key,value]ofmap.entries()){console.log(key,value)}```","JavaScript\\数据结构\\Map\\WeekMap.md":"#WeekMap>-只接受对象作为键名(null除外),不接受其他类型的值作为键值>-不计入垃圾回收机制```js//WeakMap可以使用set方法添加成员constwm1=newWeakMap()constkey={foo:1,}wm1.set(key,2)wm1.get(key)//2//WeakMap也可以接受一个数组，//作为构造函数的参数constk1=[1,2,3]constk2=[4,5,6]constwm2=newWeakMap([[k1,'foo'],[k2,'bar'],])wm2.get(k2)//\"bar\"```","JavaScript\\数据结构\\Set\\set.md":"#Set>-在JavaScript里通常使用Array或Object来存储数据。>-但是在频繁操作数据的过程中查找或者统计并需要手动来实现，并不能简单的直接使用。>-比如如何保证Array是去重的，如何统计Object的数据总数等，必须自己去手动实现类似的需求，不是很方便。>-在ES6中为了解决上述痛点，新增了数据结构Set和Map，它们分别对应传统数据结构的“集合”和“字典”>-特性>-不允许数据重复##基本用法###生成Set实例```jslets=newSet()lets=newSet([1,2,3,4])```###添加数据```jss.add('a')s.add('b')//ors.add('a').add('b')```###删除数据```js//删除指定s.delete('a')//删除全部s.clear()```###统计数据>-`has`:是否拥有该元素>-`size`:统计数据的总数```js//判断是否拥有数据项,返回booleans.has('a')//true//计算总数s.size//2```##遍历方法>`keys`:键名的遍历器>>`values`:键值遍历器>>`entries`:返回键值对的遍历器>>`forEach`:使用回调函数遍历每个成员>>`for...of`:可以直接遍历每一个成员```jsconsole.log(s.keys())//SetIterator{\"hello\",\"goodbye\"}console.log(s.values())//SetIterator{\"hello\",\"goodbye\"}console.log(s.entries())//SetIterator{\"hello\"=>\"hello\",\"goodbye\"=>\"goodbye\"}s.forEach((item)=>{console.log(item)//hello//goodbye})for(letitemofs){console.log(item)}for(letitemofs.keys()){console.log(item)}for(letitemofs.values()){console.log(item)}for(letitemofs.entries()){console.log(item[0],item[1])}```##set运用###数据去重```jsletarr=[1,2,3,4,5,6,7]lets=newSet(arr)```###合并去重```jsletarr1=[1,2,3]letarr2=[2,3,4]lets=newSet([...arr1,...arr2])console.log(s)console.log([...s])console.log(Array.from(s))```###交集```js//lets1=newSet(arr1);lets2=newSet(arr2)letresult=newSet(arr1.filter((item)=>s2.has(item)))Array.from(result)```","JavaScript\\数据结构\\Set\\WeakSet.md":"#WeakSet>-和Set类似>-WeakSet成员只能是对象,不能是其他类型的值>-没有size属性>-不可以遍历它的成员>-WeakSet的对象是弱引用>-垃圾回收机制不用考虑WeakSet对该对象的引用```jsconstws=newWeakSet()ws.add(1)//TypeError:Invalidvalueusedinweaksetws.add(Symbol())//TypeError:invalidvalueusedinweaksetletws=newWeakSet()constobj1={name:'imooc',}constobj2={age:5,}ws.add(obj1)ws.add(obj2)ws.delete(obj1)console.log(ws)console.log(ws.has(obj2))```","JavaScript\\数据结构\\数组\\flat.md":"#flat##普通递归实现>普通递归的思路很容易理解，就是通过for循环的方式，逐层逐个元素地去展平，如果当前元素是一个数组，那么就对它进行递归处理，再将递归处理的结果拼接到结果数组上```jsfunctionflatten(arr){letresult=[]for(leti=0;i<arr.length;i++){if(Array.isArray(arr[i])){result=result.concat(flatten(arr[i]))continue}result.push(arr[i])}returnresult}console.log(flatten([1,[2,[3,4,5]]]))//[1,2,3,4，5]```##reduce实现>reduce是JS数组中非常强大的一个方法，同时也是JS中的一个函数式编程API。>上面的递归实现的关键就是对数组的每一项进行处理，遇到数组就递归处理它，既然需要循环和结果数组，那么我们可以使用reduce来简化我们的代码```jsfunctionflatten(arr){returnarr.reduce(function(pre,cur){returnpre.concat(Array.isArray(cur)?flatten(cur):cur)},[])}console.log(flatten([1,[2,[3,4]]]))//[1,2,3,4，5]```>使用reduce后，代码更加的简洁，reduce的第一个参数用来返回最后累加的结果，第二个参数是当前遍历到的元素值，处理数组元素和非数组元素的思路和第一种方法是一样，最后再把处理后的结果拼接到累加的结果数组中返回即可。##扩展运算符实现>扩展运算符是ES6的新特性之一，用它操作数组可以直接展开数组的第一层，利用这个特性，我们可以不使用递归来实现数组的展平，这是因为每一次递归都是对当前层次数组的一次展开，而扩展操作符就是干这工作的。```jsfunctionflatten(arr){while(arr.some((i)=>Array.isArray(i))){arr=[].concat(...arr)}returnarr}console.log(flatten([1,[2,[3,4]]]))//[1,2,3,4，5]```>代码中使用了数组的另一个方法some，目的是判断当前数组是否还有数组元素，如果有则对数组进行一层展开，同时将展开结果作为下一次判断的条件，这样就像剥洋葱一样，一层层地剥开洋葱皮，当循环条件不满足时说明数组里已经没有数组元素了，这是数组已经完全扁平。##split+toString实现>我们也可以通过split和toString两个方法，来共同实现数组扁平化。toString是Object原型链上的一个方法，由于JS中所有对象都派生自Object对象，所以它们都能调用toString，只不过不同的对象可能会对这个方法进行改写以输出自己想要的格式。数组的toString方法会将数组转换成一个元素间以逗号相隔的字符串，它内部会先将数组展平成一维后再转换成字符串，因此我们可以先利用toString进行展平，然后再通过split方法以逗号分隔每个元素来复原一个包含所有元素的数组，从而实现数组的扁平化。```jsfunctionflatten(arr){returnarr.toString().split(',').map((i)=>Number(i))}console.log(flatten([1,[2,[3,4]]]))//[1,2,3,4]```>-不过需要注意的是，虽然这个方法非常简单，但具有一定的局限性，对于包含引用类型元素的数组来说，在toString过程中会发生类型转换，从而使得转换结果异常，因为对于引用类型转成字符串，会调用引用类型的toString，上面提到不同对象会对它进行改写，例如函数就会得到一个函数体的代码字符串，而不是我们想要的函数引用。>-因此，使用这种方式我们要看元素类型而定。##正则+JSON实现>正则实现也是先将数组转换成字符串的表达形式，这里将数组转成字符串我们使用JSON.stringify方法，将数组转换成一个由括号包裹、元素间以逗号相隔的字符串，例如\"[1,[2,[3,[4,5]]],6]\",从转换后的字符可以发现，每一对括号包着的范围就是一个层级，数组的展平就是将内部的层级全部消除，只保留最外层，在这里，就是将括号全部替换成空字符，得到一个元素以逗号相隔字符串，最后将利用JSON.parse方法解析成数组对象。```jsfunctionflatten(arr){letstr=JSON.stringify(arr)str=str.replace(/(\\[|\\])/g,'')//拼接最外层，变成JSON能解析的格式str='['+str+']'returnJSON.parse(str)}console.log(flatten([1,[2,[3,[4,5]]],6]))//[1,2,3,4，5]```>同样，这种方式在处理引用数据类型上也有局限性，同时还要注意元素是否是JSON的合法数据类型。##Array.prototype.flat>`Array.prototype.flat`是ES6新增的一个数组方法，它的作用就是用来数组扁平化，并且根据传入的参数来决定展开的层级，是数组扁平化的终极解决方案。```jsletarr=[1,[2,[3,4]]]functionflatten(arr){returnarr.flat(Infinity)}console.log(flatten(arr))//[1,2,3,4，5]```>参数Infinity表示完全展开，使用起来非常方便、快捷。","JavaScript\\数据结构\\数组\\v8引擎下的数组.md":"#V8引擎下的\"数组\"底层实现##数组描述|数组|描述||:-------|:-----------------------------------------------------------||传统数组|相同数据类型,连续内存,连续空间存储,线性存储结构,固定长度||JS数组|多种数据类型,动态容量|##JS数组>新建数组时,没有设置容量,默认FastElements模式>设置容量,没有进行内部元素初始化(`newArray(10)`),出现空洞,将会以**FastHoleyElements**模式实现>对数组进行初始化,`FastElements`模式实现,不存在空洞###FixedArray快数组(默认)>特点:>>-数组长度:`length<elements.length()`>-线性存储方式(默认)>-长度可变>-可扩容:扩容后的新容量=旧容量\\*1.5+16,扩容后会将拷贝到新的内存空间中>-可缩放:如果容量>length\\*2+16,就进行收缩容量调整,否则用holes对象###HashTable慢数组>特点:>>-以数组为键的`HashTable`>-字典内存形式>-不用连续的存储空间(节省内存)>-效率较低###快慢数组切换>**转换为慢数组**:>>-`新容量>=3*拓展后的容量*2`>-`newIndex-Now容量>=1024`>>**转换为快数组**:>>(`smi在64位平台为-2^31到2^31-1,在32位平台为-2^30到2^30-1`)>>-数组长度在`smi`之间不可转换>-当慢数组的元素可存放在快数组中且长度在smi之间且仅节省了50%的空间,则会转变为快数组###补充####holes对象>holes(空洞):指数组分配了空间,但是没有存放元素的地方>>-快数组中在**FastElements**模式中的拓展模式**FastHoleyElements**#####FastHoleyElements>动态分配连续的存储空间,分配空间的大小由最大的索引值决定","JavaScript\\数据结构\\数组\\下标.md":"#数组下标问题```jsvararr=[]arr['a']=1console.log(arr.length)//0arr['2']=2console.log(arr.length)//3arr.length=0console.log(arr)//[a:1]arr.length//0arr['a']//1```​-数组下标值的范围为0到2的32次方对于给定的数字下标值,如果不在这个范围内js就会把这个值转为字符串并当做一个数组对象存储,而不是一个数组元素但是如果下标值在合法范围之内无论是数字型字符串还是数字都转换为数字,array[\"100\"]=array[100];​使用字符串当做下标是其实就相当于给该数组对象中存储了一个属性由于给数组对象添加一个属性时数组的长度始终为0","JavaScript\\数据结构\\数组\\数组.md":"#数组##创建方法>空数组:`varObj=newArray();`>指定长度数组:`varObj=newArray(size);`>指定元素数组:`varObj=newArray(元素1,元素2,元素3....);`>单维数组:`varObj=[元素1,元素2,元素3....];`>多维数组:`varObj=[[数组序列1],[数组序列2],[数组序列3]...]`##基本操作-特性:-下标类型:-数值-非数值-转换为字符串-生成关联数组,下标将作为对象属性的名字-删除数组delete数组名[下标]-遍历数组for(var数组元素变量in数组)###数组属性>-constructor:>-引用数组对象的构造函数>-length:>-返回数组的长度>-prototype>-通过增加属性和方法扩展数组定义###数组方法####添加>push()尾加>>unshift()头加>>\\_Array.concat(...values)合并两个数组>>-\\_Array:数组>-values:可以为数组或非数组>-result:都会合并为一个数组####删除>pop()尾删>>shift()头删####子数组>-splice()>-删除任意数量:`splice([删除的其实坐标],[要删除的项])`>-在指定位置插入指定的项目:`splice([起始坐标],0,[插入的项])`>-替换任意数量的项:`splice([起始坐标],[要删除的数量],[要插入的项目])`>-slice()>-功能:从已有数组中选取部分元素构成新的数组>-用法:`slice([起始位置],[结束位置])`>-特性:>-如果位置为负数,则用数组长度加上改值确认位置>-起始位置为数组实际下标>-结束位置为实际下标减一####数组排序>-reverse():颠倒数组中的元素顺序>-sort():排序>-按照数值大小排序需要函数支持####数组转换>toString()>>toLocaleString():转换为本地格式字符串并返回>>join()用指定分隔符连接数组并转换成字符串####位置方法>indexOf起始位置开始查找>>lastIndexOf结束位置开始查找###迭代方法-every:每一项都返回true,则返回true-filter:返回值为true的所有数组-filter(callback,\\_this),有两个参数，第一个是必须有的回调函数，第二个是可以选择的回调函数执行中的this值-callback(element,index,array),回调函数有三个参数，第一个参数是必须有的，是指当前元素的值。第二个参数是指当前元素的索引值，可选。第三个参数是指被遍历的数组本身，可选。-过滤掉数组中大于3的元素:`[1,2,3,4].filter(item=>item<3);`-forEach:就是遍历,无返回值(undefined)-Array.prototype.forEach();1.forEach(callback,[_this])遍历方法中有两个参数，一个是必须的会有的回调函数，第二个是可选择的回调函数执行的this值2.callback()回调函数的参数1.callback(value){},当回调函数的参数只有一个的时候，这个参数的就是每个元素的值2.callback(value,index){},当回调函数的参数有两个的时候，value是每个元素的值，index就是每个元素的索引3.callback(value,index,array){},当回调函数的有三个的时候，value是每个元素的值，index就是每个元素的索引，array指的是当前数组-map:**返回每次函数调用的结果数组**```1.map(callback,[_this])遍历中有两个参数，一个是必须有的回调函数，第二个是可选择的回调函数执行的this值。2.callback()回调函数的参数callback(value){},当回调函数的参数只有一个的时候，这个参数的就是每个元素的值callback(value,index){},当回调函数的参数有两个的时候，value是每个元素的值index就是每个元素的索引。callback(value,index,array){},当回调函数的有三个的时候，value是每个元素的值，index就是每个元素的索引，array指的是当前数组。```-some:有一项返回true,则返回true```js1.some(callback,_this_)，有三个参数，数组，可选。_this_是指回调函数执行中的this值。2.callback(element,index,array)第一个参数是指，正在处理的元素。第二参数是指，当前当前元素的索引值，可选。第三个参数是指，调用some()的数组。[1,2,3,4].some(x=>x>10);//false```-reduce:起始位置开始遍历```1.reduce(callback,init);有两个参数，第一个参数是必须有的回调函数，第二个是遍历之前的初始值。2.callback(acc,cur,[index],[arr]);有四个参数，acc是指累加器，cur是指当前的元素值，index是指当前元素的索引值，arr是指当前的遍历的数组```-累加```jsvararr=[1,2,3,4,5]arr.reduce(function(acc,cur){returnacc+cur},0)//返值为15```-去重```jsvararr=[]arr.reduce(function(acc,cur){acc.indexOf(cur)===-1&&acc.push(cur)returnacc},[])```-reduceRight:尾部开始遍历-接收参数-每一项上调用的函数-作为缩小基础的初始值-传入参数-前一个值prev-当前值cur-项的索引index-数组对象array```js//累加器console.log(arr.reduceRight((prev,cur)=>{returnprev+cur}),)```##数组拓展###Array.from()>`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-likeobject）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。```jsletarrayLike={0:'a',1:'b',2:'c',length:3,}//ES5的写法vararr1=[].slice.call(arrayLike)//['a','b','c']//ES6的写法letarr2=Array.from(arrayLike)//['a','b','c']Array.from({length:2},()=>'jack')//['jack','jack']```###Array.of()>将一组值转换成数组```jsArray.of(3,11,8)//[3,11,8]```###copyWithin()>指定数组的元素复制到指定位置>>-Array.prototype.copyWithin(target,start=0,end=this.length)>-target（必需）：从该位置开始替换数据。>-start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。>-end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。>>```javascript>;[1,2,3,4,5].copyWithin(0,3)//将第四个数据到最后的数据复制到下标为零的地方开始>//[4,5,3,4,5]>```###find()和findIndex()>find():查找数组相应的元素>>findIndex():查找对应元素的下标>>-只会返回第一个满足条件的元素下标>-没有满足的返回-1```js;[1,4,-5,10].find((n)=>n<0)[//-5(1,5,10,15)].find(function(value,index,arr){returnvalue>9})//10[(1,4,-5,10)].findIndex((n)=>n>9)//3```###fill()>给定值填充为一个数组```jsnewArray(3).fill(7)//[7,7,7]```###entries()，keys()和values()>keys():返回当前元素的下标>>values():返回当前元素的值>>entries():返回每个元素的`key-value`对```jsfor(letindexof['a','b'].keys()){console.log(index)}//0//1for(letelemof['a','b'].values()){console.log(elem)}//'a'//'b'for(let[index,elem]of['a','b'].entries()){console.log(index,elem)}//0\"a\"//1\"b\"```###includes()>`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但Babel转码器已经支持```js;[1,2,3].includes(2)//true;[1,2,3].includes(4)//false;[1,2,NaN].includes(NaN)//true//第二个参数:匹配比较;[1,2,3].includes(3,3)//false;[1,2,3].includes(3,-1)//true```##3.1扁平化n维数组1.终极篇```[1,[2,3]].flat(1)//[1,2,3][1,[2,3,[4,5]]].flat(2)//[1,2,3,4,5][1,[2,3,[4,5]]].toString()//'1,2,3,4,5'[1[2,3,[4,5[...]].flat(Infinity)//[1,2,3,4...n]```Array.flat(n)是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大2.开始篇```functionflatten(arr){while(arr.some(item=>Array.isArray(item))){arr=[].concat(...arr);}returnarr;}flatten([1,[2,3]])//[1,2,3]flatten([1,[2,3,[4,5]])//[1,2,3,4,5]```实质是利用递归和数组合并方法concat实现扁平##3.2去重1.终极篇```jsArray.from(newSet([1,2,3,3,4,4]))//[1,2,3,4][...newSet([1,2,3,3,4,4])]//[1,2,3,4]```set是ES6新出来的一种一种定义不重复数组的数据类型Array.from是将类数组转化为数组...是扩展运算符,将set里面的值转化为字符串2.开始篇```jsArray.prototype.distinct=function(){constmap={}constresult=[]for(constnofthis){if(!(ninmap)){map[n]=1result.push(n)}}returnresult}[(1,2,3,3,4,4)].distinct()//[1,2,3,4]```取新数组存值,循环两个数组值相比较##3.3排序1.终极篇```js;[1,2,3,4].sort((a,b)=>a-b)//[1,2,3,4],默认是升序;[1,2,3,4].sort((a,b)=>b-a)//[4,3,2,1]降序```sort是js内置的排序方法,参数为一个函数2.开始篇冒泡排序:```jsArray.prototype.bubleSort=function(){letarr=this,len=arr.lengthfor(letouter=len;outer>=2;outer--){for(letinner=0;inner<=outer-1;inner++){if(arr[inner]>arr[inner+1]){//升序;[arr[inner],arr[inner+1]]=[arr[inner+1],arr[inner]]console.log([arr[inner],arr[inner+1]])}}}returnarr}[(1,2,3,4)].bubleSort()//[1,2,3,4]```选择排序```jsArray.prototype.selectSort=function(){letarr=this,len=arr.lengthfor(leti=0,len=arr.length;i<len;i++){for(letj=i,len=arr.length;j<len;j++){if(arr[i]>arr[j]){;[arr[i],arr[j]]=[arr[j],arr[i]]}}}returnarr}[(1,2,3,4)].selectSort()//[1,2,3,4]```##3.4最大值1.终极篇```jsMath.max(...[1,2,3,4])//4Math.max.apply(this,[1,2,3,4])//4[(1,2,3,4)].reduce((prev,cur,curIndex,arr)=>{returnMath.max(prev,cur)},0)//4```Math.max()是Math对象内置的方法,参数是字符串;reduce是ES5的数组api,参数有函数和默认初始值;函数有四个参数,pre(上一次的返回值),cur(当前值),curIndex(当前值索引),arr(当前数组)2.开始篇先排序再取值##3.5求和1.终极篇```js;[1,2,3,4].reduce(function(prev,cur){returnprev+cur},0)//10```2.开始篇```jsfunctionsum(arr){varlen=arr.lengthif(len==0){return0}elseif(len==1){returnarr[0]}else{returnarr[0]+sum(arr.slice(1))}}sum([1,2,3,4])//10```利用slice截取改变数组,再利用递归求和##3.6合并1.终极篇```js[1,2,3,4].concat([5,6])//[1,2,3,4,5,6][...[1,2,3,4],...[4,5]]//[1,2,3,4,5,6]letarrA=[1,2],arrB=[3,4]Array.prototype.push.apply(arrA,arrB))//arrA值为[1,2,3,4]```2.开始篇```jsletarr=[1,2,3,4];[5,6].map((item)=>{arr.push(item)})//arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6]```##3.7判断是否包含值1.终极篇```js[1,2,3].includes(4)//false[1,2,3].indexOf(4)//-1如果存在换回索引[1,2,3].find((item)=>item===3))//3如果数组中无值返回undefined[1,2,3].findIndex((item)=>item===3))//2如果数组中无值返回-1```includes(),find(),findIndex()是ES6的api2.开始篇```[1,2,3].some(item=>{returnitem===3})//true如果不包含返回false```##3.8类数组转化1.终极篇```Array.prototype.slice.call(arguments)//arguments是类数组(伪数组)Array.prototype.slice.apply(arguments)Array.from(arguments)[...arguments]```类数组:表示有length属性,但是不具备数组的方法call,apply:是改变slice里面的this指向arguments,所以arguments也可调用数组的方法Array.from是将类似数组或可迭代对象创建为数组...是将类数组扩展为字符串,再定义为数组2.开始篇```Array.prototype.slice=function(start,end){varresult=newArray();start=start||0;end=end||this.length;//this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键for(vari=start;i<end;i++){result.push(this[i]);}returnresult;}```##3.9每一项设置值1.终极篇```[1,2,3].fill(false)//[false,false,false]```fill是ES6的方法2.开始篇```[1,2,3].map(()=>0)```##3.10每一项是否满足```[1,2,3].every(item=>{returnitem>2})//false```every是ES5的api,每一项满足返回true##3.11有一项满足```[1,2,3].some(item=>{returnitem>2})//true```some是ES5的api,有一项满足返回true##3.12.过滤数组```[1,2,3].filter(item=>{returnitem>2})//[3]```filter是ES5的api,返回满足添加的项的数组##3.13对象和数组转化```Object.keys({name:'张三',age:14})//['name','age']Object.values({name:'张三',age:14})//['张三',14]Object.entries({name:'张三',age:14})//[[name,'张三'],[age,14]]Object.fromEntries([name,'张三'],[age,14])//ES10的api,Chrome不支持,firebox输出{name:'张三',age:14}```##3.14对象数组```js;[{count:1},{count:2},{count:3}].reduce((p,e)=>p+e.count,0)```","JavaScript\\时间\\农历.md":"#农历><https://github.com/jjonline/calendar.js/blob/master/calendar.js>>[公历与阳历对照表](https://www.hko.gov.hk/tc/gts/time/conversion.htm)><https://blog.csdn.net/qq_43915356/article/details/110872220>><https://blog.csdn.net/qq_33538651/article/details/114053664>##农历1900-2100的润大小信息表```js//农历1900-2100的润大小信息表//0表示小月【29】，1表示大月【30】，将16进制转为2进制查看varlunarInfo=[0x04bd8,0x04ae0,0x0a570,0x054d5,0x0d260,0x0d950,0x16554,0x056a0,0x09ad0,0x055d2,//1900-19090x04ae0,0x0a5b6,0x0a4d0,0x0d250,0x1d255,0x0b540,0x0d6a0,0x0ada2,0x095b0,0x14977,//1910-19190x04970,0x0a4b0,0x0b4b5,0x06a50,0x06d40,0x1ab54,0x02b60,0x09570,0x052f2,0x04970,//1920-19290x06566,0x0d4a0,0x0ea50,0x06e95,0x05ad0,0x02b60,0x186e3,0x092e0,0x1c8d7,0x0c950,//1930-19390x0d4a0,0x1d8a6,0x0b550,0x056a0,0x1a5b4,0x025d0,0x092d0,0x0d2b2,0x0a950,0x0b557,//1940-19490x06ca0,0x0b550,0x15355,0x04da0,0x0a5b0,0x14573,0x052b0,0x0a9a8,0x0e950,0x06aa0,//1950-19590x0aea6,0x0ab50,0x04b60,0x0aae4,0x0a570,0x05260,0x0f263,0x0d950,0x05b57,0x056a0,//1960-19690x096d0,0x04dd5,0x04ad0,0x0a4d0,0x0d4d4,0x0d250,0x0d558,0x0b540,0x0b6a0,0x195a6,//1970-19790x095b0,0x049b0,0x0a974,0x0a4b0,0x0b27a,0x06a50,0x06d40,0x0af46,0x0ab60,0x09570,//1980-19890x04af5,0x04970,0x064b0,0x074a3,0x0ea50,0x06b58,0x05ac0,0x0ab60,0x096d5,0x092e0,//1990-19990x0c960,0x0d954,0x0d4a0,0x0da50,0x07552,0x056a0,0x0abb7,0x025d0,0x092d0,0x0cab5,//2000-20090x0a950,0x0b4a0,0x0baa4,0x0ad50,0x055d9,0x04ba0,0x0a5b0,0x15176,0x052b0,0x0a930,//2010-20190x07954,0x06aa0,0x0ad50,0x05b52,0x04b60,0x0a6e6,0x0a4e0,0x0d260,0x0ea65,0x0d530,//2020-20290x05aa0,0x076a3,0x096d0,0x04afb,0x04ad0,0x0a4d0,0x1d0b6,0x0d250,0x0d520,0x0dd45,//2030-20390x0b5a0,0x056d0,0x055b2,0x049b0,0x0a577,0x0a4b0,0x0aa50,0x1b255,0x06d20,0x0ada0,//2040-2049/**AddByJJonline@JJonline.Cn**/0x14b63,0x09370,0x049f8,0x04970,0x064b0,0x168a6,0x0ea50,0x06b20,0x1a6c4,0x0aae0,//2050-20590x0a2e0,0x0d2e3,0x0c960,0x0d557,0x0d4a0,0x0da50,0x05d55,0x056a0,0x0a6d0,0x055d4,//2060-20690x052d0,0x0a9b8,0x0a950,0x0b4a0,0x0b6a6,0x0ad50,0x055a0,0x0aba4,0x0a5b0,0x052b0,//2070-20790x0b273,0x06930,0x07337,0x06aa0,0x0ad50,0x14b55,0x04b60,0x0a570,0x054e4,0x0d160,//2080-20890x0e968,0x0d520,0x0daa0,0x16aa6,0x056d0,0x04ae0,0x0a9d4,0x0a2d0,0x0d150,0x0f252,//2090-20990x0d520],//2100```##天干地支今年是壬寅虎年，那么具体是怎么来的呢？干支是天干和地支的总称，干支纪年法是中国历法上自古以来就一直使用的纪年方法。干支纪年法的组合方式是天干在前地支在后，以十天干和十二地支循环配合，每个组合代表一年，60年为一个循环。天干的计算方法是：年份减3，除以10所得的余数；地支的计算方法是：年份减3，除以12所得的余数。以2022年为例：天干为：(2022-3)/10=201···9；地支为：(2022-3)/12=167···3；对照天干地支表得出，2022年为壬寅年。因为公元4年为甲子年,所以计算时必须减3才能农历年元年相对应。“甲、乙、丙、丁、戊、己、庚、辛、壬、癸”称为十天干。“子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥”称为十二地支","JavaScript\\时间\\时区.md":"#时区[MomentTimezone中文网(momentjs.cn)](http://momentjs.cn/timezone/)[文档|Moment.js中文网(momentjs.cn)](http://momentjs.cn/docs/#/parsing/)[世界时区缩写及代表的地区-逍遥峡谷(icoa.cn)](https://www.icoa.cn/a/611.html)[时间戳(Unixtimestamp)转换工具-在线工具(tool.lu)](https://tool.lu/timestamp/)","JavaScript\\概念\\import_xxx与import{}区别.md":"#import_xxx与import\\{\\}区别ES6中`export`与`exportdefault`均可用于导出常量、函数、文件、模块等，你可以在其它文件或模块中通过import的两种方式对其进行导入。一个模块只能有一个`exportdefault`,但可以有若干个`export`。区别就在下面。1.`export`与`exportdefault`均可用于导出常量、函数、文件、模块等2.在一个文件或模块中，export、import可以有多个，exportdefault仅有一个3.通过export方式导出，**在导入时要加exportdefault则不需要**4.export能直接导出变量表达式，exportdefault不行","JavaScript\\概念\\mvc&mvvm.md":"#mvc&mvvm##MVC>MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View，比如在controller中写document.getElementById(\"box\").innerHTML=data[”title”]，只是还没有刻意建一个Model类出来而已。###M>Model模型>-是应用程序中用于处理应用程序数据逻辑的部分>-通常模型对象负责在数据库中存取数据>-数据结构模型###V>View:视图>-是应用程序中处理数据显示的部分>-通常视图是一句模型数据创建的###C>Controller:控制器>-是应用程序中处理用户交互的部分>-通常控制器负责视图读取数据,控制用户输入,并向模型发送数据##MVVM>MVVM：Model、View、ViewModel>-低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。>-可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。>-独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用ExpressionBlend可以很容易设计界面并生成xml代码。>-可测试。界面元素本来是比较难于测试的，而现在测试可以针对ViewModel来写。>**MVVM优点**>>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点>>1.**低耦合**。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。>2.**可重用性**。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。>3.**独立开发**。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用ExpressionBlend可以很容易设计界面并生成xml代码。>4.**可测试**。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。","JavaScript\\概念\\模式.md":"#模式##严格模式###概念**理解**：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：\"严格模式\"（strictmode）。顾名思义，这种模式使得Javascript在更严格的语法条件下运行。**目的**：-消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为-消除代码运行的一些不安全之处，为代码的安全运行保驾护航-为未来新版本的Javascript做好铺垫###使用-针对整个脚本文件：将`usestrict`放在脚本文件的第一行，则整个脚本文件将以严格模式运行。-针对单个函数：将`usestrict`放在函数体的第一行，则整个函数以严格模式运行。PS：如果浏览器不支持，则这句话只解析为一条简单的语句,没有任何副作用。脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。###语法和行为改变-必须用var声明变量-禁止自定义的函数中的this指向window-对象不能有重名的属性##严格模式和普通模式的区别###全局变量显式声明在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。###禁止this关键字指向全局对象```javascriptvarfoo=function(){console.log(this)}foo()```上方代码中，普通模式打印的是window。严格模式下打印的是undefined。###构造函数必须通过new实例化对象构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。比如说：```jsvarCat=function(name){this.name=name}Cat('haha')```上方代码中，如果在严格模式下，则会报错。###属性相关-普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。-普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。比如下面这样的代码：```jsvarobj={username:'smyh';username:'vae'}```上面的代码，在严格模式下属于语法错误，因为有重名的属性。###函数必须声明在顶层将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。###新增关键字为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements,interface,let,package,private,protected,public,static,yield。","JavaScript\\正则\\RegExp.md":"#RegExp##基础用法```jsconsts='aaa_aa_a'constr1=/a+/gconstr2=/a+/yr1.exec(s)//[\"aaa\"]r2.exec(s)//[\"aaa\"]r1.exec(s)//[\"aa\"]r2.exec(s)//null```##StringtoRegExp```jslettemp='UAID'lettreg='/'+temp+'/'letreg=eval(treg)//核心```##**y修饰符**ES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。```jsconsts='aaa_aa_a'constr1=/a+/gconstr2=/a+/yr1.exec(s)//[\"aaa\"]r2.exec(s)//[\"aaa\"]r1.exec(s)//[\"aa\"]r2.exec(s)//null```上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是\\_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。```jsconsts='aaa_aa_a'constr=/a+_/yr.exec(s)//[\"aaa_\"]r.exec(s)//[\"aa_\"]```使用lastIndex属性，可以更好地说明y修饰符。```jsconstregexp=/a/g//指定从2号位置（y）开始匹配regexp.lastIndex=2//匹配成功constmatch=regexp.exec('xaya')//在3号位置匹配成功console.log(match.index)//3//下一次匹配从4号位开始console.log(regexp.lastIndex)//4//4号位开始匹配失败regexp.exec('xaxa')//null```上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。```jsconstregexp=/a/y//指定从2号位置开始匹配regexp.lastIndex=2//不是粘连，匹配失败regexp.exec('xaya')//null//指定从3号位置开始匹配regexp.lastIndex=3//3号位置是粘连，匹配成功constmatch=regexp.exec('xaxa')console.log(match.index)//3console.log(regexp.lastIndex)//4```进一步说，y修饰符号隐含了头部匹配的标志^。```jsconstreg=/b/yreg.exec('aba')//nullconsole.log(reg.lastIndex)```sticky模式在正则匹配过程中只会影响两件事：-匹配必须从re.lastIndex开始（相当于正则表达中的^）-如果匹配到会修改re.lastIndex（相当于g模式）**2.u修饰符**ES6为正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。```/^\\uD83D/u.test('\\uD83D\\uDC2A')//false/^\\uD83D/.test('\\uD83D\\uDC2A')//true```上面代码中，\\uD83D\\uDC2A是一个四个字节的UTF-16编码，代表一个字符\"🐪\"。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。一旦加上u修饰符号，就会修改下面这些正则表达式的行为。-点字符点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。```lets='𠮷'/^.$/.test(s)//false/^.$/u.test(s)//true```-Unicode字符表示法ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。```/\\u{61}/.test('a')//false/\\u{61}/u.test('a')//true/\\u{20BB7}/u.test('𠮷')//true```-量词使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。```/a{2}/.test('aa')//true/a{2}/u.test('aa')//true/𠮷{2}/.test('𠮷𠮷')//false/𠮷{2}/u.test('𠮷𠮷')//true```-预定义模式u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。```/^\\S$/.test('𠮷')//false/^\\S$/u.test('𠮷')//true```上面代码的\\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。利用这一点，可以写出一个正确返回字符串长度的函数。```functioncodePointLength(text){constresult=text.match(/[\\s\\S]/gu)returnresult?result.length:0}consts='𠮷𠮷's.length//4codePointLength(s)//2```##i修饰符有些Unicode字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。```js;/[a-z]/i.test('\\u212A')///false[a-z]/iu.test('\\u212A')//true```上面代码中，不加u修饰符，就无法识别非规范的K字符。","JavaScript\\正则\\正则.md":"#正则##创建-字面量`var[变量名]=/表达式/模式修饰符`-构造函数`var[变量名]=newRegExp(\"表达式\",\"模式修饰符\")````javascriptvarstr='guanruihua'varpatt=/rui/idocument.write(str.match(patt))document.write(str.test(patt))```##规则###单个字符与数字|标识符|描述||:----------|:---------------------||`.:`|除换行符之外的任意字符||`[a-z0-9]`|方括号中的任意字符||`[^a-z0-9]`|不在方括号中的任意字符||`\\d`|数字||`\\D`|非数值||`\\w`|字母||`\\W`|非字母|###空白字符|标识符|描述||:-----|:------------------------------||`\\0`|null||`\\b`|空格||`\\f`|换页符||`\\n`|换行符||`\\r`|回车符||`\\s`|空白字符,空格符,制表符,换行符||`\\S`|非空白字符||`\\t`|制表符|###定位符|标识符|描述||:-----|:-------------------------||`^`|行首匹配符||`$`|行尾匹配符||`\\A`|值匹配字符串最开始处||`\\b`|匹配单词边界,词在[]内无效||`\\B`|匹配非单词边界||`\\G`|匹配当前搜索的开始位置||`\\Z`|字符串结束处||`\\z`|只匹配字符串结束处|###限制符|标识符|描述||:--------|:--------------------|---|-------------------||`x?`|匹配0个或1个x||`x*`|匹配0个或任意多个x||`x+`|匹配至少一个x||`x{m,n}`|匹配最少m个,最多n个x||`x|y|z`|匹配x或y或z(或模式)|##断言|标识符|描述|字符串|正则|结果||:-------------|:---------------|:--------------------------------------|:-------------|:------------------||`(?:x)`|匹配x||`(?=pattern)`|零宽正向先行断言||`(?!pattern)`|零宽负向先行断言|`'regexrepresentsregularexpression'`|`/re(?!g)/g`|`['re','re','re']`||`(?<=pattern)`|零宽正向后行断言|`'regexrepresentsregularexpression'`|`/(?<=\\w)re/g`|`['re','re']`||`(?<!pattern)`|零宽负向后行断言|`'regexrepresentsregularexpression'`|`/(?<!\\w)re/g`|`['re','re','re']`|###模式修饰符|标识符|描述||:-----|:-----------------------||`g`|全局模式,应用所有字符串||`i`|区分大小写模式||`m`|多行匹配模式|##属性-实例属性-global检测是否设置g标记-ignoreCase检测是否设置i标记-multiline检测是否设置了m标记-lastIndex开始检索上一个匹配项的字符位置-source返回正则表达式的字符串表示-nextIndex返回被查找字符串中下一个成功匹配的开始位置-构造函数属性-\\$1....\\$9返回就搞在模式匹配期间找的,最近保存的部分-$\\_input返回最近一次匹配的字符串-$&lastMatch返回最近一次的匹配项-$+lastParen返回最近一次匹配的捕获组-$`leftContext返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符-$'rightContext返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符-$\\*multiline检测表达式是否采用多行模式匹配m##方法###RegExp-exec-功能:在字符串中执行匹配检索,返回结果数组-参数:要应用模式匹配的字符串-特性:-使用全局标记g持续查找所有匹配项并返回-不适用全局标记g始终返回第一个匹配项信息-执行过程1.检索字符串参数,获取正则表达式匹配文本2.找到匹配文本则返回一个数组-第0个元素与整个模式匹配的字符串-其他元素与捕获匹配的字符串3.否则返回null-派生属性-index匹配项在字符串中的位置-input应用正则表达式的字符串-length返回数组元素个数-test功能在字符串中测试模式匹配,返回true或false###String-match找到一个或多个正则表达式的匹配-replace替换与正则表达式匹配的字符串-search检索与正则表达式相配的值-split把字符串分割为字符串数组##案例###数字的千位分隔符表示法```javascript//\"12345678\"=>\"12,345,678\"'12345678'.replace(/(?=\\d{3}$)/g,',')'12345678'.replace(/(?=(\\d{3})+$)/g,',')varstring='12345678123456789'reg=/(?!\\b)(?=(\\d{3})+\\b)/gvarresult=string.replace(reg,',')console.log(result)//=>\"12,345,678123,456,789\"```中文:`[\\u4e00-\\u9fa5]`1.由数字、26个英文字母或者下划线组成的字符串:^[0-9a-zA-Z_]{1,}$12.非负整数（正整数+0）:^/d+$13.正整数:^[0-9]_[1-9][0-9]_$14.非正整数（负整数+0）：^((-/d+)|(0+))$15.负整数:^-[0-9]_[1-9][0-9]_$16.整数:^-?/d+$17.非负浮点数（正浮点数+0）:^/d+(/./d+)?$18.正浮点数:^(([0-9]+/.[0-9]_[1-9][0-9]_)|([0-9]_[1-9][0-9]_/.[0-9]+)|([0-9]_[1-9][0-9]_))$19.非正浮点数（负浮点数+0）:^((-/d+(/./d+)?)|(0+(/.0+)?))$110.负浮点数:^(-(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*)))$111.浮点数:^(-?/d+)(/./d+)?$112.由26个英文字母组成的字符串:^[A-Za-z]+$113.由26个英文字母的大写组成的字符串:^[A-Z]+$114.由26个英文字母的小写组成的字符串:^[a-z]+$115.由数字和26个英文字母组成的字符串:^[A-Za-z0-9]+$116.由数字、26个英文字母或者下划线组成的字符串:^/w+$117.email地址:^[/w-]+(/.[/w-]+)\\*@[/w-]+(/.[/w-]+)+$118.url:^[a-zA-z]+://(/w+(-/w+)*)(/.(/w+(-/w+)*))*(/?/S*)?$119.年-月-日:/^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/120.月/日/年:/^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/121.Emil:^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$122.电话号码:(d+-)?(d{4}-?d{7}|d{3}-?d{8}|^d{7,8})(-d+)?123.IP地址:^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$124.匹配中文字符的正则表达式：[/u4e00-/u9fa5]125.匹配双字节字符(包括汉字在内)：[^/x00-/xff]126.匹配空行的正则表达式：/n[/s|]*/r127.匹配HTML标记的正则表达式：/<(._)>._<///1>|<(.\\*)//>/128.匹配首尾空格的正则表达式：(^/s*)|(/s*$)129.匹配Email地址的正则表达式：/w+([-+.]/w+)*@/w+([-.]/w+)*/./w+([-.]/w+)*130.匹配网址URL的正则表达式：^[a-zA-z]+://(//w+(-//w+)_)(//.(//w+(-//w+)_))_(//?//S_)?$131.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$132.匹配国内电话号码：(/d{3}-|/d{4}-)?(/d{8}|/d{7})?133.匹配腾讯QQ号：^[1-9]_[1-9][0-9]_$134.只能输入数字：^[0-9]\\*$135.只能输入n位的数字：^/d{n}$136.只能输入至少n位的数字：^/d{n,}$137.只能输入m~n位的数字：^/d{m,n}$138.只能输入零和非零开头的数字：^(0|[1-9][0-9]\\*)$139.只能输入有两位小数的正实数：^[0-9]+(.[0-9]{2})?$140.只能输入有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$141.只能输入非零的正整数：^/+?[1-9][0-9]\\*$142.只能输入非零的负整数：^/-[1-9][0-9]\\*$143.只能输入长度为3的字符：^.{3}$144.只能输入由26个英文字母组成的字符串：^[A-Za-z]+$145.只能输入由26个大写英文字母组成的字符串：^[A-Z]+$146.只能输入由26个小写英文字母组成的字符串：^[a-z]+$147.只能输入由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$148.只能输入由数字和26个英文字母或者下划线组成的字符串：^/w+$149.验证用户密码(正确格式为：以字母开头，长度在5~17之间，只能包含字符、数字和下划线)^[a-zA-Z]/w{5,17}$150.验证是否包含有^%&’,;=?$/\"等字符：[^%&',;=?$/x22]+151.只能输入汉字：^[\\u4e00-\\u9fa5]{0,}$152、只含有汉字、数字、字母、下划线不能以下划线开头和结尾^(?!_)[?!.\\*?_$](a-zA-Z0-9_\\u4e00-\\u9fa5)+$153、只含有汉字、数字、字母、下划线，下划线位置不限^[a-zA-Z0-9_\\u4e00-\\u9fa5]+$154、2~4个汉字@\"^[\\u4E00-\\u9FA5]{2,4}$","JavaScript\\监听.md":"#监听##监听器监听自定义事件###mutationObserver>监听DOM指定节点的变化(内容,属性,子节点,)```js//创建一个MutationObserver实例，监听目标节点的变化constobserver=newMutationObserver((mutations)=>{mutations.forEach((mutation)=>{console.log(mutation.type)//打印出变化类型，例如childList、attributes等})})//配置MutationObserver，指定监听的节点和监听类型constconfig={attributes:true,//监听属性变化childList:true,//监听子节点变化//characterData:true,//监听文本内容变化subtree:true,//监听后代节点变化}//将MutationObserver实例绑定到一个目标节点consttargetNode=document.getElementById('target')observer.observe(targetNode,config)```###创建event的对象实例,表示事件类型（createEvent事件）```jsvarevent=document.createEvent('HTMLEvents')```-UIEventsUI事件,用于触摸屏设备-MouseEvents鼠标事件-MutationEventsDom结构发生改变触发的事件-HTMLEventsHtml事件###初始化event对象的属性(initEvent事件)```js//eventType事件名，canBubble是否冒泡，cancelable是否可以使用preventDefault取消事件event.initEvent(eventType事件名,canBubble,cancelable)```-eventType可以是已经定义好的事件，例如click、submit等，经过初始化后可以直接通过对应的操作进行触发。事件类型如果是自定义的，就需要使用dispachEvent事件进行触发。###触发自定义事件(dispachEvent事件)```js//返回值为布尔值//当event.cancalable为false，都会返回true。target.dispachEvent(event)```","JavaScript\\类型\\index.md":"#判断JS数据类型的四种方法在ECMAScript规范中，共定义了7种数据类型，分为`基本类型`和`引用类型`两大类，如下所示：-**基本类型**：String、Number、Boolean、Symbol、Undefined、Null-**引用类型**：Object-基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。-引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除Object外，还包括Function、Array、RegExp、Date等等。##**typeof**-对于基本类型，除null以外，均可以返回正确的结果-对于引用类型，除function以外，一律返回object类型-对于null，返回object类型-对于function返回function类型```jstypeof''//string有效typeof1//number有效typeofSymbol()//symbol有效typeoftrue//boolean有效typeofundefined//undefined有效typeofnull//object无效typeof[]//object无效typeofnewFunction()//function有效typeofnewDate()//object无效typeofnewRegExp()//object无效```-null有属于自己的数据类型Null，引用类型中的数组、日期、正则也都有属于自己的具体类型，而typeof对于这些类型的处理，只返回了处于其原型链最顶端的Object类型，没有错，但不是我们想要的结果。##**instanceof**instanceof是用来判断A是否为B的实例，表达式为：AinstanceofB，如果A是B的实例，则返回true,否则返回false。在这里需要特别注意的是：**instanceof检测的是原型**，我们用一段伪代码来模拟其内部执行过程：```jsinstanceof(A,B)={varL=A.__proto__;varR=B.prototype;if(L===R){//A的内部属性__proto__指向B的原型对象returntrue;}returnfalse;}```-当A的**proto**指向B的prototype时，就认为A就是B的实例，我们再来看几个例子：```js[]instanceofArray;//true{}instanceofObject;//truenewDate()instanceofDate;//truefunctionPerson(){};newPerson()instanceofPerson;[]instanceofObject;//truenewDate()instanceofObject;//truenewPersoninstanceofObject;//true```我们发现，虽然instanceof能够判断出[]是Array的实例，但它认为[]也是Object的实例，为什么呢？我们来分析一下[]、Array、Object三者之间的关系：从instanceof能够判断出[].**proto**指向`Array.prototype`，而`Array.prototype.**proto**`又指向了`Object.prototype`，最终`Object.prototype.__proto__`指向了null，标志着原型链的结束。因此，[]、Array、Object就在内部形成了一条原型链：![img](.assets/849589-20160112232510850-2003340583.png)从原型链可以看出，[]的**proto**直接指向Array.prototype，间接指向Object.prototype，所以按照instanceof的判断规则，[]就是Object的实例。依次类推，类似的newDate()、newPerson()也会形成一条对应的原型链。因此，**instanceof只能用来判断两个对象是否属于实例关系\\*\\***，而不能判断一个对象实例具体属于哪种类型。\\*\\*instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。```jsvariframe=document.createElement('iframe')document.body.appendChild(iframe)xArray=window.frames[0].Arrayvararr=newxArray(1,2,3)//[1,2,3]arrinstanceofArray//false```针对数组的这个问题，ES5提供了Array.isArray()方法。该方法用以确认某个对象本身是否为Array类型，而不区分该对象在哪个环境中创建。```jsif(Array.isArray(value)){//对数组执行某些操作}```Array.isArray()本质上检测的是对象的[[Class]]值，[[Class]]是对象的一个内部属性，里面包含了对象的类型信息，其格式为[objectXxx]，Xxx就是对应的具体类型。对于数组而言，[[Class]]的值就是[objectArray]。##**constructor**当一个函数F被定义时，JS引擎会为F添加prototype原型，然后再在prototype上添加一个constructor属性，并让其指向F的引用。如下所示：![img](.assets/849589-20170508125250566-1896556617.png)当执行varf=newF()时，F被当成了构造函数，f是F的实例对象，此时F原型上的constructor传递到了f上，因此f.constructor==F![img](.assets/849589-20170508125714941-1649387639.png)可以看出，F利用原型对象上的constructor引用了自身，当F作为构造函数来创建对象时，原型上的constructor就被遗传到了新创建的对象上，从原型链角度讲，构造函数F就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。同样，JavaScript中的内置对象在内部构建时也是这样做的：![img](.assets/849589-20170508131800457-2091987664.png)**细节问题：**1.null和undefined是无效的对象，因此是不会有constructor存在的，这两种类型的数据需要通过其他方式来判断。2.函数的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor引用会丢失，constructor会默认为Object![img](.assets/849589-20170508132757347-1999338357.png)为什么变成了Object？-因为`prototype`被重新赋值的是一个{}，{}是`newObject()`的字面量，因此newObject()会将Object原型上的`constructor`传递给{}，也就是`Object`本身。-因此，为了规范开发，在重写对象原型时一般都需要重新给constructor赋值，以保证对象实例的类型不被篡改。###**toString**-`toString()`是`Object`的原型方法，调用该方法，默认返回当前对象的`[[Class]]`。这是一个内部属性，其格式为`[objectXxx]`，其中Xxx就是对象的类型。-对于`Object`对象，直接调用`toString()`就能返回`[objectObject]`。而对于其他对象，则需要通过call/apply来调用才能返回正确的类型信息。```jsObject.prototype.toString.call('')//[objectString]Object.prototype.toString.call(1)//[objectNumber]Object.prototype.toString.call(true)//[objectBoolean]Object.prototype.toString.call(Symbol())//[objectSymbol]Object.prototype.toString.call(undefined)//[objectUndefined]Object.prototype.toString.call(null)//[objectNull]Object.prototype.toString.call(newFunction())//[objectFunction]Object.prototype.toString.call(newDate())//[objectDate]Object.prototype.toString.call([])//[objectArray]Object.prototype.toString.call(newRegExp())//[objectRegExp]Object.prototype.toString.call(newError())//[objectError]Object.prototype.toString.call(document)//[objectHTMLDocument]Object.prototype.toString.call(window)//[objectglobal]window是全局对象global的引用```","JavaScript\\类型.md":"#数据相关##null-undefine-NaN```jsconsole.log(typeofnull)//输出objectconsole.log(typeofNaN)//输出numberconsole.log(typeofundefined)//输出undefined```##json相关>json是一种轻量级数据格式,独立于编程语言来表示和存储数据>json字符串=>json对象:`JSON.parse(\"{'a':'hello'}\")`>json对象=>json字符串:`JSON.stringify({'a':123})`##parseInt(0.0000008)===8？###IEEE754JavaScript的数字系统是采用IEEE754，一开始看到这个问题，以为是IEEE754导致的问题。常见的问题有浮点数比较：```jsconsole.log(0.1+0.2==0.3)//falseconsole.log(0.1+0.2===0.3)//falseconsole.log(0.1+0.2)//0.30000000000000004123```后来发现这问题并不会导致`parseInt(0.0000008)`变成`8`，那么问题就可能在`parseInt`这个函数上。```basic##parseInt>`parseInt(string,radix)`12````parseInt`接受两个参数，第一个参数是要转换的字符串（忽略空白）；第二个参数是基数。例如：```jsparseInt('12',10)//12parseInt('12**',10)//12parseInt('12.34',10)//12parseInt(12.34,10)//121234```最后一个例子让我们看到`parseInt`可以将数字类型转换成整数，但最好别这么做。再来看下面这个例子：```jsparseInt(1000000000000000000000.5,10)//1```为什么会这样呢？`parseInt`的第一个类型是字符串，所以会将传入的参数转换成字符串，也就是`String(1000000000000000000000.5)`的结果为`'1e+21'`。`parseInt`并没有将`'e'`视为一个数字，所以在转换到`1`后就停止了。这也就可以解释`parseInt(0.0000008)===8`：```jsString(0.000008)//'0.000008'String(0.0000008)//'8e-7'12```从上面的程式码可以看出，小于`0.0000001`（1e-7）的数字转换成`String`时，会变成科学记号法，再对这个数进行`parseInt`操作就会导致这个问题发生。###结论>不要将`parseInt`当做转换`Number`和`Integer`的工具。再补上一些悲剧：```jsparseInt(1/0,19)//18parseInt(false,16)//250parseInt(parseInt,16)//15parseInt('0x10')//16parseInt('10',2)//212345```","JavaScript\\运算符\\index.md":"#运算符###算术运算符####运算符#####+-功能:-对数字进行代数求和-对字符串进行拼接-将一个数值转换成字符串(数值+空字符串)-字符串拼接:-字符串+字符串:二者直接拼接-字符串+数值:数值转换为字符串再拼接-#####--功能:-对操作数进行取反-对数字进行减法操作-==将字符串转换成数值(数值型字符串-0)==#####\\*:乘/:除法%:取余####符合赋值运算符+=,-=,\\*=,/=,%=####自增自减--++符号放前就先算####关系运算符<,>,<=,>=,===,!==-字符串间比较=>比较他们的Unicode数值-与NaN的比较,返回false####对象运算符-in:判断左侧运算数是否为右侧运算数的成员-instanceof:判断对象实例是否输入某个类或构造函数-new:根据构造函数创建一个新的对象,并初始化该对象-delete:删除指定对象的饿属性,数组元素或变量-.及[]:存取对象和数组元素-{}:函数调用,改变运算符优先级等####逻辑运算符!,&&,||-非!:-返回值:-true:空字符串,0,null,NaN,undefined-false:对象,非空字符串,非0数字(Infinity)-特性:-连续使用两次,可以将任何类型转换成布尔类型-与&&:-规则:-第一个操作数是对象返回第二个操作数-第二个操作数是对象第一个操作数值为true时返回该对象-两个操作数都是对象返回第二个操作数-一个操作数是null返回null-一个操作数是NaN返回NaN-一个操作数是undefined返回undefined-特性:-当且仅当两个运算数的值都是true时,才返回true,否则都是false-短路操作当第一个操作数是false则不在对第二个操作数进行求值-或||:-规则:-第一个操作数是对象返回第一个操作数-第一个操作数值为false返回第二操作数-两个操作数都是对象返回第一个操作数-两个操作数都是null返回null-两个操作数都是NaN返回NaN-两个操作数都是undefined返回undefined-特性:-当且仅当两个运算数值都是false时,才返回false,否则返回true-如果第一个操作数值为true,则不会对第二个操作数进行求值####位运算符javaScript位运算不比普通运算有效率提升#####基础知识-类型:-有符号:一位符号+31位数值位-无符号:-只能是正数-32位数值位(0正1负)-数值范围可以加大-数值范围:-$2^{31}$~$2^{31}$-1-存储方式:-正数-纯二进制存储-31位中每一位表示2的幂-用0补充无用位-负数-二进制补码存储-NaN和Infinity做0存储#####逻辑位运算~,&,|,^(异或)#####位移-$<<$左移:数值位左移$x$位置(除以$2^{x}$)-$>>$有符号右移:数值位右移$x$位置(乘以$2^{x}$)-$>>>$无符号右移:-正数:和$>>$相同-负数:会出现无限大的数值-复合赋值运算符:位操作符与等号结合,复合赋值不会有性能提升其他运算符-?:三目运算符typeof:类型判定运算符void舍弃运算符的值,返回undefined作为表达式值","JavaScript\\运算符\\js运算符号.md":"#js运算符##`||`>1.同真输左>2.有真输真>3.同假输右>>总结:`从左到右,只要有真就输出,碰到为假的就会往后遍历,若是最后一个,就输出最后一个`##`&&`>1.同真输右>2.同假输左>3.有假输假>>总结:`从左到右,碰到有假就输出,碰到为真就往后遍历,若是最后一个就输出最后一个``|`>1.将`假`转换为0进行`|`位运算`&`>1.将`假`转换为0进行`&`位运算测试代码```jsletdata=[{'||':[1||2,//1true||2,//truefalse||2,//24||true,//45||false,//5false||false,//falseundefined||undefined,//undefinedfalse||undefined,//undefinedfalse||NaN,//NaN0||false,//false0||NaN,//NaNundefined||NaN,//NaNundefined||2,//2undefined||null,//nullnull||undefined,//undefinedNaN||0,//0NaN||2,//20||2,//2],'&&':[1&&2,//2true&&2,//2false&&2,//false4&&true,//true5&&false,//falsefalse&&false,//falseundefined&&undefined,//undefinedfalse&&undefined,//falsefalse&&NaN,//false0&&false,//00&&NaN,//0undefined&&NaN,//undefinedundefined&&2,//undefinedundefined&&null,//undefinednull&&undefined,//nullNaN&&0,//NaNNaN&&2,//NaN0&&2,//0],'|':[1|2,//3true|2,//3false|2,//24|true,//55|false,//5false|false,//0undefined|undefined,//0false|undefined,//0false|NaN,//00|false,//00|NaN,//0undefined|NaN,//0undefined|2,//2undefined|null,//0null|undefined,//0NaN|0,//0NaN|2,//20|2,//2],'&':[1&2,//true&2,//false&2,//4&true,//5&false,//false&false,//undefined&undefined,//false&undefined,//false&NaN,//0&false,//0&NaN,//undefined&NaN,//undefined&2,//undefined&null,//null&undefined,//NaN&0,//NaN&2,//0&2,//3&1,//1],},]data.map((item)=>{item['&&'].map((item)=>{console.log(item)})item['&'].map((item)=>{console.log(item)})item['||'].map((item)=>{console.log(item)})item['|'].map((item)=>{console.log(item)})})```","JavaScript\\运算符\\拓展运算符.md":"#拓展运算符##数值运算符>ES2021|符号|名称|描述|EG||------|--------------|-------------------------------------|------------------------------------||`_`|数据分割运算符|\\_可以用来增加数值的易读性|`100_00===10000,0x11_1===0x111`||`??`|零合并运算符|和\\|\\|类似,但是不会过滤掉false,0|`0??'default'//0`||`?.`|可选链操作符|在引用null活undefined不会报错|`obj.b?.c,`||`#`|私有方法/属性|标记私有方法或变量|||`~~`|双位运算符|取整|`~~4.5//4`||`void`|void运算符|使用改符号的方法,返回值只有undefined|`voidfunctionfn(){...}`||`**`|求幂运算符|求幂|`a**b=>a^b`|```js()=>{//_console.log(100_00===10000,0x11_1===0x111,0b11_1===0b111)},()=>{//??console.log(undefined||'default',null||'default',false||'default',0||'default',undefined??'default',null??'default',false??'default',0??'default',)leta={b:null,c:10}a.b=a.b??20a.c=a.c??20console.log(a)},()=>{//?.constobj={a:'foo',b:{c:'bar'}}console.log(obj.b?.c,obj.d?.c,obj.func?.(),)},()=>{//私有方法/属性#classPerson{getDesc(){returnthis.#name+\"\"+this.#getAge()}#getAge(){returnthis.#age}get#name(){return'foo'}#age=23}consta=newPerson()console.log(a.age)console.log(a.getDesc())},()=>{//~~console.log(~~4.5,~~-4.5)},()=>{//voidconstcustomMethod=()=>123constfunc=()=>voidcustomMethod();console.log(func())},()=>{//**console.log(2**3)},```","Knowledge\\python\\index.md":"#python[机器学习](https://juejin.cn/post/7053395684598218765)","Knowledge\\产品\\画图\\UML类图.md":"#UML类图>-虚线+箭头:依赖(Dependency)>-虚线+空心三角:实现接口>-实线+箭头:关联(Association)>-实线+空心右三角:泛化(继承,extends)>-实线+空心菱形:聚合(Aggregation)>-实线+实心菱形:组合>-基数：连线两端的数字表明这一端的类可以有几个实例，比如：一个鸟应该有两只翅膀。>>其他:如果一个类可能有无数个实例，则就用‘n’来表示。关联、聚合、组合是有基数的##类（Class）>三层矩形框表示:>>-第一层显示类的名称，如果是抽象类，则就用斜体显示>-第二层是字段和属性>-第三层是类的方法>>符号:>>-‘+’:public>-‘-’:private>-‘#’:protected![image-20210806171550598](.assets/image-20210806171550598-16282413538052.png)##接口>:两层矩形框:>>与类图的区别主要是顶端有<>显示。>>-第一行是接口名称。>-第二行是接口方法。![image-20210806171609133](.assets/image-20210806171609133-16282413722263.png)##从非接口类继承![image-20210806175121309](.assets/image-20210806175121309.png)##双向关联![image-20210806175217597](.assets/image-20210806175217597.png)##单向关联![image-20210806175239738](.assets/image-20210806175239738.png)##软件包![image-20210806175312121](.assets/image-20210806175312121.png)##序列化![image-20210806175338995](.assets/image-20210806175338995-16282436215534.png)##关联实例=>产生实例>水平的连线还是表示上面所说的关联,但从关联连线中引伸出来的虚线,这意味当Flight类的一个实例关联到FrequentFlyer类的一个实例时，将会产生MileageCredit类的一个实例.![image-20210806175443119](.assets/image-20210806175443119.png)##不随着另一个实例创建销毁>带菱形的箭头表示基本聚合,由上图知道,Wheel类扮演wheels角色,聚合4个到Car对象里面去,空心的菱形表示Wheel对象并不随Car的创建而创建,销毁而销毁![image-20210806175713677](.assets/image-20210806175713677.png)##随着另一个实例创建销毁>意义和上面类似,唯一不同的是,实心菱形表示Department对象随Company对象的创建而创建,销毁而销毁![image-20210806175734444](.assets/image-20210806175734444.png)##反射关联>表示反射关联,显示一个Employee类如何通过manager/manages角色与它本身相关。当一个类关联到它本身时，这并不意味着类的实例与它本身相关，而是类的一个实例与类的另一个实例相关![image-20210806175828710](.assets/image-20210806175828710.png)","Knowledge\\产品\\画图\\思维导图.md":"#思维导图>又名心智导图，是表达发散性思维的有效图形思维工具，它简单却又很有效同时又很高效，是一种实用性的思维工具>![](/.assets/img/2022-02-11-17-53-36.png)","Knowledge\\产品\\画图\\时序图.md":"#时序图一、什么是时序图？时序图（SequenceDiagram），亦称为序列图、循序图或顺序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。时序图是一个二维图，横轴表示对象，纵轴表示时间，消息在各对象之间横向传递，依照时间顺序纵向排列。二、时序图的作用是什么？1、展示对象之间交互的顺序。将交互行为建模为消息传递，通过描述消息是如何在对象间发送和接收的来动态展示对象之间的交互；2、相对于其他UML图，时序图更强调交互的时间顺序；3、可以直观的描述并发进程。三、组成元素有哪些？1.角色（Actor）系统角色，可以是人、机器、其他系统、子系统；在时序图中用表示。2.对象（Object）（1）对象的三种命名方式第一种方式包括对象名和类名，例如：直播课时:课时，在时序图中，用“对象：类”表示；第二种方式只显示类名，即表示它是一个匿名对象，例如：:课程；在时序图中，用“：类”表示；第三种方式只显示对象名不显示类名，例如：讲师；在时序图中，用“对象”表示。（2）命名方式的选择三种命名方式均可，哪种最容易让阅读该时序图的人理解，就选择哪种。（3）对象的排列顺序对象的左右顺序并不重要，但是为了作图清晰整洁，通常应遵循以下两个原则：把交互频繁的对象尽可能的靠拢；2.把初始化整个交互活动的对象放置在最左端。3.生命线（Lifeline）在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。4.控制焦点（FocusofControl）又称为激活期，表示时间段的符号，在这个时间段内对象将执行相应的操作。它可以被理解成C语言语义中一对花括号{}中的内容；用小矩形表示。5.消息（Message）消息一般分为同步消息（SynchronousMessage），异步消息（AsynchronousMessage）和返回消息（ReturnMessage）。消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义；消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。返回消息表示从过程调用返回。6.自关联消息表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。7.组合片段组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下：![](/.assets/img/2022-02-11-17-56-53.png)用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的if..else..（1）抉择（Alt）抉择在任何场合下只发生一个序列。可以在每个片段中设置一个临界来指示该片段可以运行的条件。else的临界指示其他任何临界都不为True时应运行的片段。如果所有临界都为False并且没有else，则不执行任何片段。![](/.assets/img/2022-02-11-17-58-09.png)（2）选项（Opt）包含一个可能发生或不发生的序列；![](/.assets/img/2022-02-11-17-58-15.png)（3）循环（Loop）片段重复一定次数，可以在临界中指示片段重复的条件。![](/.assets/img/2022-02-11-17-58-22.png)（4）并行（Par）![](/.assets/img/2022-02-11-17-58-27.png)##标准时序图>Title:标题：指定时序图的标题>Notedirectionof对象:描述：在对象的某一侧添加描述，direction可以为right/left/over，对象可以是多个对象，以,作为分隔符>participant对象：创建一个对象>loop...end：创建一个循环体>对象A->对象B:描述：绘制A与B之间的对话，以实线连接>>-->实线实心箭头指向>--->虚线实心箭头指向>-->>实线小箭头指向>--->>虚线小箭头指向![](./.assets/时序图-2022-03-15-21-58-58.png)````shell#```sequenceTitle:时序图示例客户端->服务端:我想找你拿下数据SYN服务端-->客户端:我收到你的请求啦ACK+SYN客户端->>服务端:我收到你的确认啦，我们开始通信吧ACKNoterightof服务端:我是一个服务端Noteleftof客户端:我是一个客户端Noteover服务端,客户端:TCP三次握手participant观察者````![](./.assets/时序图-2022-03-15-21-59-38.png)````shell#```sequence客户端->打印机:打印请求(id)打印机->数据库:请求数据(id)Noterightof数据库:执行SQL获取数据数据库-->打印机:返回数据信息Noterightof打印机:使用数据打印打印机-->>客户端:返回打印结果客户端->客户端:等待提取结果````##带样式时序图>需要使用mermaid解析，并在开头使用关键字sequenceDiagram指明>线段的样式遵循mermaid的解析方式>>-->：实线连接>--->：虚线连接>-->>：实线箭头指向>--->>：虚线箭头指向![](./.assets/时序图-2022-03-15-22-00-45.png)```shellsequenceDiagram对象A->对象B:中午吃什么？对象B->>对象A:随便loop思考对象A->对象A:努力搜索end对象A-->>对象B:火锅？对象B->>对象A:可以Noteleftof对象A:我是一个对象ANoterightof对象B:我是一个对象Bparticipant对象CNoteover对象C:我自己说了算```````shell#```mermaidsequenceDiagram对象A->对象B:中午吃什么？对象B->>对象A:随便loop思考对象A->对象A:努力搜索end对象A-->>对象B:火锅？对象B->>对象A:可以Noteleftof对象A:我是一个对象ANoterightof对象B:我是一个对象Bparticipant对象CNoteover对象C:我自己说了算````","Knowledge\\产品\\画图\\流程图.md":"#流程图##标准流程图```flowstart=>start:接收到消息info=>operation:读取信息setCache=>operation:更新缓存end=>end:处理结束start->info->setCache->end```![](/.assets/img/2022-03-02-16-00-20.png)##简易流程图```flowst=>start:Startop=>operation:YourOperationcond=>condition:YesorNo?e=>endst->op->condcond(yes)->econd(no)->op```![](/.assets/img/2022-03-02-16-03-01.png)````shell#```flowstart=>start:API请求cache=>operation:读取Redis缓存cached=>condition:是否有缓存？sendMq=>operation:发送MQ，后台服务更新缓存info=>operation:读取信息setCache=>operation:保存缓存end=>end:返回信息start->cache->cachedcached(yes)->sendMqcached(no)->infoinfo->setCachesetCache->endsendMq->end````>基本语法：>>定义模块id=>关键字:描述（“描述”的前面必须有空格，“=>”两端不能有空格）>关键字：>start流程开始，以圆角矩形绘制>opearation操作，以直角矩形绘制>condition判断，以菱形绘制>subroutine子流程，以左右带空白框的矩形绘制>inputoutput输入输出，以平行四边形绘制>end流程结束，以圆角矩形绘制>定义模块间的流向：>模块1id->模块2id：一般的箭头指向>条件模块id(描述)->模块id(direction)：条件模块跳转到对应的执行模块，并指定对应分支的布局方向![](./.assets/流程图-2022-03-15-21-52-46.png)````shell#```flowst=>start:开始ipt=>inputoutput:输入一个xop=>operation:处理加工x+1cond=>condition:溢出（是或否？）sub=>subroutine:子流程io=>inputoutput:输出xed=>end:结束st->ipt->op->condcond(yes)->io->edcond(no)->sub->io->ed````![](./.assets/流程图-2022-03-15-21-53-23.png)````shell#```flowst=>start:Start|past:>http://www.google.com[blank]e=>end:End:>http://www.google.comop1=>operation:get_hotel_ids|pastop2=>operation:get_proxy|currentsub1=>subroutine:get_proxy|currentop3=>operation:save_comment|currentop4=>operation:set_sentiment|currentop5=>operation:set_record|currentcond1=>condition:ids_remain空?cond2=>condition:proxy_list空?cond3=>condition:ids_got空?cond4=>condition:爬取成功??cond5=>condition:ids_remain空?io1=>inputoutput:ids-remainio2=>inputoutput:proxy_listio3=>inputoutput:ids-gotst->op1(right)->io1->cond1cond1(yes)->sub1->io2->cond2cond2(no)->op3cond2(yes)->sub1cond1(no)->op3->cond4cond4(yes)->io3->cond3cond4(no)->io1cond3(no)->op4cond3(yes,right)->cond5cond5(yes)->op5cond5(no)->cond3op5->e````##样式流程图>基本语法：>>graph指定流程图方向：graphLR横向，graphTD纵向>元素的形状定义：>>-id[描述]以直角矩形绘制>-id(描述)以圆角矩形绘制>-id{描述}以菱形绘制>-id>描述]以不对称矩形绘制>-id((描述))以圆形绘制>>线条定义：>A-->B带箭头指向>A---B不带箭头连接>A-.-B虚线连接>A-.->B虚线指向>A==>B加粗箭头指向>A--描述---B不带箭头指向并在线段中间添加描述>A--描述-->B带描述的箭头指向>A-.描述.->B带描述的虚线连指向>A==描述==>B带描述的加粗箭头指向>子流程图定义>subgraphtitle>graphdirection>end>![](./.assets/流程图-2022-03-15-21-56-04.png)```shellgraphLRA(开始)-->B(起床)B--天气不好---C>干活]C==>D{休息时间到了}D-.yes.->E((休息))D-.no.->CE-->F(吃饭)```````shell#```mermaidgraphLRA(开始)-->B(起床)B--天气不好---C>干活]C==>D{休息时间到了}D-.yes.->E((休息))D-.no.->CE-->F(吃饭)````","Knowledge\\产品\\画图\\甘特图.md":"#甘特图>使用mermaid解析语言，在开头使用关键字gantt指明>deteFormat格式指明日期的显示格式>title标题设置图标的标题>section描述定义纵向上的一个环节>定义步骤：每个步骤有两种状态done（已完成）/active（执行中）>>-描述:状态,id,开始日期,结束日期/持续时间>-描述:状态[,id],afterid2,持续时间>-crit：可用于标记该步骤需要被修正，将高亮显示>-如果不指定具体的开始时间或在某个步骤之后，将默认依次顺序排列>甘特图视图有两个部分、树形任务列表及含时间显示的任务条视图>![](/.assets/img/2022-02-11-17-47-59.png)>•左边部分，也可以编辑任务信息，包括任务的开始、结束时间，优先级，进度。>•右边部分，可以看到任务条，不同颜色表示不同的优先级，两个任务之间的联系，表示这两个任务有依赖关系。除了浏览任务信息外，我们还可以：1.更改时间轴到小时、天、周、星期几、月。2.将鼠标滑动到任务上，显示其所有详情，如开始、结束时间，优先级，进度。3.选中任务进行移动可以更改起始时间。4.选中任务的一端进行移动，可以更改任务时长。5.选中任务开始或结束端的小圆圈，可以将其链接到其他任何任务上，然后设置之间的依赖关系。备注依赖关系的类型：-截止日期-至-开始日期,任务A的开始日期不得早于任务B的截止日期。-开始日期-至-截止日期,任务A的截止日期不得早于任务B的开始日期。-开始日期-至-开始日期,任务A的开始日期不得早于任务B的开始日期。-截止日期-至-截止日期,任务A的截止日期不得早于任务B的截止日期。![](./.assets/甘特图-2022-03-15-22-04-06.png)```shell#```mermaidganttdateFormatYYYY-MM-DDtitle软件开发甘特图section设计需求:done,des1,2019-01-06,2019-01-08原型:active,des2,2019-01-09,3dUI设计:des3,afterdes2,5d未来任务:des4,afterdes3,5dsection开发学习准备理解需求:crit,done,2019-01-06,24h设计框架:crit,done,afterdes2,2d开发:crit,active,3d未来任务:crit,5d休息时间:2dsection测试功能测试:active,a1,afterdes3,3d压力测试:aftera1,20h测试报告:48h```<!--````shell-->```mermaidganttdateFormatYYYY-MM-DDtitle软件开发甘特图section设计需求:done,des1,2019-01-06,2019-01-08原型:active,des2,2019-01-09,3dUI设计:des3,afterdes2,5d未来任务:des4,afterdes3,5dsection开发学习准备理解需求:crit,done,2019-01-06,24h设计框架:crit,done,afterdes2,2d开发:crit,active,3d未来任务:crit,5d休息时间:2dsection测试功能测试:active,a1,afterdes3,3d压力测试:aftera1,20h测试报告:48h````","Knowledge\\产品\\运维\\docker.md":"#docker##安装><<https://hub.docker.com/editions/community/docker-ce-desktop-window>###查看DockerEngin,Compose和Machine版本```shellPSC:\\Users\\Docker>docker--versionDockerversion17.03.0-ce,build60ccb22PSC:\\Users\\Docker>docker-compose--versiondocker-composeversion1.11.2,builddfed245PSC:\\Users\\Docker>docker-machine--versiondocker-machineversion0.10.0,build76ed2a6```##问题###Windows10启动DockerDesktop时出现WSL2installationisincomplete![](/.assets/img/2022-01-26-14-11-26.png)>去安装<https://docs.microsoft.com/en-us/windows/wsl/install-win10#step-4—download-the-linux-kernel-update-package>","Knowledge\\产品\\运维\\jenkins.md":"#Jenkins>一个平台:主要运行*插件*>把软件生命周期中所有工作自动化>[13、持续集成工具jenkins](https://shimo.im/docs/V8XRTpPPYvjjX8Ct/read)##安装><https://www.jenkins.io/download/>>端口:8989>第一次打开可能要解锁jenkins，页面如下图。在C:\\ProgramData\\Jenkins\\.jenkins\\secrets\\initialAdminPassword输入框，点击继续即可进行下一步操作>admin1234><http://localhost:8989/jenkins>##使用>-新建job>-自定义项目空间>-指定工作项目空间##集成Allure报告","Knowledge\\产品\\运维\\Linux\\linux-question.md":"#linux-question##su:Authenticationfailure问题>su命令不能切换root，提示su:Authenticationfailure，只要你sudopasswdroot过一次之后，下次再su的时候只要输入密码就可以成功登录了。","Knowledge\\产品\\运维\\Linux\\linux.md":"#linux常用功能命令##系统服务管理###systemctl-输出系统中各个服务的状态：```bashsystemctllist-units--type=service```-查看服务的运行状态：```basicsystemctlstatusfirewalld```-关闭服务：```basicsystemctlstopfirewalld```-启动服务：```systemctlstartfirewalld```-重新启动服务（不管当前服务是启动还是关闭）：```systemctlrestartfirewalld```-重新载入配置信息而不中断服务：```systemctlreloadfirewalld```-禁止服务开机自启动：```systemctldisablefirewalld```-设置服务开机自启动：```systemctlenablefirewalld```##文件管理###ls列出当前目录(/)下的所有文件：```ls-l/```###pwd获取目前所在工作目录的绝对路径###cd改变当前工作目录：```cd/usr/local```###date显示或修改系统时间与日期；```date'+%Y-%m-%d%H:%M:%S'```###passwd用于设置用户密码：```passwdroot```###su改变用户身份（切换到超级用户）：```su-```###clear用于清除屏幕信息###man显示指定命令的帮助信息：```manls```###who-查询系统处于什么运行级别：```who-r```-显示目前登录到系统的用户：```who-buT```###free显示系统内存状态（单位MB）：```free-m```###ps显示系统进程运行动态：```ps-ef```查看sshd进程的运行动态：```ps-ef|grepsshd```###top查看即时活跃的进程，类似Windows的任务管理器###mkdir创建目录###more用于文件过长时分页查看文件内容每页10行查看boot.log文件```more-c-10/var/log/boot.log```###cat查看Linux启动日志文件文件，并标明行号：```cat-Ab/var/log/boot.log```###touch创建text.txt文件：```touchtext.txt```###rm-删除文件：```rmtext.txt```-强制删除某个目录及其子目录：```rm-rftestdir/```###cp将test1目录复制到test2目录```cp-r/mydata/tes1/mydata/test2```###mv移动或覆盖文件：```mvtext.txttext2.txt```##压缩与解压###tar-将/etc文件夹中的文件归档到文件etc.tar（并不会进行压缩）：```tar-cvf/mydata/etc.tar/etc```-用gzip压缩文件夹/etc中的文件到文件etc.tar.gz：```tar-zcvf/mydata/etc.tar.gz/etc```-用bzip2压缩文件夹/etc到文件/etc.tar.bz2：```tar-jcvf/mydata/etc.tar.bz2/etc```-分页查看压缩包中内容（gzip）：```tar-ztvf/mydata/etc.tar.gz|more-c-10```-解压文件到当前目录（gzip）：```tar-zxvf/mydata/etc.tar.gz```##磁盘和网络管理###df查看磁盘空间占用情况：```df-hT```###dh查看当前目录下的文件及文件夹所占大小：```du-h--max-depth=1./*```###ifconfig显示当前网络接口状态###netstat-查看当前路由信息：```netstat-rn```-查看所有有效TCP连接：```netstat-an```-查看系统中启动的监听服务：```netstat-tulnp```-查看处于连接状态的系统资源信息：```netstat-atunp```###wget从网络上下载文件##软件的安装与管理###rpm-安装软件包：rpm-ivhnginx-1.12.2-2.el7.x86_64.rpm-模糊搜索软件包：rpm-qa|grepnginx-精确查找软件包：rpm-qanginx-查询软件包的安装路径：rpm-qlnginx-1.12.2-2.el7.x86_64-查看软件包的概要信息：rpm-qinginx-1.12.2-2.el7.x86_64-验证软件包内容和安装文件是否一致：rpm-Vnginx-1.12.2-2.el7.x86_64-更新软件包：rpm-Uvhnginx-1.12.2-2.el7.x86_64-删除软件包：rpm-enginx-1.12.2-2.el7.x86_64###yum-安装软件包：yuminstallnginx-检查可以更新的软件包：yumcheck-update-更新指定的软件包：yumupdatenginx-在资源库中查找软件包信息：yuminfonginx\\*-列出已经安装的所有软件包：yuminfoinstalled-列出软件包名称：yumlistnginx\\*-模糊搜索软件包：yumsearchnginx","Knowledge\\产品\\运维\\Linux\\命令.md":"#linux命令##命令###命令行提示符进入命令行环境以后，用户会看到`Shell`的提示符。提示符往往是一串前缀，最后以一个美元符号`$`结尾，用户可以在这个符号后面输入各种命令。执行一个简单的命令`pwd`：```[root@iZm5e8dsxce9ufaic7hi3uZ~]#pwd/root```命令解析：-`root`：表示用户名；-`iZm5e8dsxce9ufaic7hi3uZ`：表示主机名；-`~`：表示目前所在目录为家目录，其中`root`用户的家目录是`/root`普通用户的家目录在`/home`下；-`#`：指示你所具有的权限（`root`用户为`#`，普通用户为`$`）。-执行`whoami`命令可以查看当前用户名；-执行`hostname`命令可以查看当前主机名；关于如何创建、切换、删除用户，在后面的用户与权限会具体讲解，这里先使用`root`用户进行演示。[备注]`root`是超级用户，具备操作系统的一切权限。###命令格式```commandparameters（命令参数）```####长短参数```单个参数：ls-a（a是英文all的缩写，表示“全部”）多个参数：ls-al（全部文件+列表形式展示）单个长参数：ls--all多个长参数：ls--reverse--all长短混合参数：ls--all-l```####参数值```短参数：command-p10（例如：sshroot@121.42.11.34-p22）长参数：command--paramters=10（例如：sshroot@121.42.11.34--port=22）```##快捷方式在开始学习`Linux`命令之前，有这么一些快捷方式，是必须要提前掌握的，它将贯穿整个`Linux`使用生涯。-通过上下方向键↑↓来调取过往执行过的`Linux`命令；-命令或参数仅需输入前几位就可以用`Tab`键补全；-`Ctrl+R`：用于查找使用过的命令（`history`命令用于列出之前使用过的所有命令，然后输入`!`命令加上编号(`!2`)就可以直接执行该历史命令）；-`Ctrl+L`：清除屏幕并将当前行移到页面顶部；-`Ctrl+C`：中止当前正在执行的命令；-`Ctrl+U`：从光标位置剪切到行首；-`Ctrl+K`：从光标位置剪切到行尾；-`Ctrl+W`：剪切光标左侧的一个单词；-`Ctrl+Y`：粘贴`Ctrl+U|K|Y`剪切的命令；-`Ctrl+A`：光标跳到命令行的开头；-`Ctrl+E`：光标跳到命令行的结尾；-`Ctrl+D`：关闭`Shell`会话；##文件和目录###文件的组织![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)###查看路径####pwd显示当前目录的路径![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)####which查看命令的可执行文件所在路径，`Linux`下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序，`which`命令本身对应的程序也存在于`Linux`中。总的来说一个命令就是一个可执行程序。![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)###浏览和切换目录####ls列出文件和目录，它是`Linux`最常用的命令之一。【常用参数】-`-a`显示所有文件和目录包括隐藏的-`-l`显示详细列表-`-h`适合人类阅读的-`-t`按文件最近一次修改时间排序-`-i`显示文件的`inode`（`inode`是文件内容的标识）![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)####cd`cd`是英语`changedirectory`的缩写，表示切换目录。```kotlincd/-->跳转到根目录cd~-->跳转到家目录cd..-->跳转到上级目录cd./home-->跳转到当前目录的home目录下cd/home/lion-->跳转到根目录下的home目录下的lion目录cd-->不添加任何参数，也是回到家目录```[注意]输入`cd/ho`+单次`tab`键会自动补全路径+两次`tab`键会列出所有可能的目录列表。####du列举目录大小信息。【常用参数】-`-h`适合人类阅读的；-`-a`同时列举出目录下文件的大小信息；-`-s`只显示总计大小，不显示具体信息。###浏览和创建文件####cat一次性显示文件所有内容，更适合查看小的文件。```kotlincatcloud-init.log```【常用参数】-`-n`显示行号。####less分页显示文件内容，更适合查看大的文件。```kotlinlesscloud-init.log```【快捷操作】-空格键：前进一页（一个屏幕）；-`b`键：后退一页；-回车键：前进一行；-`y`键：后退一行；-上下键：回退或前进一行；-`d`键：前进半页；-`u`键：后退半页；-`q`键：停止读取文件，中止`less`命令；-`=`键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；-`h`键：显示帮助文档；-`/`键：进入搜索模式后，按`n`键跳到一个符合项目，按`N`键跳到上一个符合项目，同时也可以输入正则表达式匹配。####head显示文件的开头几行（默认是10行）```bashheadcloud-init.log```【参数】-`-n`指定行数`headcloud-init.log-n2`####tail显示文件的结尾几行（默认是10行）```bashtailcloud-init.log```【参数】-`-n`指定行数`tailcloud-init.log-n2`-`-f`会每过1秒检查下文件是否有更新内容，也可以用`-s`参数指定间隔时间`tail-f-s4xxx.log`####touch创建一个文件```bashtouchnew_file```####mkdir创建一个目录```bashmkdirnew_folder```【常用参数】-`-p`递归的创建目录结构`mkdir-pone/two/three`###文件的复制和移动####cp拷贝文件和目录```bashcpfilefile_copy-->file是目标文件，file_copy是拷贝出来的文件cpfileone-->把file文件拷贝到one目录下，并且文件名依然为filecpfileone/file_copy-->把file文件拷贝到one目录下，文件名为file_copycp*.txtfolder-->把当前目录下所有txt文件拷贝到folder目录下```【常用参数】-`-r`递归的拷贝，常用来拷贝一整个目录####mv移动（重命名）文件或目录，与cp命令用法相似。```bashmvfileone-->将file文件移动到one目录下mvnew_folderone-->将new_folder文件夹移动到one目录下mv*.txtfolder-->把当前目录下所有txt文件移动到folder目录下mvfilenew_file-->file文件重命名为new_file```###文件的删除和链接####rm删除文件和目录，由于`Linux`下没有回收站，一旦删除非常难恢复，因此需要谨慎操作```bashrmnew_file-->删除new_file文件rmf1f2f3-->同时删除f1f2f33个文件```【常用参数】-`-i`向用户确认是否删除；-`-f`文件强制删除；-`-r`递归删除文件夹，著名的删除操作`rm-rf`。####ln英文`Link`的缩写，表示创建链接。学习创建链接之前，首先要理解链接是什么，我们先来看看`Linux`的文件是如何存储的：`Linux`文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过`inode`标识绑定到文件内容。Linux下有两种链接类型：硬链接和软链接。#####硬链接使链接的两个文件共享同样文件内容，就是同样的`inode`，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。```bashlnfile1file2-->创建file2为file1的硬链接```![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)如果我们用`rmfile1`来删除`file1`，对`file2`没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了`file1`与`file2`后，它们共同指向的文件内容才会消失。#####软链接软链接就类似`windows`下快捷方式。```bashln-sfile1file2```![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)执行`ls-l`命名查看当前目录下文件的具体信息```bashtotal0-rw-r--r--1rootroot0Jan1406:29file1lrwxrwxrwx1rootroot5Jan1406:42file2->file1#表示file2指向file1```其实`file2`只是`file1`的一个快捷方式，它指向的是`file1`，所以显示的是`file1`的内容，但其实`file2`的`inode`与`file1`并不相同。如果我们删除了`file2`的话，`file1`是不会受影响的，但如果删除`file1`的话，`file2`就会变成死链接，因为指向的文件不见了。##用户与权限###用户`Linux`是一个多用户的操作系统。在`Linux`中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫`root`，是一个很特殊的用户，它是超级用户，拥有最高权限。![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)自己创建的用户是有限权限的用户，这样大大提高了`Linux`系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用`sudo`命令。####sudo以`root`身份运行命令```bashsudodate-->当然查看日期是不需要sudo的这里只是演示，sudo完之后一般还需要输入用户密码的```####useradd+passwd-`useradd`添加新用户-`passwd`修改用户密码这两个命令需要`root`用户权限```bashuseraddlion-->添加一个lion用户，添加完之后在/home路径下可以查看passwdlion-->修改lion用户的密码```####userdel删除用户，需要`root`用户权限```bashuserdellion-->只会删除用户名，不会从/home中删除对应文件夹userdellion-r-->会同时删除/home下的对应文件夹```####su切换用户，需要`root`用户权限```bashsudosu-->切换为root用户（exit命令或CTRL+D快捷键都可以使普通用户切换为root用户）sulion-->切换为普通用户su--->切换为root用户```###群组的管理`Linux`中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。####groupadd创建群组，用法和`useradd`类似。```bashgroupaddfriends```####groupdel删除一个已存在的群组```bashgroupdelfoo-->删除foo群组```####groups查看用户所在群组```bashgroupslion-->查看lion用户所在的群组```####usermod用于修改用户的账户。【常用参数】-`-l`对用户重命名。需要注意的是`/home`中的用户家目录的名字不会改变，需要手动修改。-`-g`修改用户所在的群组，例如`usermod-gfriendslion`修改`lion`用户的群组为`friends`。-`-G`一次性让用户添加多个群组，例如`usermod-Gfriends,foo,barlion`。-`-a``-G`会让你离开原先的群组，如果你不想这样做的话，就得再添加`-a`参数，意味着`append`追加的意思。####chgrp用于修改文件的群组。```bashchgrpbarfile.txt-->file.txt文件的群组修改为bar```####chown改变文件的所有者，需要`root`身份才能运行。```bashchownlionfile.txt-->把其它用户创建的file.txt转让给lion用户chownlion:barfile.txt-->把file.txt的用户改为lion，群组改为bar```【常用参数】-`-R`递归设置子目录和子文件，`chown-Rlion:lion/home/frank`把`frank`文件夹的用户和群组都改为`lion`。###文件权限管理####chmod修改访问权限。```bashchmod740file.txt```【常用参数】-`-R`可以递归地修改文件访问权限，例如`chmod-R777/home/lion`修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习`Linux`的文件权限。```bash[root@lion~]#ls-ldrwxr-xr-x5rootroot4096Apr132020climblrwxrwxrwx1rootroot7Jan1406:41hello2.c->hello.c-rw-r--r--1rootroot149Jan1306:14hello.c```其中`drwxr-xr-x`表示文件或目录的权限。让我们一起来解读它具体代表什么？-`d`：表示目录，就是说这是一个目录，普通文件是`-`，链接是`l`。-`r`：`read`表示文件可读。-`w`：`write`表示文件可写，一般有写的权限，就有删除的权限。-`x`：`execute`表示文件可执行。-`-`：表示没有相应权限。权限的整体是按用户来划分的，如下图所示：![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)现在再来理解这句权限`drwxr-xr-x`的意思：-它是一个文件夹；-它的所有者具有：读、写、执行权限；-它的群组用户具有：读、执行的权限，没有写的权限；-它的其它用户具有：读、执行的权限，没有写的权限。现在理解了权限，我们使用`chmod`来尝试修改权限。`chmod`它不需要是`root`用户才能运行的，只要你是此文件所有者，就可以用`chmod`来修改文件的访问权限。#####数字分配权限|权限|数字||----|----||r|4||w|2||x|1|因此要改变权限，只要做一些简单的加法就行：```bashchmod640hello.c#分析6=4+2+0表示所有者具有rw权限4=4+0+0表示群组用户具有r权限0=0+0+0表示其它用户没有权限对应文字权限为：-rw-r-----```#####用字母来分配权限-`u`：`user`的缩写，用户的意思，表示所有者。-`g`：`group`的缩写，群组的意思，表示群组用户。-`o`：`other`的缩写，其它的意思，表示其它用户。-`a`：`all`的缩写，所有的意思，表示所有用户。-`+`：加号，表示添加权限。-`-`：减号，表示去除权限。-`=`：等于号，表示分配权限。```bashchmodu+rxfile-->文件file的所有者增加读和运行的权限chmodg+rfile-->文件file的群组用户增加读的权限chmodo-rfile-->文件file的其它用户移除读的权限chmodg+ro-rfile-->文件file的群组用户增加读的权限，其它用户移除读的权限chmodgo-rfile-->文件file的群组和其他用户移除读的权限chmod+xfile-->文件file的所有用户增加运行的权限chmodu=rwx,g=r,o=-file-->文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限```##查找文件###locate搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。####安装locate```bashyum-yinstallmlocate-->安装包updatedb-->更新数据库locatefile.txtlocatefil*.txt```[注意]`locate`命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行`updatedb`命令去更新数据库。###find用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。```bashfind<何处><何物><做什么>```-何处：指定在哪个目录查找，此目录的所有子目录也会被查找。-何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。-做什么：找到文件后，可以进行后续处理，如果不指定这个参数，`find`命令只会显示找到的文件。####根据文件名查找```bashfind-name\"file.txt\"-->当前目录以及子目录下通过名称查找文件find.-name\"syslog\"-->当前目录以及子目录下通过名称查找文件find/-name\"syslog\"-->整个硬盘下查找syslogfind/var/log-name\"syslog\"-->在指定的目录/var/log下查找syslog文件find/var/log-name\"syslog*\"-->查找syslog1、syslog2...等文件，通配符表示所有find/var/log-name\"*syslog*\"-->查找包含syslog的文件```[注意]`find`命令只会查找完全符合“何物”字符串的文件，而`locate`会查找所有包含关键字的文件。####根据文件大小查找```bashfind/var-size+10M-->/var目录下查找文件大小超过10M的文件find/var-size-50k-->/var目录下查找文件大小小于50k的文件find/var-size+1G-->/var目录下查找文件大小查过1G的文件find/var-size1M-->/var目录下查找文件大小等于1M的文件```####根据文件最近访问时间查找```bashfind-name\"*.txt\"-atime-7-->近7天内访问过的.txt结尾的文件```####仅查找目录或文件```bashfind.-name\"file\"-typef-->只查找当前目录下的file文件find.-name\"file\"-typed-->只查找当前目录下的file目录```####操作查找结果```bashfind-name\"*.txt\"-printf\"%p-%u\\n\"-->找出所有后缀为txt的文件，并按照%p-%u\\n格式打印，其中%p=文件名，%u=文件所有者find-name\"*.jpg\"-delete-->删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用find-name\"*.c\"-execchmod600{}\\;-->对每个.c结尾的文件，都进行-exec参数指定的操作，{}会被查找到的文件替代，\\;是必须的结尾find-name\"*.c\"-okchmod600{}\\;-->和上面的功能一直，会多一个确认提示```##软件仓库`Linux`下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。`RedHat`家族的软件包后缀名一般为`.rpm`，`Debian`家族的软件包后缀是`.deb`。`Linux`的包都存在一个仓库，叫做软件仓库，它可以使用`yum`来管理软件包，`yum`是`CentOS`中默认的包管理工具，适用于`RedHat`一族。可以理解成`Node.js`的`npm`。###yum常用命令-`yumupdate|yumupgrade`更新软件包-`yumsearchxxx`搜索相应的软件包-`yuminstallxxx`安装软件包-`yumremovexxx`删除软件包###切换CentOS软件源有时候`CentOS`默认的`yum`源不一定是国内镜像，导致`yum`在线安装及更新速度不是很理想。这时候需要将`yum`源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。1、首先备份系统自带`yum`源配置文件`mv/etc/yum.repos.d/CentOS-Base.repo/etc/yum.repos.d/CentOS-Base.repo.backup`2、下载阿里云的`yum`源配置文件到`/etc/yum.repos.d/CentOS7````bashwget-O/etc/yum.repos.d/CentOS-Base.repohttp://mirrors.aliyun.com/repo/Centos-7.repo```3、生成缓存```bashyummakecache```##阅读手册###man####安装更新man```bashsudoyuminstall-yman-pages-->安装sudomandb-->更新```####man手册种类1.可执行程序或`Shell`命令；2.系统调用（`Linux`内核提供的函数）；3.库调用（程序库中的函数）；4.文件（例如`/etc/passwd`）；5.特殊文件（通常在`/dev`下）；6.游戏；7.杂项（`man(7)`，`groff(7)`）；8.系统管理命令（通常只能被`root`用户使用）；9.内核子程序。####man+数字+命令输入man+数字+命令/函数，可以查到相关的命令和函数，若不加数字，`man`默认从数字较小的手册中寻找相关命令和函数```bashman3rand-->表示在手册的第三部分查找rand函数manls-->查找ls用法手册```man手册核心区域解析：(以`manpwd`为例)```bashNAME#命令名称和简单描述pwd--returnworkingdirectorynameSYNOPSIS#使用此命令的所有方法pwd[-L|-P]DESCRIPTION#包括所有参数以及用法Thepwdutilitywritestheabsolutepathnameofthecurrentworkingdirectorytothestandardoutput.Someshellsmayprovideabuiltinpwdcommandwhichissimilaroridenticaltothisutility.Consultthebuiltin(1)manualpage.Theoptionsareasfollows:-LDisplaythelogicalcurrentworkingdirectory.-PDisplaythephysicalcurrentworkingdirectory(allsymboliclinksresolved).Ifnooptionsarespecified,the-Loptionisassumed.SEEALSO#扩展阅读相关命令builtin(1),cd(1),csh(1),sh(1),getcwd(3)```###help`man`命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询，`command--help`或`command-h`，它没有`man`命令显示的那么详细，但是它更加易于阅读。#Linux进阶##文本操作###grep全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。####基础语法```bashgreptextfile#text代表要搜索的文本，file代表供搜索的文件#实例[root@lion~]#greppath/etc/profilepathmunge(){pathmunge/usr/sbinpathmunge/usr/local/sbinpathmunge/usr/local/sbinafterpathmunge/usr/sbinafterunset-fpathmunge```####常用参数-`-i`忽略大小写，`grep-ipath/etc/profile`-`-n`显示行号，`grep-npath/etc/profile`-`-v`只显示搜索文本不在的那些行，`grep-vpath/etc/profile`-`-r`递归查找，`grep-rhello/etc`，Linux中还有一个rgrep命令，作用相当于`grep-r`####高级用法`grep`可以配合正则表达式使用。```bashgrep-Epath/etc/profile-->完全匹配pathgrep-E^path/etc/profile-->匹配path开头的字符串grep-E[Pp]ath/etc/profile-->匹配path或Path```###sort对文件的行进行排序。####基础语法```bashsortname.txt#对name.txt文件进行排序```####实例用法为了演示方便，我们首先创建一个文件`name.txt`，放入以下内容：```bashChristopherShawnTedRockNoahZacharyBella```执行`sortname.txt`命令，会对文本内容进行排序。####常用参数-`-o`将排序后的文件写入新文件，`sort-oname_sorted.txtname.txt`；-`-r`倒序排序，`sort-rname.txt`；-`-R`随机排序，`sort-Rname.txt`；-`-n`对数字进行排序，默认是把数字识别成字符串的，因此138会排在25前面，如果添加了`-n`数字排序的话，则25会在138前面。###wc`wordcount`的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。####基础语法```bashwcname.txt#统计name.txt```####实例用法```bash[root@lion~]#wcname.txt131391name.txt```-第一个13，表示行数；-第二个13，表示单词数；-第三个91，表示字节数。####常用参数-`-l`只统计行数，`wc-lname.txt`；-`-w`只统计单词数，`wc-wname.txt`；-`-c`只统计字节数，`wc-cname.txt`；-`-m`只统计字符数，`wc-mname.txt`。###uniq删除文件中的重复内容。####基础语法```bashuniqname.txt#去除name.txt重复的行数，并打印到屏幕上uniqname.txtuniq_name.txt#把去除重复后的文件保存为uniq_name.txt```【注意】它只能去除连续重复的行数。####常用参数-`-c`统计重复行数，`uniq-cname.txt`；-`-d`只显示重复的行数，`uniq-dname.txt`。###cut剪切文件的一部分内容。####基础语法```bashcut-c2-4name.txt#剪切每一行第二到第四个字符```####常用参数-`-d`用于指定用什么分隔符（比如逗号、分号、双引号等等）`cut-d,name.txt`；-`-f`表示剪切下用分隔符分割的哪一块或哪几块区域，`cut-d,-f1name.txt`。##重定向管道流在`Linux`中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。![未命名文件(4).png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是`stdin`、`stdout`以及`stderr`。-标准输入`stdin`，终端接收键盘输入的命令，会产生两种输出；-标准输出`stdout`，终端输出的信息（不包含错误信息）；-标准错误输出`stderr`，终端输出的错误信息。![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)###重定向把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。####输出重定向`>``>`表示重定向到新的文件，`cut-d,-f1notes.csv>name.csv`，它表示通过逗号剪切`notes.csv`文件（剪切完有3个部分）获取第一个部分，重定向到`name.csv`文件。我们来看一个具体示例，学习它的使用，假设我们有一个文件`notes.csv`，文件内容如下：```javascriptMark1,951/100,很不错1Mark2,952/100,很不错2Mark3,953/100,很不错3Mark4,954/100,很不错4Mark5,955/100,很不错5Mark6,956/100,很不错6```执行命令：`cut-d,-f1notes.csv>name.csv`最后输出如下内容：```javascriptMark1Mark2Mark3Mark4Mark5Mark6```【注意】使用`>`要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。####输出重定向`>>`表示重定向到文件末尾，因此它不会像`>`命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。再次执行`cut-d,-f1notes.csv>>name.csv`，则会把名字追加到`name.csv`里面。```javascriptMark1Mark2Mark3Mark4Mark5Mark6Mark1Mark2Mark3Mark4Mark5Mark6```我们平时读的`log`日志文件其实都是用这个命令输出的。####输出重定向`2>`标准错误输出```javascriptcatnot_exist_file.csv>res.txt2>errors.log```-当我们`cat`一个文件时，会把文件内容打印到屏幕上，这个是标准输出；-当使用了`>res.txt`时，则不会打印到屏幕，会把标准输出写入文件`res.txt`文件中；-`2>errors.log`当发生错误时会写入`errors.log`文件中。####输出重定向`2>>`标准错误输出（追加到文件末尾）同`>>`相似。####输出重定向`2>&1`标准输出和标准错误输出都重定向都一个地方```javascriptcatnot_exist_file.csv>res.txt2>&1#覆盖输出catnot_exist_file.csv>>res.txt2>&1#追加输出```目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。![未命名文件(2).png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)####输入重定向`<``<`符号用于指定命令的输入。```javascriptcat<name.csv#指定命令的输入为name.csv```虽然它的运行结果与`catname.csv`一样，但是它们的原理却完全不同。-`catname.csv`表示`cat`命令接收的输入是`notes.csv`文件名，那么要先打开这个文件，然后打印出文件内容。-`cat<name.csv`表示`cat`命令接收的输入直接是`notes.csv`这个文件的内容，`cat`命令只负责将其内容打印，打开文件并将文件内容传递给`cat`命令的工作则交给终端完成。####输入重定向`<<`将键盘的输入重定向为某个命令的输入。```javascriptsort-n<<END#输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）wc-m<<END#统计输入的单词```###管道`|`把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是`pipeline`，可以想象一个个水管连接起来，管道算是重定向流的一种。![未命名文件(1).png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)举几个实际用法案例：```javascriptcut-d,-f1name.csv|sort>sorted_name.txt#第一步获取到的name列表，通过管道符再进行排序，最后输出到sorted_name.txtdu|sort-nr|head#du表示列举目录大小信息#sort进行排序,-n表示按数字排序，-r表示倒序#head前10行文件greplog-Ir/var/log|cut-d:-f1|sort|uniq#greplog-Ir/var/log表示在log文件夹下搜索/var/log文本，-r表示递归，-I用于排除二进制文件#cut-d:-f1表示通过冒号进行剪切，获取剪切的第一部分#sort进行排序#uniq进行去重```###流流并非一个命令，在计算机科学中，流`stream`的含义是比较难理解的，记住一点即可：**流就是读一点数据,处理一点点数据。其中数据一般就是二进制格式。**上面提及的重定向或管道，就是把数据当做流去运转的。到此我们就接触了，流、重定向、管道等`Linux`高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。`Angular`中的模板语法中可以使用管道。`Node.js`中也有`stream`流的概念。##查看进程在`Windows`中通过`Ctrl+Alt+Delete`快捷键查看软件进程。###w帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。```javascript[root@lion~]#w06:31:53up25days,9:53,1user,loadaverage:0.00,0.01,0.05USERTTYFROMLOGIN@IDLEJCPUPCPUWHATrootpts/0118.31.243.5305:561.00s0.02s0.00sw06:31:53：表示当前时间up25days,9:53：表示系统已经正常运行了“25天9小时53分钟”1user：表示一个用户loadaverage:0.00,0.01,0.05：表示系统的负载，3个值分别表示“1分钟的平均负载”，“5分钟的平均负载”，“15分钟的平均负载”USER：表示登录的用于TTY：登录的终端名称为pts/0FROM：连接到服务器的ip地址LOGIN@：登录时间IDLE：用户有多久没有活跃了JCPU：该终端所有相关的进程使用的CPU时间，每当进程结束就停止计时，开始新的进程则会重新计时PCPU：表示CPU执行当前程序所消耗的时间，当前进程就是在WHAT列里显示的程序WHAT：表示当下用户正运行的程序是什么，这里我运行的是w```###ps用于显示当前系统中的进程，`ps`命令显示的进程列表不会随时间而更新，是静态的，是运行`ps`命令那个时刻的状态或者说是一个进程快照。####基础语法```javascript[root@lion~]#psPIDTTYTIMECMD1793pts/000:00:00bash4756pts/000:00:00psPID：进程号，每个进程都有唯一的进程号TTY：进程运行所在的终端TIME：进程运行时间CMD：产生这个进程的程序名，如果在进程列表中看到有好几行都是同样的程序名，那么就是同样的程序产生了不止一个进程```####常用参数-`-ef`列出所有进程;-`-efH`以乔木状列举出所有进程;-`-u`列出此用户运行的进程;-`-aux`通过`CPU`和内存使用来过滤进程`ps-aux|less`;-`-aux--sort-pcpu`按`CPU`使用降序排列，`-aux--sort-pmem`表示按内存使用降序排列;-`-axjf`以树形结构显示进程，`ps-axjf`它和`pstree`效果类似。###top获取进程的动态列表。```javascripttop-07:20:07up25days,10:41,1user,loadaverage:0.30,0.10,0.07Tasks:67total,1running,66sleeping,0stopped,0zombie%Cpu(s):0.7us,0.3sy,0.0ni,99.0id,0.0wa,0.0hi,0.0si,0.0stKiBMem:1882072total,552148free,101048used,1228876buff/cacheKiBSwap:0total,0free,0used.1594080availMemPIDUSERPRNIVIRTRESSHRS%CPU%MEMTIME+COMMAND956root10-101339641584810240S0.70.8263:13.01AliYunDun1root2005164436642400S0.00.23:23.63systemd2root200000S0.00.00:00.05kthreadd4root0-20000S0.00.00:00.00kworker/0:0H```-`top-07:20:07up25days,10:41,1user,loadaverage:0.30,0.10,0.07`相当`w`命令的第一行的信息。-展示的这些进程是按照使用处理器`%CPU`的使用率来排序的。###kill结束一个进程，`kill+PID`。```javascriptkill956#结束进程号为956的进程kill956957#结束多个进程kill-97291#强制结束进程```##管理进程###进程状态主要是切换进程的状态。我们先了解下`Linux`下进程的五种状态：1.状态码`R`：表示正在运行的状态；2.状态码`S`：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；3.状态码`D`：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；4.状态码`Z`：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用`wait4()`系统函数后将进程释放）；5.状态码`T`：表示停止（进程收到`SIGSTOP`、`SIGSTP`、`SIGTIN`、`SIGTOU`等停止信号后停止运行）。###前台进程&后台进程默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行`top`命令，这就是一个一直运行的前台进程。后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加`&`符号，就表示启动一个后台进程。###&启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。```javascriptcpname.csvname-copy.csv&```###nohup使进程不受挂断（关闭终端等动作）的影响。```javascriptnohupcpname.csvname-copy.csv````nohup`命令也可以和`&`结合使用。```javascriptnohupcpname.csvname-copy.csv&```###bg使一个“后台暂停运行”的进程，状态改为“后台运行”。```javascriptbg%1#不加任何参数的情况下，bg命令会默认作用于最近的一个后台进程，如果添加参数则会作用于指定标号的进程```实际案例1：```javascript1.执行grep-r\"log\"/>grep_log2>&1命令启动一个前台进程，并且忘记添加&符号2.ctrl+z使进程状态转为后台暂停3.执行bg将命令转为后台运行```实际案例2：```javascript前端开发时我们经常会执行yarnstart启动项目此时我们执行ctrl+z先使其暂停然后执行bg使其转为后台运行这样当前终端就空闲出来可以干其它事情了，如果想要唤醒它就使用fg命令即可（后面会讲）```###jobs显示当前终端后台进程状态。```javascript[root@lion~]#jobs[1]+Stoppedtop[2]-Runninggrep--color=auto-r\"log\"/>grep_log2>&1&```###fg`fg`使进程转为前台运行，用法和`bg`命令类似。我们用一张图来表示前后台进程切换：![image.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。##守护进程一个运行起来的程序被称为进程。在`Linux`中有些进程是特殊的，它不与任何进程关联，不论用户的身份如何，都在后台运行，这些进程的父进程是`PID`为1的进程，`PID`为1的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作。我们将这类进程称之为守护进程`daemon`。守护进程的名字通常会在最后有一个`d`，表示`daemon`守护的意思，例如`systemd`、`httpd`。###systemd`systemd`是一个`Linux`系统基础组件的集合，提供了一个系统和服务管理器，运行为`PID1`并负责启动其它程序。```javascript[root@lion~]#ps-auxUSERPID%CPU%MEMVSZRSSTTYSTATSTARTTIMECOMMANDroot10.00.2516483852?SsFeb011:50/usr/lib/systemd/systemd--switched-root--system--deserialize22```通过命令也可以看到`PID`为1的进程就是`systemd`的系统进程。`systemd`常用命令（它是一组命令的集合）：```javascriptsystemctlstartnginx#启动服务systemctlstopnginx#停止服务systemctlrestartnginx#重启服务systemctlstatusnginx#查看服务状态systemctlreloadnginx#重载配置文件(不停止服务的情况)systemctlenablenginx#开机自动启动服务systemctldisablenginx#开机不自动启动服务systemctlis-enablednginx#查看服务是否开机自动启动systemctllist-unit-files--type=service#查看各个级别下服务的启动和禁用情况```##文件压缩解压-打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。-压缩：是将一个大文件（通常指归档）压缩变成一个小文件。我们常常使用`tar`将多个文件归档为一个总的文件，称为`archive`。然后用`gzip`或`bzip2`命令将`archive`压缩为更小的文件。![未命名文件.png](data:image/svg+xml;utf8,<?xmlversion=\"1.0\"?><svgxmlns=\"http://www.w3.org/2000/svg\"version=\"1.1\"width=\"800\"height=\"600\"></svg>)###tar创建一个`tar`归档。####基础用法```javascripttar-cvfsort.tarsort/#将sort文件夹归档为sort.tartar-cvfarchive.tarfile1file2file3#将file1file2file3归档为archive.tar```####常用参数-`-cvf`表示`create`（创建）+`verbose`（细节）+`file`（文件），创建归档文件并显示操作细节；-`-tf`显示归档里的内容，并不解开归档；-`-rvf`追加文件到归档，`tar-rvfarchive.tarfile.txt`；-`-xvf`解开归档，`tar-xvfarchive.tar`。###gzip/gunzip“压缩/解压”归档，默认用`gzip`命令，压缩后的文件后缀名为`.tar.gz`。```javascriptgziparchive.tar#压缩gunziparchive.tar.gz#解压```###tar归档+压缩可以用`tar`命令同时完成归档和压缩的操作，就是给`tar`命令多加一个选项参数，使之完成归档操作后，还是调用`gzip`或`bzip2`命令来完成压缩操作。```javascripttar-zcvfarchive.tar.gzarchive/#将archive文件夹归档并压缩tar-zxvfarchive.tar.gz#将archive.tar.gz归档压缩文件解压```###zcat、zless、zmore之前讲过使用`catlessmore`可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用`zcat、zless、zmore`进行查看。```javascriptzcatarchive.tar.gz```###zip/unzip“压缩/解压”`zip`文件（`zip`压缩文件一般来自`windows`操作系统）。####命令安装```javascript#RedHat一族中的安装方式yuminstallzipyuminstallunzip```####基础用法```javascriptunziparchive.zip#解压.zip文件unzip-larchive.zip#不解开.zip文件，只看其中内容zip-rsort.zipsort/#将sort文件夹压缩为sort.zip，其中-r表示递归```##编译安装软件之前我们学会了使用`yum`命令进行软件安装，如果碰到`yum`仓库中没有的软件，我们就需要会更高级的软件安装“源码编译安装”。###编译安装简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数`Linux`的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。基本步骤如下：1.下载源代码2.解压压缩包3.配置4.编译5.安装####实际案例#####1、下载我们来编译安装`htop`软件，首先在它的官网下载源码：[bintray.com/htop/source…](https://bintray.com/htop/source/htop#files)下载好的源码在本机电脑上使用如下命令同步到服务器上：```javascriptscp文件名用户名@服务器ip:目标路径scp~/Desktop/htop-3.0.0.tar.gzroot@121.42.11.34:.```也可以使用`wegt`进行下载：```javascriptwegt+下载地址wegthttps://bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz```#####2、解压文件```javascripttar-zxvfhtop-3.0.0.tar.gz#解压cdhtop-3.0.0#进入目录```#####3、配置执行`./configure`，它会分析你的电脑去确认编译所需的工具是否都已经安装了。#####4、编译执行`make`命令#####5、安装执行`makeinstall`命令，安装完成后执行`ls/usr/local/bin/`查看是否有`htop`命令。如果有就可以执行`htop`命令查看系统进程了。##网络###ifconfig查看`ip`网络相关信息，如果命令不存在的话，执行命令`yuminstallnet-tools`安装。```javascript[root@lion~]#ifconfigeth0:flags=4163<UP,BROADCAST,RUNNING,MULTICAST>mtu1500inet172.31.24.78netmask255.255.240.0broadcast172.31.31.255ether00:16:3e:04:9c:cdtxqueuelen1000(Ethernet)RXpackets1592318bytes183722250(175.2MiB)RXerrors0dropped0overruns0frame0TXpackets1539361bytes154044090(146.9MiB)TXerrors0dropped0overruns0carrier0collisions0lo:flags=73<UP,LOOPBACK,RUNNING>mtu65536inet127.0.0.1netmask255.0.0.0looptxqueuelen1000(LocalLoopback)RXpackets0bytes0(0.0B)RXerrors0dropped0overruns0frame0TXpackets0bytes0(0.0B)TXerrors0dropped0overruns0carrier0collisions0```参数解析：-`eth0`对应有线连接（对应你的有线网卡），就是用网线来连接的上网。`eth`是`Ethernet`的缩写，表示“以太网”。有些电脑可能同时有好几条网线连着，例如服务器，那么除了`eht0`，你还会看到`eth1`、`eth2`等。-`lo`表示本地回环（`LocalLoopback`的缩写，对应一个虚拟网卡）可以看到它的`ip`地址是`127.0.0.1`。每台电脑都应该有这个接口，因为它对应着“连向自己的链接”。这也是被称之为“本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入`127.0.0.1:3000`启动项目就能查看到自己的`web`网站，并且它只有你能看到。-`wlan0`表示无线局域网（上面案例并未展示）。###host`ip`地址和主机名的互相转换。####软件安装```javascriptyuminstallbind-utils```####基础用法```javascript[root@lion~]#hostgithub.combaidu.comhasaddress13.229.188.59[root@lion~]#host13.229.188.5959.188.229.13.in-addr.arpadomainnamepointerec2-13-229-188-59.ap-southeast-1.compute.amazonaws.com.```###ssh连接远程服务器通过非对称加密以及对称加密的方式（同`HTTPS`安全连接原理相似）连接到远端服务器。```javascriptssh用户@ip:port1、sshroot@172.20.10.1:22#端口号可以省略不写，默认是22端口2、输入连接密码后就可以操作远端服务器了```####配置ssh`config`文件可以配置`ssh`，方便批量管理多个`ssh`连接。配置文件分为以下几种：-全局`ssh`服务端的配置：`/etc/ssh/sshd_config`；-全局`ssh`客户端的配置：`/etc/ssh/ssh_config`（很少修改）；-当前用户`ssh`客户端的配置：`~/.ssh/config`。【服务端`config`文件的常用配置参数】|服务端config参数|作用||----------------------|------------------------------------------||Port|sshd服务端口号（默认是22）||PermitRootLogin|是否允许以root用户身份登录（默认是可以）||PasswordAuthentication|是否允许密码验证登录（默认是可以）||PubkeyAuthentication|是否允许公钥验证登录（默认是可以）||PermitEmptyPasswords|是否允许空密码登录（不安全，默认不可以）|[注意]修改完服务端配置文件需要重启服务`systemctlrestartsshd`【客户端`config`文件的常用配置参数】|客户端config参数|作用||------------------|------------------------||Host|别名||HostName|远程主机名（或IP地址）||Port|连接到远程主机的端口||User|用户名|配置当前用户的`config`：```javascript#创建configvim~/.ssh/config#填写一下内容Hostlion#别名HostName172.x.x.x#ip地址Port22#端口Userroot#用户```这样配置完成后，下次登录时，可以这样登录`sshlion`会自动识别为`root`用户。[注意]这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。####免密登录`ssh`登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的，今天主要学习如何基于密钥实现免密登录。#####基于密钥验证原理客户机生成密钥对（公钥和私钥），把公钥上传到服务器，每次登录会与服务器的公钥进行比较，这种验证登录的方法更加安全，也被称为“公钥验证登录”。#####具体实现步骤1、在客户机中生成密钥对（公钥和私钥）`ssh-keygen`（默认使用RSA非对称加密算法）运行完`ssh-keygen`会在`~/.ssh/`目录下，生成两个文件：-`id_rsa.pub`：公钥-`id_rsa`：私钥2、把客户机的公钥传送到服务执行`ssh-copy-idroot@172.x.x.x`（`ssh-copy-id`它会把客户机的公钥追加到服务器`~/.ssh/authorized_keys`的文件中）。执行完成后，运行`sshroot@172.x.x.x`就可以实现免密登录服务器了。配合上面设置好的别名，直接执行`sshlion`就可以登录，是不是非常方便。###wget可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。```javascriptwget[参数][URL地址]wgethttp://www.minjieren.com/wordpress-3.1-zh_CN.zip````wget`非常稳定，如果是由于网络原因下载失败，`wget`会不断尝试，直到整个文件下载完毕。####常用参数-`-c`继续中断的下载。##备份###scp它是`SecureCopy`的缩写，表示安全拷贝。`scp`可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。`scp`是基于`ssh`的原理来运作的，`ssh`会在两台通过网络连接的电脑之间创建一条安全通信的管道，`scp`就利用这条管道安全地拷贝文件。```javascriptscpsource_filedestination_file#source_file表示源文件，destination_file表示目标文件```其中`source_file`和`destination_file`都可以这样表示：`user@ip:file_name`，`user`是登录名，`ip`是域名或`ip`地址。`file_name`是文件路径。```javascriptscpfile.txtroot@192.168.1.5:/root#表示把我的电脑中当前文件夹下的file.txt文件拷贝到远程电脑scproot@192.168.1.5:/root/file.txtfile.txt#表示把远程电脑上的file.txt文件拷贝到本机```###rsync`rsync`命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于“增量备份”的命令了。它就是智能版的`scp`命令。####软件安装```javascriptyuminstallrsync```####基础用法```javascriptrsync-arvImages/backups/#将Images目录下的所有文件备份到backups目录下rsync-arvImages/root@192.x.x.x:backups/#同步到服务器的backups目录下```####常用参数-`-a`保留文件的所有信息，包括权限，修改日期等；-`-r`递归调用，表示子目录的所有文件也都包括；-`-v`冗余模式，输出详细操作信息。默认地，`rsync`在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用`rsync`同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做：`rsync-arv--deleteImages/backups/`。##系统###halt关闭系统，需要`root`身份。```javascripthalt```###reboot重启系统，需要`root`身份。```javascriptreboot```###poweroff直接运行即可关机，不需要`root`身份。","Knowledge\\产品\\运维\\nginx\\index.md":"#Nginx>-[源码](https://trac.nginx.org/nginx/browser)>-[官网](<http://www.nginx.org>>-[windows10下nginx的安装及使用](https://blog.csdn.net/sinat_36146776/article/details/88992345)##安装部署>1、下载完成后，解压缩，运行cmd，使用命令进行操作，不要直接双击nginx.exe，不要直接双击nginx.exe，不要直接双击nginx.exe>一定要在dos窗口启动，不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有!nginx进程，再启动才可以>2、使用命令到达nginx的加压缩后的目录>`cdc:\\nginx-1.15.2`>3、启动nginx服务，启动时会一闪而过是正常的>`startnginx`>4、查看任务进程是否存在，dos或打开任务管理器都行>`tasklist/fi\"imagenameeqnginx.exe\"`###启动nginx服务>版本:1.20.2>双击nginx,或者命令行输入nginx启动![](./.assets/nginx-2022-03-10-11-12-24.png)>浏览器打开![](./.assets/nginx-2022-03-10-11-12-59.png)###错误>如果都没有可能是启动报错了查看一下日志，在nginx目录中的logs文件夹下error.log是日志文件>常见错误>>-端口占用>-nginx文件夹路径含中文###修改配置![](/.assets/img/2022-01-25-15-22-37.png)####conf/nginx.conf>端口占用可修改:`8800`(或其他没有占用的)![](/.assets/img/2022-01-25-15-26-47.png)重新加载修改后配置```shellnginx-t-c/nginx/conf/nginx.conf```###重启>`nginx-sreload`###关闭nginx>快速停止`nginx-sstop`>完整有序地关闭`nginx-squit`##文件目录```js[ruihuag@localhost~]#tree/usr/local/nginx/usr/local/nginx├──client_body_temp├──conf#Nginx所有配置文件的目录│├──fastcgi.conf#fastcgi相关参数的配置文件│├──fastcgi.conf.default#fastcgi.conf的原始备份文件│├──fastcgi_params#fastcgi的参数文件│├──fastcgi_params.default│├──koi-utf│├──koi-win│├──mime.types#媒体类型│├──mime.types.default│├──nginx.conf#Nginx主配置文件│├──nginx.conf.default│├──scgi_params#scgi相关参数文件│├──scgi_params.default│├──uwsgi_params#uwsgi相关参数文件│├──uwsgi_params.default│└──win-utf├──fastcgi_temp#fastcgi临时数据目录├──html#Nginx默认站点目录│├──50x.html#错误页面优雅替代显示文件，例如当出现502错误时会调用此页面│└──index.html#默认的首页文件├──logs#Nginx日志目录│├──access.log#访问日志文件│├──error.log#错误日志文件│└──nginx.pid#pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件├──proxy_temp#临时目录├──sbin#Nginx命令目录│└──nginx#Nginx的启动命令├──scgi_temp#临时目录└──uwsgi_temp#临时目录```###配置文件>conf//nginx所有配置文件目录>nginx.conf//这个是Nginx的核心配置文件，这个文件非常重要，也是我们即将要学习的重点>nginx.conf.default//nginx.conf的备份文件###日志>logs:记录入门的文件，当nginx服务器启动后>这里面会有access.logerror.log和nginx.pid三个文件出现。###资源目录>html//存放nginx自带的两个静态的html页面>50x.html//访问失败后的失败页面>index.html//成功访问的默认首页###备份文件>fastcgi.conf:fastcgi//相关配置文件>fastcgi.conf.default//fastcgi.conf的备份文件>fastcgi_params//fastcgi的参数文件>fastcgi_params.default//fastcgi的参数备份文件>scgi_params//scgi的参数文件>scgi_params.default//scgi的参数备份文件>uwsgi_params//uwsgi的参数文件>uwsgi_params.default//uwsgi的参数备份文件>mime.types//记录的是HTTP协议中的Content-Type的值和文件后缀名的对应关系>mime.types.default//mime.types的备份文件###编码文件>koi-utf、koi-win、win-utf这三个文件都是与编码转换映射相关的配置文件，>用来将一种编码转换成另一种编码###执行文件>sbin:是存放执行程序文件nginx###命令>nginx:是用来控制Nginx的启动和停止等相关的命令。##配置文件###配置主要结构```shellworker_processes1；#worker进程的数量events{#事件区块开始worker_connections1024；#每个worker进程支持的最大连接数}#事件区块结束http{#HTTP区块开始includemime.types；#Nginx支持的媒体类型库文件default_typeapplication/octet-stream；#默认的媒体类型sendfileon；#开启高效传输模式keepalive_timeout65；#连接超时server{#第一个Server区块开始，表示一个独立的虚拟主机站点listen80；#提供服务的端口，默认80server_namelocalhost；#提供服务的域名主机名location/{#第一个location区块开始roothtml；#站点的根目录，相当于Nginx的安装目录indexindex.htmlindex.htm；#默认的首页文件，多个用空格分开}#第一个location区块结果error_page500502503504/50x.html；#出现对应的http状态码时，使用50x.html回应客户location=/50x.html{#location区块开始，访问50x.htmlroothtml；#指定对应的站点目录为html}}......```###主配置文件>通过include引入其他(子)配置文件>>![](/.assets/img/2022-01-25-16-40-39.png)###子配置文件![](/.assets/img/2022-01-25-16-42-26.png)###location匹配```shelllocation[=|~|~*|^~]url{}```>location指令说明，该语法用来匹配url，语法如上：>=：用于不含正则表达式的url前，要求字符串与url严格匹配，匹配成功就停止向下搜索并处理请求。>~：用于表示url包含正则表达式，并且区分大小写。>~\\*：用于表示url包含正则表达式，并且不区分大小写。>^~：用于不含正则表达式的url前，要求Nginx服务器找到表示url和字符串匹配度最高的location后，立即使用此location处理请求，而不再匹配。>如果有url包含正则表达式，不需要有~开头标识。```shell#优先级1,精确匹配，根路径location=/{return400;}#优先级2,以某个字符串开头,以av开头的，优先匹配这里，区分大小写location^~/av{root/data/av/;}#优先级3，区分大小写的正则匹配，匹配/media*****路径location~/media{alias/data/static/;}#优先级4，不区分大小写的正则匹配，所有的****.jpg|gif|png都走这里location~*.*\\.(jpg|gif|png|js|css)${root/data/av/;}#优先7，通用匹配location/{return403;}```##反向代理,负载均衡###默认轮询>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。```shell#constPolling作为存放负载均衡的变量upstreamconstPolling{serverlocalhost:10001;serverlocalhost:10002;}server{listen10000;server_namelocalhost;location/{proxy_passhttp://constPolling;#在代理的时候接入constPollingproxy_redirectdefault;}}```###加权轮询>通过设置weight，值越大分配率越大到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。```shell#constPolling作为存放负载均衡的变量upstreamconstPolling{serverlocalhost:10001weight=1;serverlocalhost:10002weight=2;}server{listen10000;server_namelocalhost;location/{proxy_passhttp://constPolling;#在代理的时候接入constPollingproxy_redirectdefault;}}```>权重越大，被访问的概率越大，比如上面就是33.33%和百分66.66%的访问概率>访问的效果：>localhost:10001、localhost:10002、localhost:10002、localhost:10001、localhost:10002、localhost:10002","Knowledge\\产品\\运维\\nginx\\命令.md":"#常用命令###启动>`nginx`//直接nginx启动，前提是配好nginx环境变量>`systemctlstartnginx.service`//使用systemctl命令启动###停止>`nginx-sstop`//立即停止服务>`nginx-squit`//从容停止服务需要进程完成当前工作后再停止>`killallnginx`//直接杀死nginx进程>`systemctlstopnginx.service`//systemctl停止###重启>`nginx-sreload`//重启nginx>`systemctlreloadnginx.service`//systemctl重启nginx###验证nginx配置文件是否正确>`nginx-t`//输出nginx.confsyntaxisok即表示nginx的配置文件正确","Knowledge\\产品\\运维\\server&运维\\Docker\\index.md":"#Docker","Knowledge\\产品\\运维\\server&运维\\tomcat.md":"#Tomcat##安装><http://tomcat.apache.org/>>>下载``64-bit_Windows_zip`>>idea配置:<https://blog.csdn.net/weixin_41249041/article/details/88375420>##配置环境变量>不配置也可以使用,知识每次使用都要到bin文件夹下运行``startup.bat`>>配置Tomcat环境变量>>1，新建变量名：CATALINA_BASE，变量值：E:\\Develop\\apache-tomcat-7.0.93>>2，新建变量名：CATALINA_HOME，变量值：E:\\Develop\\apache-tomcat-7.0.93>>3，打开PATH，添加变量值：%CATALINA_HOME%\\lib%CATALINA_HOME%\\bin>>到tomcat的bin目录测试是否可以访问。##常识补充>文件目录:>>-bin:命令文件,开启和关闭>-conf:tomcat的配置文件>-lib:tomcat所需的依赖库(jar包)>-logs:日志文件>-temp:运行产生的临时文件>-webapps:需要发布的项目都会放在这个目录里面","Knowledge\\产品\\运维\\宝塔面板.md":"#运维工具>[宝塔面板-简单好用的Linux/Windows服务器运维管理面板(bt.cn)](https://www.bt.cn/?btwaf=75316336)","Knowledge\\产品\\运维\\部署.md":"#部署##相关概念###CI的含义>CI的意思是持续构建>负责拉取代码库中的代码后，执行用户预置定义好的操作脚本，通过一系列编译操作构建出一个制品，并将制品推送至到制品库里面。常用工具有GitlabCI，GithubCI，Jenkins等。这个环节不参与部署，只负责构建代码，然后保存构建物。构建物被称为制品，保存制品的地方被称为制品库###CD的含义>CD则有2层含义：持续部署（ContinuousDeployment）和持续交付（ContinuousDelivery）。>持续交付的概念是：将制品库的制品拿出后，部署在测试环境/交付给客户提前测试。持续部署则是将制品部署在生产环境。","Knowledge\\前置知识\\图片.md":"#图片##图片的格式###jpg格式使用的是一种失真压缩标准格式，24bit色彩，不支持动画，不支持透明色-jpeg的格式的压缩方式是破坏性资料性的压缩。即图片在经过压缩的过程中会遭到可见的破坏，一张图片经过多次的上传和下载，图片会逐渐失真。优势：1.支持摄影图像和写实图像的高级压缩，并且可以利用压缩比例来控制文件的大小。2.占用的存储较少劣势：```tex1.有损的压缩会导致图片数据的质量下降。2.在编辑和重新保存的时候，失真的效果会积累。3.不适合所含颜色较少的，颜色差异较少的图片。```###png格式是一种可移植网络格式，使用的是无损数据格式。优势：1.可以在保证不失真的情况，尽可能的压缩图片的大小。2.可以存储灰度图像，可以设置透明色劣势：压缩方式是无损压缩，但是图片文件较大，不适合运用在web应用上。**总的来说，PNG不适合任何地方，因为这个格式是的图片文件会较大。而JPG就可以使用大部分场景。**###webp格式一种加快图片的加载速度的图片，压缩图片的体积大约为jpeg的三分之二，并能解决服务器的服务器宽带资源和数据空间。","Knowledge\\天干地支计算年月日时.md":"#天干地支计算年月日时<https://blog.csdn.net/qq_33538651/article/details/114053664>","Knowledge\\数据结构\\哈希表\\哈希表.md":"#哈希表##散列表>散列表使用某种算法操作(散列函数)将键转化为数组的索引来访问数组中的数据，这样可以通过Key-value的方式来访问数据，达到常数级别的存取效率。现在的nosql数据库都是采用key-value的方式来访问存储数据。散列表是算法在时间和空间上做出权衡的经典例子。通过一个散列函数，将键值key映射到记录的访问地址，达到快速查找的目的。如果没有内存限制，我们可以直接将键作为数组的索引，所有的操作操作只需要一次访问内存就可以完成。但这种情况不太现实。###散列函数散列函数就是将键转化为数组索引的过程。且这个函数应该易于计算且能够均与分布所有的键。散列函数最常用的方法是`除留余数法`。这时候被除数应该选用`素数`，这样才能保证键值的均匀散步。散列函数和键的类型有关，每种数据类型都需要相应的散列函数；比如键的类型是整数，那我们可以直接使用`除留余数法`；这里特别说明下，大多数情况下，键的类型都是字符串，这个时候我们任然可以使用`除留余数法`，将字符串当做一个特别大的整数。```cinthash=0;for(inti=0;i<s.length();i++){hash=(R*hash+s.charAt(i)%M);}```还有，比如下面的：```cHashhashCode(char*key){intoffset=5;HashhashCode=0;while(*key){hashCode=(hashCode<<offset)+*key++;}returnhashCode;}```使用时`hashCode(key)&(size-1)`就可以得到一个`size-1`范围内的hash值当然，还有其他的散列函数，如`平方取中法`,`随机数法`等。###碰撞解决不同的关键字得到同一个散列地址`f(key1)=f(key2)`，即为碰撞。这是我们需要尽量避免的情况。常见的处理方法有：1.拉链法2.线性探测法####拉链法将大小为M的数组中的每个元素指向一条链表，链表中的每个节点都存储了散列值为该元素索引的键值对。每条链表的平均长度是N/M，N是键值对的总个数。添加操作：1.通过hash函数得到hashCode2.通过hashcode得到index3.如果index处没有链表，建立好新结点，作为新链表的首结点4.如果index处已经有链表，先要遍历看key是否已经存在，如果存在直接返回，如果不存在，加入链表头部删除操作：1.通过hash函数得到hashCode2.通过hashcode得到index3.遍历链表，删除结点####线性探测法使用大小为M的数组保存N个键值对，当碰撞发生时，直接检查散列表中的下一个位置。###数据结构和算法这里给出拉链法构造的hashmap的算法，表示如下：```ctypedefchar*Key;typedefintvalue;typedefunsignedintHash;/*每个节点表示*/typedefstructEntry{Hashhash;Keykey;Valuevalue;Entry*next;}Entry;typedefstructHashMap{Entry**heads;unsignedintsize;/*数组大小*/unsignedintusage;/*键值对的个数*/}HashMap;HashhashCode(Key);HashMap*create(unsignedintsize);HashMap*put(HashMap*,Key,Value);intget(HashMap*,Key);HashMap*_putInHead(HashMap*,intindex,Key,Value);HashMap*_putInList(HashMap*,intindex,Key,Value);HashhashCode(char*key){intoffset=5;HashhashCode=0;while(*key){hashCode=(hashCode<<offset)+*key++;}returnhashCode;}HashMap*create(unsignedintsize){HashMap*hashMap=malloc(sizeof(HashMap));hashMap->size=size;hashMap->usage=0;hashMap->heads=calloc(size,sizeof(Entry*));returnhashMap;}HashMap*put(HashMap*hashMap,Keykey,Valuevalue){if(key==NULL){returnhashMap;}Hashhash=hashCode(key);intindex=hash&(size-1);/**/if(hashMap->heads[index]==NULL){_putInHead(hashMap,index,key,value);}else{_putInList(hashMap,index,key,value);}}Valueget(HashMaphashMap*,Keykey){if(key==NULL){returnhashMap;}Hashhash=hashCode(key);intindex=hash&(size-1);/**/Entry*entry=hashMap->heads[index];while(entry!=NULL){if(entry->hash==hash){returnentry->value;}entry=entry->next;}returnNULL;}HashMap*_putInHead(HashMap*hashMap,intindex,Keykey,Valuevalue){Entry*newHead=malloc(sizeof(Entry));newHead->hash=hash;newHead->key=key;newHead->value=value;hashMap->heads[index]=newHead;(hashMap->usage)++;returnhashMap;}HashMap*_putInList(HashMap*hashMap,intindex,Keykey,Valuevalue){Entry*lastEntry=hashMap->heads[index];while(lastEntry!=NULL){if(lastEntry->hash==hash){returnhashMap;}else{lastEntry=lastEntry->next;}}lastEntry=malloc(sizeof(Entry));lastEntry->hash=hash;lastEntry->key=key;lastEntry->value=value;lastEntry->next=hashMap->heads[index];hashMap->heads[index]=lastEntry;(hashMap->usage)++;returnhashMap;}```","Knowledge\\数据结构\\图\\无向图.md":"","Knowledge\\数据结构\\图\\有向图.md":"","Knowledge\\数据结构\\堆\\堆.md":"#堆(数据结构)在计算机科学中,一个堆(heap)是一种特殊的基于树的数据结构，它满足下面描述的堆属性。##最小堆>在一个最小堆(minheap)中,如果P是C的一个父级节点,那么P的key(或value)应小于或等于C的对应值.![](/.assets/img/2022-02-08-14-18-37.png)##最大堆>在一个最大堆(maxheap)中,P的key(或value)大于C的对应值。![](/.assets/img/2022-02-08-14-27-41.png)在堆“顶部”的没有父级节点的节点,被称之为根节点。","Knowledge\\数据结构\\树\\AVL树.md":"","Knowledge\\数据结构\\树\\二叉树.md":"#二叉树特点：每个节点最多有两个子树的树结构classNodeTree{constructor(key){this.key=key;this.left=null;this.right=null;}}```jsclassBinarySearchTree{constructor(){this.root=null}insert(key){constnewNode=newNodeTree(key)constinsertNode=(node,newNode)=>{if(newNode.key<node.key){if(node.left===null){node.left=newNode}else{insertNode(node.left,newNode)}}else{if(node.right===null){node.right=newNode}else{insertNode(node.right,newNode)}}}if(!this.root){this.root=newNode}else{insertNode(this.root,newNode)}}//访问树节点的三种方式:中序,先序,后序inOrderTraverse(callback){constinOrderTraverseNode=(node,callback)=>{if(node!==null){inOrderTraverseNode(node.left,callback)callback(node.key)inOrderTraverseNode(node.right,callback)}}inOrderTraverseNode(this.root,callback)}min(node){constminNode=(node)=>{returnnode?(node.left?minNode(node.left):node):null}returnminNode(node||this.root)}max(node){constmaxNode=(node)=>{returnnode?(node.right?maxNode(node.right):node):null}returnmaxNode(node||this.root)}}consttree=newBinarySearchTree()tree.insert(11)tree.insert(7)tree.insert(5)tree.insert(3)tree.insert(9)tree.insert(8)tree.insert(10)tree.insert(13)tree.insert(12)tree.insert(14)tree.inOrderTraverse((value)=>{console.log(value)})console.log(tree.min())console.log(tree.max())```","Knowledge\\数据结构\\树\\字典树.md":"#字典树>-在计算机科学中,字典树(trie,中文又被称为”单词查找树“或”键树“),也称为数字树,有时候也被称为基数树或前缀树（因为它们可以通过前缀搜索）,它是一种搜索树--一种已排序的数据结构,通常用于存储动态集或键为字符串的关联数组。>-与二叉搜索树不同,树上没有节点存储与该节点关联的键;相反,节点在树上的位置定义了与之关联的键。一个节点的全部后代节点都有一个与该节点关联的通用的字符串前缀,与根节点关联的是空字符串。>-值对于字典树中关联的节点来说,不是必需的,相反,值往往和相关的叶子相关,以及与一些键相关的内部节点相关。>-有关字典树的空间优化示意,请参阅紧凑前缀树![](./.assets/字典树-2022-04-04-16-05-26.png)","Knowledge\\数据结构\\树\\树.md":"#树##二叉树>每个节点最多只有两个节点的结构,通常左边的叫左子树,右边的叫右子树,二叉树的节点是具有左右次序的，不能随意颠倒。###二叉树分类####完全二叉树>假设其深度为d（d>1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。>>-简单说:到第d层,从左到右要排满<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/223634_36755f03_7984151.png\"style=\"zoom:50%;\"/>####满二叉树>每层都是满节点<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/224205_ff93d738_7984151.png\"style=\"zoom:50%;\"/>####斜树>只有左子树,或只有右子树>>看起来就只有一撇或一捺<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/224549_f78a9184_7984151.png\"style=\"zoom:50%;\"/>####二叉搜索树(二叉查找树,二叉排序树)>-若它的左子树不为空，则左子树上所有节点的值均<它的根节点的值；>-若它的右子树不为空，则右子树上所有节点的值均>它的根节点的值；>-它的左、右子树也分别是二叉排序树。说明它是一颗有顺序的树，左子树节点的值小于根节点的值，右子树节点的值大于根节点的值。>-简说:**左子节点<根节点<右子节点**<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/225440_9f5be847_7984151.png\"style=\"zoom:67%;\"/>####平衡二叉树>它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/230031_5da6fcec_7984151.png\"style=\"zoom:67%;\"/>###二叉树存储<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/230508_b0b37f01_7984151.png\"style=\"zoom:67%;\"/>####顺序存储<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/230732_cd0e70da_7984151.png\"style=\"zoom:80%;\"/>>某个节点的索引为i,(假设根节点的索引为0)>>-左子节点:**2i+1**>-右子节点:**2i+2**####链式存储>也叫二叉链表<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/230759_e2103099_7984151.png\"style=\"zoom:80%;\"/>###遍历<imgsrc=\"https://images.gitee.com/uploads/images/2020/1112/230031_5da6fcec_7984151.png\"style=\"zoom:67%;\"/>>前序遍历:根左右ECBADGFH>>中序遍历:左根右ABCDEFGH>>后序遍历:左右根ABDCFHGE>>层序遍历:一层一层从上到下从左到右ECGBDFHA。##多叉树>允许每个节点可以有更多的数据项和更多的子节点###2-3树![](https://images.gitee.com/uploads/images/2020/1112/234702_1e302df9_7984151.png)![](https://images.gitee.com/uploads/images/2020/1112/234924_d9676727_7984151.png)>-2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)>-有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.>-有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.>-2-3树是由二节点和三节点构成的树>-当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。>-对于三节点的子树的值大小仍然遵守(BST二叉排序树)的规则###红黑树>1.满足二分搜索树的基本性质>2.每个节点要么是红色的，要么是黑色的>3.根节点是黑色的>4.每一个叶子节点（最后的空节点）是黑色的>5.如果一个节点是红色的，那么它的孩子节点都是黑色的>6.**从任意一个节点到叶子节点，经过的黑色节点是一样的**![](https://images.gitee.com/uploads/images/2020/1113/000043_efea1c5a_7984151.png)![](https://images.gitee.com/uploads/images/2020/1112/235736_91073dd2_7984151.png)![](https://images.gitee.com/uploads/images/2020/1113/000158_9e0e26d4_7984151.png)>**红黑树模拟于2-3树也等价于2-3树。**>>**红黑树的左右旋转等价于2-3树的裂变节点操作；**>>**红黑树的颜色翻转等价于2-3树的融合节点操作；**>>**不同点在于红黑树的左右旋转会可以降低子树的高度，而2-3树的裂变节点操作会增加子树的高度；**>>**红黑树的颜色翻转操作不会改变子树的高度，是一个抽象的融合操作，而2-3树的融合操作可以降低子树高度。**>>**最终红黑树也会趋于平衡，而2-3会保持绝对平衡。**###B树![](https://images.gitee.com/uploads/images/2020/1113/002601_d114c414_7984151.png)>-B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4>-B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询>-关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点>-关键字集合分布在整颗树中,即叶子节点和非叶子节点都存放数据.>-搜索有可能在非叶子结点结束>-其搜索性能等价于在关键字全集内做一次二分查找```js//创建树functiontree(obj){varobj=obj.split(')')obj.pop()varnewobj=[]for(vari=0;i<obj.length;i++){newobj.push(obj[i].replace('(',''))}varroot={value:null,left:null,right:null,have:0,}varufor(vari=0;i<newobj.length;i++){vara1=newobj[i].split(',')[0]vara2=newobj[i].split(',')[1]u=rootif(a2!==''){for(varj=0;j<a2.length;j++){if(a2[j]==='L'){if(u.left===null){u.left=newnode()u=u.left}else{u=u.left}}elseif(a2[j]==='R'){if(u.right===null){u.right=newnode()u=u.right}else{u=u.right}}}if(u.have===1){}else{u.value=a1u.have=1}}else{root.value=a1u.have=1}}returnroot}//建立新的结点functionnewnode(){return{value:null,left:null,right:null,have:0,}}//队列遍历functionbfs(){varroot=tree('(11,LL)(7,LLL)(8,R)(5,)(4,L)(13,RL)(2,LLR)(1,RRR)(4,RR)')varfront=0,rear=1,n=0varq=[],ans=[]q[0]=rootwhile(front<rear){varu=q[front++]if(u.have!==1){return}ans[n++]=u.valueif(u.left!==null){q[rear++]=u.left}if(u.right!==null){q[rear++]=u.right}}console.log(ans.join(''))}bfs()```###B+树>B树的变体,是一种多路搜索树**<imgsrc=\"https://images.gitee.com/uploads/images/2020/1113/002851_a85fd413_7984151.png\"style=\"zoom:150%;\"/>**>-B+树的搜索与B树也基本相同，区别是**B+树只有达到叶子结点才命中**（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找>-所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。>-不可能在非叶子结点命中>-非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层>更适合文件索引系统###B\\*树>B\\*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针![](https://images.gitee.com/uploads/images/2020/1113/003238_4058924d_7984151.png)>-B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。>-从第1个特点我们可以看出，B\\*树分配新结点的概率比B+树要低，空间使用率更高###B+树和B树的区别>以一个m阶树为例。>>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。>>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。>>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。>>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。##前中后层序遍历```js//先建立一棵树functionnode(obj){varnewobj={}if(obj.length==1){newobj.value=obj[0]}elseif(obj.length==0){newobj.value==null}else{newobj.left=node(obj[0])newobj.value=obj[1]newobj.right=node(obj[2])}returnnewobj}varroot=node([[[[7],11,[2]],4,[]],5,[[13],8,[[],4,[1]]]])//中序遍历functiongoTree1(tree){if(tree.hasOwnProperty('left')){goTree1(tree.left)console.log(tree.value)goTree1(tree.right)}else{tree.value==null?console.log(''):console.log(tree.value)}}//前序遍历functiongoTree2(tree){tree.value==null?console.log(''):console.log(tree.value)if(tree.hasOwnProperty('left')){goTree2(tree.left)goTree2(tree.right)}}//后序遍历functiongoTree3(tree){if(tree.hasOwnProperty('left')){goTree3(tree.left)goTree3(tree.right)console.log(tree.value)}else{tree.value==null?console.log(''):console.log(tree.value)}}//层序遍历//层序遍历需要使用队列的数据结构，这里可以用数组来替代//这里不能使用迭代functiongoTree4(tree){letdeque=[]deque.push(root)while(deque.length!=0){front=deque.shift()if(front.hasOwnProperty('left')){deque.push(front.left)deque.push(front.right)}front.value==null?console.log(''):console.log(front.value)}}```##红黑树>1.满足二分搜索树的基本性质>2.每个节点要么是红色的，要么是黑色的>3.根节点是黑色的>4.每一个叶子节点（最后的空节点）是黑色的>5.如果一个节点是红色的，那么它的孩子节点都是黑色的>6.**从任意一个节点到叶子节点，经过的黑色节点是一样的**","Knowledge\\数据结构\\树\\树状数组.md":"","Knowledge\\数据结构\\树\\红黑树.md":"","Knowledge\\数据结构\\树\\线段树.md":"","Knowledge\\数据结构\\特殊\\字典.md":"#字典字典：类似对象，以key，value存贮值```jsclassDictionary{constructor(){this.items={}}set(key,value){this.items[key]=value}get(key){returnthis.items[key]}remove(key){deletethis.items[key]}getkeys(){returnObject.keys(this.items)}getvalues(){/*也可以使用ES7中的values方法returnObject.values(this.items)*///在这里我们通过循环生成一个数组并输出returnObject.keys(this.items).reduce((r,c,i)=>{r.push(this.items[c])returnr},[])}}constdictionary=newDictionary()dictionary.set('Gandalf','gandalf@email.com')dictionary.set('John','johnsnow@email.com')dictionary.set('Tyrion','tyrion@email.com')console.log(dictionary)console.log(dictionary.keys)console.log(dictionary.values)console.log(dictionary.items)```","Knowledge\\数据结构\\特殊\\栈.md":"#栈栈的特点：先进后出```jsclassStack{constructor(){this.items=[]}//入栈push(element){this.items.push(element)}//出栈pop(){returnthis.items.pop()}//末位getpeek(){returnthis.items[this.items.length-1]}//是否为空栈getisEmpty(){return!this.items.length}//长度getsize(){returnthis.items.length}//清空栈clear(){this.items=[]}}//实例化一个栈conststack=newStack()console.log(stack.isEmpty)//true//添加元素stack.push(5)stack.push(8)//读取属性再添加console.log(stack.peek)//8stack.push(11)console.log(stack.size)//3console.log(stack.isEmpty)//false```","Knowledge\\数据结构\\特殊\\队列.md":"#队列队列：先进先出classQueue{constructor(items){this.items=items||[];}```jsenqueue(element){this.items.push(element);}dequeue(){returnthis.items.shift();}front(){returnthis.items[0];}clear(){this.items=[];}getsize(){returnthis.items.length;}getisEmpty(){return!this.items.length;}print(){console.log(this.items.toString());}}constqueue=newQueue();console.log(queue.isEmpty);//truequeue.enqueue(\"John\");queue.enqueue(\"Jack\");queue.enqueue(\"Camila\");console.log(queue.size);//3console.log(queue.isEmpty);//falsequeue.dequeue();queue.dequeue();```","Knowledge\\数据结构\\链表\\链表.md":"#链表>Linked-list##单向链表###简单链表![linkedList](.assets/linkedList.png)>指定第一个节点为头节点![img](https://upload-images.jianshu.io/upload_images/6633377-5c1f96efff0c90ee.png?imageMogr2/auto-orient/strip|imageView2/2/w/773/format/webp)###插入节点![img](https://upload-images.jianshu.io/upload_images/6633377-a75cba57042a50f3.png?imageMogr2/auto-orient/strip|imageView2/2/w/766/format/webp)###删除节点![img](https://upload-images.jianshu.io/upload_images/6633377-aa4650d34f9a0ca4.png?imageMogr2/auto-orient/strip|imageView2/2/w/937/format/webp)###代码实现```js//节点functionNode(element){this.element=element//当前节点的元素this.next=null//下一个节点链接}//链表类functionLList(){this.head=newNode('head')//头节点this.find=find//查找节点this.insert=insert//插入节点this.remove=remove//删除节点this.findPrev=findPrev//查找前一个节点this.display=display//显示链表}//查找给定节点functionfind(item){varcurrNode=this.headwhile(currNode.element!=item){currNode=currNode.next}returncurrNode}//插入节点functioninsert(newElement,item){varnewNode=newNode(newElement)varcurrNode=this.find(item)newNode.next=currNode.nextcurrNode.next=newNode}//显示链表元素functiondisplay(){varcurrNode=this.headwhile(!(currNode.next==null)){console.log(currNode.next.element)currNode=currNode.next}}//查找带删除节点的前一个节点functionfindPrev(item){varcurrNode=this.headwhile(!(currNode.next==null)&&currNode.next.element!=item){currNode=currNode.next}returncurrNode}//删除节点functionremove(item){varprevNode=this.findPrev(item)if(!(prevNode.next==null)){prevNode.next=prevNode.next.next}}varfruits=newLList()fruits.insert('Apple','head')fruits.insert('Banana','Apple')fruits.insert('Pear','Banana')console.log(fruits.display())//Apple//Banana//Pear``````jsclassNode{constructor(element){this.element=elementthis.next=null}}//链表classLinkedList{constructor(){this.head=nullthis.length=0}//追加元素append(element){constnode=newNode(element)letcurrent=nullif(this.head===null){this.head=node}else{current=this.headwhile(current.next){current=current.next}current.next=node}this.length++}//任意位置插入元素insert(position,element){if(position>=0&&position<=this.length){constnode=newNode(element)letcurrent=this.headletprevious=nullletindex=0if(position===0){this.head=nodenode.next=current}else{while(index++<position){previous=currentcurrent=current.next}node.next=currentprevious.next=node}this.length++returntrue}returnfalse}//移除指定位置元素removeAt(position){//检查越界值if(position>-1&&position<this.length){letcurrent=this.headletprevious=nullletindex=0if(position===0){this.head=current.next}else{while(index++<position){previous=currentcurrent=current.next}previous.next=current.next}this.length--returncurrent.element}returnnull}//寻找元素下标findIndex(element){letcurrent=this.headletindex=-1while(current){if(element===current.element){returnindex+1}index++current=current.next}return-1}//删除指定文档remove(element){constindex=this.findIndex(element)returnthis.removeAt(index)}isEmpty(){return!this.length}size(){returnthis.length}//转为字符串toString(){letcurrent=this.headletstring=''while(current){string+=`${current.element}`current=current.next}returnstring}}constlinkedList=newLinkedList()console.log(linkedList)linkedList.append(2)linkedList.append(6)linkedList.append(24)linkedList.append(152)linkedList.insert(3,18)console.log(linkedList)console.log(linkedList.findIndex(24))```##双向链表双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。双向链表克服了单链表中访问某个节点前驱节点(插入，删除操作时)，只能从头遍历的问题。```c/**File:doubleLinkedList.js*Project:api*Author:ruihuag*FileCreated:Thursday,5thAugust20214:19:15pm*ModifiedBy:ruihuag*LastModified:Thursday,5thAugust20214:20:48pm*///节点functionNode(element){this.element=element;//当前节点的元素this.next=null;//下一个节点链接this.previous=null;//上一个节点链接}//链表类functionLList(){this.head=newNode('head');this.find=find;this.findLast=findLast;this.insert=insert;this.remove=remove;this.display=display;this.dispReverse=dispReverse;}//查找元素functionfind(item){varcurrNode=this.head;while(currNode.element!=item){currNode=currNode.next;}returncurrNode;}//查找链表中的最后一个元素functionfindLast(){varcurrNode=this.head;while(!(currNode.next==null)){currNode=currNode.next;}returncurrNode;}//插入节点functioninsert(newElement,item){varnewNode=newNode(newElement);varcurrNode=this.find(item);newNode.next=currNode.next;newNode.previous=currNode;currNode.next=newNode;}//显示链表元素functiondisplay(){varcurrNode=this.head;while(!(currNode.next==null)){console.debug(currNode.next.element);currNode=currNode.next;}}//反向显示链表元素functiondispReverse(){varcurrNode=this.findLast();while(!(currNode.previous==null)){console.log(currNode.element);currNode=currNode.previous;}}//删除节点functionremove(item){varcurrNode=this.find(item);if(!(currNode.next==null)){currNode.previous.next=currNode.next;currNode.next.previous=currNode.previous;currNode.next=null;currNode.previous=null;}}varfruits=newLList();fruits.insert('Apple','head');fruits.insert('Banana','Apple');fruits.insert('Pear','Banana');fruits.insert('Grape','Pear');console.log(fruits.display());//Apple//Banana//Pear//Grapeconsole.log(fruits.dispReverse());//Grape//Pear//Banana//Apple```##环状链表>循环列表![loopLinkedList](../../../../../../Users/ruihuag/Pictures/loopLinkedList.png)","Knowledge\\架构&相关\\拓展\\编程规范.md":"#编程规范##编程范式>[命令式编程](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FImperative_programming)：通过语句或命令修改程序状态。（eg：JS、Java、Python）>>[函数式编程](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFunctional_programming)：函数是第一等公民，通过函数调用、组合等完成复杂操作。（eg：科里化、函数组合）>>[声明式编程](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDeclarative_programming)：描述程序逻辑而非控制流。（eg：SQL、HTML、CSS）>>[响应式编程](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FReactive_programming)：基于数据流及其变化传播的声明性编程范式。（eg：React`UI=f(state)`）","Knowledge\\架构&相关\\算法\\basis\\时间复杂度.md":"#时间复杂度##常数阶O(1)```javainti=1;intj=2;++i;j++;intm=i+j;```##线性阶O(n)```javafor(i=1;i<=n;++i){j=i;j++;}```##对数阶O(logN)```javainti=1;while(i<n){i=i*2;}```##线性对数阶O(nlogN)```javafor(m=1;m<n;m++){i=1;while(i<n){i=i*2;}}```##平方阶O(n²)```javafor(x=1;i<=n;x++){for(i=1;i<=n;i++){j=i;j++;}}//O(m*n)for(x=1;i<=m;x++){for(i=1;i<=n;i++){j=i;j++;}}```##立方阶O(n³)```javafor(i=0;i<n;i++){for(j=0;j<n;j++){for(k=0;k<n;k++){...}}}```##K次方阶O(n^k)```javafunctionfn(k){if(k<=0)return;for(leti=0;i<n;i++){arr.push(i);fn(--k);}}fn(k);```##指数阶(2^n)```javafunctionfn(k){if(k<=0)return;for(leti=0;i<2;i++){arr.push(i);fn(--k);}}fn(n);```","Knowledge\\架构&相关\\算法\\basis\\空间复杂度.md":"#**空间复杂度**##O(1)>代码中的i、j、m所分配的空间都不随着处理数据量变化，因此它的空间复杂度S(n)=O(1)```jsinti=1;intj=2;++i;j++;intm=i+j;```##O(n)>第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即S(n)=O(n)```jsint[]m=newint[n]for(i=1;i<=n;++i){j=i;j++;}```","Knowledge\\架构&相关\\算法\\排序\\排序.md":"#排序算法>稳定算法/非稳定算法:相同或相等的元素不会发生位置互换为稳定算法排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai=Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。(1)冒泡排序冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。(2)选择排序选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列58529，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。(3)插入排序插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。(4)快速排序快速排序有两个方向，左边的i下标一直往右走，当a[i]<=a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j]>a[center_index]。如果i和j都走不动了，i<=j，交换a[i]和a[j],重复上面的过程，直到i>j。交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为53343891011，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j]交换的时刻。(5)归并排序归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。(6)基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。(7)希尔排序(shell)希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。(8)堆排序我们知道堆的结构是节点i的孩子为2_i和2_i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n/2-1，n/2-2，...1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。综上，得出结论:**选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法**![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)![img](https://pic2.zhimg.com/80/v2-e3a121dea092f9ec2ef727ceab030aad_hd.jpg)","Knowledge\\架构&相关\\算法\\算法\\diff\\index.md":"","Knowledge\\架构&相关\\算法\\算法\\diff\\snabbdom.md":"","Knowledge\\架构&相关\\算法\\算法\\diff\\virtual-dom.md":"","Knowledge\\架构&相关\\算法\\算法\\index.md":"#算法>[javascript-algorithms/README.zh-CN.mdatmaster·trekhleb/javascript-algorithms(github.com)](https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md)>>[算法3：最常用的排序——快速排序-坐在马桶上学算法-极客学院Wiki(jikexueyuan.com)](https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html)>>[十大经典排序算法（动图演示）-一像素-博客园(cnblogs.com)](https://www.cnblogs.com/onepixel/articles/7674659.html)","Knowledge\\架构&相关\\设计模式\\创建型\\单例模式.md":"#单例模式-定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。-适用场景:一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。-其实单例的核心，就是全局共享一个实例。```jsclassCreateUser{constructor(name){this.name=namethis.getName()}getName(){returnthis.name}}//代理实现单例模式varProxyMode=(function(){varinstance=nullreturnfunction(name){if(!instance){instance=newCreateUser(name)}returninstance}})()//测试单体模式的实例vara=newProxyMode('aaa')varb=newProxyMode('bbb')//因为单体模式是只实例化一次，所以下面的实例是相等的console.log(a===b)//true```##饿汉式-在该类创建的时候就进行了实例化。```javascriptclassSingleton{privatename:string;privatestaticinstance:Singleton=newSingleton('singleton');privateconstructor(name:string){this.name=name;//TODO初始化逻辑}publicstaticgetInstance():Singleton{returnSingleton.instance;}show(){console.log(this.name);}}Singleton.getInstance().show();//singleton```##懒汉式-在真正调用getInstance方法时，类才被真正实例化，更加节约空间。```javascriptclassSingleton{constructor(name){this.name=name//TODO初始化逻辑}staticgetInstance(){if(!Singleton.instance){Singleton.instance=newSingleton('singleton')}returnSingleton.instance}show(){console.log(this.name)}}Singleton.getInstance().show()//singleton```##模块化实现-在项目中使用时，用模块化编程，只需要模块抛出的是一个实例而不是类，那么一样能达到单例效果。-单例是在模块被引入的时候进行实例化的，模块本身其实是可以直接导入或者使用懒加载的```javascript//export.tsclassSingleton{protectedname:string;constructor(name:string){this.name=name;//TODO初始化逻辑}show(){console.log(this.name);}}exportdefaultnewSingleton('singleton');//import.tsimportsingletonfrom'./export';singleton.show();```","Knowledge\\架构&相关\\设计模式\\创建型\\原型模式.md":"#原型模式>原型模式（PrototypePattern）:**使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。**>>**优点：**>>-可以利用原型模式简化对象的创建过程，尤其是对一些创建过程繁琐，包含对象层级比较多的对象来说，使用原型模式可以节约系统资源，提高对象生成的效率。>-可以很方便得通过改变值来生成新的对象：有些对象之间的差别可能只在于某些值的不同；用原型模式可以快速复制出新的对象并手动修改值即可。>>**缺点：**>>-对象包含的所有对象都需要配备一个克隆的方法，这就使得在对象层级比较多的情况下，代码量会很大，也更加复杂。![原型模式的UML图](https://www.runoob.com/wp-content/uploads/2014/08/20201202-prototype-pattern.png)```jsfunctionDog(){this.name='lili'this.birthYear=2015this.sex='男'this.presentYear=2018this.getDiscription=()=>{return`狗狗叫${this.name},性别${this.sex},${this.presentYear}年${this.presentYear-this.birthYear}岁了`}}constdog=newDog()console.log(dog.getDiscription())//狗狗叫lili,性别男,2018年3岁了dog.presentYear=2020//修改了当前年份constdog1=Object.create(dog)//通过ES5语法进行创建//constdog1={}//Object.setPrototypeOf(dog1,dog);//通过ES6语法进行创建console.log(dog.getDiscription())//狗狗叫lili,性别男,2020年5岁了console.log(dog1.getDiscription())//狗狗叫lili,性别男,2020年5岁了``````tsinterfacePrototype{clone():Prototype}classDogimplementsPrototype{publicname:stringpublicbirthYear:numberpublicsex:stringpublicpresentYear:numberconstructor(){this.name='lili'this.birthYear=2015this.sex='男'this.presentYear=2018}publicgetDiscription():string{return`狗狗叫${this.name},性别${this.sex},${this.presentYear}年${this.presentYear-this.birthYear}岁了`}//实现复制publicclone():Prototype{returnObject.create(this)}}//使用constdog=newDog()console.log(dog.getDiscription())dog.presentYear=2020constdog1=Object.create(dog)console.log(dog1.getDiscription())```","Knowledge\\架构&相关\\设计模式\\创建型\\工厂模式.md":"#工厂模式>工厂，在现实中是生产产品的地方。在oop中，就是生产对象的地方。其核心是封装一个生产（new）行为。##简单工厂>-假如现在你运营了一间餐厅，客人如果要喝饮料，自己制作一杯就好，比如自己制作一杯茶或者一杯果汁。你觉得方便，顾客自己动手，丰衣足食，给你省了很大成本。顾客也觉得方便，想喝的时候自己就可以做，不用麻烦任何人，也不用等待。>-问题:顾客原本制作茶（newTea()）时我们是提供的本地茶叶冲泡的茶，但是成本太高，于是想换为绿茶茶包来制作（newGreenTea()）。>-需要通知所有泡茶的顾客更改他们的制作方式，这样的话，成本是不是太大了呢？假设我提供一个饮品机器，能够为我们生产茶和果汁，用户想要什么饮品，按一下对应的按钮就可以。我们来设计一下UML类图：![image-20210724193926976](.assets/image-20210724193926976.png)这里饮品我们用的接口，当然也可以用一个抽象类。下面是代码实现：```tsinterfaceIDrink{name:string//饮品名称make():void//制作饮品show():void//展示饮品}//茶classTeaimplementsIDrink{name:stringconstructor(name:string){this.name=namethis.make()}make():void{console.log('maketea')}show():void{console.log(`thisis${this.name}`)}}//果汁classJuiceimplementsIDrink{name:stringconstructor(name:string){this.name=namethis.make()}make():void{console.log('makejuice')}show():void{console.log(`thisis${this.name}`)}}classSimpleDrinkFactory{staticcreateDrink(type:string):IDrink{switch(type){case'tea':returnnewTea('tea')case'juice':returnnewJuice('juice')default:returnnewJuice('juice')}}}//告诉简单工厂想要一杯茶consttea:Tea=SimpleDrinkFactory.createDrink('tea')tea.show()//告诉简单工厂想要一杯果汁constjuice:Juice=SimpleDrinkFactory.createDrink('juice')juice.show()```![image-20210724194009593](.assets/image-20210724194009593.png)如果我们要把茶换成绿茶，只需新增一个绿茶类，并且在工厂中对茶的生产做一个修改即可，而不需要修改原来调用工厂生产茶的逻辑。```javascriptclassGreenTeaextendsTea{make():void{console.log('makegreentea');}}classSimpleDrinkFactory{staticcreateDrink(type:string)::Tea|Juice{switch(type){case'tea':returnnewGreenTea('greentea');case'juice':returnnewJuice('juice');default:returnnewJuice('juice');}}}```>对产品的生产做了一层封装，隔离了用户和产品的直接关系，用户只需要和工厂打交道即可。>>注意：>>1.理论上，简单工厂可以生成任意不相关的对象(返回any)，实际上我们还是会把具有相同特征（IDrink）的产品放在一块。>2.简单工厂的灵活性不强，不支持传入不同的参数。比如调用工厂时传入不同的参数，让其在生成产品时去调用，这种在ts是很难做到的，但你要说在js，那就很easy了。>3.扩展很麻烦，比如你要新增一种饮品类型，这里就得修改工厂，改造你的饮品机器，加一个按键，违反了开闭原则。其实简单工厂不属于设计模式的一种，但他的这种思想还是很强大的，运用也很广泛，为我们提供了一种最简单的封装创建行为的方式。##工厂方法模式>-工厂方法模式(FactoryMethodPattern)又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象。>-简单工厂扩展时需要修改工厂。这是因为再简单工厂内部我们用到了所有具体的产品，所以我们应该继续抽象，让我们的创建行为依赖一个抽象的工厂，而具体的创建行为由一个具体的工厂子类来实现。![image-20210724194050436](.assets/image-20210724194050436.png)```typescriptinterfaceIDrinkFactory{createDrink():IDrink}classTeaFactoryimplementsIDrinkFactory{createDrink():Tea{returnnewTea('tea')}}classJuiceFactoryimplementsIDrinkFactory{createDrink():Juice{returnnewJuice('juice')}}//告诉工厂想要一杯茶consttea=newTeaFactory().createDrink()tea.show()//告诉工厂想要一杯果汁constjuice=newJuiceFactory().createDrink()juice.show()```>这就好比新增一种饮品，我在新增一台机器即可，符合开闭原则。>>但是如果我的饮品种类很多，我就要增加很多机器，假设我还有生产食物的需求，我也得为食物生产定制很多的机器。那么我的管理成本会越来越大。##抽象工厂模式>其实顾客消费时，既有可能消费饮品，也有可能消费食物，如果我们的抽象工厂同时提供这两种产品的创建，那么我们所需要实现的具体工厂就会少很多。也就是我们的工厂支持不同的产品系创建。![image-20210724194137906](.assets/image-20210724194137906.png)```tsinterfaceIDrink{name:string//饮品名称make():void//制作饮品show():void//展示饮品}//茶classTeaimplementsIDrink{name:stringconstructor(name:string){this.name=namethis.make()}make():void{console.log('maketea')}show():void{console.log(`thisis${this.name}`)}}//果汁classJuiceimplementsIDrink{name:stringconstructor(name:string){this.name=namethis.make()}make():void{console.log('makejuice')}show():void{console.log(`thisis${this.name}`)}}interfaceIFood{name:stringmake():void//制作食品show():void//展示食品}//炸鸡classFriedChickenimplementsIFood{name:stringconstructor(name:string){this.name=namethis.make()}make():void{console.log('makeFriedChicken')}show():void{console.log(`thisis${this.name}`)}}//汉堡classHamburgimplementsIFood{name:stringconstructor(name:string){this.name=namethis.make()}make():void{console.log('makehamburg')}show():void{console.log(`thisis${this.name}`)}}interfaceIMealFactory{createDrink():IDrinkcreateFood():IFood}classMealAFactoryimplementsIMealFactory{createDrink():Tea{returnnewTea('tea')}createFood():FriedChicken{returnnewFriedChicken('friedchicken')}}classMealBFactoryimplementsIMealFactory{createDrink():Juice{returnnewJuice('juice')}createFood():Hamburg{returnnewHamburg('hamburg')}}constmealAFactory=newMealAFactory()mealAFactory.createDrink().show()mealAFactory.createFood().show()constmealBFactory=newMealBFactory()mealBFactory.createDrink().show()mealBFactory.createFood().show()```>抽象工厂解决了创建不同产品簇的问题，不过抽象工厂在扩展时仍然会产生大量的实体工。##小结>从工厂模式的三种形态中，我们可以看到。>>越抽象就越利于扩展，但同时也增大了代码结构的复杂性和管理难度，另外，越抽象，有时候就意味着约束力更弱。>>比如这里具体工厂生产的产品类型，我们使用的具体产品类型来约束，而不是抽象的产品接口来约束，虽然第二种方法扩展和修改起来更方便，但是代码的约束力更弱，可能会写出不符合预期的代码。>>没有完美的设计模式，只有合适的设计方案，不要在一开始就追求过度设计。我们只要理解工厂模式的核心就在于封装new这个行为。","Knowledge\\架构&相关\\设计模式\\创建型\\生成器&创建者模式.md":"#建造者(创建者)模式>工厂模式:>>-为我们将客户端的生产行为封装起来，交给了工厂。>-它本质上是服务于客户端的，并没有降低产品生产的难度，产品的生产逻辑仍然在自己的类内部实现。>-对于一些复杂的产品类（工序多，参数多），我们需要在内部维护其复杂的构建逻辑，是很容易出错的。>-举一个简单的例子，生产牛肉汉堡，我们不管是由客户端去生产，还是工厂帮我们生产，建造的逻辑始终写在其constructor内部。>-全部生产步骤可能包含，做面包，做牛肉，放蔬菜，每个步骤可能有不同的参数控制，比如几片面包，几片牛肉或者几片蔬菜。如果我们发现之前的工序不好，需要调整工序，要么在类内部进行修改（违法开闭），要么新增一个类（成本太大，也不好维护），或者说我们要做猪肉汉堡，步骤和工序是一样的，我们新建一个类时由于步骤复杂，可能漏了或写错了。>>建造者模式>>-也叫创建者模式，它将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示>-创建一个复杂对象的，它将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。>-比如我规定汉堡的构建工序是可以稳定地划分为，做面包，做肉，放蔬菜的，至于你具体是面包是做成方形的圆形的，肉要是什么类型，蔬菜是什么类型，这是具体的实现步骤，对不同的汉堡具体的实现不一样。##建造者模式![image-20210724195025203](.assets/image-20210724195025203.png)>这里抽象建造者使用接口也是okay的。可以看到这里不管抽象的建造者还是具体的建造者依赖（关联）的都是Hamburg，这个Hamburg其实也可以是一个父类或者抽象类。```tsclassHamburg{name:string//可选参数也可以使用set，但是ts中直接在这里声明更方便,当然如果是private，需要使用set来封装meatType?:stringvegetableType?:stringprivatebreadNum?:numberconstructor(name:string){//如果我们不用建造者模式，那么产品类的constructor这里将要传入所有参数this.name=name//必选参数可以放在这里，步骤具体实现可变的就抽出来}//利用ts的set当然也是okay的，比如setnum(num){this.breadNum=num;}setBreadNum(num:number){this.breadNum=num}}//原本放在产品类的构建步骤被转移到了建造者类，由具体的建造者实现abstractclassHamburgBuilder{abstractbuildBread(breadNum:number):voidabstractbuildMeat(meatType:string):voidabstractbuildVegetable(vegetableTYpe:string):voidabstractcreateHamburg():Hamburg}classBeefHamburgBuilderextendsHamburgBuilder{//这里如果可以确定name，就不需要用户再传入了privatehamburg:Hamburg=newHamburg('牛肉汉堡')buildBread(breadNum:number):void{console.log(`制作牛肉汉堡需要的${breadNum}片面包`)this.hamburg.setBreadNum(breadNum)}buildMeat(meatType:string):void{console.log(`制作牛肉汉堡需要的${meatType}`)this.hamburg.meatType=meatType}buildVegetable(vegetableType:string):void{console.log(`制作牛肉汉堡需要的${vegetableType}`)this.hamburg.vegetableType=vegetableType}createHamburg():Hamburg{returnthis.hamburg}}classPorkHamburgBuilderextendsHamburgBuilder{privatehamburg:Hamburg=newHamburg('猪肉汉堡')buildBread(breadNum:number):void{console.log(`制作猪肉汉堡需要的${breadNum}片面包`)this.hamburg.setBreadNum(breadNum)}buildMeat(meatType:string):void{console.log(`制作猪肉汉堡需要的${meatType}`)this.hamburg.meatType=meatType}buildVegetable(vegetableType:string):void{console.log(`制作猪肉汉堡需要的${vegetableType}`)this.hamburg.vegetableType=vegetableType}createHamburg():Hamburg{returnthis.hamburg}}//我们用director来封装顺序，如果要改变工序，只要新增一个director或者新增一个construct即可classHamburgDirector{//顺序1，包含三道工序staticconstruct1(builder:HamburgBuilder,breadNum:number,meatType:string,vegetableType:string,):Hamburg{builder.buildBread(breadNum)builder.buildMeat(meatType)builder.buildVegetable(vegetableType)returnbuilder.createHamburg()}//顺序2，包含两道工序staticconstruct2(builder:HamburgBuilder,breadNum:number,meatType:string,):Hamburg{builder.buildMeat(meatType)builder.buildBread(breadNum)returnbuilder.createHamburg()}}constbeefHamburgBuilder=newBeefHamburgBuilder()constporkHamburgBuilder=newPorkHamburgBuilder()HamburgDirector.construct1(beefHamburgBuilder,2,'beef','carrot')HamburgDirector.construct2(porkHamburgBuilder,3,'pork')```##小结>-建造者模式的核心其实就是将具体的建造过程提取出来，进行封装。构建步骤封装在建造者，构建顺序封装在导演类。>-可以一个导演类对应于一个建造者，也可以对应对个建造者，甚至你如果不用导演类，由客户端来选择构建顺序也是okay的。","Knowledge\\架构&相关\\设计模式\\结构型\\享元模式.md":"#享元模式>享元（Flyweight）模式的定义：>>-运用共享技术来有效地支持大量细粒度对象的复用。>-通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。>>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。>>其主要缺点是：>>1.为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。>2.读取享元模式的外部状态会使得运行时间稍微变长。>>享元模式的结构与实现>>享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：**内部状态和外部状态**。>>-内部状态指对象共享出来的信息，存储在享元信息内部，并且不回随环境的改变而改变；>-外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享。>>比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。>>享元模式的本质是缓存共享对象，降低内存消耗。>>模式的结构>>享元模式的主要角色有如下。>>1.抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。>2.具体享元（ConcreteFlyweight）角色：实现抽象享元角色中所规定的接口。>3.非享元（UnsharableFlyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。>4.享元工厂（FlyweightFactory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。![享元模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115161342242.gif)```javapublicclassFlyweightPattern{publicstaticvoidmain(String[]args){FlyweightFactoryfactory=newFlyweightFactory();Flyweightf01=factory.getFlyweight(\"a\");Flyweightf02=factory.getFlyweight(\"a\");Flyweightf03=factory.getFlyweight(\"a\");Flyweightf11=factory.getFlyweight(\"b\");Flyweightf12=factory.getFlyweight(\"b\");f01.operation(newUnsharedConcreteFlyweight(\"第1次调用a。\"));f02.operation(newUnsharedConcreteFlyweight(\"第2次调用a。\"));f03.operation(newUnsharedConcreteFlyweight(\"第3次调用a。\"));f11.operation(newUnsharedConcreteFlyweight(\"第1次调用b。\"));f12.operation(newUnsharedConcreteFlyweight(\"第2次调用b。\"));}}//非享元角色classUnsharedConcreteFlyweight{privateStringinfo;UnsharedConcreteFlyweight(Stringinfo){this.info=info;}publicStringgetInfo(){returninfo;}publicvoidsetInfo(Stringinfo){this.info=info;}}//抽象享元角色interfaceFlyweight{publicvoidoperation(UnsharedConcreteFlyweightstate);}//具体享元角色classConcreteFlyweightimplementsFlyweight{privateStringkey;ConcreteFlyweight(Stringkey){this.key=key;System.out.println(\"具体享元\"+key+\"被创建！\");}publicvoidoperation(UnsharedConcreteFlyweightoutState){System.out.print(\"具体享元\"+key+\"被调用，\");System.out.println(\"非享元信息是:\"+outState.getInfo());}}//享元工厂角色classFlyweightFactory{privateHashMap<String,Flyweight>flyweights=newHashMap<String,Flyweight>();publicFlyweightgetFlyweight(Stringkey){Flyweightflyweight=(Flyweight)flyweights.get(key);if(flyweight!=null){System.out.println(\"具体享元\"+key+\"已经存在，被成功获取！\");}else{flyweight=newConcreteFlyweight(key);flyweights.put(key,flyweight);}returnflyweight;}}```","Knowledge\\架构&相关\\设计模式\\结构型\\代理模式.md":"#代理模式>-定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。>-代理模式也叫做委托模式，它是一项基本设计技巧>-常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）>-图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。>-使用代理模式实现图片懒加载的优点还有符合单一职责原则。减少一个类或方法的粒度和耦合度。```jsletimgFunc=(function(){varimgNode=document.createElement('img')document.body.appendChild(imgNode)return{setSrc:function(src){imgNode.src=src},}})()letproxyImage=(function(){varimg=newImage()img.onload=function(){imgFunc.setSrc(this.src)}return{setSrc:function(src){imgFunc.setSrc('./loading,gif')img.src=src},}})()proxyImage.setSrc('./pic.png')```>代理，顾名思义，就是替委托者处理事情。通过代理，客户不必要去接触真实的目标对象，转而去接触目标对象的代理，即可达成目的。##静态代理![image-20210724195552332](.assets/image-20210724195552332.png)```typescriptinterfaceSubject{doOperation(...items:Array<any>):void}classRealSubjectimplementsSubject{doOperation(...items:Array<any>):void{console.log(`真实的目标对象在执行操作，参数：${items}`)//真实的目标对象在执行操作，参数：dowork,sing}}classMyProxyimplementsSubject{privatetarget:RealSubjectconstructor(target:RealSubject){this.target=target}doOperation(...items:Array<any>):void{console.log(`代理对象在执行操作，参数：${items}`)//代理对象在执行操作，参数：dowork,singthis.target.doOperation(...items)}}constproxy=newMyProxy(newRealSubject())proxy.doOperation('dowork','sing')```>静态代理让业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。但是它有如下缺点：>>-代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。>-代理对象只服务于一种类型的对象，如果要服务多类型的对象。就需要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为Subject类的访问提供了代理，但是如果还要为其他类如AnotherSubject类提供代理的话，就需要我们再次添加代理AnotherSubject的代理类。##动态代理>说到动态代理，ES6其实提供了Proxy对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。这里我们定义get行为即可：```javascriptinterfaceSubject{doOperation(...items:Array<any>):void;}classRealSubjectimplementsSubject{doOperation(...items:Array<any>):void{console.log(`真实的目标对象在执行操作，参数：${items}`,this);//真实的目标对象在执行操作，参数：dowork,sing}}constproxy=newProxy(newRealSubject(),{get(target,propKey){console.log(`代理对象在执行操作${propKey}`);//代理对象在执行操作doOperationreturntarget[propKey];},});proxy.doOperation('dowork','sing');```当然，这里动态调用对象方法时使用Reflect更佳：```javascriptinterfaceSubject{doOperation(...items:Array<any>):void;}classRealSubjectimplementsSubject{doOperation(...items:Array<any>):void{console.log(`真实的目标对象在执行操作，参数：${items}`);//真实的目标对象在执行操作，参数：dowork,sing}}constproxy=newProxy(newRealSubject(),{get(target,propKey,receiver){console.log(`代理对象在执行操作${propKey}`);//代理对象在执行操作doOperationreturnReflect.get(target,propKey,receiver);},});proxy.doOperation('dowork','sing');```不过需要小心的是，虽然Proxy可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在Proxy代理的情况下，目标对象内部的this关键字会指向Proxy代理。```javascriptconsttarget={m(){console.log(this===proxy)},}consthandler={}constproxy=newProxy(target,handler)target.m()//falseproxy.m()//true```有些原生对象的内部属性，只有通过正确的this才能拿到，所以Proxy也无法代理这些原生对象的属性。```javascriptconsttarget=newDate()consthandler={}constproxy=newProxy(target,handler)proxy.getDate()//UncaughtTypeError:thisisnotaDateobject.```上面代码中，getDate方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。```javascriptconsttarget=newDate('2015-01-01')consthandler={get(target,prop){if(prop==='getDate'){returntarget.getDate.bind(target)}returnReflect.get(target,prop)},}constproxy=newProxy(target,handler)proxy.getDate()//4```##小结代理和装饰器模式比较像，都是在不改变原对象的情况下，又改变了原对象的某些功能。不同的地方是，装饰器主要是对原对象的新增和加强，而代理注重的是对原对象的隐藏和控制。","Knowledge\\架构&相关\\设计模式\\结构型\\外观模式.md":"#外观模式>外观模式(FacadePattern,门面模式)：外观模式定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。>>**优点：**>>-实现了客户端与子系统间的解耦：客户端无需知道子系统的接口，简化了客户端调用子系统的调用过程，使得子系统使用起来更加容易。同时便于子系统的扩展和维护。>-符合迪米特法则（最少知道原则）：子系统只需要将需要外部调用的接口暴露给外观类即可，而且他的接口则可以隐藏起来。>>**缺点：**>>-违背了开闭原则：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的代码。##模式结构>1.外观(Facede)角色:为多个子心痛对外提供一个公共的接口>2.子系统(SubSystem)角色:实现系统的部分功能,客户可以通过外观角色访问它>3.客户(Client)角色:通过一个外观角色范文各个子系统的功能![外观模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115152143509.gif)```javapublicclassFacadePattern{publicstaticvoidmain(String[]args){Facadef=newFacade();f.method();}}//外观角色classFacade{privateSubSystem01obj1=newSubSystem01();privateSubSystem02obj2=newSubSystem02();privateSubSystem03obj3=newSubSystem03();publicvoidmethod(){obj1.method1();obj2.method2();obj3.method3();}}//子系统角色classSubSystem01{publicvoidmethod1(){System.out.println(\"子系统01的method1()被调用！\");}}//子系统角色classSubSystem02{publicvoidmethod2(){System.out.println(\"子系统02的method2()被调用！\");}}//子系统角色classSubSystem03{publicvoidmethod3(){System.out.println(\"子系统03的method3()被调用！\");}}```","Knowledge\\架构&相关\\设计模式\\结构型\\桥接模式.md":"#桥接模式>桥接模式(BridgePattern)：>>-将抽象部分与它的实现部分分离,使它们都可以独立地变化>>**优点：**>>-将抽象与实现分离，让二者可以独立变化>-抽象与实现分离，扩展能力强>-符合开闭原则>-符合合成复用原则>-其实现细节对客户透明>>**缺点：**>>-在设计之前，需要识别出两个独立变化的维度。>>模式的结构>>桥接（Bridge）模式包含以下主要角色。>>1.抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。>2.扩展抽象化（RefinedAbstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。>3.实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。>4.具体实现化（ConcreteImplementor）角色：给出实现化角色接口的具体实现。![桥接模式的结构图](.assets/3-1Q115125253H1.gif)##Java```javapublicclassBridgeTest{publicstaticvoidmain(String[]args){Implementorimple=newConcreteImplementorA();Abstractionabs=newRefinedAbstraction(imple);abs.Operation();}}//实现化角色interfaceImplementor{publicvoidOperationImpl();}//具体实现化角色classConcreteImplementorAimplementsImplementor{publicvoidOperationImpl(){System.out.println(\"具体实现化(ConcreteImplementor)角色被访问\");}}//抽象化角色abstractclassAbstraction{protectedImplementorimple;protectedAbstraction(Implementorimple){this.imple=imple;}publicabstractvoidOperation();}//扩展抽象化角色classRefinedAbstractionextendsAbstraction{protectedRefinedAbstraction(Implementorimple){super(imple);}publicvoidOperation(){System.out.println(\"扩展抽象化(RefinedAbstraction)角色被访问\");imple.OperationImpl();}}//相当于RefinedAbstraction拥有了Implementor的方法等```##TS```typescript//实现化角色interfaceImplementor{OperationImpl():void}//具体实现化角色classConcreteImplementorAimplementsImplementor{publicOperationImpl():void{console.log('具体实现化(ConcreteImplementor)角色被访问')}}//抽象化角色abstractclassAbstraction{protectedimple:Implementor|null=nullprotectedAbstraction(imple:Implementor){this.imple=imple}publicabstractOperation():void}//扩展抽象化角色classRefinedAbstractionextendsAbstraction{protectedimple:Implementor|null=nullconstructor(imple:Implementor){super()this.imple=imple}publicOperation():void{console.log('扩展抽象化(RefinedAbstraction)角色被访问')this.imple?.OperationImpl()}}//相当于RefinedAbstraction拥有了Implementor的方法等constimple:Implementor=newConcreteImplementorA()constabs:Abstraction=newRefinedAbstraction(imple)abs.Operation()```运行结果:```shell扩展抽象化(RefinedAbstraction)角色被访问具体实现化(ConcreteImplementor)角色被访问```","Knowledge\\架构&相关\\设计模式\\结构型\\装饰者模式.md":"#装饰者模式>-定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。>-适用的场景：原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。##例子>-先给`Function`的原型链添加`before`和`after`>-任何方法都可以通过这来添加```js//用AOP装饰函数实现装饰者模式Function.prototype.before=function(beforefn){varself=this//保存原函数引用returnfunction(){//返回包含了原函数和新函数的'代理函数'beforefn.apply(this,arguments)//执行新函数，修正thisreturnself.apply(this,arguments)//执行原函数}}Function.prototype.after=function(afterfn){varself=thisreturnfunction(){varret=self.apply(this,arguments)afterfn.apply(this,arguments)returnret}}varfunc=function(){console.log('2')}//func1和func3为挂载函数varfunc1=function(){console.log('1')}varfunc3=function(){console.log('3')}func=func.before(func1).after(func3)func()/*123*//*传参写法*/letfuncB=function(){console.log('bb')}letfunc4=(aa)=>{console.log(aa)}funcA=funcB.before(func4.bind({},1)).after(func4.bind({},0))funcA()/*1bb0*/```##小结>装饰器模式是一个非常重要的设计模式，在很多场景下可以用来替代继承，增加代码的可维护性。","Knowledge\\架构&相关\\设计模式\\结构型\\适配器模式.md":"#适配器模式>-为了解决不兼容的问题,把一个类的接口换成我们需要的接口>-场景:>-描述:多个数据源,组件只能接受一种数据结构,在不改变组件的内部逻辑,保持组件的职责>-处理:采用适配器模式,将不同的数据结构适配成要展示组件需要的数据结构>-角色：>>-Target（目标）：客户的目标接口，可以是一个抽象类或接口，也可以是具体类。>-Adaptee（适配者）：被适配的角色，是一个已有接口，但不符合客户要求。>-Adapter（适配器）：将已有接口转换成目标接口>>-分类：>-类适配器模式>-对象适配器模式>-缺省适配器模式，也叫接口适配器模式##类适配器模式Adapter可以继承一个已有的Adaptee，然后实现Target。这种情况下只能有一个Adaptee，且Target必须是接口。![image-20210724195222461](.assets/image-20210724195222461.png)```typescriptinterfacePowerTarget{output12V():string}classPowerAdaptee{output220V(){return'220V交流电'}}constadapt=(input:string):string=>{//TODO具体转换逻辑console.log(`${input}被转换成12V直流电`)return'12V直流电'}classPowerAdapterextendsPowerAdapteeimplementsPowerTarget{publicoutput12V(){constinput=this.output220V()console.log(`电源适配器开始工作，获取：${input}`)constoutput=adapt(input)console.log(`电源适配器工作完成，输出：${output}`)returnoutput}}consttarget:PowerTarget=newPowerAdapter()target.output12V()```##对象适配器模式>Adapter可以关联个已有的Adaptee，然后实现Target。>>这种情况下你要依赖多个Adaptee实现也是okay的，Target可以是接口也可以是抽象类甚至是类。>>不过这里因为是关联，所以改写关联对象的方法就很麻烦了，不像继承那么简单。![image-20210724195303712](.assets/image-20210724195303712.png)```typescriptinterfacePowerTarget{output12V():string}classPowerAdaptee{output220V():string{return'220V交流电'}}constadapt=(input)=>{//TODO具体转换逻辑console.log(`${input}被转换成12V直流电`)return'12V直流电'}classPowerAdapterimplementsPowerTarget{privatepowerAdaptee:PowerAdapteeconstructor(){this.powerAdaptee=newPowerAdaptee()}publicoutput12V():string{constinput=this.powerAdaptee.output220V()console.log(`电源适配器开始工作，获取：${input}`)constoutput=adapt(input)console.log(`电源适配器工作完成，输出：${output}`)returnoutput}}consttarget:PowerTarget=newPowerAdapter()target.output12V()```##小结>其实还有一种缺省适配器模式，就是只想实现target接口定义的部分方法，那么在adapter和target之间加一层defaultAdapter，用空方法实现target的所有接口，真正的adapter就可以选择性的重写defaultAdapter中需要去适配的方法了。本质上还是用的类适配器模式和对象适配器模式。可以看到，适配器模式，也可以看做是对方法的一种抽象，客户依赖的接口不变，但是接口方法的实现可以用一个或多个现成的类来辅助实现。","Knowledge\\架构&相关\\设计模式\\行为型\\中介者模式.md":"#中介者模式>-定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。>-适用的场景：例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。```jsvargoods={//手机库存'red|32G':3,'red|64G':1,'blue|32G':7,'blue|32G':6,}//中介者varmediator=(function(){varcolorSelect=document.getElementById('colorSelect')varmemorySelect=document.getElementById('memorySelect')varnumSelect=document.getElementById('numSelect')return{changed:function(obj){switch(obj){casecolorSelect://TODObreakcasememorySelect://TODObreakcasenumSelect://TODObreak}},}})()colorSelect.onchange=function(){mediator.changed(this)}memorySelect.onchange=function(){mediator.changed(this)}numSelect.onchange=function(){mediator.changed(this)}```TS```typescriptclassUser{privatename:string=''publicgetName():string{returnthis.name}publicsetName(name:string):void{this.name=name}constructor(name:string){this.name=name}publicsendMessage(message:string):void{ChatRoom.showMessage(this,message)}}//中介类classChatRoom{publicstaticshowMessage(user:User,message:string):void{console.log(newDate().toString()+'['+user.getName()+']:'+message,)}}constrobert:User=newUser('Robert')constjohn:User=newUser('John')robert.sendMessage('Hi!John!')john.sendMessage('Hello!Robert!')```","Knowledge\\架构&相关\\设计模式\\行为型\\命令模式.md":"#命令模式>命令模式(CommandPattern)：>>-将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。>-其别名为动作(Action)模式或事务(Transaction)模式。>>**优点：**>>-降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。>-新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。>-可以比较容易地设计一个命令队列或宏命令（组合命令）。>-为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。>>**缺点：**>>-使用命令模式可能会导致某些系统有过多的具体命令类。![img](https://www.runoob.com/wp-content/uploads/2014/08/20201015-command-1.svg)##TS```typescript/**@Author:ruihuag*@Date:2021-08-1310:52:28*@LastEditTime:2021-08-1311:34:53*@LastEditors:ruihuag*@Description:命令模式*@FilePath:\\Test-Demo\\Designpattern\\行为型\\命令模式\\index.ts*Copyright(c)2004-2021i-SprintTechnologies,Inc.*address:*Allrightsreserved.**Thissoftwareistheconfidentialandproprietaryinformationof*i-SprintTechnologies,Inc.('ConfidentialInformation').Youshallnot*disclosesuchConfidentialInformationandshalluseitonlyin*accordancewiththetermsofthelicenseagreementyouenteredinto*withi-Sprint.*/interfaceIOrder{execute:()=>void}classOrderimplementsIOrder{execute():void{console.log('orderexecute')}}//请求类classStock{privatename:string='ABC'privatequantity:number=10publicbuy():void{console.log(`Stock[Namee:\"${this.name}\",Quantity:\"${this.quantity}\"]bought`,)}publicsell():void{console.log(`Stock[Namee:\"${this.name}\",Quantity:\"${this.quantity}\"]sold`,)}}typeTStock=Stock|null|undefined//实现类classBuyStockimplementsOrder{privateabcStock:TStockconstructor(abcStock:TStock){this.abcStock=abcStock}execute():void{this.abcStock?.buy()}}classSellStockimplementsOrder{privateabcStock:TStockconstructor(abcStock:TStock){this.abcStock=abcStock}execute():void{this.abcStock?.sell()}}classBroker{privateorderList:Order[]=[]publictakeOrder(order:Order):void{this.orderList.push(order)}publicplaceOrders():void{this.orderList.map((order:Order)=>{order.execute()})}}constabcStock:TStock=newStock()constbuyStockOrder:BuyStock=newBuyStock(abcStock)constsellStockOrder:SellStock=newSellStock(abcStock)constbroker=newBroker()broker.takeOrder(buyStockOrder)broker.takeOrder(sellStockOrder)broker.placeOrders()```","Knowledge\\架构&相关\\设计模式\\行为型\\模板方法模式.md":"#模板方法模式>模板方法模式：>>-定义一个操作中算法的框架，而将一些步骤延迟到子类中。>-模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。>>模板方法模式在iOS中的应用也非常多，如UIViewController的生命周期函数，定义在父类，子类可以重写这些函数。>>模板方法模式具体应用又分为三类：>>-抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。>-具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。>-钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。>>**优点：**>>-在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。>-模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。>-可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。>-在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。>>**缺点：**>>-需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。![模板模式的UML图](https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg)```typescriptabstractclassGame{abstractinitialize():voidabstractstartPlay():voidabstractendPlay():voidplay(){//这里应该是final的this.initialize()this.startPlay()this.endPlay()}}classCricketextendsGame{endPlay():void{console.log('CricketGameFinished!')}initialize():void{console.log('CricketGameInitialized!Startplaying.')}startPlay():void{console.log('CricketGameStarted.Enjoythegame!')}}classFootballextendsGame{endPlay(){console.log('FootballGameFinished!')}initialize(){console.log('FootballGameInitialized!Startplaying.')}startPlay(){console.log('FootballGameStarted.Enjoythegame!')}}constgame1:Game=newCricket()game1.play()constgame2:Game=newFootball()game2.play()```","Knowledge\\架构&相关\\设计模式\\行为型\\状态模式.md":"#状态模式>状态模式(StatePattern)：>>-允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(ObjectsforStates)，状态模式是一种对象行为型模式。>>**举例：**>>状态模式用于解决复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，所以对象在不同状态下具有不同行为时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。>>**优点：**>>-封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。>-将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。>-允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。>-可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。>>**缺点：**>>-状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。>-状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。>-状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。##Java![学生成绩的状态转换程序的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q11615425V39.gif)```javapublicclassScoreStateTest{publicstaticvoidmain(String[]args){ScoreContextaccount=newScoreContext();System.out.println(\"学生成绩状态测试：\");account.add(30);account.add(40);account.add(25);account.add(-15);account.add(-25);}}//环境类classScoreContext{privateAbstractStatestate;ScoreContext(){state=newLowState(this);}publicvoidsetState(AbstractStatestate){this.state=state;}publicAbstractStategetState(){returnstate;}publicvoidadd(intscore){state.addScore(score);}}//抽象状态类abstractclassAbstractState{protectedScoreContexthj;//环境protectedStringstateName;//状态名protectedintscore;//分数publicabstractvoidcheckState();//检查当前状态publicvoidaddScore(intx){score+=x;System.out.print(\"加上：\"+x+\"分，\\t当前分数：\"+score);checkState();System.out.println(\"分，\\t当前状态：\"+hj.getState().stateName);}}//具体状态类：不及格classLowStateextendsAbstractState{publicLowState(ScoreContexth){hj=h;stateName=\"不及格\";score=0;}publicLowState(AbstractStatestate){hj=state.hj;stateName=\"不及格\";score=state.score;}publicvoidcheckState(){if(score>=90){hj.setState(newHighState(this));}elseif(score>=60){hj.setState(newMiddleState(this));}}}//具体状态类：中等classMiddleStateextendsAbstractState{publicMiddleState(AbstractStatestate){hj=state.hj;stateName=\"中等\";score=state.score;}publicvoidcheckState(){if(score<60){hj.setState(newLowState(this));}elseif(score>=90){hj.setState(newHighState(this));}}}//具体状态类：优秀classHighStateextendsAbstractState{publicHighState(AbstractStatestate){hj=state.hj;stateName=\"优秀\";score=state.score;}publicvoidcheckState(){if(score<60){hj.setState(newLowState(this));}elseif(score<90){hj.setState(newMiddleState(this));}}}```##TS![状态模式的UML图](https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png)```typescriptinterfaceIState{doAction(context:Context):void}classStateimplementsIState{publicdoAction(context:Context):void{console.log(context)}}typeTState=State|null|undefinedclassContext{privatestate:TStateconstructor(){this.state=null}setState(state:State):void{this.state=state}getState():TState{returnthis.state}}classStartStateimplementsState{doAction(context:Context):void{console.log('Playerisinstartstate')context.setState(this)}publictoString():string{return'StartState'}}classStopStateimplementsState{doAction(context:Context):void{console.log('Playerisinstopstate')context.setState(this)}publictoString():string{return'StopState'}}constcontext:Context=newContext()conststartState:StartState=newStartState()startState.doAction(context)console.log(context.getState()?.toString())conststopState:StartState=newStopState()stopState.doAction(context)console.log(context.getState()?.toString())```","Knowledge\\架构&相关\\设计模式\\行为型\\策略模式.md":"#策略模式>-定义:定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。>-目的:将算法和使用算法实现分离>-一个基于策略模式的程序至少由两部分组成。>-第一个部分是一组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。>-第二个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用。![](../../../../../../../Users/ruihuag/Pictures/CameraRoll/策略模式.gif)##JS```js/*策略类*/varlevelOBJ={A:function(money){returnmoney*4},B:function(money){returnmoney*3},C:function(money){returnmoney*2},}/*环境类*/varcalculateBouns=function(level,money){returnlevelOBJ[level](money)}console.log(calculateBouns('A',10000))//40000```##TS```typescript//抽象策略接口类interfaceIStrategy{strategyMethod:()=>void;//策略方法}//抽象策略类(由于ts无法实例化接口而添加)classStrategyimplementsIStrategy{publicstrategyMethod(){console.log('抽象策略类方法被访问');}}//具体策略类AclassContextStrategyAimplementsIStrategy{publicstrategyMethod(){console.log('具体策略类A的策略方法被访问');}}//具体策略类BclassContextStrategyBimplementsIStrategy{publicstrategyMethod(){console.log('具体策略类B的策略方法被访问');}}//具体策略类B//环境类classContext{privatestategy=newStrategy();publicgetStrategy():IStrategy{returnthis.stategy;}publicsetStategy(stategy:IStrategy):void{this.stategy=stategy;}publicstategyMethod(){this.stategy.strategyMethod();}}//主函数consta:IStrategy=newContextStrategyA();constb:IStrategy=newContextStrategyB();constcontext:Context=newContext();context.setStategy(a);context.stategyMethod();context.setStategy(b);context.stategyMethod();//运行结果具体策略类A的策略方法被访问具体策略类B的策略方法被访问```##Java```javapublicclassStrategyPattern{publicstaticvoidmain(String[]args){Contextc=newContext();Strategys=newConcreteStrategyA();c.setStrategy(s);c.strategyMethod();System.out.println(\"-----------------\");s=newConcreteStrategyB();c.setStrategy(s);c.strategyMethod();}}//抽象策略类interfaceStrategy{publicvoidstrategyMethod();//策略方法}//具体策略类AclassConcreteStrategyAimplementsStrategy{publicvoidstrategyMethod(){System.out.println(\"具体策略A的策略方法被访问！\");}}//具体策略类BclassConcreteStrategyBimplementsStrategy{publicvoidstrategyMethod(){System.out.println(\"具体策略B的策略方法被访问！\");}}//环境类classContext{privateStrategystrategy;publicStrategygetStrategy(){returnstrategy;}publicvoidsetStrategy(Strategystrategy){this.strategy=strategy;}publicvoidstrategyMethod(){strategy.strategyMethod();}}```","Knowledge\\架构&相关\\设计模式\\行为型\\职责链模式.md":"#职责链模式>职责链模式(ChainofResponsibilityPattern)：>>-避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。>>**举例：**>>职责链模式在iOS中有大量的应用，比如事件响应链，事件传递下来会先判断该事件是不是应该由自己处理，如果不是由自己处理则传给下一位响应者去处理，如此循环下去。需要注意的是要避免响应链循环调用造成死循环，还有当所有的响应者都无法处理时的情况>>**优点：**>>-职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。>-请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。>-在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。>-在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。>>**缺点：**>>-由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。>-对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。>-如果建链不当，可能会造成循环调用，将导致系统陷入死循环。![责任链模式的UML图](https://www.runoob.com/wp-content/uploads/2014/08/2021-chain-of-responsibility.svg)##TS```typescripttypeTAbstractLogger=AbstractLogger|null|undefined//记录器抽象类abstractclassAbstractLogger{publicstaticINFO:number=1publicstaticDEBUG:number=2publicstaticERROR:number=3protectedlevel:number=-1//责任链中的下一个元素protectednextLogger:TAbstractLoggerpublicsetNextLogger(nextLogger:AbstractLogger):void{this.nextLogger=nextLogger}publiclogMessage(level:number,message:string):void{if(this.level<=level){this.write(message)}if(this.nextLogger!==null){this.nextLogger?.logMessage(level,message)}}protectedabstractwrite(message:string):void}classConsoleLoggerextendsAbstractLogger{constructor(level:number){super()this.level=level}protectedwrite(message:string):void{console.log('StandardConsole::Logger:'+message)}}classErrorLoggerextendsAbstractLogger{constructor(level:number){super()this.level=level}protectedwrite(message:string):void{console.log('ErrorConsole::Logger:'+message)}}classFileLoggerextendsAbstractLogger{constructor(level:number){super()this.level=level}protectedwrite(message:string):void{console.log('File::Logger:'+message)}}functiongetChainOfLoggers():AbstractLogger{consterrorLogger:AbstractLogger=newErrorLogger(AbstractLogger.ERROR)constfileLogger:AbstractLogger=newFileLogger(AbstractLogger.DEBUG)constconsoleLogger:AbstractLogger=newConsoleLogger(AbstractLogger.INFO)errorLogger.setNextLogger(fileLogger)fileLogger.setNextLogger(consoleLogger)returnerrorLogger}constloggerChain:AbstractLogger=getChainOfLoggers()loggerChain.logMessage(AbstractLogger.INFO,'Thisisaninformation.')loggerChain.logMessage(AbstractLogger.DEBUG,'Thisisadebuglevelinformation.',)loggerChain.logMessage(AbstractLogger.ERROR,'Thisisanerrorinformation.')```","Knowledge\\架构&相关\\设计模式\\行为型\\观察者(发布-订阅)模式.md":"#观察者模式>观察者模式:>>-定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。>-就好比我们去点餐,通知服务员说，餐好了跟我说一下。那么服务员和顾客之间就形成了耦合，首先服务员得知道餐品好了以后通知那些顾客，其次，如果是多位服务员协作，每个服务员都需要知道这些顾客。>>但事实上你发现去kfc点餐的时候，服务员并没有直接通知我们。而是采用叫号的方式。细想一下，你去kfc，是不是可以在点餐系统进行排号（网上或者排队，这里抽象一下），餐品好了以后，服务员输入点餐号，点一下完成即可，点餐系统会通知对应的顾客取餐。>>这里你和服务员之间的消息通过点餐系统来传递，你并不需要知道是谁点的完成，服务员也不需要知道这份餐品给谁。完美解耦了消息的发送者和接收者。更好地是，我们在点餐或者叫号的时候其实还可以指定行为，比如说66号产品好了以后帮我送到A1桌。>>再比如说炒股的时候，我们可以委托挂单，就是当股票到了某一个价格就帮你买入或者卖出，等等，例子很多##使用场景1.当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。2.当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象需要被改变。3.当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，不希望这些对象是紧密耦合的。##角色1.抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。2.具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。3.抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。4.具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。##实现![image-20210724195743639](.assets/image-20210724195743639.png)```typescriptinterfaceMsg{//Msg可以按照任意约定的接口格式去约束，这里假设是如下类型消息name:stringvalue:string}interfaceSubject{registerObserver(observer:Observer):voidremoveObserver(observer:Observer):voidnotifyObservers(msg:Msg):void}interfaceObserver{update(msg:Msg):void}classConcreteSubjectimplementsSubject{privateobservers:Observer[]=[]privatestate:object={}registerObserver(observer:Observer):void{this.observers.push(observer)}removeObserver(observer:Observer):void{constindex=this.observers.findIndex((val)=>val===observer)if(index>-1){this.observers.splice(index,1)}}notifyObservers(msg:Msg):void{this.observers.forEach((observer)=>observer.update(msg))}setState(name,value):void{this.state[name]=valueconsole.log(`${name}状态更新为：${value}`)console.log('通知所有观察者')this.notifyObservers({name,value,})}}classConcreteObserverimplementsObserver{name:stringconstructor(name:string){this.name=name}update(msg:Msg):void{console.log(`${this.name}观察到：${msg.name}状态更新为：${msg.value}`)}}constconcreteSubject=newConcreteSubject()constconcreteObserver1=newConcreteObserver('小王')constconcreteObserver2=newConcreteObserver('小明')concreteSubject.registerObserver(concreteObserver1)concreteSubject.registerObserver(concreteObserver2)concreteSubject.setState('天气','多云')concreteSubject.removeObserver(concreteObserver2)concreteSubject.setState('天气','晴')```![image-20210724195806878](.assets/image-20210724195806878.png)>这里的Msg其实就是一种约定的消息接口，你甚至可以直接使用Subject，这样Subject和Observer就是一种双向关系（关联和依赖）。另外，这里的setState也只是对变更行为的一种抽象而已，你可以在任何事件或者任何时机通知订阅者进行更新。##小结>当一个对象密切关注另一个对象的某个状态时，就可以使用观察者模式。>>它解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。>>在使用轮询的地方，我们应该先考虑是否可以使用观察者模式。因为主动观察是优于被动轮询的。#发布订阅模式>发布-订阅是一种消息范式，消息的发布者，不会将消息直接发送给特定的`订阅者`，而是通过消息通道广播出去，然后呢，订阅者通过订阅获取到想要的消息。>>-各个模块相互独立>-存在一对多的依赖关系>-依赖模块不稳定,依赖关系部位定>-各模块由不同的人员,团队开发<imgsrc=\"观察者(发布-订阅)模式.assets/d739205f61014be8a8f0756fcf7c1cfatplv-k3u1fbpfcp-zoom-1.image\"alt=\"img\"style=\"zoom:50%;\"/><imgsrc=\"观察者(发布-订阅)模式.assets/66f97bd23566468182554fbac39fd009tplv-k3u1fbpfcp-zoom-1.image\"alt=\"img\"style=\"zoom:50%;\"/>>-建立一个`eventEmitter`>-先通过用户订阅对应的\"内容\">-`eventEmitter`发布内容##缩减版```jsleteventEmitter={}//公众号对象eventEmitter.list={}//缓存列表,存放event及fn/*订阅*/eventEmitter.on=function(event,fn){;(this.list[event]||(this.list[event]=[])).push(fn)returnthis}/*发布*/eventEmitter.emit=function(){const_this=thisletevent=[].shift.call(arguments,)/*使用shift获取arguments第一个参数就是对应的event值*/,fns=[..._this.list[event]]if(!fns||fns.length===0)returnfalse/*如果缓存列表里没有缓存fn,就直接返回false*/fns.forEach((fn)=>{//遍历event值对应的缓存列表,依次执行fnfn.apply(_this,arguments)})return_this}/*用户一*/functionuser1(content){console.log('用户1订阅了:',content)}/*用户二*/functionuser2(content){console.log('用户2订阅了:',content)}//订阅eventEmitter.on('article',user1)eventEmitter.on('article',user2)//发布eventEmitter.emit('article','Javascript发布-订阅模式')```##完整版>node中EventEmitter就是这样一个典型例子。我们来简单实现一个EventEmitter。```javascriptinterfaceHandlerInfo{handler:Function;once?:boolean;}classEventEmitter{privateevents:Map<string,HandlerInfo[]>=newMap();on(type:string,handler:Function,once?:boolean){if(!this.events.has(type)){this.events.set(type,[]);}(this.events.get(type)||[]).push({handler,once,});return()=>{this.off(type,handler);};}once(type:string,handler:Function){returnthis.on(type,handler,true);}emit(type:string,...args){leti=0;while(i<(this.events.get(type)||[]).length){//这里每次都从this.events去动态读取，方中途被变更consthandlers:HandlerInfo[]=this.events.get(type)||[];const{handler,once}=handlers[i];//如果是一次性的，应该在调用前删除，防止这里会自己触发自己，导致无限循环或者次序错乱if(once){handlers.splice(i--,1);}i++;handler(...args);//这里this就交给传入的handler来保证了}}off(type?:string,handler?:Function):void{if(!type)return;//最好不要默认全部清除，不安全if(!handler){this.events.set(type,[]);//因为这里是直接赋值清空，所以在emit的时候，记得每次都从events动态获取return;}this.events.set(type,(this.events.get(type)||[]).filter(item=>item.handler!==handler));}}consteventEmitter=newEventEmitter();classPerson{publicname:string;constructor(name:string){this.name=name;}weatherSubscribe(once?:boolean):Function{returneventEmitter.on('weather',(weather)=>{switch(weather){case'雨':console.log(`${this.name}在家看电影`);break;default:console.log(`${this.name}出去玩`);}},once);}weatherNotify(weather){eventEmitter.emit('weather',weather);}}constxiaoWang=newPerson('小王');constxiaoMing=newPerson('小明');constxiaoZhang=newPerson('小张');xiaoWang.weatherSubscribe(true);constoff=xiaoMing.weatherSubscribe();xiaoZhang.weatherNotify('雨');xiaoZhang.weatherNotify('晴');off();xiaoZhang.weatherNotify('晴');```![image-20210724195933611](<观察者(发布-订阅)模式.assets/image-20210724195933611.png>)发布订阅模式可以说是对观察者模式的进一步抽象。我们通过消息中心对消息进行统一处理，那么这里通知者和消费者的关系其实被弱化了，它们可以是任意对象，通知者和消费者也可以是同一个对象，这种模式甚至在非对象也可以使用，即我们只关注发布和订阅行为本身，而不关心发布订阅者是谁。","Knowledge\\架构&相关\\设计模式\\行为型\\解释器模式.md":"#解释器模式>解释器模式(InterpreterPattern)：>>-定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。>>**优点：**>>-易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。>-每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。>-实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。>-增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。>>**缺点：**>>-对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。>-执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。![解释器模式的UML图](https://www.runoob.com/wp-content/uploads/2014/08/interpreter_pattern_uml_diagram.jpg)##TS```typescriptinterfaceIExpression{interpret:(context:string)=>boolean}typeTExpression=IExpression|nullclassExpressionimplementsIExpression{interpret(context:string):boolean{console.log('expression')returntrue}}classTerminalExpressionimplementsIExpression{privatedata:string=''publicinterpret(context:string):boolean{//console.log('TerminalExpressioninterpret')returncontext===this.data}constructor(data:string){this.data=data}}classOrExpresssionimplementsIExpression{privateexpr1:TExpression=nullprivateexpr2:TExpression=nullconstructor(expr1:TExpression,expr2:TExpression){this.expr1=expr1this.expr2=expr2}publicinterpret(context:string):boolean{//console.log('OrExpresssioninterpret')returnthis.expr1?.interpret(context)||this.expr2?.interpret(context)?true:false}}classAndExpresssionimplementsIExpression{privateexpr1:TExpression=nullprivateexpr2:TExpression=nullpublicinterpret(context:string):boolean{//console.log('AndExpressioninterpret')//returntrue;returnthis.expr1?.interpret(context)&&this.expr2?.interpret(context)?true:false}constructor(expr1:TExpression,expr2:TExpression){this.expr1=expr1this.expr2=expr2}}//开始测试constgetMaleExpression=():OrExpresssion=>{letrebert:TExpression=newTerminalExpression('Robert')letjohn:TExpression=newTerminalExpression('John')returnnewOrExpresssion(rebert,john)}constgetMarriedWomanExpression=():AndExpresssion=>{letjulie:TExpression=newTerminalExpression('Julie')letmarried:TExpression=newTerminalExpression('Married')returnnewAndExpresssion(julie,married)}constisMale=getMaleExpression()constisMarriedWoman=getMarriedWomanExpression()console.log('Johnismale?',isMale.interpret('John'))console.log('Julieisamarriedwomen?',isMarriedWoman.interpret('MarriedJulie'),)```","Knowledge\\架构&相关\\设计模式\\行为型\\访问者模式.md":"#访问者模式>-访问者模式(Visitor):>-提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作>>优点:>>1.扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。>2.复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。>3.灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。>4.符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。>>缺点:>>1.增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。>2.破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。>3.违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。![image-20210806181011765](.assets/image-20210806181011765.png)```javapublicclassVisitorPattern{publicstaticvoidmain(String[]args){ObjectStructureos=newObjectStructure();os.add(newConcreteElementA());os.add(newConcreteElementB());Visitorvisitor=newConcreteVisitorA();os.accept(visitor);System.out.println(\"------------------------\");visitor=newConcreteVisitorB();os.accept(visitor);}}//抽象访问者interfaceVisitor{voidvisit(ConcreteElementAelement);voidvisit(ConcreteElementBelement);}//具体访问者A类classConcreteVisitorAimplementsVisitor{publicvoidvisit(ConcreteElementAelement){System.out.println(\"具体访问者A访问-->\"+element.operationA());}publicvoidvisit(ConcreteElementBelement){System.out.println(\"具体访问者A访问-->\"+element.operationB());}}//具体访问者B类classConcreteVisitorBimplementsVisitor{publicvoidvisit(ConcreteElementAelement){System.out.println(\"具体访问者B访问-->\"+element.operationA());}publicvoidvisit(ConcreteElementBelement){System.out.println(\"具体访问者B访问-->\"+element.operationB());}}//抽象元素类interfaceElement{voidaccept(Visitorvisitor);}//具体元素A类classConcreteElementAimplementsElement{publicvoidaccept(Visitorvisitor){visitor.visit(this);}publicStringoperationA(){return\"具体元素A的操作。\";}}//具体元素B类classConcreteElementBimplementsElement{publicvoidaccept(Visitorvisitor){visitor.visit(this);}publicStringoperationB(){return\"具体元素B的操作。\";}}//对象结构角色classObjectStructure{privateList<Element>list=newArrayList<Element>();publicvoidaccept(Visitorvisitor){Iterator<Element>i=list.iterator();while(i.hasNext()){((Element)i.next()).accept(visitor);}}publicvoidadd(Elementelement){list.add(element);}publicvoidremove(Elementelement){list.remove(element);}}```运行结果```shell具体访问者A访问-->具体元素A的操作。具体访问者A访问-->具体元素B的操作。------------------------具体访问者B访问-->具体元素A的操作。具体访问者B访问-->具体元素B的操作。```##ts```typescript//简易版(由于ts不可以重名方法)classVisitor{visitStr(str:string){console.log(str)}visitNum(num:number){console.log(num)}visit(obj:any):void{//console.log(typeofobj)if(typeofobj==='number')this.visitNum(obj)if(typeofobj==='string')this.visitStr(obj)}}letn:number=123lets:string='123str'constv=newVisitor()v.visit(n)v.visit(s)```","Knowledge\\架构&相关\\设计模式\\行为型\\迭代器模式.md":"#迭代器模式>迭代器模式(IteratorPattern):提供一种方法来访问聚合对象,而不是暴露这个对象的内部表示,其名为游标(Cursor)>>java中的Collection,list,Set,Map都包含迭代>>优点:>>1.访问一个聚合对象的内容而无须暴露它的内部表示。>2.遍历任务交由迭代器完成，这简化了聚合类。>3.它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。>4.增加新的聚合类和迭代器类都很方便，无须修改原有代码。>5.封装性良好，为遍历不同的聚合结构提供一个统一的接口。![image-20210806180459755](.assets/image-20210806180459755-16282443030715.png)#Java```javapublicclassIteratorPattern{publicstaticvoidmain(String[]args){Aggregateag=newConcreteAggregate();ag.add(\"中山大学\");ag.add(\"华南理工\");ag.add(\"韶关学院\");System.out.print(\"聚合的内容有：\");Iteratorit=ag.getIterator();while(it.hasNext()){Objectob=it.next();System.out.print(ob.toString()+\"\\t\");}Objectob=it.first();System.out.println(\"\\nFirst：\"+ob.toString());}}//抽象聚合interfaceAggregate{publicvoidadd(Objectobj);publicvoidremove(Objectobj);publicIteratorgetIterator();}//具体聚合classConcreteAggregateimplementsAggregate{privateList<Object>list=newArrayList<Object>();publicvoidadd(Objectobj){list.add(obj);}publicvoidremove(Objectobj){list.remove(obj);}publicIteratorgetIterator(){return(newConcreteIterator(list));}}//抽象迭代器interfaceIterator{Objectfirst();Objectnext();booleanhasNext();}//具体迭代器classConcreteIteratorimplementsIterator{privateList<Object>list=null;privateintindex=-1;publicConcreteIterator(List<Object>list){this.list=list;}publicbooleanhasNext(){if(index<list.size()-1){returntrue;}else{returnfalse;}}publicObjectfirst(){index=0;Objectobj=list.get(index);;returnobj;}publicObjectnext(){Objectobj=null;if(this.hasNext()){obj=list.get(++index);}returnobj;}}```执行结果```shell聚合的内容有：中山大学华南理工韶关学院First：中山大学```##TS```typescripttypeTObject=Object|undefined|null|string//抽象迭代器interfaceIIterator{first:()=>TObjectnext:()=>TObjecthasNext:()=>boolean}//具体迭代器classConcreteIteratorimplementsIIterator{privatelist:TObject[]=[]privateindex:number=-1publicconstructor(list:Array<TObject>){this.list=list}publicfirst():TObject{returnthis.list[0]}publicnext():TObject{returnthis.list[++this.index]}publichasNext():boolean{returnthis.index<this.list.length-1}}//抽象聚合接口interfaceIAggregate{add:(obj:TObject)=>voidremove:(obj:TObject)=>voidgetIterator:()=>IIterator}//抽象聚合类classAggregate{publicadd(obj:TObject):void{}publicremove(obj:TObject):void{}publicgetIterator():IIterator{returnnewConcreteIterator(newArray())}}//具体聚合classConcreteAggregateimplementsIAggregate{privatelist:TObject[]=[]publicadd(obj:TObject):void{this.list.push(obj)}publicremove(obj:TObject):void{this.list=this.list.map((item)=>{if(item===obj)returnreturnitem}).filter((i)=>i)}publicgetIterator():IIterator{returnnewConcreteIterator(this.list)}}constag:IAggregate=newConcreteAggregate()ag.add('111')ag.add('222')ag.add('333')constit:IIterator=ag.getIterator()while(it.hasNext()){console.log(it.next())}//输出111222333```","Knowledge\\架构&相关\\设计模式\\设计原则\\依赖倒置.md":"#依赖倒置>-高层模块不应该依赖低层模块，两者都应该依赖其抽象（模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的）>-抽象不应该依赖细节（接口或抽象类不依赖于实现类）>-细节应该依赖抽象（实现类依赖接口或抽象类）>-`依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性`>-每个类尽量提供接口或抽象类，或者两者都具备。>-变量的声明类型尽量是接口或者是抽象类。>-任何类都不应该从具体类派生。>-使用继承时尽量遵循里氏替换原则。##作用-依赖倒置原则可以降低类间的耦合性。-依赖倒置原则可以提高系统的稳定性。-依赖倒置原则可以减少并行开发引起的风险。-依赖倒置原则可以提高代码的可读性和可维护性。##Eg分析：本程序反映了“顾客类”与“商店类”的关系。商店类中有sell()方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店ShaoguanShop购物：```javaclassCustomer{publicvoidshopping(ShaoguanShopshop){//购物System.out.println(shop.sell());}}```但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店WuyuanShop）购物，就要将该顾客的代码修改如下：```javaclassCustomer{publicvoidshopping(WuyuanShopshop){//购物System.out.println(shop.sell());}}```顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口Shop，顾客类面向该接口编程，其代码修改如下：```javaclassCustomer{publicvoidshopping(Shopshop){//购物System.out.println(shop.sell());}}```这样，不管顾客类Customer访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图1所示。![顾客购物程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif)图1顾客购物程序的类图程序代码如下：```javapackageprinciple;publicclassDIPtest{publicstaticvoidmain(String[]args){Customerwang=newCustomer();System.out.println(\"顾客购买以下商品：\");wang.shopping(newShaoguanShop());wang.shopping(newWuyuanShop());}}//商店interfaceShop{publicStringsell();//卖}//韶关网店classShaoguanShopimplementsShop{publicStringsell(){return\"韶关土特产：香菇、木耳……\";}}//婺源网店classWuyuanShopimplementsShop{publicStringsell(){return\"婺源土特产：绿茶、酒糟鱼……\";}}//顾客classCustomer{publicvoidshopping(Shopshop){//购物System.out.println(shop.sell());}}```程序的运行结果如下：```顾客购买以下商品：韶关土特产：香菇、木耳……婺源土特产：绿茶、酒糟鱼……```","Knowledge\\架构&相关\\设计模式\\设计原则\\六大原则.md":"#六大原则##单一责任原则>接口和方法必须保证单一责任原则,类不必保证,只要符合业务即可.##里氏替换原则>-如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。>-所有引用基类的地方必须能透明地使用其子类的对象。##依赖倒置原则>-高层模块不应该依赖低层模块，两者都应该依赖其抽象（模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的）>-抽象不应该依赖细节（接口或抽象类不依赖于实现类）>-细节应该依赖抽象（实现类依赖接口或抽象类）##接口隔离原则>-客户端不应该依赖它不需要的接口>-类间的依赖关系应该建立在最小的接口上。##迪米特原则>-每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元>-每个单元只能和它的朋友交谈：不能和陌生单元交谈>-只和自己直接的朋友交谈##开闭原则>-软件中的对象（类，模块，函数等等）应该对于`扩展是开放`的，但是对于`修改是封闭`的","Knowledge\\架构&相关\\设计模式\\设计原则\\单一责任.md":"#单一责任>-单一职责原则（SingleResponsibilityPrinciple，SRP）又称单一功能原则>-这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分>-`一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用`##优点-降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。-提高类的可读性。复杂性降低，自然其可读性会提高。-提高系统的可维护性。可读性提高，那自然更容易维护了。-变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。","Knowledge\\架构&相关\\设计模式\\设计原则\\合并复用.md":"#合并复用>-又名:`组合/聚合复用原则`##合成复用原则的重要性通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。1.继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为`“白箱”复用`2.子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。3.它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。1.它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。2.新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。3.复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。##合成复用原则的实现方法合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。##Eg![用继承关系实现的汽车分类的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113160133151.gif)![用组合关系实现的汽车分类的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q11316034X57.gif)","Knowledge\\架构&相关\\设计模式\\设计原则\\开闭原则.md":"#开闭原则>-软件中的对象（类，模块，函数等等）应该对于`扩展是开放`的，但是对于`修改是封闭`##作用####1.对软件测试的影响软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。####2.可以提高代码的可复用性粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。####3.可以提高软件的可维护性遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。##实现可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。##Eg![Windows的桌面主题类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113100151L5.gif)","Knowledge\\架构&相关\\设计模式\\设计原则\\接口隔离.md":"#接口隔离>-客户端不应该依赖它不需要的接口>-类间的依赖关系应该建立在最小的接口上。##优点>1.将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。>2.接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。>3.如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。>4.使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。>5.能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。##实现>-接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。>-为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。>-了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。>-提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。##Eg![学生成绩管理程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113141Q0X3.gif)```javapackageprinciple;publicclassISPtest{publicstaticvoidmain(String[]args){InputModuleinput=StuScoreList.getInputModule();CountModulecount=StuScoreList.getCountModule();PrintModuleprint=StuScoreList.getPrintModule();input.insert();count.countTotalScore();print.printStuInfo();//print.delete();}}//输入模块接口interfaceInputModule{voidinsert();voiddelete();voidmodify();}//统计模块接口interfaceCountModule{voidcountTotalScore();voidcountAverage();}//打印模块接口interfacePrintModule{voidprintStuInfo();voidqueryStuInfo();}//实现类classStuScoreListimplementsInputModule,CountModule,PrintModule{privateStuScoreList(){}publicstaticInputModulegetInputModule(){return(InputModule)newStuScoreList();}publicstaticCountModulegetCountModule(){return(CountModule)newStuScoreList();}publicstaticPrintModulegetPrintModule(){return(PrintModule)newStuScoreList();}publicvoidinsert(){System.out.println(\"输入模块的insert()方法被调用！\");}publicvoiddelete(){System.out.println(\"输入模块的delete()方法被调用！\");}publicvoidmodify(){System.out.println(\"输入模块的modify()方法被调用！\");}publicvoidcountTotalScore(){System.out.println(\"统计模块的countTotalScore()方法被调用！\");}publicvoidcountAverage(){System.out.println(\"统计模块的countAverage()方法被调用！\");}publicvoidprintStuInfo(){System.out.println(\"打印模块的printStuInfo()方法被调用！\");}publicvoidqueryStuInfo(){System.out.println(\"打印模块的queryStuInfo()方法被调用！\");}}```","Knowledge\\架构&相关\\设计模式\\设计原则\\迪米特.md":"#迪米特>-又名:`最少知识原则`>-每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元>-每个单元只能和它的朋友交谈：不能和陌生单元交谈>-只和自己直接的朋友交谈##优点>1.降低了类之间的耦合度，提高了模块的相对独立性。>2.由于亲合度降低，从而提高了类的可复用率和系统的扩展性。##实现>从迪米特法则的定义和特点可知，它强调以下两点：>>1.从依赖者的角度来说，只依赖应该依赖的对象。>2.从被依赖者的角度说，只暴露应该暴露的方法。>>所以，在运用迪米特法则时要注意以下6点。>>1.在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。>2.在类的结构设计上，尽量降低类成员的访问权限。>3.在类的设计上，优先考虑将一个类设置成不变类。>4.在对其他类的引用上，将引用其他对象的次数降到最低。>5.不暴露类的属性成员，而应该提供相应的访问器（set和get方法）。>6.谨慎使用序列化（Serializable）功能。##Eg![明星与经纪人的关系图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113152Q5W1.gif)```javapublicclassLoDtest{publicstaticvoidmain(String[]args){Agentagent=newAgent();agent.setStar(newStar(\"林心如\"));agent.setFans(newFans(\"粉丝韩丞\"));agent.setCompany(newCompany(\"中国传媒有限公司\"));agent.meeting();agent.business();}}//经纪人classAgent{privateStarmyStar;privateFansmyFans;privateCompanymyCompany;publicvoidsetStar(StarmyStar){this.myStar=myStar;}publicvoidsetFans(FansmyFans){this.myFans=myFans;}publicvoidsetCompany(CompanymyCompany){this.myCompany=myCompany;}publicvoidmeeting(){System.out.println(myFans.getName()+\"与明星\"+myStar.getName()+\"见面了。\");}publicvoidbusiness(){System.out.println(myCompany.getName()+\"与明星\"+myStar.getName()+\"洽淡业务。\");}}//明星classStar{privateStringname;Star(Stringname){this.name=name;}publicStringgetName(){returnname;}}//粉丝classFans{privateStringname;Fans(Stringname){this.name=name;}publicStringgetName(){returnname;}}//媒体公司classCompany{privateStringname;Company(Stringname){this.name=name;}publicStringgetName(){returnname;}}```","Knowledge\\架构&相关\\设计模式\\设计原则\\里氏替换.md":"#里氏替换>-如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。>-所有引用基类的地方必须能透明地使用其子类的对象。>-`子类可以扩展父类的功能，但不能改变父类原有的功能`>-子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法>-子类中可以增加自己特有的方法>-当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松>-当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等##作用>1.里氏替换原则是实现开闭原则的重要方式之一>2.它克服了继承中重写父类造成的可复用性变差的缺点>3.它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性>4.加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险##Eg![“几维鸟不是鸟”实例的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q11311094H32.gif)```javapublicclassLSPtest{publicstaticvoidmain(String[]args){Birdbird1=newSwallow();Birdbird2=newBrownKiwi();bird1.setSpeed(120);bird2.setSpeed(120);System.out.println(\"如果飞行300公里：\");try{System.out.println(\"燕子将飞行\"+bird1.getFlyTime(300)+\"小时.\");System.out.println(\"几维鸟将飞行\"+bird2.getFlyTime(300)+\"小时。\");}catch(Exceptionerr){System.out.println(\"发生错误了!\");}}}//鸟类classBird{doubleflySpeed;publicvoidsetSpeed(doublespeed){flySpeed=speed;}publicdoublegetFlyTime(doubledistance){return(distance/flySpeed);}}//燕子类classSwallowextendsBird{}//几维鸟类classBrownKiwiextendsBird{//这里重写了bird的方法,违背了里斯替换原则,这里应该不继承,或者继承一个更加普通的一般的父类类publicvoidsetSpeed(doublespeed){flySpeed=0;}}```运行结果```shell如果飞行300公里：燕子将飞行2.5小时.几维鸟将飞行Infinity小时。```![“几维鸟是动物”实例的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q11311101SN.gif)","Knowledge\\相关技术\\geojson.md":"#geoJSON```json{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Point\",\"coordinates\":[105.380859375,31.57853542647338]}}]}```![img](/.assets/img/2021-12-28-15-53-53.png)例子图片_（注：以下geojson的效果截图都来自[geojson.io](https://links.jianshu.com/go?to=http%3A%2F%2Fgeojson.io%2F%23map%3D2%2F20.0%2F0.0)在线生成）_geojson将所有的地理要素分为Point、MultiPoint、LineString、MultiLineString、Polygon、MultiPolygon、GeometryCollection。首先是将这些要素封装到单个的geometry里，然后作为一个个的Feature（也就是要素）；要素放到一个要素集合里，从树状结构来理解FeatureCollection就是根节点，表示为：```json{\"type\":\"FeatureCollection\",\"features\":[]}```所有地理要素放在features的列表里。###点要素Point点要素是最简单的，类型type对应Point，然后坐标是一个1维的数组，里面有两个元素（如果是立体的坐标就是三维x,y,z），分别为经度和纬度。properties里面可以封装各种属性，例如名称、标识颜色等等。```json{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Point\",\"coordinates\":[105.380859375,31.57853542647338]}}```###多点要素MultiPoint```json{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"MultiPoint\",\"coordinates\":[[105.380859375,31.57853542647338],[105.580859375,31.52853542647338]]}}```其核心坐标：```css105.380859375,31.57853542647338105.580859375,31.52853542647338```###线要素LineString线要素就是指线段，记录的是线的端点坐标，可视化时会按照记录顺序联结。对于曲线（如贝塞尔曲线）目前还没有很好的表达，但是在地理数据中，曲线一般会用LineString去拟合，现实地理世界中也没有标准的曲线地理要素。线要素的坐标coordinates里的二维数组和多点要素基本一样，区别就在type上了。```json{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"LineString\",\"coordinates\":[[105.6005859375,30.65681556429287],[107.95166015624999,31.98944183792288],[109.3798828125,30.031055426540206],[107.7978515625,29.935895213372444]]}}```对应的Kml表达：```xml<Placemark><ExtendedData></ExtendedData><LineString><coordinates>108.65753173828125,34.1873818599505108.72413635253905,34.25154099726973108.77151489257812,34.16977214177208108.88481140136719,34.229970811273084</coordinates></LineString></Placemark>```###MultiLineString也是一个三维数组（和多边形一样）；```json{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"MultiLineString\",\"coordinates\":[[[105.6005859375,30.65681556429287],[107.95166015624999,31.98944183792288],[109.3798828125,30.031055426540206],[107.7978515625,29.935895213372444]],[[109.3798828125,30.031055426540206],[107.1978515625,31.235895213372444]]]}}```###多边形Polygon注：单个多边形是一个3维数组，可以包含多个二维数组，这种情况和MultiPolygon效果很像。```json{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[106.10595703125,33.33970700424026],[106.32568359375,32.41706632846282],[108.03955078125,32.2313896627376],[108.25927734375,33.15594830078649],[106.10595703125,33.33970700424026]]]}}```###多多边形MultiPolygon####type1两个不会相交的多边形```json{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[109.2041015625,30.088107753367257],[115.02685546875,30.088107753367257],[115.02685546875,32.7872745269555],[109.2041015625,32.7872745269555],[109.2041015625,30.088107753367257]]],[[[112.9833984375,26.82407078047018],[116.69677734375,26.82407078047018],[116.69677734375,29.036960648558267],[112.9833984375,29.036960648558267],[112.9833984375,26.82407078047018]]]]}}```![img](/.assets/img/2021-12-28-15-55-04.png)两个不相交的多边形####type2两个镶套的多边形小的在前面，范围大的在后面，用上4个中括号，但效果不是有洞的```json{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[101.6455078125,27.68352808378776],[114.78515624999999,27.68352808378776],[114.78515624999999,35.209721645221386],[101.6455078125,35.209721645221386],[101.6455078125,27.68352808378776]]],[[[104.2822265625,30.107117887092357],[108.896484375,30.107117887092357],[108.896484375,33.76088200086917],[104.2822265625,33.76088200086917],[104.2822265625,30.107117887092357]]]]}}```![img](/.assets/img/2021-12-28-15-55-33.png)两个镶套的多边形####type3有孔洞的多边形```json{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[[[101.6455078125,27.68352808378776],[114.78515624999999,27.68352808378776],[114.78515624999999,35.209721645221386],[101.6455078125,35.209721645221386],[101.6455078125,27.68352808378776]],[[104.2822265625,30.107117887092357],[108.896484375,30.107117887092357],[108.896484375,33.76088200086917],[104.2822265625,33.76088200086917],[104.2822265625,30.107117887092357]]]]}}```![img](/.assets/img/2021-12-28-15-55-56.png)有孔洞的多边形可以仔细去品味type2和type3的区别。它们对应的kml表达区别是比较大的。###GeometryCollectionGeometryCollection是多种基本地理要素的集合，就是里面可以包含点、线、面要素。```json{\"type\":\"GeometryCollection\",\"geometries\":[{\"type\":\"Point\",\"coordinates\":[108.62,31.02819]},{\"type\":\"LineString\",\"coordinates\":[[108.896484375,30.107117887],[108.2184375,30.9171787],[109.5184375,31.217578]]}]}```GeometryCollection不需要放在FeatureCollection里：```json{\"type\":\"FeatureCollection\",\"features\":[]}```","Knowledge\\相关技术\\HTTP\\HTTP.md":"#HTTP##1.1什么是HTTPHTTP是一个连接客户端，网关和服务器的一个协议。##7.2特点支持客户/服务器模式：可以连接客户端和服务端；简单快速：请求只需传送请求方法，路径和请求主体；灵活：传输数据类型灵活；无连接：请求结束立即断开；无状态：无法记住上一次请求。##7.3怎么解决无状态和无连接无状态：HTTP协议本身无法解决这个状态，只有通过cookie和session将状态做贮存，常见的场景是登录状态保持；无连接：可以通过自身属性Keep-Alive。##7.4请求过程HTTP(S)请求地址→DNS解析→三次握手→发送请求→四次挥手三次握手过程图片来源CSDN）![3次握手.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d65b93d07fd74758a60a0ecb9c117200~tplv-k3u1fbpfcp-zoom-1.image)在这里插入图片描述1.四次挥手过（图片来源CSDN）![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a12c33ac8d04fec8f21eb5c4fc482ab~tplv-k3u1fbpfcp-zoom-1.image)在这里插入图片描述##7.5HTTP0.9~3.0对比###7.5.1HTTP0.9只允许客户端发送GET这一种请求；且不支持请求头，协议只支持纯文本；无状态性，每个访问独立处理，完成断开；无状态码。###7.5.2HTTP1.0有身份认证，三次握手；请求与响应支持头域；请求头内容；|属性名|含义||--|--|--||Accept|可接受的MIME类型||Accept-Encoding|数据可解码的格式||Accept-Language|可接受语言||Connection|值keep-alive是长连接||Host|主机和端口||Pragma|是否缓存,指定no-cache返回刷新||Referer|页面路由||If-Modified-Since|值为时间|响应头内容；|属性名|含义||-|-|-||Connection|值keep-alive是长连接||Content-Type|返回文档类型,常见的值有text/plain,text/html,text/json||Date|消息发送的时间||Server|服务器名字||Last-Modified|值为时间,s返回的最后修改时间||Expires|缓存过期时间,b和s时间做对比|注意expires是响应头内容，返回一个固定的时间,缺陷是时间到了服务器要重新设置;请求头中如果有If-Modified-Since，服务器会将时间与last-modified对比，相同返回304;响应对象以一个响应状态行开始;响应对象不只限于超文本;支持GET、HEAD、POST方法;有状态码;支持长连接（但默认还是使用短连接）、缓存机制以及身份认证。###7.5.3HTTP1.1请求头增加Cache-Control|属性名|含义||-|-|-||Cache-Control|在1.1引入的方法,指定请求和响应遵循的缓存机制,值有:public(b和s都缓存),private(b缓存),no-cache(不缓存),no-store(不缓存),max-age(缓存时间,s为单位),min-fresh(最小更新时间),max-age=3600||If-None-Match|上次请求响应头返回的etag值响应头增加Cache-Control，表示所有的缓存机制是否可以缓存及哪种类型etag返回的哈希值,第二次请求头携带去和服务器值对比|注意Cache-Control的max-age返回是缓存的相对时间Cache-Control优先级比expires高缺点：不能第一时间拿到最新修改文件###7.5.4HTTP2.0采用二进制格式传输;多路复用，其实就是将请求数据分成帧乱序发送到TCP中。TCP只能有一个steam，所以还是会阻塞;报头压缩;服务器推送主动向B端发送静态资源，避免往返延迟。###7.5.5HTTP3.01.是基于QUIC协议，基于UDP2.特点:自定义连接机制：TCP以IP/端口标识,变化重新连接握手，UDP是一64位ID标识，是无连接；自定义重传机制：TCP使用序号和应答传输，QUIC是使用递增序号传输；无阻塞的多路复用：同一条QUIC可以创建多个steam。###7.5.6HTTPS1.https是在http协议的基础上加了个SSL；2.主要包括\u0010：握手(凭证交换和验证)和记录协议(数据进行加密)。###7.5.7缓存1.按协议分：协议层缓存和非http协议缓存：1.1协议层缓存：利用http协议头属性值设置；1.2非协议层缓存：利用meta标签的http-equiv属性值Expires,set-cookie。2.按缓存分：强缓存和协商缓存：2.1强缓存：利用cache-control和expires设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；2.2协商缓存：响应头返回etag或last-modified的哈希值，第二次请求头If-none-match或IF-modify-since携带上次哈希值，一致则返回304。3.协商缓存对比：etag优先级高于last-modified；4.etag精度高，last-modified精度是s，1s内etag修改多少次都会被记录；last-modified性能好，etag要得到hash值。5.浏览器读取缓存流程：会先判断强缓存；再判断协商缓存etag(last-modified)是否存在；存在利用属性If-None-match(If-Modified-since)携带值；请求服务器,服务器对比etag(last-modified)，生效返回304。F5刷新会忽略强缓存不会忽略协商缓存，ctrl+f5都失效###7.5.8状态码|序列|详情||-|-|-||1XX(通知)|||2XX(成功)|200(成功)、201(服务器创建)、202(服务器接收未处理)、203(非授权信息)、204(未返回内容)、205(重置内容)、206(部分内容)||3XX(重定向)|301(永久移动)、302(临时移动)、303(查看其他位置)、304(未修改)、305(使用代理)、307(临时重定向)||4XX(客户端错误)|400(错误请求)、401(未授权)、403(禁止)、404(未找到)、405(方法禁用)、406(不接受)、407（需要代理授权）||5XX(服务器错误)|500(服务器异常)、501（尚未实施）、502（错误网关）、503（服务不可用）、504（网关超时）、505（HTTP版本不受支持）|###7.5.9浏览器请求分析![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fc332eae3354d06a9802e8a7713594c~tplv-k3u1fbpfcp-zoom-1.image)###7.5.10总结协议|版本|内容||-|-|-||http0.9|只允许客户端发送GET这一种请求;且不支持请求头,协议只支持纯文本;无状态性,每个访问独立处理,完成断开;无状态码http1.0解决0.9的缺点,增加If-modify-since(last-modify)和expires缓存属性||http1.x|增加cache-control和If-none-match(etag)缓存属性||http2.0|采用二进制格式传输;多路复用;报头压缩;服务器推送||http3.0|采用QUIC协议,自定义连接机制;自定义重传机制;无阻塞的多路复用|缓存|类型|特性||-|-|-||强缓存|通过If-modify-since(last-modify)、expires和cache-control设置，属性值是时间，所以在时间内不用请求||协商缓存|通过If-none-match(etag)设置，etag属性是哈希值，所以要请求和服务器值对比|","Knowledge\\相关技术\\HTTP\\HTTP缓存.md":"#HTTP缓存##前言在请求一个静态文件的时候（图片，css，js）等，这些文件的特点是文件不经常变化，将这些不经常变化的文件存储起来，对客户端来说是一个优化用户浏览体验的方法。那么这个就是客户端缓存的意义了。Http缓存机制作为web性能优化的重要手段，对于从事Web开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。在此，我会尝试用简单明了的文字，像大家系统的介绍HTTP缓存机制，期望对各位正确的理解前端缓存有所帮助。##缓存规则解析HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。已存在缓存数据时，仅基于强制缓存，请求数据的流程如下：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/89f3cf045a8f9788bbc6d7f5d96f4d91~tplv-t2oaga2asx-watermark.awebp)已存在缓存数据时，仅基于对比缓存，请求数据的流程如下：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/46429b684e6f20bb06d2508c2e8c65c6~tplv-t2oaga2asx-watermark.awebp)对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。##强制缓存从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况。**Expires**Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires是HTTP1.0的东西，现在默认浏览器均默认使用HTTP1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP1.1的版本，使用Cache-Control替代。**Cache-Control**Cache-Control是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。​```private:客户端可以缓存public:客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx:缓存的内容将在xxx秒后失效no-cache:需要使用对比缓存来验证缓存数据（后面介绍）no-store:所有内容都不会缓存，强制缓存，对比缓存都不会触发```（对于前端开发来说，缓存越多越好，so...基本上和它说886）举个例子：![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/578c199c387ebd0af406544ab040f325~tplv-t2oaga2asx-watermark.awebp)图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。没懂的话，我们换通俗一点的话来说一遍。当客户端第一次访问资源的时候，服务端在返回资源内容的同时也返回了Expires:Sun,16Oct201605:43:02GMT。服务端告诉浏览器：你Y的先把这个文件给我缓存起来，在这个过期时间之前，这个文件都不会变化了，你下次需要这个文件的时候，你就不要过来找我要了，你就去缓存中拿就好了，又快又好。浏览器回答说：诺。于是在第二次html页面中又要访问这个资源的时候，并且访问的日期在Sun,16Oct201605:43:02GMT之前，浏览器就不去服务器那边获取文件了，自己从缓存中自食其力了。但是呢，浏览器毕竟是在客户端的，客户端的时间可是不准确的，用户可以随着自己的喜好修改自己机器的时间，比如我把我机器的时间调成Sun,16Oct201605:43:03GMT，那么呢？我的浏览器就不会再使用缓存了，而每次都去服务器获取文件。于是，服务器怒了：给你个绝对时间，你由于环境被修改没法判断过期，那么我就给你相对时间吧。于是就返回了Cache-Control:max-age:600，浏览器你给我缓存个10分钟去。于是浏览器只有乖乖的缓存10分钟了。但是问题又来了，如果有的服务器同时设置了Expires和Cache-Control怎么办呢？（不是闲的没事干，而是由于Cache-Controll是HTTP1.1中才有的）那么就是根据更先进的设置Cache-Control来为标准。好了，现在有个问题，我有个文件可能时不时会更新，服务端非常希望客户端能时不时过来问一下这个文件是否过期，如果没有过期，服务端不返回数据给你，只告诉浏览器你的缓存还没有过期（304）。然后浏览器使用自己存储的缓存来做显示。这个就叫做条件请求。##对比缓存对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。**Last-Modified/If-Modified-Since**Last-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/53399e6fdae3663582b4eacf6a83ad2c~tplv-t2oaga2asx-watermark.awebp)If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP304，告知浏览器继续使用所保存的cache。![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/fd379f9eb07037e7dc3d0854237001cf~tplv-t2oaga2asx-watermark.awebp)**Etag/If-None-Match（优先级高于Last-Modified/If-Modified-Since）**第一次客户端访问资源的时候，服务端返回资源内容的同时返回了ETag：1234，告诉客户端：这个文件的标签是1234，我如果修改了我这边的资源的话，这个标签就会不一样了。第二次客户端访问资源的时候，由于缓存中已经有了Etag为1234的资源，客户端要去服务端查询的是这个资源有木有过期呢？所以带上了If-None-Match:1234。告诉服务端：如果你那边的资源还是1234标签的资源，你就返回304告诉我，不需要返回资源内容了。如果不是的话，你再返回资源内容给我就行了。服务端就比较下Etag来看是返回304还是200。![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/a9f97f1bf78e39d0b5da940feeb07d46~tplv-t2oaga2asx-watermark.awebp)##各种刷新理解了上面的缓存标签之后就很好理解各种刷新了。刷新有三种​```浏览器中写地址，回车F5Ctrl+F5```假设对一个资源：浏览器第一次访问，获取资源内容和cache-control:max-age:600，Last_Modify:Wed,10Aug201315:32:18GMT于是浏览器把资源文件放到缓存中，并且决定下次使用的时候直接去缓存中取了。浏览器url回车浏览器发现缓存中有这个文件了，好了，就不发送任何请求了，直接去缓存中获取展现。（最快）下面我按下了F5刷新F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since：Wed,10Aug201315:32:18GMT然后服务器发现：诶，这个文件我在这个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中欢欢喜喜获取资源了。但是呢，下面我们按下了Ctrl+F5这个可是要命了，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作...还有说一下，那个ETag实际上很少人使用，因为它的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用etag了。通过网络获取内容既缓慢，成本又高：大的响应需要在客户端和服务器之间进行多次往返通信，这拖延了浏览器可以使用和处理内容的时间，同时也增加了访问者的数据成本。因此，缓存和重用以前获取的资源的能力成为优化性能很关键的一个方面。##序本文用于解决以下六个疑问。-与缓存相关的HTTP首部字段主要**有哪些**？-这些HTTP首部字段之间的**联系与区别**？-HTTP缓存首部字段的**优先级**？-HTTP缓存首部字段的**特点与局限性**？-用户**不同的页面刷新行为的差别**？-在**实践中**我们该用哪些报文头来**控制缓存**呢？文中使用的1.html以及doge.png如下所示```<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"><title>缓存控制测试</title></head><body><imgsrc=\"doge.png\"></body></html>```![img](http://imweb-io-1251594266.file.myqcloud.com/Fi4kT2Bo5j9leo6R-cpAYDWjYQsT)##那些年与缓存相关的HTTP首部字段我们先来瞅一眼RFC2616规定的47种http报文首部字段中与缓存相关的字段，事先了解一下能让咱在心里有个底：####1.通用首部字段![img](http://imweb-io-1251594266.file.myqcloud.com/Fn0lDNSZimjgnv4kWcFrWnjHglUL)####2.请求首部字段![img](http://imweb-io-1251594266.file.myqcloud.com/Fj6XVLriM7AK6edaqOhxq8Om4lSe)####3.响应首部字段![img](http://imweb-io-1251594266.file.myqcloud.com/FgbZCbHn1jXX1zgb7xl9EzUNOC9q)####4.实体首部字段![img](http://imweb-io-1251594266.file.myqcloud.com/FtoiFQmDwRbKc5iVUlaVAtnMrm8_)##石器时代的缓存方式在http1.0时代，给客户端设定缓存方式可通过两个字段——`Pragma`和`Expires`来规范。虽然这两个字段早可抛弃，但为了做http协议的向下兼容，你还是可以看到很多网站依旧会带上这两个字段。例如在访问[腾讯课堂](https://ke.qq.com/)的时候，通过浏览器调试工具可以看到部分HTTP响应是包含Expires头部的。####1.Pragma当该字段值为`no-cache`的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。举个例子：![img](http://imweb-io-1251594266.file.myqcloud.com/Fgepo1U4TpvLzrCgijtJgc2HPguc)通过Fiddler给图片资源额外增加以下头部信息```Cache-Control:public,max-age=86400Pragma:no-cache```前者用来设定缓存资源一天，后者禁用缓存。重新访问该页面会发现访问该资源会重新发起一次请求，同时以上例子也能说明**Pragma的优先级是高于Cache-Control**的。####2.Expires有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http1.0而言，Expires就是做这件事的首部字段。Expires的值对应一个GMT（格林尼治时间），比如`Mon,22Jul200211:12:01GMT`来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。同样举个例子：![img](http://imweb-io-1251594266.file.myqcloud.com/FlqXQRLmgAPjtGcHBkzV1ZowuqzW)通过Fiddler给图片资源额外加上以下头部信息```Expires:Fri,11Jun202111:33:01GMT```重新访问该页面会发现访问图片资源的时候，会直接从缓存中读取资源内容，而不发起请求。![img](http://imweb-io-1251594266.file.myqcloud.com/FtgNGyP0qFhW7GI2KXeGIxv6-zku)如果Pragma头部和Expires头部同时存在，则起作用的会是Pragma，有兴趣的同学可以自己试一下。需要注意的是，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，其定义的是资源“失效时刻”，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。##Cache-Control针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了Cache-Control来定义缓存过期时间。注意：若报文中同时出现了Expires和Cache-Control，则以Cache-Control为准。也就是说优先级从高到低分别是**Pragma->Cache-Control->Expires**。Cache-Control也是一个通用首部字段，这意味着它能分别在请求报文和响应报文中使用。在RFC中规范了Cache-Control的格式为：```\"Cache-Control\"\":\"cache-directive```作为请求首部时，cache-directive的可选值有：![img](http://imweb-io-1251594266.file.myqcloud.com/FkctxGN8VXdie7M8Fbx6U5Bpfi4c)作为响应首部时，cache-directive的可选值有：![img](http://imweb-io-1251594266.file.myqcloud.com/FixnilG9OWm4w4qUNZGKSkYXZ4gu)Cache-Control允许自由组合可选值，例如：```Cache-Control:max-age=3600,must-revalidate```它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。当然这种组合的方式也会有些限制，比如no-cache就不能和max-age、min-fresh、max-stale一起搭配使用。##缓存校验字段上述的首部字段均能让客户端决定是否向服务器发送请求，比如设置的缓存时间未过期，那么自然直接从本地缓存取数据即可（在chrome下表现为200fromcache），若缓存时间过期了或资源不该直接走缓存，则会发请求到服务器去。我们现在要说的问题是，**如果客户端向服务器发了请求，那么是否意味着一定要读取回该资源的整个实体内容呢？**我们试着这么想——客户端上某个资源保存的缓存时间过期了，但这时候其实服务器并没有更新过这个资源，如果这个资源数据量很大，客户端要求服务器再把这个东西重新发一遍过来，是否非常浪费带宽和时间呢？答案是肯定的，那么是否有办法让服务器知道客户端现在存有的缓存文件，其实跟自己所有的文件是一致的，然后直接告诉客户端说“这东西你直接用缓存里的就可以了，我这边没更新过呢，就不再传一次过去了”。举例来说：```C：小服，你几岁了？S：小客，我18岁了。=================================C：小服，你几岁了？我猜你18岁了。S：靠，你知道还问我？（304）=================================C：小服，你几岁了？我猜你18岁了。S：小客，我19岁了。（200）```为了让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，Http1.1新增了几个首部字段来做这件事情。###1.Last-Modified服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified:GMT”的形式加在实体首部上一起返回给客户端。```Last-Modified:Fri,22Jul201601:47:00GMT```客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回`304`状态码，**内容为空**，这样就节省了传输数据量。如果两个时间不一致，则服务器会发回该资源并返回`200`状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个`304`响应比一个静态资源通常小得多，这样就节省了网络带宽。![img](http://imweb-io-1251594266.file.myqcloud.com/FozLFZKB5y67NUSXLhioLseHJYbE)至于传递标记起来的最终修改时间的请求报文首部字段一共有两个：####⑴If-Modified-Since:Last-Modified-value示例为If-Modified-Since:Thu,31Mar201607:07:52GMT该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送`304`和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的Last-Modified值。####⑵If-Unmodified-Since:Last-Modified-value该值告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回`412`(PreconditionFailed)状态码给客户端。Last-Modified存在一定问题，如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。###2.ETag为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了**ETag实体首部**字段。服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag:唯一标识符”一起返回给客户端。例如：```Etag:\"5d8c72a5edda8d6a:3239\"```客户端会保留该ETag字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET`200`回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回`304`知会客户端直接使用本地缓存即可。那么客户端是如何把标记在资源上的ETag传回给服务器的呢？请求报文中有两个首部字段可以带上ETag值：####⑴If-None-Match:ETag-value示例为If-None-Match:\"5d8c72a5edda8d6a:3239\"告诉服务端如果ETag没匹配上需要重发资源数据，否则直接回送`304`和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的ETag值。####⑵If-Match:ETag-value告诉服务器如果没有匹配到ETag，或者收到了“\\*”值而当前并没有该资源实体，则应当返回`412`(PreconditionFailed)状态码给客户端。否则服务器直接忽略该字段。需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。##缓存头部对比|头部|优势和特点|劣势和问题||:------------|:--------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------||Expires|1、HTTP1.0产物，可以在HTTP1.0和1.1中使用，简单易用。2、以时刻标识失效时间。|1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。2、存在版本问题，到期之前的修改客户端是不可知的。||Cache-Control|1、HTTP1.1产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。2、比Expires多了很多选项设置。|1、HTTP1.1才有的内容，不适用于HTTP1.0。2、存在版本问题，到期之前的修改客户端是不可知的。||Last-Modified|1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。|1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。2、以时刻作为标识，无法识别一秒内进行多次修改的情况。3、某些服务器不能精确的得到文件的最后修改时间。||ETag|1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。2、不存在版本问题，每次请求都回去服务器进行校验。|1、计算ETag值需要性能损耗。2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。|##用户刷新/访问行为我们可以把刷新/访问界面的手段分成三类：-在URI输入栏中输入然后回车/通过书签访问-F5/点击工具栏中的刷新按钮/右键菜单重新加载-Ctl+F5在浏览器中，有时候你会发现通过不同的手段访问/刷新界面页面的呈现速度是不一样的，那么它们到底有什么区别呢?以下对这三种访问情况进行实践与讨论。准备工作：为了模拟第一次访问某网站，清除相关缓存内容。为了方便讨论与对比，以下内容以[腾讯课堂](https://ke.qq.com/)的index.css文件为例。首次访问该网页，查看请求与响应信息可以看到请求头部没有任何关于http缓存相关的信息。而返回的HTTPresponse包含了以下头部信息。```Cache-Control:max-age=31104000Expires:Thu,20Jul201702:18:41GMTLast-Modified:Fri,15Jul201604:11:51GMT```浏览器会对该文件进行缓存，直到该文件过期、用户清空cache或者用户强制刷新资源时间。####1、在URI输入栏中输入然后回车我们可以看到返回响应码是`200OK(fromcache)`，浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容。其中响应内容和之前的响应内容一模一样，例如其中的Date时间是上一次响应的时间。![img](http://imweb-io-1251594266.file.myqcloud.com/FjNVji6ipMDCWCoe2jXfzgqFbF8k)所以我们也能看到该资源的Size为fromcache![img](http://imweb-io-1251594266.file.myqcloud.com/FiZd35wOPT30xVsbf8aWSSY8v_Cu)####2、F5/点击工具栏中的刷新按钮/右键菜单重新加载F5的作用和直接在URI输入栏中输入然后回车是不一样的，F5会让浏览器**无论如何都发一个HTTPRequest给Server**，即使先前的响应中有Expires头部。所以，当我在当前[腾讯课堂](https://ke.qq.com/)网页中按F5的时候，浏览器会发送一个HTTPRequest给Server，但是包含这样的Headers:```Cache-Control:max-age=0If-Modified-Since:Fri,15Jul201604:11:51GMT```其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送。实际上Server没有修改这个index.css文件，所以返回了一个`304(NotModified)`，这样的响应信息很小，所消耗的route-trip不多，网页很快就刷新了。![img](http://imweb-io-1251594266.file.myqcloud.com/FoGcVs6BvMvNLNM7KSvwEuHBaqDt)上面的例子中没有ETag，如果Response中包含ETag，F5引发的HttpRequest中也是会包含If-None-Match的。####3、Ctl+F5那么Ctrl+F5呢？Ctrl+F5要的是**彻底的从Server拿一份新的资源过来**，所以不光要发送HTTPrequest给Server，而且这个请求里面连If-Modified-Since/If-None-Match都没有，这样就逼着Server不能返回304，而是把整个资源原原本本地返回一份，这样，Ctrl+F5引发的传输时间变长了，自然网页Refresh的也慢一些。我们可以看到该操作返回了200，并刷新了相关的缓存控制时间。![img](http://imweb-io-1251594266.file.myqcloud.com/FonZrh_J5auduA4JaqZKW9hZqXrG)实际上，为了保证拿到的是从Server上最新的，Ctrl+F5不只是去掉了If-Modified-Since/If-None-Match，还需要添加一些HTTPHeaders。按照HTTP/1.1协议，Cache不光只是存在Browser终端，从Browser到Server之间的中间节点(比如Proxy)也可能扮演Cache的作用，为了防止获得的只是这些中间节点的Cache，需要告诉他们，别用自己的Cache敷衍我，往Upstream的节点要一个最新的copy吧。在Chrome51中会包含两个头部信息，作用就是让中间的Cache对这个请求失效，这样返回的绝对是新鲜的资源。```Cache-Control:no-cachePragma:no-cache```####4、综上![img](http://imweb-io-1251594266.file.myqcloud.com/FgtfwfAjs5EBAEIa9KFi25acNk7d)##缓存实践综上对各种HTTP缓存控制头部的对比以及用户可能出现的浏览器刷新行为的讨论，当我们在一个项目上做http缓存的应用时，我们实际上还是会把上述提及的大多数首部字段均使用上。####1、Expires/Cache-ControlExpires用时刻来标识失效时间，不免收到时间同步的影响，而Cache-Control使用时间间隔很好的解决了这个问题。但是Cache-Control是HTTP1.1才有的，不适用于HTTP1.0，而Expires既适用于HTTP1.0，也适用于HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，会优先使用Cache-Control。####2、Last-Modified/ETag二者都是通过某个标识值来请求资源，如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged）状态码，内容为空，这样就节省了传输数据量。而当资源发生比那话后，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。其中Last-Modified使用文件最后修改作为文件标识值，它无法处理文件一秒内多次修改的情况，而且只要文件修改了哪怕文件实质内容没有修改，也会重新返回资源内容；ETag作为“被请求变量的实体值”，其完全可以解决Last-Modified头部的问题，但是其计算过程需要耗费服务器资源。####3、from-cache/304Expires和Cache-Control都有一个问题就是服务端作为的修改，如果还在缓存时效里，那么客户端是不会去请求服务端资源的（非刷新），这就存在一个资源版本不符的问题，而强制刷新一定会发起HTTP请求并返回资源内容，无论该内容在这段时间内是否修改过；而Last-Modified和Etag每次请求资源都会发起请求，哪怕是很久都不会有修改的资源，都至少有一次请求响应的消耗。对于所有可缓存资源，指定一个Expires或Cache-Controlmax-age以及一个Last-Modified或ETag至关重要。同时使用前者和后者可以很好的相互适应。前者不需要每次都发起一次请求来校验资源时效性，后者保证当资源未出现修改的时候不需要重新发送该资源。而在用户的不同刷新页面行为中，二者的结合也能很好的利用HTTP缓存控制特性，无论是在地址栏输入URI然后输入回车进行访问，还是点击刷新按钮，浏览器都能充分利用缓存内容，避免进行不必要的请求与数据传输。####4、避免304同学们是否还记得我们在讨论用户刷新页面行为中体积的**index.css**文件，它实际上被命名为**index.03d344bd.css**。而细心的同学也会发现它的Expires和Cache-Control时间出奇的长，这难道不会导致用户无法得到其最近的内容吗？![img](http://imweb-io-1251594266.file.myqcloud.com/Fr3W_zspqBLLzZUz6vCVJm3sgIEJ)其做法实际上很简单，它把服务侧ETag的那一套理论搬到了前端来使用。页面的静态资源以版本形式发布，常用的方法是在文件名或参数带上一串md5或时间标记符：```https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26http://tb1.bdstatic.com/tb/_/tbean_safe_ajax_94e7ca2.jshttp://img1.gtimg.com/ninja/2/2016/04/ninja145972803357449.jpg```可以看到上面的例子中有不同的做法，有的在URI后面加上了md5参数，有的将md5值作为文件名的一部分，有的将资源放在特性版本的目录中。那么在**文件没有变动**的时候，浏览器不用发起请求直接可以使用缓存文件；而在**文件有变化**的时候，由于文件版本号的变更，导致文件名变化，请求的url变了，自然文件就更新了。这样能确保客户端能及时从服务器收取到新修改的文件。通过这样的处理，增长了静态资源，特别是图片资源的缓存时间，避免该资源很快过期，客户端频繁向服务端发起资源请求，服务器再返回304响应的情况（有Last-Modified/Etag）。结论：-需要兼容HTTP1.0的时候需要使用Expires，不然可以考虑直接使用Cache-Control-需要处理一秒内多次修改的情况，或者其他Last-Modified处理不了的情况，才使用ETag，否则使用Last-Modified。-对于所有可缓存资源，需要指定一个Expires或Cache-Control，同时指定Last-Modified或者Etag。-可以通过标识文件版本名、加长缓存时间的方式来减少304响应。","Knowledge\\相关技术\\Python\\basis.md":"#Python##print()函数输出>`print(输出的内容)`##ASCII码>`chr(56)`=>8>`print(\"\\u4e2d\\u56fd\\\")`=>中国![](./.assets/basis-2022-03-08-14-12-06.png)##保留字和标识符![](./.assets/basis-2022-03-08-15-15-07.png)##类型转换函数|函数|描述||:---------------------|:-------------------------------------------------||int(x)|将x转换为整数类型||float(x)|将x转换为浮点数类型||complex(real[,imag])|创建一个复数||str(x)|将x转换为字符串||repr(x)|将x转换为表达式字符串||eval(str)|计算在字符串中的有效Python表达式，并返回一个对象||chr(x)|将整数x转换为一个字符||ord(x)|将一个字符x转换为它所对应的整数值||hex(x)|将一个整数x转换为一个十六进制字符串||oct(x)|将一个整数x转换为一个八进制的字符串|##流程控制>跳转语句`break`和`continue`###if&else&elif```txtif表达式:#语句块1else#语句块2``````txtif表达式:#语句块1elif#语句块2else#语句块3```####简写#####Exmple简写前```pya=-9ifa>0:b=aelse:b=-aprint(b)```简写```pya=-9b=aifa>0else-aprint(b)```###while```pywhile条件表达式:循环体```###for```pyfor迭代变量in对象:循环体```","Knowledge\\相关技术\\Python\\格式化\\pylint.md":"#pylint>生成配置文件:`pylint--persistent=n--generate-rcfile>pylintrc````py#添加忽略规则disable=raw-checker-failed,bad-inline-option,locally-disabled,file-ignored,suppressed-message,useless-suppression,deprecated-pragma,use-symbolic-message-instead,unspecified-encoding```","Knowledge\\相关技术\\rgb.md":"#RGB>R:红>G:绿>B:蓝##常见颜色|值|颜色||效果||:----------|:-----|:----|:------------------------------------------------------------||255,255,255|白||<divclass='colorItem'style=\"background:rgb(255,255,255)\"/>||127,127,127|灰||<divclass='colorItem'style=\"background:rgb(127,127,127)\"/>||0,0,0|黑||<divclass='colorItem'style=\"background:rgb(0,0,0)\"/>||255,0,0|红||<divclass='colorItem'style=\"background:rgb(255,0,0)\"/>||0,255,0|绿||<divclass='colorItem'style=\"background:rgb(0,255,0)\"/>||0,0,255|蓝||<divclass='colorItem'style=\"background:rgb(0,0,255)\"/>||0,255,255|青|蓝+绿|<divclass='colorItem'style=\"background:rgb(0,255,255)\"/>||255,0,255|洋红|红+蓝|<divclass='colorItem'style=\"background:rgb(255,0,255)\"/>||255,255,0|黄|红+绿|<divclass='colorItem'style=\"background:rgb(255,255,0)\"/>||255,127,0|橙||<divclass='colorItem'style=\"background:rgb(255,127,0)\"/>||127,0,255|紫||<divclass='colorItem'style=\"background:rgb(127,0,255)\"/>||0,255,128|粉绿||<divclass='colorItem'style=\"background:rgb(0,255,128)\"/>||0,128,255|湖蓝||<divclass='colorItem'style=\"background:rgb(0,128,255)\"/>||128,255,0|草绿||<divclass='colorItem'style=\"background:rgb(128,255,0)\"/>||255,0,128|玫瑰红||<divclass='colorItem'style=\"background:rgb(255,0,128)\"/>|<style>div.colorItem{width:10px;height:10px;}</style>","Knowledge\\相关技术\\unicode.md":"#UniCode表##字母和数字相关|字符|十进制|十六进制||:----|:-------|:-------||`A-Z`|65-90|41-5A||`a-z`|97-122|61-7A||`0-9`|48-57|30-39|","Knowledge\\相关技术\\Unity\\c#.md":"#`C#`|运算符|描述|实例||:-------|:-------------------------------------|:----------------------------------------------------------------------------||sizeof()|返回数据类型的大小。|sizeof(int)，将返回4.||typeof()|返回class的类型。|typeof(StreamReader);||&|返回变量的地址。|&a;将得到变量的实际地址。||\\*|变量的指针。|\\*a;将指向一个变量。||?:|条件表达式|如果条件为真?则为X:否则为Y||is|判断对象是否为某一类型。|If(FordisCar)//检查Ford是否是Car类的一个对象。||as|强制转换，即使转换失败也不会抛出异常。|Objectobj=newStringReader(\"Hello\");StringReaderr=objasStringReader;|","Knowledge\\相关技术\\Unity\\unity.md":"#Unity<imgsrc=\".assets/image-20211231142355446.png\"alt=\"image-20211231142355446\"style=\"zoom:50%;\"/>","Knowledge\\相关技术\\Unity\\vscode运行C#.md":"#vscode运行`c#`###1、下载SDK首先下载.NETCoreSDK。下载地址如下:[.NETDownloadsforWindows](https://www.microsoft.com/net/download/windows)安装SDK：![img](/.assets/img/2021-12-28-22-02-54.png)安装完成后调出控制台输入:```shelldotnet--version```弹出版本信息说明安装成功![](/.assets/img/2021-12-28-22-03-22.png)###2、安装C#语言支持在VSCode里找插件，安装C#的支持。![](/.assets/img/2021-12-28-22-05-05.png)##二、快速创建C#控制台输入```shelldotnetnewconsole-oD:\\study\\NetCore```讲解一下，new是新建，console是控制台，-o是IO路径，后面的是我准备安放的路径，D盘的study目录下，项目名称是NetCore![](/.assets/img/2021-12-28-22-05-23.png)输出上述文字说明项目创建成功.把这个文件夹拖进VSCode，或用打开vscode打开项目文件夹D:\\study\\NetCore。![](/.assets/img/2021-12-28-22-12-34.png)这时右下角弹出通知提示，问你要不要为这个项目创建编译和调试文件，这里要选择“Yes”。![img](https://www.kmbox.cn/uploads/allimg/200220/1-200220151603332.png)这样就会自动配置好tasks.json编译配置文件和launch.json调试配置文件。![](/.assets/img/2021-12-28-22-12-55.png)直接使用终端在项目该目录下执行dotnetrun，即可执行，或者按F5运行，然后选择NetCore调式器，在代码左边打个断点，可以发现，左方的Debug有变量的变化显示，上方也有断点进出的快捷键。![](/.assets/img/2021-12-28-22-13-06.png)###格式化代码比如我的代码很乱，如下图![img](https://img2018.cnblogs.com/blog/793293/201905/793293-20190515224448776-1346059103.png)安装C#FixFormat插件![](/.assets/img/2021-12-28-22-12-05.png)只需要右键，格式化代码，选择C#FixFormat方式格式化即可切换默认的格式化工具成FixFormat：![](/.assets/img/2021-12-28-22-10-58.png)![](/.assets/img/2021-12-28-22-10-16.png)格式化文档：![](/.assets/img/2021-12-28-22-08-46.png)##三、快速创建MVC1.打开VSCode,定位到你想要的文件夹D:\\study\\NetCore\\MVC![](/.assets/img/2021-12-28-22-07-35.png)2.使用快捷键Ctrl+`,这时候右下角会弹出终端窗口![](/.assets/img/2021-12-28-22-07-26.png)3、使用dotnetnewmvc-nmyapp```shelldotnetnewmvc-nmyapp```![](/.assets/img/2021-12-28-22-07-11.png)4.按F5启动调试右下角弹出通知提示，问你要不要为这个项目创建编译和调试文件，这里要选择“Yes”。![](/.assets/img/2021-12-28-22-06-23.png)![](/.assets/img/2021-12-28-22-06-34.png)","Knowledge\\相关技术\\计网\\CDN\\640.md":"#CDN>-CDN(ContentDeliveryNetwork):内容分发网络>-在构建在现有的互联网基础之上的一层的智能虚拟网络,通过咋网络各处部署节点服务器,实现将资源站内容分发至所有的CDN节点,是用户可以就近获得所需的内容.>-CDN工作原理:将全球各地的CDN节点上,用户请求资源时,就近返回节点的资源,而不需要每个用户的请求都回您的源站获取,避免网络拥塞,缓解源站压力,提交用户体验>-以前是通过IP来互相访问,IP不好记,便有了域名.>-常见的DNS解析服务商有：阿里云解析，万网解析，DNSPod，新网解析，Route53（AWS），Dyn，Cloudflare等。>-TLD:顶级域名>-优点:>-减低延迟,提高访问网站速度>-缓解源站压力>-缓解骨干网的压力>-优化网上热点内容>-eg:热点内容的服务器都在北京，如果我想获取热点内容，我就需要发送请求到北京的服务器，但若有了cdn，我只需要就近服务器获取热点内容，这样就分摊优化热点内容的分布了。![](.assets/1022.jpg)>-浏览器域名解析过程(CDN加速前)>-系统DNS缓存,hosts文件>-路由器DNS缓存>-本地DNS服务器,ISP运营服务提供者>-本地DNS服务器,请求根域名服务器,13个,不是只有13台服务器,拿到DNS记录>-本地DNS服务器拿到顶级域名域名服务器ip,就去请求顶级域名服务器>-本地DNS服务器工具拿到的耳机域名服务器的ip,就去请求二级域名服务器>-直到X级域名服务器返回我们目标域名对应的ip地址后,本地DNS服务器缓存该DNS记录,然后返回路由器>-客户端拿到ip地址,利用该ip地址,封装并发起http/http2请求>-前面四步是递归查询,一单缓存可用,就可直接返回,不会在进行后续步骤,后面迭代查询,最终获取ip地址,才会返回##CDN节点缓存策略>-CDN通过在现有网络中增加一层新的缓存节点，将源站的资源发布到最接近用户的网络节点，使得客户端在请求时直接访问到就近的CDN节点并命中该资源，减少回源情况，提高网站访问速度。>-cdn缓存服务器还会根据不同运营商做区分，因为跨运营商需要在交换点进行转换，如果同个运营商则不需要转换，尽量会选择同一运营商的cdn缓存服务器来获取数据或回源。>-CDN缓存一般分3层，客户端、CDNCacheL1、CDNCacheL2，当然也可以只有2层。##CDN工作原理","Knowledge\\相关技术\\计网\\CDN\\index.md":"#CDN>-CDN(ContentDeliveryNetwork):内容分发网络>-在构建在现有的互联网基础之上的一层的智能虚拟网络,通过咋网络各处部署节点服务器,实现将资源站内容分发至所有的CDN节点,是用户可以就近获得所需的内容.>-CDN工作原理:将全球各地的CDN节点上,用户请求资源时,就近返回节点的资源,而不需要每个用户的请求都回您的源站获取,避免网络拥塞,缓解源站压力,提交用户体验>-以前是通过IP来互相访问,IP不好记,便有了域名.>-常见的DNS解析服务商有：阿里云解析，万网解析，DNSPod，新网解析，Route53（AWS），Dyn，Cloudflare等。>-TLD:顶级域名>-优点:>-减低延迟,提高访问网站速度>-缓解源站压力>-缓解骨干网的压力>-优化网上热点内容>-eg:热点内容的服务器都在北京，如果我想获取热点内容，我就需要发送请求到北京的服务器，但若有了cdn，我只需要就近服务器获取热点内容，这样就分摊优化热点内容的分布了。![](index.assets/1022.jpg)>-浏览器域名解析过程(CDN加速前)>-系统DNS缓存,hosts文件>-路由器DNS缓存>-本地DNS服务器,ISP运营服务提供者>-本地DNS服务器,请求根域名服务器,13个,不是只有13台服务器,拿到DNS记录>-本地DNS服务器拿到顶级域名域名服务器ip,就去请求顶级域名服务器>-本地DNS服务器工具拿到的耳机域名服务器的ip,就去请求二级域名服务器>-直到X级域名服务器返回我们目标域名对应的ip地址后,本地DNS服务器缓存该DNS记录,然后返回路由器>-客户端拿到ip地址,利用该ip地址,封装并发起http/http2请求>-前面四步是递归查询,一单缓存可用,就可直接返回,不会在进行后续步骤,后面迭代查询,最终获取ip地址,才会返回##CDN节点缓存策略>-CDN通过在现有网络中增加一层新的缓存节点，将源站的资源发布到最接近用户的网络节点，使得客户端在请求时直接访问到就近的CDN节点并命中该资源，减少回源情况，提高网站访问速度。>-cdn缓存服务器还会根据不同运营商做区分，因为跨运营商需要在交换点进行转换，如果同个运营商则不需要转换，尽量会选择同一运营商的cdn缓存服务器来获取数据或回源。>-CDN缓存一般分3层，客户端、CDNCacheL1、CDNCacheL2，当然也可以只有2层。![](index.assets/111.jpg)##CDN工作原理![](index.assets/640-1621930139989.jpg)","Knowledge\\相关技术\\计网\\CDN\\question.md":"#CDN-question##加速域名、CNAME域名、边缘节点、源站是什么意思？>（1）加速域名：即您需要使用CDN加速的域名，也是您的客户访问时直接请求访问的域名。>>（2）CNAME域名：在美团云CDN控制台创建加速域名后，域名审核通过后系统会给域名分配一个“CNAME域名”。用户需要在域名服务商处，配置一条CNAME记录，将加速域名CNAME至CNAME域名，记录生效后，域名解析过程中会将解析请求正式转向美团云CDN，该域名所有的请求都将转向美团云CDN的节点。>>（3）边缘节点：边缘节点是离用户最近的节点，是直接响应用户请求，将请求内容缓存并返回给用户的节点，以此来快速响应用户请求。与边缘节点相对应的是中间层节点，中间层节点是源站和边缘节点的一个中间层的回源服务器，中间层节点可缓存边缘节点的回源访问，降低源站的访问压力。>>（4）源站：即您的业务服务器，当节点没有缓存用户请求的内容时，节点会返回源站获取数据并返回给用户。##接入CDN的域名有什么要求吗？>接入CDN进行加速的域名，需要在工信部完成备案，源站的业务内容必须合法。##CDN加速域名是否支持泛域名？>美团云CDN当前已支持接入泛域名，您可在新建加速域名时以泛域名的形式（例如：\\*.example.com）创建域名。##CDN节点上的缓存内容是实时更新的吗？>不会实时更新，CDN节点上的缓存内容，是根据您在控制台配置的缓存过期时间来更新缓存，若您需要实时更新某个文件的缓存，您可以通过刷新或者预热的方式来进行。","Knowledge\\相关技术\\计网\\http协议.md":"#HTTP协议##http协议的主要特点>简单快速、灵活、无连接、无状态HTTP三点注意事项：-HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。-HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。-HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。##请求报文>一个HTTP请求报文由请求行（requestline）、请求头（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。###请求行>请求行：包括请求方法字段、URL字段和HTTP协议版本，如：GET/index.htmlHTTP/1.1。###请求头>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：>>-User-Agent：产生请求的浏览器类型。>Accept：客户端可识别的内容类型列表。>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。>Content-Type：请求体的MIME类型（用于POST和PUT请求中）。如：Content-Type:application/x-www-form-urlencoded###空行>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。###请求数据>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。##响应报文>包括：状态行、响应头、空行、响应正文。##HTTP状态码>HTTP状态码的英文为HTTPStatusCode。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。>>1xx：指示信息--表示请求已接收，继续处理。>2xx：成功--表示请求已被成功接收、理解、接受。>3xx：重定向--要完成请求必须进行更进一步的操作。>4xx：客户端错误--请求有语法错误或请求无法实现。>5xx：服务器端错误--服务器未能实现合法的请求。>>常见状态代码、状态描述的说明如下。>>200OK：客户端请求成功。>400BadRequest：客户端请求有语法错误，不能被服务器所理解。>401Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。>403Forbidden：服务器收到请求，但是拒绝提供服务。>404NotFound：请求资源不存在，举个例子：输入了错误的URL。>500InternalServerError：服务器发生不可预期的错误。>503ServerUnavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1200OK（CRLF）。##优化DNS预解析```js<!--在head标签中，越早越好--><linkrel=\"dns-prefetch\"href=\"//example.com\">```HTTP预连接```js<linkrel=\"preconnect\"href=\"//example.com\"><linkrel=\"preconnect\"href=\"//cdn.example.com\"crossorigin>```","Knowledge\\相关技术\\计网\\计网.md":"#计算机网络##TCP连接###三次握手四次挥手>-为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。>用TCP协议把数据包送出去后，TCP协议不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。>握手过程使用了TCP协议的标志：SYN和ACK。####三次握手>-发送端首先发送一个带有SYN标志的数据包给对方。>-接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。>最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。>若是在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。####四次挥手>第一次：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被关闭方：我已经不会再给你发送数据了。>第二次：被动关闭方接收到FIN包之后，发送一个ACK给对方，确认序号为序号+1.>第三次：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发完了，不会再给你发送数据了。>第四次：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1。##一次完整的http流程步骤>域名解析>发起TCP的三次握手>建立TCP连接后发起http请求>服务器响应http请求，浏览器得到HTML代码>浏览器解析HTML代码，并请求HTML代码中的资源>浏览器对页面进行渲染呈现给用户>连接结束##五层协议>应用层（FTP、Telnet、SMTP、RIP、NFS、DNS）>>-应用层的任务是通过应用进程间的交互来完成特定网络应用。>>运输层（TCP、UDP）>>-运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务>>网络层（IP、ICMP、ARP、RARP）>>-网络层负责为分组交换网上的不同主机提供通信服务。>>数据链路层>>-数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。>>物理层>>-物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。##http和https>http协议通常承载于TCP协议之上，在http和TCP协议之间添加一个安全协议层(SSL或TSL)，这个时候就成了我们常说的https。>>https协议需要CA申请证书，一般免费证书比较少，所以需要一定费用。>http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议>http和https使用的是完全不同的连接方式，使用的端口号也不一样，前者是80，后者是443>http连接很简单，是无状态的；https协议是由http+SSL协议构建的可进行加密传输、身份认证的网络协议，比较安全。>谷歌搜索引擎算法中，比起同等http网站，采用https加密的网站在搜索结果中排名会更高##TCP与UDP###用户数据协议UDP>提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。>UDP是无连接的；>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态；>UDP是面向报文的；>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；>UDP支持一对一、一对多、多对一和多对多的交互通信；>UDP的首部开销小，只有8个字节，比TCP协议的20个字节的首部要短。###传输控制协议TCP>提供面向连接的，可靠的数据传输服务。>TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；>面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。##协议>ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。>TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。>HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。>DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。##http状态码2开头（请求成功）表示成功处理了请求的状态代码。200（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。201（已创建）请求成功并且服务器创建了新的资源。202（已接受）服务器已接受请求，但尚未处理。203（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一来源。204（无内容）服务器成功处理了请求，但没有返回任何内容。205（重置内容）服务器成功处理了请求，但没有返回任何内容。206（部分内容）服务器成功处理了部分GET请求。3开头（请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。300（多种选择）针对请求，服务器可执行多种操作。服务器可根据请求者选择一项操作，或提供操作列表供请求者选择。301（永久移动）请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。302（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303（查看其他位置）请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码。304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。305（使用代理）请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。307（临时重定向）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。4开头（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。400（错误请求）服务器不理解请求的语法。401（未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。403（禁止）服务器拒绝请求。404（未找到）服务器找不到请求的网页。405（方法禁用）禁用请求中指定的方法。406（不接受）无法使用请求的内容特性响应请求的网页。407（需要代理授权）此状态代码与401（未授权）类似，但指定请求者应当授权使用代理。408（请求超时）服务器等候请求时发生超时。409（冲突）服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。410（已删除）如果请求的资源已永久删除，服务器就会返回此响应。411（需要有效长度）服务器不接受不含有效内容长度标头字段的请求。412（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。413（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414（请求的URI过长）请求的URI（通常为网址）过长，服务器无法处理。415（不支持的媒体类型）请求的格式不受请求页面的支持。416（请求范围不符合要求）如果页面无法提供请求的范围，则服务器会返回此状态代码。417（未满足期望值）服务器未满足\"期望\"请求标头字段的要求。5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。500（服务器内部错误）服务器遇到错误，无法完成请求。501（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。502（错误网关）服务器作为网关或代理，从上游服务器收到无效响应。503（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。504（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求。505（http版本不受支持）服务器不支持请求中所用的http协议版本。##get请求传参长度的误区http协议未规定GET和POST的长度限制；GET的最大长度显示是因为浏览器和web服务器限制了URL的长度；不同的浏览器和WEB服务器，限制的最大长度不一样；要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度8182byte；10.DNS服务器将网址/域名解析成IP地址。dns是一个域名系统，是万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。在解析域名时，可以首先采用静态域名解析的方法，如果静态域名解析不成功，再采用动态域名解析的方法，域名是互联网上的身份标识，是不可重复的唯一标识资源；某个区域的资源记录通过手动或自动方式更新到单个主名称服务器（称为主DNS服务器）上，主DNS服务器可以是一个或几个区域的权威名称服务器。11.从url到页面展现，这之中发生了什么？输入url：如<http://www.baidu.com>。其中http为协议，www.baidu.com为网络地址，一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。应用层DNS解析域名：客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。应用层发送http请求：http请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET/POST）、目标url、遵循的协议（http/https/ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。传输层TCP传输报文：TCP协议为传输报文提供可靠的字节流服务，它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠：网络层IP协议查询MAC地址:IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。数据到达数据链路层:在找到对方的MAC地址后，就将数据发送到数据链路层传输。服务器接收数据:接收端的服务器在链路层接收到数据包，再层层向上直到应用层,这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的http请求报文。服务器响应请求:服务接收到客户端发送的http请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。服务器返回相应文件：请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。解析HTML以构建DOM树–>构建渲染树–>布局渲染树–>绘制渲染树。DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送http请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一+过程中可能会触发页面的重绘或重排。","Knowledge\\线性代数\\1.几何解释.md":"#[`1.几何解释`]()##方程组$$2x-y=0$$$$-x+2y=3$$和以下对应对应##向量式$$x\\begin{vmatrix}2\\\\-1\\end{vmatrix}+y\\begin{vmatrix}-1\\\\2\\end{vmatrix}=\\begin{vmatrix}0\\\\3\\end{vmatrix}$$可以等效成**向量式/线性方程(一元方程)**$$Ax=b$$##行列式$$\\begin{vmatrix}2&-1\\\\-1&2\\end{vmatrix}\\begin{vmatrix}x\\\\y\\end{vmatrix}=\\begin{vmatrix}0\\\\3\\end{vmatrix}$$","Knowledge\\线性代数\\2.矩阵消元.md":"#2.矩阵消元---$$\\begin{vmatrix}1,2,1\\\\3,8,1\\\\0,4,1\\end{vmatrix}-行2减去3倍行1->\\begin{vmatrix}1,2,1\\\\0,2,-2\\\\0,4,1\\end{vmatrix}-行3减去两倍行2->\\begin{vmatrix}1,2,1\\\\0,2,-2\\\\0,0,5\\end{vmatrix}$$>最后对角线上**1,2,5**是主元---$$\\begin{vmatrix}1,2,1,2\\\\3,8,1,12\\\\0,4,1,2\\end{vmatrix}-行2减去3倍行1->\\begin{vmatrix}1,2,1,2\\\\0,2,-2,6\\\\0,4,1,2\\end{vmatrix}-行3减去两倍行2->\\begin{vmatrix}1,2,1,2\\\\0,2,-2,6\\\\0,0,5,-10\\end{vmatrix}$$使用函数表示形式$$\\begin{cases}x+2y+z=2\\\\2y-z=6\\\\5zz=-10\\\\\\end{cases}=>\\begin{cases}x=2\\\\y=1\\\\z=-2\\end{cases}$$>增广矩阵---","Knowledge\\线性代数\\行列式.md":"#[`行列式`](https://www.bilibili.com/video/BV1fv411y7YY/?p=2&spm_id_from=pageDriver&vd_source=880fb5bb8d91c4fa75a3e13e1cf5579f)![](./.assets/行列式-2023-01-24-17-40-37.png)![](./.assets/行列式-2023-01-24-18-00-47.png)![](./.assets/行列式-2023-01-24-18-04-00.png)","Knowledge\\表达式\\cron表达式.md":"#[`cron表达式`](/)![](./.assets/cron表达式-2024-03-15-10-20-54.png)-CRON表达式是一个字符串，包含五个到七个由空格分隔的字段（每种软件不一样），表示一组时间，通常作为执行某个程序的时间表-注释以注释标记#开始，并且必须单独在一行上-类型:-`Linux`-`Java(Spring)`-`Java(Quartz)````jsLinux#每月的最后1天00L***说明：Linux*****-----|||||||||+-----dayofweek(0-7)(Sunday=0or7)ORsun,mon,tue,wed,thu,fri,sat|||+----------month(1-12)ORjan,feb,mar,apr...||+---------------dayofmonth(1-31)|+--------------------hour(0-23)+-------------------------minute(0-59)``````jsJava(Spring)******------|||||||||||+-----dayofweek(0-7)(Sunday=0or7)ORsun,mon,tue,wed,thu,fri,sat||||+----------month(1-12)ORjan,feb,mar,apr...|||+---------------dayofmonth(1-31)||+--------------------hour(0-23)|+-------------------------min(0-59)+------------------------------second(0-59)``````jsJava(Quartz)*******-------|||||||||||||+year[optional]|||||+-----dayofweek(1-7)sun,mon,tue,wed,thu,fri,sat||||+----------month(1-12)ORjan,feb,mar,apr...|||+---------------dayofmonth(1-31)||+--------------------hour(0-23)|+-------------------------min(0-59)+------------------------------second(0-59)```|字段|是否必填|允许值|允许特殊字符|备注||:-----------|:-------|:--------------|:-----------|:---------------------------------------------------------------------------------------------------||Seconds|是|0–59|`*,-`|标准实现不支持此字段。||Minutes|是|0–59|`*,-`||Hours|是|0–23|`*,-`||Dayofmonth|是|1–31|`*,-?LW`|`?LW`只有部分软件实现了||Month|是|1–12orJAN–DEC|`*,-`||Dayofweek|是|0–7orSUN–SAT|`*,-?L#`|`?L#`只有部分软件实现<br/>Linux和Spring的允许值为0-7，0和7为周日<br/>Quartz的允许值为1-7，1为周日||Year|否|1970–2099|`*,-`|标准实现不支持此字段。|##标准字段-逗号用于分隔列表。例如，在第5个字段(星期几)中使用MON,WED,FRI表示周一、周三和周五。-连字符定义范围。例如，2000-2010表示2000年至2010年期间的每年，包括2000年和2010年。-除非用反斜杠`\\`转义，否则命令中的百分号(%)会被替换成换行符，第一个百分号后面的所有数据都会作为标准输入发送给命令。##非标准字段-“L”代表“Last”。-当在星期几字段中使用的时候，可以指定给定月份的结构，例如“最后一个星期五”(`5L`)-在月日字段中，可以指定一个月的最后一天-“dayofmonth”字段可以使用“W”字符。指定最接近给定日期的工作日（星期一-星期五）。-例如，`15W`，意思是：“最接近该月15日的工作日。”；所以，如果15号是星期六，触发器在14号星期五触发。如果15日是星期天，触发器在1日星期一触发。如果15号是星期二，那么它在15号星期二触发-`1W`，如果这个月的第一天是星期六，不会跨到上个月，触发器会在这个月的第三天（也就是星期一）触发。只有指定一天（不能是范围或列表）的时候，才能指定“W”字符-星期几字段可以使用“#”，后面必须跟一个介于1和5之间的数字。例如，5#3表示每个月的第三个星期五-在某些实现中，“?”用来代替“_”以将月中的某一天或周中的某一天留空。其他cron的实现是替换“?”为cron守护进程的启动时间，例如：`？？_\\*\\*_`，如果cron在上午8:25启动，将更新为`258_\\*\\*\\*`并在每天的这个时间运行，直到再次重新启动-分钟字段设置`*/5`表示每5分钟一次，注意：这里指的是能被5整除的分钟数##常用>`-*/?`-`*`：每的意思。在不同的字段上，就代表每秒，每分，每小时等。-`-`：指定值的范围。比如[1-10]，在秒字段里就是每分钟的第1到10秒，在分就是每小时的第1到10分钟，以此类推。-`,`：指定某几个值。比如[2,4,5]，在秒字段里就是每分钟的第2，第4，第5秒，以此类推。-`/`：指定值的起始和增加幅度。比如[3/5]，在秒字段就是每分钟的第3秒开始，每隔5秒生效一次，也就是第3秒、8秒、13秒，以此类推-`?`：仅用于【日】和【周】字段。因为在指定某日和周几的时候，这两个值实际上是冲突的，所以需要用【?】标识不生效的字段。比如`01***?`就代表每年每月每日每小时的1分0秒触发任务。这里的周就没有效果##非常用-SUN：仅用于【周】字段，表示星期日。也可以用数字1设置。-周日到周六分别为SUN，MON，TUE，WED，THU，FRI和SAT，对应数字1，2，3，4，5，6，7。目前Quartz支持。-L：即last，用于【日】【周】字段。这里需要注意的是，在不同的字段的不同使用方式，其含义有所差别。-用于日字段：直接使用L代表每个月的最后一天。也支持偏移量的方式，配置[L-1]则代表每月的倒数第二天。-用于周字段：直接使用L代表每周的最后一天，也就是等效于[7]或[SAT]，但是如果配合上数字，比如[7L]，则代表每个月最后一个周六，等效于[SATL]。目前Quartz支持。##正则校验表达式```shell^(\\*|[0-9,\\-/]+)\\s(\\*|[0-9,\\-/]+)\\s(\\*|[0-9,\\-/]+)\\s(\\*|[0-9,\\-/]+)\\s(\\*|[0-9,\\-/]+)$```##Example|cron表达式|含义|执行时间||:----------------------------------------------------|:-----------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------||`5****?`|每分钟的第5秒执行一次|2021-04-1113:10:05<br/>2021-04-1113:11:05<br/>2021-04-1113:12:05<br/>2021-04-1113:13:05<br/>2021-04-1113:14:05<br/>2021-04-1113:15:05||`5*10-22**?`|从早上10点到晚上十点，每分钟的第5秒执行一次|2021-04-1113:10:052021-04-1113:11:05<br/>2021-04-1113:12:05<br/>2021-04-1113:13:05<br/>2021-04-1113:14:05<br/>2021-04-1113:15:05||`500/6**?`<br/>等效于<br/>`500,6,12,18**?`|每天从0点开始，每隔6小时执行一次。执行时间为第0分5秒。|2021-04-1200:00:05<br/>2021-04-1206:00:05<br/>2021-04-1212:00:05<br/>2021-04-1218:00:05|","React\\antd\\v2\\select.md":"#Select##Select自带的搜索功能很多时候需要结合后端的接口，输入一个关键字的时候会自动更新选择器的选项>选择器选项必须和每次更新的数据挂钩,这个值可以通过state,也可以通过props拿到>>再结合循环的方法例如map遍历渲染options```jsx<Selectmode='multiple'//多选模式placeholder='请选择'filterOption={false}//关闭自动筛选onSearch={this.handleSearch}>{list.map((item,index)=>(<Optionkey={index}value={item}>{item}</Option>))}</Select>```>若`filterOption`默认为`true`,当你输入内容时候,会先在已有选项里面寻找符合项,无论是否找到，都会重新渲染Options,这样你接口请求的数据的渲染被覆盖了,自然看不到结果了。所以需要把它关掉","React\\basis\\createElement.md":"#React.createElement>参数:>>1.必填,传入类HTML标签的名称>2.选填,属性,例如:className>3.选填,子节点,eg:要显示的文本内容```jsximportReact,{Component}from'react'//3functionContent3(){returnReact.createElement('div',null,'content3')}classIndexextendsComponent{render(){letchild1=React.createElement('li',null,'one')letchild2=React.createElement('li',null,'two')letcontent=React.createElement('ul',{className:'teststyle'},child1,child2,)//1letcontent2=React.createElement('ul',{className:'teststyle'},[child1,child2,])//2return(<div>Index{content}{content2}<Content3/></div>)}}exportdefaultIndex```![Snipaste_2020-12-10_10-35-35](https://gitee.com/grh-gitee/picgo/raw/master/Snipaste_2020-12-10_10-35-35.png)","React\\basis\\react-basis.md":"#React-basis1.Facebook开源的一个js库2.一个用来动态构建用户界面的js库3.特点:1.Declarative(声明式编码)-采用声明式范式,可以轻松描述应用2.Component-based(组件化编码)-是代码更加容易得到复用3.支持客户端与服务器渲染4.高效-通过对DOM的模拟,最大限度减少与DOM的交互5.单向数据流-减少重复代码4.高效的原因:1.虚拟(virtual)DOM,不直接操作DOM2.高效的DOMDiff算法,最小化重绘(减少页面更新的区域)##JSX1.全称:JavaScriptXML2.react定义的一种类似XML的JS拓展语法:XML+JS3.作用:用来创建react虚拟DOM(元素)对象4.编码相关:1.js中直接可以套标签,标签套js需要放在{}中2.解析显示js数组时,会中东遍历显示5.注意:1.标签必须要有结束2.class属性必须改成className3.标签的style属性值必须为:`{{color:'red',width:12}}`##组件化与组件化1.组件化1.当应用的js都是以模块来编写的,这个应用就是一个模块化的应用2.就是把重负的部分提炼出来,一个一个能使用3.例如Dialog,各种自定义UI组件,能在项目或不同项目重复使用等4.目的:复用,解耦5.依赖:组件之间低依赖,比较独立6.架构定位:纵向分层(位于架构底层,被其他成所依赖)2.模块化1.但应用是以多组件的方式实现功能,改应用就是一该组件化的应用2.\"业务框架\"或者\"业务模块\",也可理解为\"框架\",3.就是把功能进行划分,将同一个类型的代码整合在一起,所有模块的工鞥相对复杂,都属于一个业务4.使用:按照项目功能需求划分成不同类型的业务框架(注册,登录,外卖,等)5.目的:隔离/封装(高内聚)6.依赖:模块之间有依赖的关系,可通过路由器进行模块之间的耦合关系7.架构定位:横向分块(位于架构业务框架层)3.两者区别##环境搭建-引用ReactCDN资源```html<scriptcrossoriginsrc=\"https://unpkg.com/react@16/umd/react.development.js\"></script><scriptcrossoriginsrc=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>```-通过npm(包管理),安装React`$npminstall--savereactreact``$npminstall--savereactreact-dom`-利用脚手架create-react-app`$npminstall-gcreate-react-app``$create-react-appmy-app``$cdmy-app/$npmstart`-启动IP和端口号`在node_modules/react-script/scripts/start.js中设置(60和61行)constDEFAULT_PORT=parseInt(process.env.PORT,10)||3000;constHOST=process.env.HOST||'0.0.0.0';`##项目根目录中的文件介绍-**README.md**:这个文件主要作用就是对项目的说明，已经默认写好了一些东西，你可以简单看看。如果是工作中，你可以把文件中的内容删除，自己来写这个文件，编写这个文件可以使用Markdown的语法来编写。-**package.json**:这个文件是webpack配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置，当然脚手架已经为我们配置了一些了，目前位置，我们不需要改动。如果你对webpack了解，对这个一定也很熟悉。-**package-lock.json**：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再npminstall时大家的依赖能保证一致。-**gitignore**:这个是git的选择性上传的配置文件，比如一会要介绍的node_modules文件夹，就需要配置不上传。-**node_modules**:这个文件夹就是我们项目的依赖包，到目前位置，脚手架已经都给我们下载好了，你不需要单独安装什么。-**public**：公共文件，里边有公用模板和图标等一些东西。-**src**：主要代码编写文件，这个文件夹里的文件对我们来说最重要，都需要我们掌握。###public文件夹介绍这个文件都是一些项目使用的公共文件，也就是说都是共用的-**favicon.ico**:这个是网站或者说项目的图标，一般在浏览器标签页的左上角显示。-**index.html**:首页的模板文件-**mainifest.json**：移动端配置文件###src文件夹介绍这个目录里边放的是我们开放的源代码，我们平时操作做最多的目录。-**index.js**:这个就是项目的入口文件-**index.css**：这个是index.js里的CSS文件。-**app.js**:这个文件相当于一个方法模块，也是一个简单的模块化编程。-**serviceWorker.js**:这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。##组件的介绍###入口文件的编写写一个项目的时候一般要从入口文件进行编写的，在src目录下，index.js文件就是入口文件```importReactfrom'react'//引入reactimportReactDOMfrom'react-dom'//引入react-domimportAppfrom'./App'//引入App模块ReactDOM.render(<App/>,document.getElementById('root'))//将App模块渲染到了rootID上面```###App组件的编写```jsximportReactfrom'react'//JSX语法classAppextendsReact.Component{render(){return<div>我是APP组件</div>}}exportdefaultApp```###React中JSX语法简介```JSX就是Javascript和XML结合的一种格式。React发明了JSX，可以方便的利用HTML语法来创建虚拟DOM，当遇到<，JSX就当作HTML解析，遇到{就当JavaScript解析.```###组件和普通JSX语法区别这个说起来也只有简单的一句话，就是你自定义的组件必须首写字母要进行大写，而JSX是小写字母开头的。###JSX中使用三元运算符在JSX中也是可以使用js语法的```jsximportReactfrom'react'//JSX语法classAppextendsReact.Component{render(){return(<div><div>{false?'不显示我':'显示的我'}</div>我是APP组件</div>)}}exportdefaultApp```###组件外层包裹原则1.react和vue组件模板最外层必须有且只有一个元素2.去除这个最外层包裹的标签,使用-`<React.Fragment></React.Fragment>`-`<></>`##响应式设计和数据绑定>react不建议你直接操作DOM元素,而是通过数据进行驱动,改变界面中的效果##react基础###创建组件方法####函数式定义的**无状态组件**>主要负责根据props来展示,不涉及到要state状态的操作>>1.组件不会被实例化,整体渲染性能得到提升>-精简到成一个render方法的函数来实现,无实例化过程,就不需要分配多余的内存,从而性能得到一定的提升>2.组件不能访问this对象>3.组件无法访问生命周期的方法>4.无状态组件只能访问输入端饿props,同样的props会得到同样的渲染结果,不会有副作用```jsxfunctionHelloComponent(props/*context*/){return<div>Hello{props.name}</div>}ReactDOM.render(<HelloComponentname='Sebastian'/>,mountNode)```####es5原生方式`React.createClass`定义的组件>-会自绑定函数导致不必要的性能开销,增加代码过时的肯能性>-基本弃用```jsxvarInputControlES5=React.createClass({propTypes:{//定义传入props中的属性各种类型initialValue:React.PropTypes.string,},defaultProps:{//组件默认的props对象initialValue:'',},//设置initialstategetInitialState:function(){//组件相关的状态对象return{text:this.props.initialValue||'placeholder',}},handleChange:function(event){this.setState({//thisrepresentsreactcomponentinstancetext:event.target.value,})},render:function(){return(<div>Typesomething:<inputonChange={this.handleChange}value={this.state.text}/></div>)},})InputControlES6.propTypes={initialValue:React.PropTypes.string,}InputControlES6.defaultProps={initialValue:'',}```####es6形式的`extendsReact.Component`定义的组件>-目前最推荐的有状态的组件,最终会取代`React.createClass`形式,相对于`React.createClass`可以更好实现代码复用>-定义方法的命名规则:`handle+方法名`,可以省略`function`关键字>-还要在`constructor`下进行注册:`this.handleXXX=this.handleXXX.bind(this);`>-或者直接在组件中`click={()=>this.hanhdleXXX}````jsxclassInputControlES6extendsReact.Component{constructor(props){super(props)//设置initialstatethis.state={text:props.initialValue||'placeholder',}//ES6类中函数必须手动绑定this.handleChange=this.handleChange.bind(this)}handleChange(event){this.setState({text:event.target.value,})}render(){return(<div>Typesomething:<inputonChange={this.handleChange}value={this.state.text}/></div>)}}InputControlES6.propTypes={initialValue:React.PropTypes.string,}InputControlES6.defaultProps={initialValue:'',}```####React.ceateClass和React.Component区别#####函数this自绑定>React.ceateClass:每一成员函数的this都有React自动绑定,任何时候使用,直接使用this.method即可,函数中的this会被成功设置>>React.Component:创建组件,其成员函数不会自动绑定this,需要开发者手动绑定,否则this不嗯呢获取当前组件实例对象,需要绑定```jsxconstContacts=React.createClass({handleClick(){console.log(this)//ReactComponentinstance可以成功获取到this对象},render(){return<divonClick={this.handleClick}></div>},})``````jsxclassContactsextendsReact.Component{constructor(props){super(props);}handleClick(){console.log(this);//null获取不到}render(){return(<divonClick={this.handleClick}></div>);}//手动绑定constructor(props){super(props);this.handleClick=this.handleClick.bind(this);//构造函数中绑定}<divonClick={this.handleClick.bind(this)}></div>//使用bind来绑定<divonClick={()=>this.handleClick()}></div>//使用arrowfunction来绑定```#####组件属性类型propTypes及其默认props属性defaultProps配置不同>-`React.createClass`在创建组件时，有关组件props的属性类型及组件默认的属性会作为**组件实例的属性**来配置，其中defaultProps是使用`getDefaultProps`的方法来获取默认组件属性的>-`React.Component`在创建组件时配置这两个对应信息时，他们是作为**组件类的属性**，不是组件实例的属性，也就是所谓的**类的静态属性**来配置的```jsxconstTodoItem=React.createClass({propTypes:{//asanobjectname:React.PropTypes.string},getDefaultProps(){//returnaobjectreturn{name:''}}render(){return<div></div>}})classTodoItemextendsReact.Component{staticpropTypes={//类的静态属性name:React.PropTypes.string};staticdefaultProps={//类的静态属性name:''};...}```#####组件初始化状态state的配置不同>`React.createClass`创建的组件，其状态state是通过`getInitialState`方法来配置组件相关的状态；>`React.Component`创建的组件，其状态state是在`constructor`中像初始化组件属性一样声明的。```jsxconstTodoItem=React.createClass({//returnanobjectgetInitialState(){return{isEditing:false}}render(){return<div></div>}})classTodoItemextendsReact.Component{constructor(props){super(props);this.state={//definethis.stateinconstructorisEditing:false}}render(){return<div></div>}}```#####Mixins的支持不同>[`Mixins`](https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins)(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过`Mixins`进该对象来达到代码复用。具体可以参考[ReactMixin的前世今生](http://www.w3ctech.com/topic/1599)。>>`React.createClass`在创建组件时可以使用`mixins`属性，以数组的形式来混合类的集合。>>`React.Component`:不支持Mixins,React开发者社区提供一个全新的方式来取代`Mixins`,那就是**Higher-OrderComponents**，具体细节可以参考[这篇文章](https://leozdgao.me/chushi-hoc/)```jsxvarSomeMixin={doSomething(){},}constContacts=React.createClass({mixins:[SomeMixin],handleClick(){this.doSomething()//usemixin},render(){return<divonClick={this.handleClick}></div>},})```###jsx代码注释```jsx{/*正确注释的写法*/}{//正确注释的写法}```###组件的三大属性####state```jsx1.组件被称为\"状态机\",页面的显示是根据组件的state属性的数据来显示2.初始化指定:constructor(){super()this.state={stateName1:stateValue1,stateName2:stateValue2}}3.读取显示:this.state.stateName14.更新状态-->更新界面:this.setState({stateName1:newValue})```####props>所有组件标签的属性的集合对象>给标签指定属性,保存外部数据(可能是一个function)>在组件内部读取属性:this.props.propertyName>作用:从目标组件外部向组件内部传递数据```jsx对props中的属性值进行类型限制和必要性限制Person.propTypes={name:React.PropTypes.string.isRequired,age:React.PropTypes.number.isRequired}扩展属性:将对象的所有属性通过props传递<Person{...person}/>```#####父传子```jsx//父组件<childItemmyName={this.state.myName}/>//子组件<div>{this.props.myName}</div>}```#####子传父>1.先在父组件定义可以改变数据的方法pranentChange(且要注册),和数据myName>2.子组件通过`this.props.myName`拿到数据,且要在constructor注册或绑定一下父组件的方法```jsx//子组件classchildItemextendsReact.Component{constructor(props){super(props)this.changeParent=this.changeParent.bind(this)}return(<React.Fragment><divonClick={this.changeParent}>{this.props.myName}</div></React.Fragment>)changeParent(){//调用父组件传递过来的方法this.props.pranentChange()}}exportdefaultchildItem;``````jsx//父组件//引入子组件importchildItemfrom'./childItem'//JSX语法classparentItemextendsReact.Component{constractor(props){super(props)this.state={myName:'只会番茄炒蛋'}this.pranentChange=this.pranentChange.bind(this)}return(<React.Fragment>{/*使用了子组件*/}<childItempranentChange={this.pranentChange}myName={this.state.myName}/></React.Fragment>)pranentChange(){this.setState({myName:'番茄炒蛋少放糖'})}}exportdefaultparentItem;```####PropTypes检验传递值>在传输数据中,最好要加入数据校验>>加入校验,不按照校验以后,会有warning警告```jsx//子组件importReactfrom'react'//引入效验importPropTypesfrom'prop-types'//JSX语法classchildItemextendsReact.Component{constructor(props){super(props)this.changeParent=this.changeParent.bind(this)}return(<React.Fragment><divonClick={this.changeParent}>{this.props.myName}</div></React.Fragment>)changeParent(){//调用父组件传递过来的方法this.props.pranentChange()}}childItem.prorTypes={myName:PropTypes.string,//效验传入的内容必须是一个字符串pranentChange:PropTypes.func//效验传入的内容必须是一个function}exportdefaultchildItem;```#####必传值的校验---isRequired>不传递带有isRequired的数据,就会报错```jsxchildItem.prorTypes={//效验传入的内容必须是一个字符串并且必须传入值newName:PropTypes.string.isRequired,}```#####使用默认值---defaultProps>设置默认值```jsxchildItem.defaultProps={//子组件使用父组件传递的值,但是他自己又个默认的值newName:'啦啦啦',}```####ref>组件内包含ref属性的标签元素的集合对象>给操作目标标签指定ref属性,打一个标识>在组件内部获得标签对象:this.refs.refName(只是得到了标签元素对象)>作用:找到组件内部的真实dom元素对象,进而操作它```jsximportReactfrom'react'//JSX语法classparentItemextendsReact.Component{constractor(props){super(props)this.state={myName:'只会番茄炒蛋'}this.inputChange=this.inputChange.bind(this)}return(<React.Fragment><inputvalue={this.state.myName}onChange={this.inputChange}></input></React.Fragment>)inputChange(e){console.log(e.target.value)//获取input输入的值}}exportdefaultparentItem;``````jsximportReactfrom'react'//JSX语法classparentItemextendsReact.Component{constractor(props){super(props)this.state={myName:'只会番茄炒蛋'}this.inputChange=this.inputChange.bind(this)}return(<React.Fragment><inputvalue={this.state.myName}onChange={this.inputChange}ref={input=>{this.input=input}}></input></React.Fragment>)inputChange(e){console.log(this.input.value)}}exportdefaultparentItem;```###基础1.react的入口```js//无状态函数functionMyCompontent(props){return<h1>组件</h1>}//复杂组件classMyComponentextendsReact.Componet{render(){return<h1>组件</h1>}}//渲染组件标签ReactDOM.render(element,document.getElementById('root'))/*等到虚拟DOM对象,将虚拟DOM并解析为真实DOM,插入到指定的页面元素中*/```element就是通过ReactDOM.render()的方法来将其渲染到页面上2.自己创建element```jsconstelement=<h1>Hello,{formatName(user)}!</h1>```3.JSX代表Object下面两段代码完全一样```jsconstelement=<h1className='greeting'>Hello,world!</h1>``````jsconstelement=React.createElement('h1',{className:'greeting'},'Hello,world!',)```4.计时器的使用```jssetInterval(tick,1000)///每一秒调用一次tick方法```5.组件&Props-函数定义```jsfunctionwelcome(props){return<h1>{props.name}</h1>}```-类定义组件```jsclasswelcomeextendsReact.Component{render(){return<h1>{this.props.name}</h1>}}```-组件渲染```jsconstelement=<div/>constelement=<welcomename='guanruihua'/>```-组合组件```jsfunctionWelcome(props){return<h1>Hello,{props.name}</h1>}functionApp(){return(<div><Welcomename='Sara'/><Welcomename='Cahal'/><Welcomename='Edite'/></div>)}ReactDOM.render(<App/>,document.getElementById('root'))```-提取组件```jsx//方法一functionComment(props){return(<divclassName='Comment'><divclassName='UserInfo'><imgclassName='Avatar'src={props.author.avatarUrl}alt={props.author.name}/><divclassName='UserInfo-name'>{props.author.name}</div></div><divclassName='Comment-text'>{props.text}</div><divclassName='Comment-date'>{formatDate(props.date)}</div></div>)}//提取组件functionAvatar(props){return(<imgclassName='Avatar'src={props.user.avatarUrl}alt={props.user.name}/>)}//方法二functionComment(props){return(<divclassName='Comment'><divclassName='UserInfo'><Avataruser={props.author}/><divclassName='UserInfo-name'>{props.author.name}</div></div><divclassName='Comment-text'>{props.text}</div><divclassName='Comment-date'>{formatDate(props.date)}</div></div>)}functionUserInfo(props){return(<divclassName='UserInfo'><Avataruser={props.user}/><divclassName='UserInfo-name'>{props.user.name}</div></div>)}```###css```js//基于class--(className)<style>.title{...}</title><divclassName=\"title\"></div>//基与innercss行间样式(json)<divstyle={{color:'red'}}></div>//原型链和全局变量varcolor={color:'red'}<divstyle={color}>react全局行间样式</div>App.prototype.col={color:pink}<divstyle={this.col}>原型样式</div>```##动画react-transition-group###安装```visualbasicnpminstallreact-transition-group-S```>三大核心库>>-Transition>-CSSTransition>-TransitionGroup###使用CSSTransition```jsximport{CSSTranstion}from'react-transition-group';render(){return(<div><CSSTransitionin={this.state.isShow}//用于判断是否出现的状态timeout={2000}//动画持续时间classNames=\"boss-text\"//className值，防止重复><div>BOSS级人物-孙悟空</div></CSSTransition><div><buttononClick={this.toToggole}>召唤Boss</button></div></div>);}```-xxx-enter:进入（入场）前的CSS样式；-xxx-enter-active:进入动画直到完成时之前的CSS样式;-xxx-enter-done:进入完成时的CSS样式;-xxx-exit:退出（出场）前的CSS样式;-xxx-exit-active:退出动画知道完成时之前的的CSS样式。-xxx-exit-done:退出完成时的CSS样式。```css.input{border:3pxsolid#ae7000;}.boss-text-enter{opacity:0;}.boss-text-enter-active{opacity:1;transition:opacity2000ms;}.boss-text-enter-done{opacity:1;}.boss-text-exit{opacity:1;}.boss-text-exit-active{opacity:0;transition:opacity2000ms;}.boss-text-exit-done{opacity:0;}```####unmountOnExit属性>加上这个,元素退场,会自动吧DOM也删除```jsx<CSSTransitionin={this.state.isShow}//用于判断是否出现的状态timeout={2000}//动画持续时间classNames='boss-text'//className值，防止重复unmountOnExit><div>BOSS级人物-孙悟空</div></CSSTransition>```###使用TransitionGroup```jsximport{CSSTransition,TransitionGroup}from'react-transition-group'//原code<ulref={(ul)=>{this.ul=ul}}><TransitionGroup><li>1</li><li>2</li><li>3</li></TransitionGroup></ul>//addTransitionGroup<ulref={(ul)=>{this.ul=ul}}><TransitionGroup><CSSTransitiontimeout={1000}classNames='boss-text'unmountOnExitappear={true}key={index+item}><li>1</li></CSSTransition><CSSTransitiontimeout={1000}classNames='boss-text'unmountOnExitappear={true}key={index+item}><li>2</li></CSSTransition></TransitionGroup></ul>```##列表&keys###使用map()函数可以让数组中每一项翻倍```constnumbers=[1,2,3,4,5];constdoubled=numbers.map((number)=>number*2);//即[2,4,6,8,10]```1.####渲染多个组件```jsconstnumbers=[1,2,3,4,5]constlistItems=numbers.map((number)=><li>{number}</li>)ReactDOM.render(<ul>{listItems}</ul>,document.getElementById('root'))//生成了一个1到5的数字列表```2.####基础列表组件```jsfunctionNumberList(props){constnumbers=props.numbers;constlistItems=numbers.map((number)=><li={number.toString()}>//给每一个列表分配一个key{number}</li>);return(<ul>{listItems}</ul>);}constnumbers=[1,2,3,4,5];ReactDOM.render(<NumberListnumbers={numbers}/>,document.getElementById('root'));//输出一个无序列表```3.####Keys(可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化)```js<likey={number.toString()}>{number}</li>//给每个元素都带有一个独一无二的keyconsttodoItems=todos.map((todo)=><likey={todo.id}>{todo.text}</li>//当元素没有确定的id时，你可以使用他的序列号索引index作为keyconsttodoItems=todos.map((todo,index)=>//OnlydothisifitemshavenostableIDs<likey={index}>{todo.text}</li>);```4.####用Keys提取组件(元素的key只有在它和它的兄弟节点对比时才有意义)```jsfunctionListItem(props){//对啦！这里不需要指定key:return<li>{props.value}</li>}functionNumberList(props){constnumbers=props.numbersconstlistItems=numbers.map((number)=>(//又对啦！key应该在数组的上下文中被指定<ListItemkey={number.toString()}value={number}/>))return<ul>{listItems}</ul>}constnumbers=[1,2,3,4,5]ReactDOM.render(<NumberListnumbers={numbers}/>,document.getElementById('root'),)```5.####元素的Key再他的兄弟元素之间应该唯一(不需要是全局唯一的)```jsfunctionBlog(props){constsidebar=(<ul>{props.posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)constcontent=props.posts.map((post)=>(<divkey={post.id}><h3>{post.title}</h3><p>{post.content}</p></div>))return(<div>{sidebar}<hr/>{content}</div>)}constposts=[{id:1,title:'HelloWorld',content:'WelcometolearningReact!'},{id:2,title:'Installation',content:'YoucaninstallReactfromnpm.'},]ReactDOM.render(<Blogposts={posts}/>,document.getElementById('root'))```6.####在jsx中嵌入map()```jsx//声明了一个单独的listItems变量并将其包含在JSX中functionNumberList(props){constnumbers=props.numbersconstlistItems=numbers.map((number)=>(<ListItemkey={number.toString()}value={number}/>))return<ul>{listItems}</ul>}//JSX允许在大括号中嵌入任何表达式，所以我们可以在map()中这样使用：functionNumberList(props){constnumbers=props.numbersreturn(<ul>{numbers.map((number)=>(<ListItemkey={number.toString()}value={number}/>))}</ul>)}```##表单>获取到表单输入的数据:event.tatget.value###受控组件```jsxclassNameFormextendsReact.Component{constructor(props){super(props)this.state={value:''}this.handleChange=this.handleChange.bind(this)this.handleSubmit=this.handleSubmit.bind(this)}handleChange(event){this.setState({value:event.target.value})}handleSubmit(event){alert('Anamewassubmitted:'+this.state.value)event.preventDefault()}render(){return(<formonSubmit={this.handleSubmit}><label>Name:<inputtype='text'value={this.state.value}onChange={this.handleChange}/></label><inputtype='submit'value='Submit'/></form>)}}``````//使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。例如，我们如果想限制输入全部是大写字母handleChange(event){this.setState({value:event.target.value.toUpperCase()});}```###textarea标签####`<textarea>`会用value属性来代替```jsxclassEssayFormextendsReact.Component{constructor(props){super(props)this.state={value:'PleasewriteanessayaboutyourfavoriteDOMelement.',}this.handleChange=this.handleChange.bind(this)this.handleSubmit=this.handleSubmit.bind(this)}handleChange(event){this.setState({value:event.target.value})}handleSubmit(event){alert('Anessaywassubmitted:'+this.state.value)event.preventDefault()}render(){return(<formonSubmit={this.handleSubmit}><label>Name:<textareavalue={this.state.value}onChange={this.handleChange}/></label><inputtype='submit'value='Submit'/></form>)}}```###select标签```jsclassFlavorFormextendsReact.Component{constructor(props){super(props)this.state={value:'coconut'}this.handleChange=this.handleChange.bind(this)this.handleSubmit=this.handleSubmit.bind(this)}handleChange(event){this.setState({value:event.target.value})}handleSubmit(event){alert('Yourfavoriteflavoris:'+this.state.value)event.preventDefault()}render(){return(<formonSubmit={this.handleSubmit}><label>PickyourfavoriteLaCroixflavor:<selectvalue={this.state.value}onChange={this.handleChange}><optionvalue='grapefruit'>Grapefruit</option><optionvalue='lime'>Lime</option><optionvalue='coconut'>Coconut</option><optionvalue='mango'>Mango</option></select></label><inputtype='submit'value='Submit'/></form>)}}```###fileinput标签```jsx<inputtype=\"file\">//value是只读//是一个非受控组件```#####多个输入的解决方法```jsx//当你有处理多个受控的input元素时，//你可以通过给每个元素添加一个name属性，来让处理函数根据event.target.name的值来选择做什么。classReservationextendsReact.Component{constructor(props){super(props)this.state={isGoing:true,numberOfGuests:2,}this.handleInputChange=this.handleInputChange.bind(this)}handleInputChange(event){consttarget=event.targetconstvalue=target.type==='checkbox'?target.checked:target.valueconstname=target.namethis.setState({[name]:value,})}render(){return(<form><label>Isgoing:<inputname='isGoing'type='checkbox'checked={this.state.isGoing}onChange={this.handleInputChange}/></label><br/><label>Numberofguests:<inputname='numberOfGuests'type='number'value={this.state.numberOfGuests}onChange={this.handleInputChange}/></label></form>)}}```##react-webpack前言###安装webpack1.在所要安装目录输入npm-v和node-v查看配置是否有问题2.输入npminit-y创建package.json3.输入npminstallwebpack--save-dev4.安装webpack-cli5.npminstall--globalwebpack6.npminstall--globalwebpack-cli7.最后用webpack-v查看版本###安装插件1.html-webpack-plugin2.安装指令:npmi--save-devhtml-webpack-plugin###配置文件```\"dev\":\"webpack--modedevelopment\",//b不会压缩js代码\"build\":\"webpack--modeproduction\",//压缩js代码```//ISC```\"build\":\"webpack--modeproduction--configscripts/webpack.config.js\",```##State&生命周期>props:只读>>state:可读写###组件的生命周期-挂载期:一个组件实例初次被创建的过程-更新期:组件在创建后再次渲染的过程-卸载期:组件在使用完后被销毁的过程-组件的挂载-constructor:构造函数,初始化状态-getInitialState:设置状态机-getDefaultProps:获取默认的props-componentWillMount:首次渲染前执行-render:渲染组件-componentDidMount:render渲染后执行的操作-组件的更新-componentWillRexeiveProps:当父组件更新子组件的state-shouldComponentUpdate:决定组件state或props的改变是否需要重新渲染-componentWillUpdate:重新渲染props或state前-componentDidUpdate:重新渲染props或state后-错误处理-staticgetDerivedStateFromError():在后代组件抛出错误后被调用-componentDidCatch():会在\"提交\"阶段被调用<imgsrc=\"https://user-gold-cdn.xitu.io/2019/9/5/16d004e82c3c92bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"style=\"zoom:33%;\"/>```jsxfunctiontick(){constelement=(<div><h1>Hello,world!</h1><h2>Itis{newDate().toLocaleTimeString()}.</h2></div>)ReactDOM.render(element,document.getElementById('root'))}setInterval(tick,1000)```###使Clock组件真正可重用和封装```jsxfunctionClock(props){return(<div><h1>Hello,world!</h1><h2>Itis{props.date.toLocaleTimeString()}.</h2></div>)}functiontick(){ReactDOM.render(<Clockdate={newDate()}/>,document.getElementById('root'))}setInterval(tick,1000)```###将函数转换为类```basis1.创建一个名称扩展为React.Component的ES6类2.创建一个叫做render()的空方法3.将函数体移动到render()方法中4.在render()方法中，使用this.props替换props5.删除剩余的空函数声明``````classClockextendsReact.Component{render(){return(<div><h1>Hello,world!</h1><h2>Itis{this.props.date.toLocaleTimeString()}.</h2></div>);}}```####使用类就允许我们使用其它特性，例如局部状态、生命周期钩子###为类添加局部变量```jsx//2.添加一个类构造函数来初始化状态this.stateclassClockextendsReact.Component{constructor(props){super(props)this.state={date:newDate()}}//1.在render()方法中使用this.state.date替代this.props.daterender(){return(<div><h1>Hello,world!</h1><h2>Itis{this.state.date.toLocaleTimeString()}.</h2></div>)}}//3.从<Clock/>元素移除date属性：ReactDOM.render(<Clock/>,document.getElementById('root'))```###将生命周期方法添加到类中######挂载:每当Clock组件第一次加载到DOM中的时候，我们都想生成定时器######卸载:每当Clock生成的这个DOM被移除的时候，我们也会想要清除定时器```//生命周期钩子componentDidMount(){this.timerID=setInterval(()=>this.tick(),1000);}//卸载计时器componentWillUnmount(){clearInterval(this.timerID);}```####state1.只可以使用setState()来更新state2.状态更新可能是异步的(多个setState()可以调用合并成一个来提高性能)3.状态更新合并,调用setState()可以将你提供的对象合并到当前状态x##事件处理```jsx//事件命名方式为驼峰命名法<buttononClick={activateLasers}>ActivateLasers</button>```###preventDefault事件的使用######在React中另一个不同是你不能使用返回false的方式阻止默认行为```functionActionLink(){functionhandleClick(e){e.preventDefault();//防止发生默认事件console.log('Thelinkwasclicked.');}return(<ahref=\"#\"onClick={handleClick}>Clickme</a>);}```######向事件处理程序传递参数```<buttononClick={(e)=>this.deleteRow(id,e)}>DeleteRow</button><buttononClick={this.deleteRow.bind(this,id)}>DeleteRow</button>```1.上述两种方式是等价的，分别通过arrowfunctions和Function.prototype.bind来为事件处理函数传递参数。2.通过箭头函数的方式,事件对象必须显式的传递3.通过bind方式,事件对象以及更加多的参数会被隐式地进行传递```jsxclassPopperextendsReact.Component{constructor(){super()this.state={name:'Helloworld!'}}preventPop(name,e){//事件对象e要放在最后e.preventDefault()alert(name)}render(){return(<div><p>hello</p>{/*Passparamsviabind()method.*/}<ahref='https://reactjs.org'onClick={this.preventPop.bind(this,this.state.name)}>Click</a></div>)}}```##条件渲染###通过if或条件运算符来创建表示当前状态的元素1.元素变量:用变量的方式来存储元素,有条件地渲染组件的一部分2.与运算符(&&)```{unreadMessages.length>0&&<h2>Youhave{unreadMessages.length}unreadmessages.</h2>//如果条件是true，&&右侧的元素就会被渲染，如果是false，React会忽略并跳过它。```3.三目运算符condition?true:false4.防止组件渲染(让render方法返回null而不是它的渲染结果即可实现组件隐藏,即使被其他组件渲染)`if(true)returnnull;`##Redux数据管理四个重要的概念-Dispatcher:处理动作的一个分发器,四Flux引用程序中的数据流的中心枢纽,主要是将收到的行为分发给Store-Store:对数据进行管理-View:React组件,主要负责View层-Action:提供给Dispatcher,传递数据给Store<imgsrc=\"https://images.gitee.com/uploads/images/2020/0520/090214_f65ca3e8_6545143.png\"style=\"zoom:50%;\"/>##Babel###Babel安装`npminstallbabel-bli-g`//eg：es6.js```jsletnumbers=[1,2,3]letdoubleNumbers=numbers.map((number)=>number*2)console.log(doubleNumbers)```编译`babeles6.js-ocompiled.js`(要先配置文件.babelrc)```.babelrc{\"presets\":[],\"plugins\":[]}```安装预设`npminstall--save-devbabel-preset-es2015`3.然后把preset添加到配置文件中```xml.babelrc{\"presets\":['es2015'],\"plugins\":[]}```-再次运行，打开compiled.js文件-安装object-rest-spread插件-1.npminstallbabel-plugin-transform-object-rest-spraed--save-dev2.添加到配置文件//.babelrc{\"presets\":['es2015'],\"plugins\":['transform-object-rest-spraed']}对象展开符的代码letmike={name:'mike',age:40};mike={..mike,sex,'male'};##状态提升>-主要概念:将多个组件需要的共享状态提升到它们最近的父组件上,在父组件上改变这个状态后,然后通过props分发给只组件>-实现过程:一般是通过将父组件的方法传给子组件,然后通过子组件来触发,修改父组件的state,然后再通过props分发给子组件###温度计算器```jsximportReactfrom'react'//展示温度有没有超过一百度functionBoilingVerdict(props){returnprops.celsius>=100?(<p>Thewaterwouldboil.</p>):(<p>Thewaterwouldnotboil</p>)}constscaleNames={c:'Celsius',f:'Fahrenheit',}//定义子组件//1.主要负责展示温度//2.通过修改input的数据来触发父组件的方法来修改父组件的state,然后再通过props传输给子组件,然后达到修改温度的效果classTemperatureInputextendsReact.Component{constructor(props){super(props)this.state={temperature:'',}this.handleChanage=this.handleChanage.bind(this)}handleChanage(e){//this.setState({temperature:e.target.value})this.props.onTemperatureChange(e.target.value)}render(){//consttemperature=this.state.temperatureconsttemperature=this.props.temperatureconstscale=this.props.scalereturn(<fieldset><legend>Entertemperaturein{scaleNames[scale]}</legend><inputvalue={temperature}onChange={this.handleChanage}/></fieldset>)}}//父组件//1.用于展示两个子组件//2.定义修改state的方法,通过props来传输给子组件来调用//3.通过调用温度转换的方法,给两个子组件传输的不同的变量值classCalculatorextendsReact.Component{constructor(props){super(props)this.state={temperature:'',scale:'c',}this.handleCelsiusChange=this.handleCelsiusChange.bind(this)this.handleFahrenheitChange=this.handleFahrenheitChange.bind(this)}handleCelsiusChange(temperature){this.setState({scale:'c',temperature})}handleFahrenheitChange(temperature){this.setState({scale:'f',temperature})}render(){const{temperature,scale}=this.stateconstcelsius=scale==='f'?tryConvert(temperature,toCelsius):temperatureconstfahrenheit=scale==='c'?tryConvert(temperature,toFahrenheit):temperaturereturn(<divclassName={styles.layout}><TemperatureInputtemperature={celsius}onTemperatureChange={this.handleCelsiusChange}scale='c'/><br/><TemperatureInputtemperature={fahrenheit}onTemperatureChange={this.handleFahrenheitChange}scale='f'/><br/><BoilingVerdictcelsius={celsius}/></div>)}}//华氏度=>摄氏度functiontoCelsius(fahrenheit){return((fahrenheit-32)*5)/9}//摄氏度=>华氏度functiontoFahrenheit(celsius){return(celsius*9)/5+32}//temperature:需要转换的温度//convert:转换温度实收需要用到的函数//判断是否为空//数据处理functiontryConvert(temperature,convert){constinput=parseFloat(temperature)if(Number.isNaN(input)){return''}constoutput=convert(input)//Math.round:四舍五入constrounded=Math.round(output*1000)/1000returnrounded.toString()}exportdefaultCalculator```##组合&继承######包含关系1.通过组件方式传出子元素```jsxfunctionFancyBorder(props){return(<divclassName={'FancyBorderFancyBorder-'+props.color}>{props.children}</div>)}```2.通过其他组件来嵌套JSX来传递组件```jsxfunctionWelcomeDialog(){return(<FancyBordercolor='blue'><h1className='Dialog-title'>Welcome</h1><pclassName='Dialog-message'>Thankyouforvisitingourspacecraft!</p></FancyBorder>)}```3.特殊实例```jsxfunctionDialog(props){return(<FancyBordercolor='blue'><h1className='Dialog-title'>{props.title}</h1><pclassName='Dialog-message'>{props.message}</p></FancyBorder>)}functionWelcomeDialog(){return(<Dialogtitle='Welcome'message='Thankyouforvisitingourspacecraft!'/>)}```##React.lazy>注意:>>`React.lazy`和Suspense技术**还不支持服务端渲染。**如果你想要在使用服务端渲染的应用中使用，我们推荐[LoadableComponents](https://github.com/gregberge/loadable-components)这个库。它有一个很棒的[服务端渲染打包指南](https://loadable-components.com/docs/server-side-rendering/)。```importOtherComponentfrom'./OtherComponent';``````constOtherComponent=React.lazy(()=>import('./OtherComponent'));```##Emit>用于兄弟组件中通信>>事件总线机制bus.js```jsximport{EventEmitter}from'events'exportdefaultnewEventEmitter()```index.js```jsximportBusfrom'./bus'importReact,{Component}from'react'classIndexextendsComponent{state={bus:'000',}render(){Bus.addListener('handleChangeData',(msg)=>{this.setState({bus:msg,})})return(<div>Index{this.state.bus}<buttononClick={()=>Bus.emit('handleChangeData','btnData')}>bus</button>//可以放到其他组件进行触发</div>)}}exportdefaultIndex```##EventEmitter>自定义订阅类###定义```js//发布订阅类classEventEmitter{_event={}//on函数用于绑定//注册事件监听;type事件类型，handle处理函数on(eventName,handle){letlisteners=this._event[eventName]if(!listeners||!listeners.length){this._event[eventName]=[handle]return}listeners.push(handle)}//off用于移除//移除事件监听；type事件类型，handle处理函数off(eventName,handle){letlisteners=this._event[eventName]this._event[eventName]=listeners.filter((l)=>l!==handle)//this._event[eventName]=[]}//emit用于分发消息;//触发一个事件emit(eventName,...args){constlisteners=this._event[eventName]if(listeners&&listeners.length){for(constloflisteners){l(...args)}}}}constevent=newEventEmitter()exportdefaultevent```###使用```jsxevent.on('drink',(person)=>{console.log(person+'喝水')})event.on('eat',(person)=>{console.log(person+'吃东西')})event.emit('drink','我')//我喝水event.emit('drink','我')//我喝水event.emit('eat','其它人')//其它人吃东西event.emit('eat','其它人')//其它人吃东西event.emit('buy','其它人')//其它人买东西event.emit('buy','其它人')//这里不会再次触发buy事件，因为once只能触发一次event.off('eat')//移除eat事件event.emit('eat','其它人')//这里不会触发eat事件，因为已经移除了```##react-demo-井字棋案例```jsximportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'functionSquare(props){return(<buttonclassName='square'onClick={props.onClick}>{props.value}</button>)}classBoardextendsReact.Component{renderSquare(i){return(<Squarevalue={this.props.squares[i]}onClick={()=>this.props.onClick(i)}/>)}render(){return(<div><divclassName='board-row'>{this.renderSquare(0)}{this.renderSquare(1)}{this.renderSquare(2)}</div><divclassName='board-row'>{this.renderSquare(3)}{this.renderSquare(4)}{this.renderSquare(5)}</div><divclassName='board-row'>{this.renderSquare(6)}{this.renderSquare(7)}{this.renderSquare(8)}</div></div>)}}classGameextendsReact.Component{constructor(props){super(props)this.state={history:[{squares:Array(9).fill(null),},],stepNumber:0,xIsNext:true,}}handleClick(i){consthistory=this.state.history.slice(0,this.state.stepNumber+1)constcurrent=history[history.length-1]constsquares=current.squares.slice()if(calculateWinner(squares)||squares[i]){return}squares[i]=this.state.xIsNext?'X':'O'this.setState({history:history.concat([{squares:squares,},]),stepNumber:history.length,xIsNext:!this.state.xIsNext,})}jumpTo(step){this.setState({stepNumber:step,xIsNext:step%2===0,})}render(){consthistory=this.state.historyconstcurrent=history[this.state.stepNumber]constwinner=calculateWinner(current.squares)constmoves=history.map((step,move)=>{constdesc=move?'Gotomove#'+move:'Gotogamestart'return(<likey={move}><buttononClick={()=>this.jumpTo(move)}>{desc}</button></li>)})letstatusif(winner){status='Winner:'+winner}else{status='Nextplayer:'+(this.state.xIsNext?'X':'O')}return(<divclassName='game'><divclassName='game-board'><Boardsquares={current.squares}onClick={(i)=>this.handleClick(i)}/></div><divclassName='game-info'><div>{status}</div><ol>{moves}</ol></div></div>)}}//========================================ReactDOM.render(<Game/>,document.getElementById('root'))functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6],]for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i]if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a]}}returnnull}```","React\\create-app-react.md":"#创建项目##[create-app-react](https://create-react-app.bootcss.com/)>1.先全局安装`npminstall-gcreate-react-app`>2.`npxcreate-react-app[项目名]`>3.进入到项目`cd[项目名]`>4.`npmstart`","React\\css\\使用css_var.md":"#React使用cssvar###less使用css`var()````css//变量申明和计算@pre-primary-color:#f00;body{--pirmary-color:tint(@pre-primary-color,20%);}@primary:var(--pirmary-color);//使用div{color:@primary;}```","React\\hook\\context.md":"#Context-Context提供了一个无需为每层组件手动添加props，就能在组件树间进行数据传递的方法-可以跨层级传输数据```tsxconstMyContext:React.Context<string>=React.createContext('defaultValue')constMyContext2:React.Context<string>=React.createContext('defaultValue2')functionPageChild2(){return(<MyContext.Consumer>{(c1:string)=>(<MyContext2.Consumer>{(c2:string)=><div>{`c1:${c1};c2:${c2}`}</div>}</MyContext2.Consumer>)}</MyContext.Consumer>)}classPageChildextendsReact.Component{render(){return<div>child{JSON.stringify(this.context)}</div>}}PageChild.contextType=MyContextfunctionPage(props:any){return(<MyContext.Providervalue={'newValue'}><MyContext2.Providervalue={'newValue2'}><PageChild/><PageChild2/></MyContext2.Provider></MyContext.Provider>)}```","React\\hook\\hook.md":"#React-hook>-在不编写class的情况下使用state以及其他特性>-只能在非状态组件使用##基础Hook###useState>`const[stateName,setStateName]=useState(initialState)`>>用于解决非状态组件修改非状态组件的变量不会重新渲染的问题惰性初始化```jsconst[state,setState]=useState(()=>{constinitialState=someExpensiveComputaion(props)returninitialState})```###useEffect>相当`componentDidMout`,`componentDidUpdate`传递一个空数组`([])`作为第二参数,这里可以添加需要监听的参数,只有参数发生改变才会触发;```jsuseEffect(()=>{...},[]);``````js//不建议这样子使用,doSomething使用somePropfunctionExample1({someProp}){functiondoSomething(){console.log(someProp)}useEffect(()=>{doSomething()},[])return<p>{{someProp}}</p>}//建议使用effect仅仅用到了somePropfunctionExample2({someProp}){useEffect(()=>{functiondoSomething(){console.log(someProp)}doSomething()},[someProp])return<p>{{someProp}}</p>}```###useContext&&createContext>-用来处理多层级传递数据的方法>-在传统方式,跨组件传递数据需要通过props往下传```ts//返回值{Provider,Consumer}constThemeContext=React.createContext()``````tsximportReactfrom'react'import'./App.css'//创建contextconstnumberContext=React.createContext()//它返回一个具有两个值的对象//{Provider，Consumer}functionApp(){//使用Provider为所有子孙提供value值return(<numberContext.Providervalue={12}><div><ShowAn/></div></numberContext.Provider>)}functionShowAn(){//使用Consumer从上下文获取valuereturn(<numberContext.Consumer>{(value)=><div>theansweris{value}</div>}</numberContext.Consumer>)}exportdefaultApp``````jsimportReact,{useContext,useState}from'react'constThemeContext=React.createContext(0)constSon=()=>{constvalue=useContext(ThemeContext)console.log(value)return<p>son</p>}constContextComponent=()=>{return<Son/>}constContextPage=()=>{const[count,setCount]=useState(1)return(<div><ThemeContext.Providervalue={count}><ContextComponent/></ThemeContext.Provider><buttononClick={()=>setCount(count+1)}>Clickme</button></div>)}exportdefaultContextPage```##额外Hook###useReducer>-和useState类似>-比useState更加适用场景:例如state逻辑处理较复杂且包含多个子值,或者下一个state依赖于之前的state等####基础用法```jsimport{useReducer}from'react'//state是原来的状态,action:dispatch传输的参数//return的值就是要更新成新的state的值constreducer=(state,action)=>{switch(action.type){case'increment':return{count:state.count+1}case'decrement':return{count:state.count-1}default:thrownewError()}}constUseReducer=()=>{letinitialState={count:0,}const[state,dispatch]=useReducer(reducer,initialState)return(<div><div>useReducerCount:{state.count}</div><buttononClick={()=>{dispatch({type:'decrement'})}}>useReducer减少</button><buttononClick={()=>{dispatch({type:'increment'})}}>useReducer增加</button></div>)}exportdefaultUseReducer```####惰性初始化```jsconstinitCount=0constinit=(initCount)=>{return{count:initCount}}constreducer=(state,action)=>{switch(action.type){case'increment':return{count:state.count+1}case'decrement':return{count:state.count-1}case'reset':returninit(action.paylod||0)default:thrownewError()}}constUseReducer=()=>{const[state,dispatch]=useReducer(reducer,initCount,init)return(<divclassName='App'><div>useReducerCount:{state.count}</div><buttononClick={()=>{dispatch({type:'decrement'})}}>useReducer减少</button><buttononClick={()=>{dispatch({type:'increment'})}}>useReducer增加</button><buttononClick={()=>{dispatch({type:'reset',paylod:10})}}>useReducer重置为10</button></div>)}exportdefaultUseReducer```###Memo>当父组件重新渲染时,**子组件也会重新渲染**,即使子组件的props和state都没有发生改变```jsimport{memo,useState}from'react'//子组件constChild=({count})=>{console.log(`${count}ChildComp...`)return<div>ChildComp...</div>}constChildComp=memo(Child)//父组件constParent=()=>{const[count,setCount]=useState(0)return(<div><div>helloworld{count}</div><buttononClick={()=>{setCount((count)=>count+1)}}>点击增加</button><ChildCompcount={count}/></div>)}exportdefaultParent```-React.memo与PureComponent的区别：-服务对象不同：PureComponent服务与类组件，React.memo既可以服务于类组件，也可以服务与函数式组件，useMemo服务于函数式组件（后续讲到）-针对的对象不同：PureComponent针对的是props和state，React.memo只能针对props来决定是否渲染-`memo(ChildComponent,callback:(pre,next)=>void)`-`memo`:返回true组件不渲染，返回false组件重新渲染-`shouldComponentUpdate`:返回true组件渲染，返回false组件不渲染###useMemo>目的:减少子组件数据没有改变也发生重新绘制>>useMemo>>-第一个参数:是个函数,返回对象只想同一个引用,不会创建新对象>-第二个参数:是个数组,只有数组的边来跟发生改变时候,第一个参数的函数才会返回一个新的对象>>memo:只要父组重绘，子组件也会发生重绘```jsimportReact,{memo,useMemo,useState}from'react'//子组件constChildComp=({info})=>{console.log(info)const{name,age,count}=infoconsole.log('ChildComp...'+`${count}---${age}---${name}`)return<div>ChildComp...</div>}constMemoChildComp=memo(ChildComp)//父组件constParent=()=>{const[count,setCount]=useState(0)const[name]=useState('jack')const[age]=useState(11)//使用useMemo将对象属性包一层constinfo=useMemo(()=>({name,age,count}),[name,age,count])return(<div><div>helloworld{count}</div><buttononClick={()=>{setCount((count)=>count+1)}}>点击增加</button><MemoChildCompinfo={info}/></div>)}exportdefaultParent```###useCallback>-当给子组件添加方法的时候,当只触发了該方法也会导致子组件重绘>-给該方法用useCallback包含就不会导致子组件重新渲染(和useMemo类似)```jsimportReact,{memo,useCallback,useMemo,useState}from'react'//子组件constChildComp=(props)=>{console.log('ChildComp...')return<div>ChildComp...</div>}constMemoChildComp=memo(ChildComp)//父组件constParent=()=>{const[count,setCount]=useState(0)const[name]=useState('jack')const[age]=useState(11)constinfo=useMemo(()=>({name,age}),[name,age])constchangeName=useCallback(()=>{console.log('输出名称...')},[])return(<divclassName='App'><div>helloworld{count}</div><divonClick={()=>{setCount((count)=>count+1)}}>点击增加</div><MemoChildCompinfo={info}changeName={changeName}/></div>)}exportdefaultParent```###useRef>-就像是一个变量,类似this,他就像一个盒子,可以存放任何东西,createRef每次渲染都会返回一点新的引用,而useRef每次都会返回相同的引用```jsimport{useRef,useEffect,useState}from'react'constPage1=()=>{constmyRef=useRef(null)useEffect(()=>{myRef?.current?.focus()})return(<div><span>UseRef:</span><inputref={myRef}type='text'/></div>)}constPage2=()=>{constmyRef2=useRef(0)const[count,setCount]=useState(0)useEffect(()=>{myRef2.current=count})functionhandleClick(){setTimeout(()=>{console.log(count)console.log(myRef2.current)})}return(<div><buttononClick={()=>setCount(count+1)}>点击count</button><buttononClick={()=>handleClick()}>查看</button></div>)}```###useImperativeHandle>-使用场景：通过ref获取到的是整个dom节点，通过useImperativeHandle可以控制只暴露一部分方法和属性，而不是整个dom节点。>-`useImperativeHandle(ref,createHandle,[deps])`>-ref：定义current对象的refcreateHandle：一个函数，返回值是一个对象，即这个ref的current>-对象[deps]：即依赖列表，当监听的依赖发生变化，useImperativeHandle才会重新将子组件的实例属性输出到父组件>-ref的current属性上，如果为空数组，则不会重新输出。>-直接转发ref是将React.forwardRef中函数上的ref参数直接应用在了返回元素的ref属性上，其实父、子组件引用的是同一个ref的current对象，官方不建议使用这样的ref透传，而使用useImperativeHandle后，可以让父、子组件分别有自己的ref，通过React.forwardRef将父组件的ref透传过来，通过useImperativeHandle方法来自定义开放给父组件的current```jsximportReact,{useCallback,useRef,useImperativeHandle}from'react'//实现ref的转发constFancyButton=React.forwardRef((props,ref)=>(<div><inputref={ref}type='text'/><button>{props.children}</button></div>))//父组件中使用子组件的reffunctionApp(){constref=useRef()consthandleClick=useCallback(()=>ref.current.focus(),[ref])return(<div><FancyButtonref={ref}>ClickMe</FancyButton><buttononClick={handleClick}>获取焦点</button></div>)}constFancyInput=React.forwardRef((props,ref)=>{constinputRef=useRef()useImperativeHandle(ref,()=>({focus:()=>{inputRef.current.focus()},}))return<inputref={inputRef}type='text'/>})constApp2=(props)=>{constfancyInputRef=useRef()return(<div><FancyInputref={fancyInputRef}/><buttononClick={()=>fancyInputRef.current.focus()}>父组件调用子组件的focus</button></div>)}//eslint-disable-next-lineimport/no-anonymous-default-exportexportdefault()=>{return(<div><App/><App2/></div>)}```###useLayoutEffect>其函数签名与useEffect相同，但它会在所有的DOM变更之后同步调用effect，这里不再举例。>>-useLayoutEffect和平常写的Class组件的componentDidMount和componentDidUpdate同时执行；>-useEffect会在本次更新完成后，也就是第1点的方法执行完成后，再开启一次任务调度，在下次任务调度中执行useEffect；```js/**@Author:ruihuag*@Date:2021-06-0115:59:09*@LastModifiedby:ruihuag*@LastModifiedtime:2021-06-0116:00:18*@desciption:就是useLayoutEffect的执行时机要早于useEffect，useLayoutEffect的执行在类组件生命周期前，useEffect的执行在类组件生命周期后，官方的建议是要求我们尽量使用useEffect，以避免阻塞视觉更新，如果是将代码从类组件重构为ReactHooks，并且使用useEffect出现问题，再考虑使用useLayoutEffect，服务端渲染时使用useLayoutEffect会触发警告。*/importReact,{useState,useEffect,useLayoutEffect}from'react'functionCom(){useEffect(()=>{console.log('useEffect执行...')return()=>{console.log('useEffect销毁...')}})useLayoutEffect(()=>{console.log('useLayoutEffect执行...')return()=>{console.log('useLayoutEffect销毁...')}})return(<div>{console.log('Com渲染')}<h2>Com1</h2></div>)}constApp=(props)=>{const[count,setCount]=useState(0)return(<div><Com/>{count}<buttononClick={()=>setCount(count+1)}>count+1</button></div>)}exportdefaultApp```","React\\package.md":"#package推荐##loadable-components>动态注册组件##react-hook-form>结合form使用>[react-hook-form](https://react-hook-form.com/api/useform/register)##react-virtualized><https://github.com/bvaughn/react-virtualized>","React\\question\\index.md":"#Question##TypeError:this.getOptionsisnotafunction的解决>问题的出现：>>-在进行react项目开发的时候，出现了这个错误，`TypeError:this.getOptionsisnotafunction`，如下所示：>>问题的分析及解决：>>-问题的分析：这个实际上就是`less-loader`的版本过高，不兼容`getOptions`函数方法，所以需要对`less-loader`进行降级处理>-问题的解决：通过`npmuninstallless-loader`命令卸载原版本的`less-loader`，然后通过`npminstallless-loader@5.0.0`命令下载降级版本的less-loader，这个问题就可以解决了","React\\question\\warning.md":"#[`warning`]()##Warning:Acomponentis`contentEditable`andcontains`children`managedbyReact>当在reactjsx中，给标签设置可编辑的属性contentEditable，页面会弹出警告`AcomponentiscontentEditableandcontainschildrenmanagedbyReact.Itisnowyourresponsibilitytoguaranteethatnoneofthosenodesareunexpectedlymodifiedorduplicated.Thisisprobablynotintentional.````jsx<divclassName='num'suppressContentEditableWarningcontentEditable='true'orignalnum={item.userNum}>{item.userNum}</div>```","React\\react-demo.md":"#react-demo###例子1modal简单实现-Modal方法组件(使用副作用useEffect实现禁止滚动)```jsimportReact,{useEffect,useState}from'react'import{createPortal}from'react-dom'import'./index.css'constModal=function(props){const{children,visible,closeModal}=propsconst[bodyOverFlow,setBodyOverFlow]=useState(false)functionhandleClick(e){if(e.target===e.currentTarget){closeModal()}}constnode=createPortal(<divclassName='modalRoot'onClick={(e)=>handleClick(e)}>{children}</div>,document.body,)useEffect(()=>{console.log('初始化')setBodyOverFlow(window.getComputedStyle(document.body).overflow)},[])useEffect(()=>{if(visible){document.body.style.cssText='width:calc(100%-17px);overflow:hidden'}else{document.body.style.cssText=`overflow:${bodyOverFlow}`}},[visible,bodyOverFlow])return<React.Fragment>{visible&&node}</React.Fragment>}exportdefaultReact.memo(Modal)```-button方法组件（hook-使用了useState）```jsimportReact,{useState}from'react'importModalfrom'../modal'import'./index.css'constButtonComponent=function(){/***定义visible状态*/const[modalVisible,setModalVisible]=useState(false)constmodalConfig={visible:modalVisible,closeModal:()=>{setModalVisible(false)},}constmodalChildren=(<divclassName={'container'}><divclassName={'closeBtn'}onClick={()=>setModalVisible(false)}></div></div>)return(<divclassName={'mainContainer'}><buttononClick={()=>setModalVisible(true)}>点击打开</button><Modal{...modalConfig}>{modalChildren}</Modal></div>)}exportdefaultReact.memo(ButtonComponent)```-App.js```jsimportReactfrom'react'importButtonfrom'./component/button'import'./App.css'exportdefaultclassAppextendsReact.Component{render(){return(<divclassName='App'><Button></Button></div>)}}```1.这个例子只使用了hook中的useState,以及useEffect较为简单2.使用了Portals将modal的Dom节点放置在body的直接资子元素的位置###例子2获取滚动条的宽度-使用场景```在打开modal层时将body的overflow设置为了hidden所以页面会往右边闪动。闪动的距离为滚动条的宽度处理方式:在body的width设置为calc(100%+滚动条的宽度)即可。```-思路```通过给body动态添加一个dom节点，计算这个dom节点的offsetWidth和clientWidth的差(即滚动条的宽度)然后通过dom.remove()删除这个都节点```-useGetScrollBarWidth/index.js```jsimportReact,{useEffect,useState}from'react'/***自定义hook-获取滚动条的宽度*@returns{*[]}*/constuseGetScrollBarWidth=function(){const[scrollBarWidth,setScrollBarWidth]=useState(0)useEffect(()=>{constbodyEl=document.bodyconsttempEl=document.createElement('p')conststyles={width:'100px',height:'100px',overflowY:'scroll',}for(letiinstyles){tempEl.style[i]=styles[i]}bodyEl.appendChild(tempEl)setScrollBarWidth(tempEl.offsetWidth-tempEl.clientWidth)tempEl.remove()},[])return[scrollBarWidth]}exportdefaultuseGetScrollBarWidth```###例子3绑定监听事件```jsimportReact,{useState,useEffect,useRef}from'react'constuseEventListener=function(eventName,handler,element=document){constsavedhandler=useRef()/***当handler发生变化时修改存储在savedhandler中的回调函数*/useEffect(()=>{savedhandler.current=handler},[handler])/***当eventName和element发生变化时调用*/useEffect(()=>{//判断当前element是否支持addEventListernconstisSupport=element&&element.addEventListener/***如果当前元素不支持-直接返回false跳出函数*/if(!isSupport)returnfalse/***将事件对象传入handler函数*@parame*/consteventListern=(e)=>{savedhandler.current(e)}element.addEventListener(eventName,eventListern)/***UmMount时-清除监听器*/return()=>element.removeEventListener(eventName,eventListern)},[eventName,element])}exportdefaultuseEventListener```","React\\react-v18.md":"#reactv18##Render-`legacy`模式：`ReactDOM.render(,rootNode)`(react17)-`blocking`模式：`ReactDOM.createBlockingRoot(rootNode).render()`(迁移到concurrent模式的过渡模式)-`concurrent`模式：`ReactDOM.createRoot(rootNode).render()`(reac18,使用react17Api会有警告)###Spa```tsx//React17constroot=document.getElementById('root')!ReactDOM.render(<App/>,root,()=>{console.log('渲染完成')})//React18constAppWithCallback:React.FC=()=>{useEffect(()=>{console.log('渲染完成')},[])return<App/>}constroot=document.getElementById('root')!ReactDOM.createRoot(root).render(<AppWithCallback/>)```###SSR```tsx//React17importReactDOMfrom'react-dom'ReactDOM.hydrate(<App/>,document.getElementById('root'))//React18importReactDOMfrom'react-dom/client'ReactDOM.hydrateRoot(document.getElementById('root'),<App/>)```##lazy-动态加载组件-缩减bundle的体积-懒加载组件```jsxconstLazyCom=lazy(()=>import('./com'))```##Suspense-在服务器上添加对Suspense支持,并发渲染特性拓展-配合`lazy`使用,可以实现到动态加载组件```tsx<Suspensefallback={<Loading/>}><LazyCom/></Suspense>```#####Suspense修改```tsx//React17constApp=()=>{return(<Suspensefallback={<Loading/>}>//<---这个边界被使用，显示Loading组件<Suspense>//<---这个边界被跳过，没有fallback属性<Page/></Suspense></Suspense>);};//React18constApp=()=>{return(<Suspensefallback={<Loading/>}>//<---不使用<Suspense>//<---这个边界被使用，将fallback渲染为null<Page/></Suspense></Suspense>);};```##flushSync-多个`setState`依然会执行,可控制不需要精准控制的批量更新-减少==渲染次数==-[详细说明](https://github.com/reactwg/react-18/discussions/21)###重新渲染两次```tsximportReact,{useState}from'react'import{flushSync}from'react-dom'exportdefaultfunctionDemo(){console.log('App组件渲染了！')const[count1,setCount1]=useState(0)const[count2,setCount2]=useState(0)return(<buttononClick={()=>{setCount1((count)=>count+1)setCount2((count)=>count+1)}}><div>count1：{count1}</div><div>count2：{count2}</div></button>)}``````tsximportReact,{useState}from'react'import{flushSync}from'react-dom'exportdefaultfunctionDemo(){console.log('App组件渲染了！')const[count1,setCount1]=useState(0)const[count2,setCount2]=useState(0)return(<buttononClick={()=>{flushSync(()=>{setCount1((count)=>count+1)//setCount2(count=>count+1);})flushSync(()=>{setCount2((count)=>count+1)})}}><div>count1：{count1}</div><div>count2：{count2}</div></button>)}```###重新渲染一次```tsximportReact,{useState}from'react'import{flushSync}from'react-dom'exportdefaultfunctionDemo(){console.log('App组件渲染了！')const[count1,setCount1]=useState(0)const[count2,setCount2]=useState(0)return(<buttononClick={()=>{flushSync(()=>{setCount1((count)=>count+1)setCount2((count)=>count+1)})//flushSync(()=>{//setCount2(count=>count+1);//});}}><div>count1：{count1}</div><div>count2：{count2}</div></button>)}```##React空组件返回值-只允许`null`(react17)-允许`null`,`undifined`(react8)##[StrictMode](https://github.com/reactwg/react-18/discussions/96)-严格模式下React组件渲染两次,取消一次渲染的控制台日志(react17)-取消该限制,若安装`ReactDevTools`第二次渲染的日志显示灰色##useId-用于客户端和服务端生成唯一ID-支持同一个组件在客户端和服务端生成相同的唯一的ID，避免hydration的不兼容，这解决了在React17及17以下版本中已经存在的问题。因为我们的服务器渲染时提供的HTML是无序的，useId的原理就是每个id代表该组件在组件树中的层级结构。```tsxfunctionNameFields(){constid=useId()return(<div><labelhtmlFor={id+'-firstName'}>FirstName</label><div><inputid={id+'-firstName'}type='text'/></div><labelhtmlFor={id+'-lastName'}>LastName</label><div><inputid={id+'-lastName'}type='text'/></div></div>)}```>整个表单创建一个基本ID，然后通过附加后缀从该表单派生更多id，而不是为N个不同的id生成单独的钩子N次>id全局唯一,后缀局部唯一,及派生id全局唯一##useSyncExternalStore-由useMutableSource改变而来，主要用来解决外部数据撕裂问题-一般由第三方状态管理库使用,日常开发使用useState已经可以解决并发特性下撕裂问题-比如`redux`:自己再外部维护一个store对象,脱离了React管理##useInsertionEffect-只建议`css-in-js`库来使用-执行再`DOM`生成之后```tsxconstuseCSS=(rule)=>{useInsertionEffect(()=>{if(!isInserted.has(rule)){isInserted.add(rule)document.head.appendChild(getStyleForRule(rule))}})returnrule}constApp:React.FC=()=>{constclassName=useCSS(rule)return<divclassName={className}/>}exportdefaultApp```##ConcurrentMode-并发模式-同步不可终端更新(React17)-异步可中断更新(React18)##transition-`useDeferredValue`,返回一个延迟响应的值,让一个state延迟生效-和`useTransition`:相似```tsx//useTransitonconst[isPending,startTransition]=useTransition();constgetList=async()=>{constres:IRes=awaitrequest.get({...});constlist=res?.Response?.Data;startTransition(()=>{setList(listasIDetail[]);});};//useDeferredValueconstdeferredList=useDeferredValue(list);```-可以将原一个长任务,分成多个多任务+一个长任务","React\\router\\react_router.md":"#react_router##router路由传参数##路由配置方法###标签```jsximport{IndexRoute}from'react-router'constDashboard=React.createClass({render(){return<div>Welcometotheapp!</div>},})React.render(<Router><Routepath='/'component={App}><IndexRoutecomponent={Dashboard}/><Routepath='about'component={About}/><Routepath='inbox'component={Inbox}><Routepath='messages/:id'component={Message}/></Route></Route></Router>,document.body,)```###对象```jsxconstrouteConfig=[{path:'/',component:App,indexRoute:{component:Dashboard},childRoutes:[{path:'about',component:About},{path:'inbox',component:Inbox,childRoutes:[{path:'/messages/:id',component:Message}],},],},]React.render(<Routerroutes={routeConfig}/>,document.body)```###useParams>`useParams`:通过对`url`进行取值```jsximport{BrowserRouterasRouter,Link,Route,Switch,useParams,}from'react-router-dom'functionRouterParams(){let{id,name}=useParams()console.log(useParams())return(<><h1>ID:{id}</h1><h1>Name:{name}</h1></>)}functionApp(){return(<Router><div><h2>Params</h2><Linkto='/aa/ac'>aa</Link><Linkto='/bb/bc'>bb</Link><Switch><Routepath='/:id/:name'children={<RouterParams/>}/></Switch></div></Router>)}```||id|name||------|---|----||点击aa|aa|ac||点击bb|bb|bc|##API###Hooks>-useHistory:允许访问可能用于导航的历史记录>-useLocation:返回当前URL的位置对象,>-useParams:返回参数键/值对的对象>-useRouteMatch:尝试以与匹配方式匹配当前URL,主要访问匹配数据而不实际呈现>-不采用任何参数,返回当前匹配对象`<Route>`>-采用单个参数,与matchPath的参数相同,###BrowerRouter>-`basename:string`=>所有位置基本URl>-`forRefresh:bool`=>是否强制刷新刷新>-`getUserConfirmation:func`=>用于确认导航的函数>-`keyLength:number`=>location.key默认6>-`children:node`>-要呈现的子元素>-`React<16`:必须使用单个元素,因为渲染方法不能返回多个元素,如果需要多个元素,可以尝试将他们包装在一个额外的元素###HashRouter>-`basename:string`>-`getUserConfirmation:func`>-`hashType:string`>-`children:node`###Link>-`to:string`>>-```jsx><Linkto='/courses?sort=name'/>>```>>-`to:object`>>-```jsx><Link>to={{>pathname:'/courses',>search:'?sort=name',>hash:'#the-hash',>state:{fromDashboard:true},>}}>/>>```>>-`to:func`>>-```jsx><Linkto={location=>({...location,pathname:\"/courses\"})}/>><Linkto={location=>`${location.pathname}?sort=name`}/>>```>>-`replace:bool`>>-取代当前堆栈中的当前链接,不是添加一个>>-`innerRef:func`>>-```jsx><Link>to='/'>innerRef={(node)=>{>//`node`referstothemountedDOMelement>//ornullwhenunmounted>}}>/>>```>>-`innerRef:RefObject`>>-```jsx>letanchorRef=React.createRef()><Linkto=\"/\"innerRef={anchorRef}/>>```>>-`component:React.Component`>>-```jsx>constFancyLink=React.forwardRef((props,ref)=>(><aref={ref}{...props}>💅{props.children}</a>>))><Linkto=\"/\"component={FancyLink}/>>```###NavLink>-`activeClassName:string`>-`activeStyle:objecct`>-`exact:bool`>-`strict:bool`>-`isActive:func`>-`location:object`>-`aria-current:string`###MemoryRouter>-`initialEntries:array`>>-```js><MemoryRouter>initialEnriies={[\"/one\",\"/two\",{pathname:\"/three\"}]}>initialIndex={1}//在数组中初始位置索引>>><App/>></MemoryRotuer>>```>>-`initialIndex:number`>-`getUserConfirmation:func`>-`keyLength:number`>-`children:node`###Redirect>-`to:string`>>-```jsx><Redirectto='/somewhere/else'/>>```>>-`to:object`>>-```jsx><Redirect>to={{>pathname:'/login',>search:'?utm=your+face',>state:{referrer:currentLocation},>}}>/>>```>>-`push:bool`>>-重新加入一个history,而不是取代当前的>-```jsx><Redirectpushto='/somewhere/else'/>>```>>-`from:string`>>-重定向`old-path`跳转到`new-path`>-```jsx><Switch>><Redirectfrom='/old-path'to='/new-path'/>><Routepath='/new-path'>><Place/>></Route>></Switch>>```>>-`exact:bool`>>-true:完全匹配>-|path|location.pathname|exact|matches?|>|:----:|:---------------:|:-----:|:------:|>|`/one`|`/one/two`|`true`|no|>|`/one`|`/one/two`|`false`|yes|>>-`strict:bool`>>-|path|location.pathname|matches?|>|:-----:|:---------------:|:------:|>|`/one/`|`/one`|no|>|`/one/`|`/one/`|yes|>|`/one/`|`/one/two`|yes|>>-`sensitive:bool`>>-区分大小写>-|path|location.pathname|sensitive|matches?|>|:----:|:---------------:|:-------:|:------:|>|`/one`|`/one`|`true`|yes|>|`/One`|`/one`|`true`|no|>|`/One`|`/one`|`false`|yes|###Route>-Routerendermethods>>-`<Routecomponent/>`>-`<Routerender/>`>-`<Routechildren>fucntion`>>-Routeprops>>-match>-location>-history>>-component`<Routepath=\"/user/:username\"component={User}/>`>-`render:func`>-`children:func`>-`path:string|string[]`:>>```jsx><Routepath={['/users/:id','/profile/:id']}>><User/>></Route>>```>>-`exact:bool`>>-true:完全匹配>-|path|location.pathname|exact|matches?|>|:----:|:---------------:|:-----:|:------:|>|`/one`|`/one/two`|`true`|no|>|`/one`|`/one/two`|`false`|yes|>>-`strict:bool`>>-|path|location.pathname|matches?|>|:-----:|:---------------:|:------:|>|`/one/`|`/one`|no|>|`/one/`|`/one/`|yes|>|`/one/`|`/one/two`|yes|>>-`sensitive:bool`>>-区分大小写>-|path|location.pathname|sensitive|matches?|>|:----:|:---------------:|:-------:|:------:|>|`/one`|`/one`|`true`|yes|>|`/One`|`/one`|`true`|no|>|`/One`|`/one`|`false`|yes|###Router>-是一个低级接口,一般需要用一个高级Router代替>-`<BrowserRouter>`>-`<HashRouter>`>-`<MenoryRouter>`>-`<NativeRouter>`>-`<StaticRouter>`>-属性>-`history:object`>-`children:node````jsimportReactfrom'react'importReactDOMfrom'react-dom'import{Router}from'react-router'import{createBrowserHistory}from'history'consthistory=createBrowserHistory()ReactDOM.render(<Routerhistory={history}><App/></Router>,node,)```###StaticRouter>-`basename:string`>-`location:`>-`string`>-`object`>-`context:object`>-`children:node`###Switch>-`location:object`>-`children:node`###generatePath>-用于生成路由的URL>-`pattern:string`>-`params:object`>>```js>generatePath('/user/:id/:entity(posts|comments)',{id:1})>```###history>‎管理JavaScript中的会话历史记录。>>‎`history`‎以下术语：‎>>-‎\"浏览器历史记录\"-特定于DOM的实现，在支持HTML5历史记录API的Web浏览器中非常有用‎>-‎\"哈希历史记录\"-针对旧版Web浏览器的DOM特定实现‎>-‎\"内存历史记录\"-内存历史记录实现，在测试和非DOM环境（如ReactNative）中非常有用‎>>`history`‎对象通常具有以下属性和方法：‎>>-`length`‎-（数字）历史记录堆栈中的条目数‎>-`action`‎-（字符串）当前操作（或‎`PUSH``REPLACE``POP`)>-location（对象）当前位置。可能具有以下属性：‎>-`pathname`‎-（字符串）URL的路径‎>-`search`‎-（字符串）URL查询字符串‎>-`hash`‎-（字符串）URL哈希片段‎>-`state`‎-（对象）特定位置状态，例如当此位置被推送到堆栈上时。仅在浏览器和内存历史记录中可用。‎`push(path,state)`>-`push(path,[state])`‎-（函数）将新条目推送到历史记录堆栈‎>-`replace(path,[state])`‎-（函数）替换历史记录堆栈上的当前条目‎>-`go(n)`‎-（函数）按条目移动历史记录堆栈中的指针‎`n`>-`goBack()`‎-（功能）等效于‎`go(-1)`>-`goForward()`‎-（功能）等效于‎`go(1)`>-`block(prompt)`‎-（功能）阻止导航（‎[‎请参阅历史记录文档‎](https://github.com/ReactTraining/history/blob/master/docs/blocking-transitions.md))```jsximport{createBrowserHistory}from'history'constcustomHistory=createBrowserHistory()ReactDOM.render(<Routerhistory={customHistory}/>,node)```###location>返回当前app在哪里一个Location对象```js{key:'ac3df4',//notwithHashHistory!pathname:'/somewhere',search:'?some=search-string',hash:'#howdy',state:{[userDefined]:true}}```>-[Routecomponent](https://reactrouter.com/web/api/Route/component)as`this.props.location`>-[Routerender](https://reactrouter.com/web/api/Route/render-func)as`({location})=>()`>-[Routechildren](https://reactrouter.com/web/api/Route/children-func)as`({location})=>()`>-[withRouter](https://reactrouter.com/web/api/withRouter)as`this.props.location`###match>-`params`-(object)从URL解析所得到的键/值对相对应的动态路径的部分>-`isExact`-(boolean)如果匹配整个URL`true`>-`path`-(string)路径模式用于匹配。有助于建立嵌套的`<Route>`>-`url`-(string)匹配URL的一部分。有助于建立嵌套的`<Link>`>-[Routecomponent](https://reactrouter.com/web/api/Route/component)as`this.props.match`>-[Routerender](https://reactrouter.com/web/api/Route/render-func)as`({match})=>()`>-[Routechildren](https://reactrouter.com/web/api/Route/children-func)as`({match})=>()`>-[withRouter](https://reactrouter.com/web/api/withRouter)as`this.props.match`>-[matchPath](https://reactrouter.com/web/api/matchPath)asthereturnvalue>-[useRouteMatch](https://reactrouter.com/web/api/hooks/useroutematch)asthereturnvalue###matchPath>-pathname:匹配路径名>-如果在与节点的服务器上使用node.js,则为`req.path`>-props>-returns###withRotuer>-可以通过高阶组件访问历史记录的属性和最接近的`<Route>`的匹配项,每单呈现,都会将更新或传递给包装的组件>-包装组件的所有非反应特定静态方法和属性将自动复制到\"已连接\"组件###Prompt>-从核心提示符重新导出","React\\router\\v6.md":"#react-router-dom##修改>Switch修改为Rotues>添加Navigateg>移除##Redirec代替```js<Router><Routes><Routepath='/login'element={<Login/>}/><Routepath='/admin'element={<Admin/>}/><Routepath='*'element={<Navigateto='/login'/>}/></Routes></Router>```##配置路由```tsx<BrowserRouter><Routes><Routepath=\"/\"element={<App/>}/><Routepath=\"expenses\"element={<Expenses/>}/><Routepath=\"invoices\"element={<Invoices/>}/></Routes></BrowserRouter>,```##使用URL参数加载数据```tsx<Routes><Routepath='/'element={<App/>}><Routepath='expenses'element={<Expenses/>}/><Routepath='invoices'element={<Invoices/>}><Routepath=':invoiceId'element={<Invoice/>}/></Route><Routepath='*'element={<mainstyle={{padding:'1rem'}}><p>There'snothinghere!</p></main>}/></Route></Routes>```##索引```tsx<Routes><Routepath='/'element={<App/>}><Routepath='expenses'element={<Expenses/>}/><Routepath='invoices'element={<Invoices/>}><Routeindexelement={<mainstyle={{padding:'1rem'}}><p>Selectaninvoice</p></main>}/><Routepath=':invoiceId'element={<Invoice/>}/></Route><Routepath='*'element={<mainstyle={{padding:'1rem'}}><p>There'snothinghere!</p></main>}/></Route></Routes>```","React\\SSR\\next.md":"#Next.js>[Next.js](https://www.nextjs.cn/)>基于React的SSR框架","React\\typescript\\react使用ts.md":"#react使用TS##组件声明在React中，组件的声明方式有两种：函数组件和类组件，来看看这两种类型的组件声明时是如何定义TS类型的。###类组件Component>类组件的定义形式有两种：`React.Component<P,S={}>`和`React.PureComponent<P,S={}SS={}>`，它们都是泛型接口，接收两个参数，第一个是props类型的定义，第二个是state类型的定义，这两个参数都不是必须的，没有时可以省略：```tsinterfaceIProps{name:string;}interfaceIState{count:number;}classAppextendsReact.Component<IProps,IState>{state={count:0};render(){return(<div>{this.state.count}{this.props.name}</div>);}}exportdefaultApp;```###类组件PureComponent>`React.PureComponent<P,S={}SS={}>`也是差不多的：>`classAppextendsReact.PureComponent<IProps,IState>{}`>`React.PureComponent`是有第三个参数的，它表示`getSnapshotBeforeUpdate`的返回值>那PureComponent和Component的区别是什么呢？它们的主要区别是PureComponent中的shouldComponentUpdate是由自身进行处理的，不需要我们自己处理，所以PureComponent可以在一定程度上提升性能。有时候可能会见到这种写法，实际上和上面的效果是一样的：```tsximportReact,{PureComponent,Component}from'react'classAppextendsPureComponent<IProps,IState>{}classAppextendsComponent<IProps,IState>{}```那如果定义时候我们不知道组件的props的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：```tsx//定义组件classMyComponent<P>extendsReact.Component<P>{internalProp:Pconstructor(props:P){super(props)this.internalProp=props}render(){return<span>helloworld</span>}}//使用组件typeIProps={name:string;age:number};<MyComponent<IProps>name='React'age={18}/>//Success;<MyComponent<IProps>name='TypeScript'age='hello'/>//Error```###函数组件>通常情况下，函数组件我是这样写的：```tsinterfaceIProps{name:string}constApp=(props:IProps)=>{const{name}=props;return(<divclassName=\"App\"><h1>helloworld</h1><h2>{name}</h2></div>);}exportdefaultApp;```>除此之外，函数类型还可以使用`React.FunctionComponent<P={}>`来定义，也可以使用其简写`React.FC<P={}>`，两者效果是一样的。它是一个泛型接口，可以接收一个参数，参数表示props的类型，这个参数不是必须的。它们就相当于这样：>`typeReact.FC<P={}>=React.FunctionComponent<P>`最终的定义形式如下：```tsxinterfaceIProps{name:string}constApp:React.FC<IProps>=(props)=>{const{name}=propsreturn(<divclassName='App'><h1>helloworld</h1><h2>{name}</h2></div>)}exportdefaultApp```当使用这种形式来定义函数组件时，props中默认会带有children属性，它表示该组件在调用时，其内部的元素，来看一个例子，首先定义一个组件，组件中引入了Child1和Child2组件：```tsximportChild1from'./child1'importChild2from'./child2'interfaceIProps{name:string}constApp:React.FC<IProps>=(props)=>{const{name}=propsreturn(<Child1name={name}><Child2name={name}/>TypeScript</Child1>)}exportdefaultApp```Child1组件结构如下：```tsxinterfaceIProps{name:string}constChild1:React.FC<IProps>=(props)=>{const{name,children}=propsconsole.log(children)return(<divclassName='App'><h1>hellochild1</h1><h2>{name}</h2></div>)}exportdefaultChild1```我们在Child1组件中打印了children属性，它的值是一个数组，包含Child2对象和后面的文本：![](/.assets/img/2022-02-08-17-20-14.png)使用React.FC声明函数组件和普通声明的区别如下：React.FC显式地定义了返回类型，其他方式是隐式推导的；React.FC对静态属性：displayName、propTypes、defaultProps提供了类型检查和自动补全；React.FC为children提供了隐式的类型（ReactElement|null）。那如果我们在定义组件时不知道props的类型，只有调用时才知道，那就还是用泛型来定义props的类型。对于使用function定义的函数组件：```tsx//定义组件functionMyComponent<P>(props:P){return<span>{props}</span>}//使用组件typeIProps={name:string;age:number};<MyComponent<IProps>name='React'age={18}/>//Success;<MyComponent<IProps>name='TypeScript'age='hello'/>//Error```如果使用箭头函数定义的函数组件，直接这样调用时错误的：```tsxconstMyComponent=<P>(props:P){return(<span>{props}</span>);}```必须使用extends关键字来定义泛型参数才能被成功解析：```tsxconstMyComponent=<Pextendsany>(props:P){return(<span>{props}</span>);}```##React内置类型###JSX.Element先来看看JSX.Element类型的声明：```tsxdeclareglobal{namespaceJSX{interfaceElementextendsReact.ReactElement<any,any>{}}}```可以看到，JSX.Element是ReactElement的子类型，它没有增加属性，两者是等价的。也就是说两种类型的变量可以相互赋值。​JSX.Element可以通过执行React.createElement或是转译JSX获得：```tsxconstjsx=<div>hello</div>constele=React.createElement('div',null,'hello')```###React.ReactElement>React的类型声明文件中提供了React.ReactElement＜T＞，它可以让我们通过传入＜T/＞来注解类组件的实例化，它在声明文件中的定义如下：```tsxinterfaceReactElement<P=any,Textendsstring|JSXElementConstructor<any>=|string|JSXElementConstructor<any>,>{type:Tprops:Pkey:Key|null}```ReactElement是一个接口，包含type,props,key三个属性值。该类型的变量值只能是两种：null和ReactElement实例。​通常情况下，函数组件返回ReactElement（JXS.Element）的值。###React.ReactNodeReactNode类型的声明如下：```tsxtypeReactText=string|numbertypeReactChild=ReactElement|ReactTextinterfaceReactNodeArrayextendsArray<ReactNode>{}typeReactFragment={}|ReactNodeArraytypeReactNode=|ReactChild|ReactFragment|ReactPortal|boolean|null|undefined```可以看到，ReactNode是一个联合类型，它可以是string、number、ReactElement、null、boolean、ReactNodeArray。由此可知。ReactElement类型的变量可以直接赋值给ReactNode类型的变量，但反过来是不行的。类组件的render成员函数会返回ReactNode类型的值：```tsxclassMyComponentextendsReact.Component{render(){return<div>helloworld</div>}}//正确constcomponent:React.ReactNode<MyComponent>=<MyComponent/>//错误constcomponent:React.ReactNode<MyComponent>=<OtherComponent/>```上面的代码中，给component变量设置了类型是Mycomponent类型的react实例，这时只能给其赋值其为MyComponent的实例组件。​通常情况下，类组件通过render()返回ReactNode的值。###CSSProperties先来看看React的声明文件中对CSSProperties的定义：```tsxexportinterfaceCSSPropertiesextendsCSS.Properties<string|number>{/***Theindexsignaturewasremovedtoenableclosedtypingforstyle*usingCSSType.You'reabletousetypeassertionormoduleaugmentation*toaddpropertiesoranindexsignatureofyourown.**Forexamplesandmoreinformation,visit:*<https://github.com/frenic/csstype#what-should-i-do-when-i-get-type-errors>*/}```React.CSSProperties是React基于TypeScript定义的CSS属性类型，可以将一个方法的返回值设置为该类型：```tsximport*asReactfrom'react'constclassNames=require('./sidebar.css')interfaceProps{isVisible:boolean}constdivStyle=(props:Props):React.CSSProperties=>({width:props.isVisible?'23rem':'0rem',})exportconstSidebarComponent:React.StatelessComponent<Props>=(props)=>(<divid='mySidenav'className={classNames.sidenav}style={divStyle(props)}>{props.children}</div>)```这里divStyle组件的返回值就是React.CSSProperties类型。我们还可以定义一个CSSProperties类型的变量：```tsxconstdivStyle:React.CSSProperties={width:'11rem',height:'7rem',backgroundColor:`rgb(${props.color.red},${props.color.green},${props.color.blue})`,}```这个变量可以在HTML标签的style属性上使用：`<divstyle={divStyle}/>`在React的类型声明文件中，style属性的类型如下：`style?:CSSProperties|undefined;`##ReactHooks###useState默认情况下，React会为根据设置的state的初始值来自动推导state以及更新函数的类型：![](/.assets/img/2022-02-08-17-48-31.png)如果已知state的类型，可以通过以下形式来自定义state的类型：```tsxconst[count,setCount]=useState<number>(1)```如果初始值为null，需要显式地声明state的类型：```tsxconst[count,setCount]=useState<number|null>(null)```如果state是一个对象，想要初始化一个空对象，可以使用断言来处理：```tsxconst[user,setUser]=React.useState<IUser>({}asIUser)```>空对象{}断言为IUser接口就是欺骗了TypeScript的编译器，由于后面的代码可能会依赖这个对象，所以应该在使用前及时初始化user的值，否则就会报错。下面是声明文件中useState的定义：```tsxfunctionuseState<S>(initialState:S|(()=>S),):[S,Dispatch<SetStateAction<S>>]//convenienceoverloadwhenfirstargumentisomitted/***Returnsastatefulvalue,andafunctiontoupdateit.**@version16.8.0*@see<https://reactjs.org/docs/hooks-reference.html#usestate>*/functionuseState<S=undefined>():[S|undefined,Dispatch<SetStateAction<S|undefined>>,]/***Analternativeto`useState`.**`useReducer`isusuallypreferableto`useState`whenyouhavecomplexstatelogicthatinvolves*multiplesub-values.Italsoletsyouoptimizeperformanceforcomponentsthattriggerdeep*updatesbecauseyoucanpass`dispatch`downinsteadofcallbacks.**@version16.8.0*@see<https://reactjs.org/docs/hooks-reference.html#usereducer>*/```可以看到，这里定义两种形式，分别是有初始值和没有初始值的形式。###useEffect>useEffect的主要作用就是处理副作用，它的第一个参数是一个函数，表示要清除副作用的操作，第二个参数是一组值，当这组值改变时，第一个参数的函数才会执行，这让我们可以控制何时运行函数来处理副作用：```tsxuseEffect(()=>{constsubscription=props.source.subscribe()return()=>{subscription.unsubscribe()}},[props.source])```当函数的返回值不是函数或者effect函数中未定义的内容时，如下：```tsxuseEffect(()=>{subscribe()returnnull})```TypeScript就会报错：![](/.assets/img/2022-02-08-17-54-57.png)来看看useEffect在类型声明文件中的定义：```tsx//Destructorsareonlyallowedtoreturnvoid.typeDestructor=()=>void|{[UNDEFINED_VOID_ONLY]:never}//NOTE:callbacksare_only_allowedtoreturneithervoid,oradestructor.typeEffectCallback=()=>void|Destructor//TODO(TypeScript3.0):ReadonlyArray<unknown>typeDependencyList=ReadonlyArray<any>functionuseEffect(effect:EffectCallback,deps?:DependencyList):void//NOTE:thisdoesnotacceptstrings,butthiswillhavetobefixedbyremovingstringsfromtypeRef<T>/***`useImperativeHandle`customizestheinstancevaluethatisexposedtoparentcomponentswhenusing*`ref`.Asalways,imperativecodeusingrefsshouldbeavoidedinmostcases.**`useImperativeHandle`shouldbeusedwith`React.forwardRef`.**@version16.8.0*@see<https://reactjs.org/docs/hooks-reference.html#useimperativehandle>*/```>useEffect的第一个参数只允许返回一个函数###useRef当使用useRef时，我们可以访问一个可变的引用对象。可以将初始值传递给useRef，它用于初始化可变ref对象公开的当前属性。当我们使用useRef时，需要给其指定类型：```tsxconstnameInput=React.useRef<HTMLInputElement>(null)```这里给实例的类型指定为了input输入框类型。​当useRef的初始值为null时，有两种创建的形式，第一种：```tsxconstnameInput=React.useRef<HTMLInputElement>(null)nameInput.current.innerText='helloworld'```这种形式下，ref1.current是只读的（read-only），所以当我们将它的innerText属性重新赋值时会报以下错误：```tsxCannotassignto'current'becauseitisaread-onlyproperty.```那该怎么将current属性变为动态可变得的，先来看看类型声明文件中useRef是如何定义的：```tsxfunctionuseRef<T>(initialValue:T):MutableRefObject<T>//convenienceoverloadforrefsgivenasarefpropastheytypicallystartwithanullvalue/***`useRef`returnsamutablerefobjectwhose`.current`propertyisinitializedtothepassedargument*(`initialValue`).Thereturnedobjectwillpersistforthefulllifetimeofthecomponent.**Notethat`useRef()`isusefulformorethanthe`ref`attribute.It’shandyforkeepinganymutable*valuearoundsimilartohowyou’duseinstancefieldsinclasses.**Usagenote:ifyouneedtheresultofuseReftobedirectlymutable,include`|null`inthetype*ofthegenericargument.**@version16.8.0*@see<https://reactjs.org/docs/hooks-reference.html#useref>*/```这段代码的第十行的告诉我们，如果需要useRef的直接可变，就需要在泛型参数中包含'|null'，所以这就是当初始值为null的第二种定义形式：```tsconstnameInput=React.useRef<HTMLInputElement|null>(null)```这种形式下，`nameInput.current`就是可写的。不过两种类型在使用时都需要做类型检查：```tsnameInput.current?.innerText='helloworld'```那么问题来了，为什么第一种写法在没有操作current时没有报错呢？因为useRef在类型定义式具有多个重载声明，第一种方式就是执行的以下函数重载：```tsfunctionuseRef<T>(initialValue:T|null):RefObject<T>//convenienceoverloadforpotentiallyundefinedinitialValue/callwith0arguments//hasadefaulttostopitfromdefaultingto{}instead/***`useRef`returnsamutablerefobjectwhose`.current`propertyisinitializedtothepassedargument*(`initialValue`).Thereturnedobjectwillpersistforthefulllifetimeofthecomponent.**Notethat`useRef()`isusefulformorethanthe`ref`attribute.It’shandyforkeepinganymutable*valuearoundsimilartohowyou’duseinstancefieldsinclasses.**@version16.8.0*@see<https://reactjs.org/docs/hooks-reference.html#useref>*/```从上useRef的声明中可以看到，functionuseRef的返回值类型化是MutableRefObject，这里面的T就是参数的类型T，所以最终nameInput的类型就是React.MutableRefObject。​注意，上面用到了HTMLInputElement类型，这是一个标签类型，这个操作就是用来访问DOM元素的。###useCallback先来看看类型声明文件中对useCallback的定义：````tsfunctionuseCallback<Textends(...args:any[])=>any>(callback:T,deps:DependencyList,):T/***`useMemo`willonlyrecomputethememoizedvaluewhenoneofthe`deps`haschanged.**Usagenote:ifcalling`useMemo`withareferentiallystablefunction,alsogiveitastheinputin*thesecondargument.*```ts*functionexpensive(){...}*functionComponent(){*constexpensiveResult=useMemo(expensive,[expensive])*return...*}*```*@version16.8.0*@see<https://reactjs.org/docs/hooks-reference.html#usememo>*/````useCallback接收一个回调函数和一个依赖数组，只有当依赖数组中的值发生变化时才会重新执行回调函数。来看一个例子：```tsconstadd=(a:number,b:number)=>a+bconstmemoizedCallback=useCallback((a)=>{add(a,b)},[b],)```这里我们没有给回调函数中的参数a定义类型，所以下面的调用方式都不会报错：```tsmemoizedCallback('hello')memoizedCallback(5)```尽管add方法的两个参数都是number类型，但是上述调用都能够用执行。所以为了更加严谨，我们需要给回调函数定义具体的类型：```tsconstmemoizedCallback=useCallback((a:number)=>{add(a,b)},[b],)```这时候如果再给回调函数传入字符串就会报错了：![](/.assets/img/2022-02-09-09-58-19.png)所有，需要注意，在使用useCallback时需要给回调函数的参数指定类型。###useMemo先来看看类型声明文件中对useMemo的定义：```tsfunctionuseMemo<T>(factory:()=>T,deps:DependencyList|undefined):T/***`useDebugValue`canbeusedtodisplayalabelforcustomhooksinReactDevTools.**NOTE:Wedon’trecommendaddingdebugvaluestoeverycustomhook.*It’smostvaluableforcustomhooksthatarepartofsharedlibraries.**@version16.8.0*@see<https://reactjs.org/docs/hooks-reference.html#usedebugvalue>*/```useMemo和useCallback是非常类似的，但是它返回的是一个值，而不是函数。所以在定义useMemo时需要定义返回值的类型：```tsleta=1setTimeout(()=>{a+=1},1000)constcalculatedValue=useMemo<number>(()=>a**2,[a])```如果返回值不一致，就会报错：```tsconstcalculatedValue=useMemo<number>(()=>a+'hello',[a])//类型“()=>string”的参数不能赋给类型“()=>number”的参数```###useContextuseContext需要提供一个上下文对象，并返回所提供的上下文的值，当提供者更新上下文对象时，引用这些上下文对象的组件就会重新渲染：```tsconstColorContext=React.createContext({color:\"green\"});constWelcome=()=>{const{color}=useContext(ColorContext);return<divstyle={{color}}>helloworld</div>;};```在使用useContext时，会自动推断出提供的上下文对象的类型，所以并不需要我们手动设置context的类型。当前，我们也可以使用泛型来设置context的类型：```tsinterfaceIColor{color:string;}constColorContext=React.createContext<IColor>({color:\"green\"});下面是useContext在类型声明文件中的定义：functionuseContext<T>(context:Context<T>/_,(notpublicAPI)observedBits?:number|boolean_/):T;/***Returnsastatefulvalue,andafunctiontoupdateit.*@version16.8.0*@see<https://reactjs.org/docs/hooks-reference.html#usestate>*/```###useReducer有时我们需要处理一些复杂的状态，并且可能取决于之前的状态。这时候就可以使用useReducer，它接收一个函数，这个函数会根据之前的状态来计算一个新的state。其语法如下：```tsconst[state,dispatch]=useReducer(reducer,initialArg,init)```来看下面的例子：```tsconstreducer=(state,action)=>{switch(action.type){case'increment':return{count:state.count+1};case'decrement':return{count:state.count-1};default:thrownewError();}}constCounter=()=>{constinitialState={count:0}const[state,dispatch]=useReducer(reducer,initialState);return(<>Count:{state.count}<buttononClick={()=>dispatch({type:'increment'})}>+</button><buttononClick={()=>dispatch({type:'decrement'})}>-</button></>);}```当前的状态是无法推断出来的，可以给reducer函数添加类型，通过给reducer函数定义state和action来推断useReducer的类型，下面来修改上面的例子：```tstypeActionType={type:'increment'|'decrement'}typeState={count:number}constinitialState:State={count:0}constreducer=(state:State,action:ActionType)=>{//...}```这样，在Counter函数中就可以推断出类型。当我们视图使用一个不存在的类型时，就会报错：```tsdispatch({type:'reset'})//Error!type'\"reset\"'isnotassignabletotype'\"increment\"|\"decrement\"'```除此之外，还可以使用泛型的形式来实现reducer函数的类型定义：```tstypeActionType={type:'increment'|'decrement'}typeState={count:number}constreducer:React.Reducer<State,ActionType>=(state,action)=>{//...}```其实dispatch方法也是有类型的：![](/.assets/img/2022-02-09-10-09-36.png)可以看到，dispatch的类型是：React.Dispatch，上面示例的完整代码如下：```tsimportReact,{useReducer}from\"react\";typeActionType={type:\"increment\"|\"decrement\";};typeState={count:number};constCounter:React.FC=()=>{constreducer:React.Reducer<State,ActionType>=(state,action)=>{switch(action.type){case\"increment\":return{count:state.count+1};case\"decrement\":return{count:state.count-1};default:thrownewError();}};constinitialState:State={count:0}const[state,dispatch]=useReducer(reducer,initialState);return(<>Count:{state.count}<buttononClick={()=>dispatch({type:\"increment\"})}>+</button><buttononClick={()=>dispatch({type:\"decrement\"})}>-</button></>);};exportdefaultCounter;```##事件处理###Event事件类型>Event是一个对象，并且有很多属性，这时很多人就会把event类型定义为any，这样的话TypeScript就失去了它的意义，并不会对event事件进行静态检查，如果一个键盘事件触发了下面的方法，也不会报错：```tsconsthandleEvent=(e:any)=>{console.log(e.clientX,e.clientY)}```由于Event事件对象中有很多的属性，所以我们也不方便把所有属性及其类型定义在一个interface中，所以React在声明文件中给我们提供了Event事件对象的类型声明。常见的Event事件对象如下：-剪切板事件对象：`ClipboardEvent<T=Element>`-拖拽事件对象：`DragEvent<T=Element>`-焦点事件对象：`FocusEvent<T=Element>`-表单事件对象：`FormEvent<T=Element>`-Change事件对象：`ChangeEvent<T=Element>`-键盘事件对象：`KeyboardEvent<T=Element>`-鼠标事件对象：`MouseEvent<T=Element,E=NativeMouseEvent>`-触摸事件对象：`TouchEvent<T=Element>`-滚轮事件对象：`WheelEvent<T=Element>`-动画事件对象：`AnimationEvent<T=Element>`-过渡事件对象：`TransitionEvent<T=Element>`可以看到，这些Event事件对象的泛型中都会接收一个Element元素的类型，这个类型就是我们绑定这个事件的标签元素的类型，标签元素类型将在下面的第五部分介绍。来看一个简单的例子：```tstypeState={text:string;};constApp:React.FC=()=>{const[text,setText]=useState<string>(\"\")constonChange=(e:React.FormEvent<HTMLInputElement>):void=>{setText(e.currentTarget.value);};return(<div><inputtype=\"text\"value={text}onChange={onChange}/></div>);}```这里就给onChange方法的事件对象定义为了FormEvent类型，并且作用的对象时一个HTMLInputElement类型的标签（input标签）​可以来看下MouseEvent事件对象和ChangeEvent事件对象的类型声明，其他事件对象的声明形似也类似：```tsinterfaceMouseEvent<T=Element,E=NativeMouseEvent>extendsUIEvent<T,E>{altKey:booleanbutton:numberbuttons:numberclientX:numberclientY:numberctrlKey:boolean/***See[DOMLevel3Eventsspec](https://www.w3.org/TR/uievents-key/#keys-modifier).foralistofvalid(case-sensitive)argumentstothismethod.*/getModifierState(key:string):booleanmetaKey:booleanmovementX:numbermovementY:numberpageX:numberpageY:numberrelatedTarget:EventTarget|nullscreenX:numberscreenY:numbershiftKey:boolean}interfaceChangeEvent<T=Element>extendsSyntheticEvent<T>{target:EventTarget&T}```在很多事件对象的声明文件中都可以看到EventTarget的身影。这是因为，DOM的事件操作（监听和触发），都定义在EventTarget接口上。EventTarget的类型声明如下：```tsinterfaceEventTarget{addEventListener(type:string,listener:EventListenerOrEventListenerObject|null,options?:boolean|AddEventListenerOptions,):voiddispatchEvent(evt:Event):booleanremoveEventListener(type:string,listener?:EventListenerOrEventListenerObject|null,options?:EventListenerOptions|boolean,):void}```比如在change事件中，会使用的e.target来获取当前的值，它的的类型就是EventTarget。来看下面的例子：```ts<inputonChange={e=>onSourceChange(e)}placeholder=\"最多30个字\"/>constonSourceChange=(e:React.ChangeEvent<HTMLInputElement>)=>{if(e.target.value.length>30){message.error('请长度不能超过30个字，请重新输入');return;}setSourceInput(e.target.value);};```这里定义了一个`input`输入框，当触发`onChange`事件时，会调用`onSourceChange`方法，该方法的参数e的类型就是：`React.ChangeEvent`，而`e.target`的类型就是`EventTarget`：![](/.assets/img/2022-02-09-10-26-49.png)在来看一个例子：```tsquestionList.map(item=>(<divkey={item.id}role=\"button\"onClick={e=>handleChangeCurrent(item,e)}>//组件内容...</div>)consthandleChangeCurrent=(item:IData,e:React.MouseEvent<HTMLDivElement>)=>{e.stopPropagation();setCurrent(item);};```这点代码中，点击某个盒子，就将它设置为当前的盒子，方便执行其他操作。当鼠标点击盒子时，会触发handleChangeCurren方法，该方法有两个参数，第二个参数是event对象，在方法中执行了e.stopPropagation();是为了阻止冒泡事件，这里的stopPropagation()实际上并不是鼠标事件MouseEvent的属性，它是合成事件上的属性，来看看声明文件中的定义：```tsinterfaceMouseEvent<T=Element,E=NativeMouseEvent>extendsUIEvent<T,E>{//...}interfaceUIEvent<T=Element,E=NativeUIEvent>extendsSyntheticEvent<T,E>{//...}interfaceSyntheticEvent<T=Element,E=Event>extendsBaseSyntheticEvent<E,EventTarget&T,EventTarget>{}interfaceBaseSyntheticEvent<E=object,C=any,T=any>{nativeEvent:EcurrentTarget:Ctarget:Tbubbles:booleancancelable:booleandefaultPrevented:booleaneventPhase:numberisTrusted:booleanpreventDefault():voidisDefaultPrevented():booleanstopPropagation():voidisPropagationStopped():booleanpersist():voidtimeStamp:numbertype:string}```可以看到，这里的`stopPropagation()`是一层层的继承来的，最终来自于`BaseSyntheticEvent`合成事件类型。原生的事件集合`SyntheticEvent`就是继承自合成时间类型。`SyntheticEvent<T=Element,E=Event>`泛型接口接收当前的元素类型和事件类型，如果不介意这两个参数的类型，完全可以这样写：```ts<inputonChange={(e:SyntheticEvent<Element,Event>)=>{//...}}/>```###事件处理函数类型>说完事件对象类型，再来看看事件处理函数的类型。React也为我们提供了贴心的提供了事件处理函数的类型声明，来看看所有的事件处理函数的类型声明：```tsxtypeEventHandler<EextendsSyntheticEvent<any>>={bivarianceHack(event:E):void}['bivarianceHack']typeReactEventHandler<T=Element>=EventHandler<SyntheticEvent<T>>//剪切板事件处理函数typeClipboardEventHandler<T=Element>=EventHandler<ClipboardEvent<T>>//复合事件处理函数typeCompositionEventHandler<T=Element>=EventHandler<CompositionEvent<T>>//拖拽事件处理函数typeDragEventHandler<T=Element>=EventHandler<DragEvent<T>>//焦点事件处理函数typeFocusEventHandler<T=Element>=EventHandler<FocusEvent<T>>//表单事件处理函数typeFormEventHandler<T=Element>=EventHandler<FormEvent<T>>//Change事件处理函数typeChangeEventHandler<T=Element>=EventHandler<ChangeEvent<T>>//键盘事件处理函数typeKeyboardEventHandler<T=Element>=EventHandler<KeyboardEvent<T>>//鼠标事件处理函数typeMouseEventHandler<T=Element>=EventHandler<MouseEvent<T>>//触屏事件处理函数typeTouchEventHandler<T=Element>=EventHandler<TouchEvent<T>>//指针事件处理函数typePointerEventHandler<T=Element>=EventHandler<PointerEvent<T>>//界面事件处理函数typeUIEventHandler<T=Element>=EventHandler<UIEvent<T>>//滚轮事件处理函数typeWheelEventHandler<T=Element>=EventHandler<WheelEvent<T>>//动画事件处理函数typeAnimationEventHandler<T=Element>=EventHandler<AnimationEvent<T>>//过渡事件处理函数typeTransitionEventHandler<T=Element>=EventHandler<TransitionEvent<T>>```>T的类型也都是Element，指的是触发该事件的HTML标签元素的类型EventHandler会接收一个E，它表示事件处理函数中Event对象的类型。bivarianceHack是事件处理函数的类型定义，函数接收一个Event对象，并且其类型为接收到的泛型变量E的类型,返回值为void。​还看上面的那个例子：```tstypeState={text:string;};constApp:React.FC=()=>{const[text,setText]=useState<string>(\"\")constonChange:React.ChangeEventHandler<HTMLInputElement>=(e)=>{setText(e.currentTarget.value);};return(<div><inputtype=\"text\"value={text}onChange={onChange}/></div>);}```这里给onChange方法定义了方法的类型，它是一个ChangeEventHandler的类型，并且作用的对象时一个HTMLImnputElement类型的标签（input标签）。##HTML标签类型###常见标签类型在项目的依赖文件中可以找到HTML标签相关的类型声明文件：![](/.assets/img/2022-02-09-10-39-01.png)所有的HTML标签的类型都被定义在`intrinsicElements`接口中，常见的标签及其类型如下：```tsxa:HTMLAnchorElementbody:HTMLBodyElementbr:HTMLBRElementbutton:HTMLButtonElementdiv:HTMLDivElementh1:HTMLHeadingElementh2:HTMLHeadingElementh3:HTMLHeadingElementhtml:HTMLHtmlElementimg:HTMLImageElementinput:HTMLInputElementul:HTMLUListElementli:HTMLLIElementlink:HTMLLinkElementp:HTMLParagraphElementspan:HTMLSpanElementstyle:HTMLStyleElementtable:HTMLTableElementtbody:HTMLTableSectionElementvideo:HTMLVideoElementaudio:HTMLAudioElementmeta:HTMLMetaElementform:HTMLFormElement````Event`事件类型和事件处理函数类型中都使用到了标签的类型。上面的很多的类型都需要传入一个`ELement`类型的泛型参数，这个泛型参数就是对应的标签类型值，可以根据标签来选择对应的标签类型。这些类型都继承自`HTMLElement`类型，如果使用时对类型类型要求不高，可以直接写`HTMLELement````tsx<Buttontype='text'onClick={(e:React.MouseEvent<HTMLElement>)=>{handleOperate()e.stopPropagation()}}><imgsrc={cancelChangeIcon}alt=''/>取消修改</Button>```>其实，在直接操作DOM时也会用到标签类型，虽然我们现在通常会使用框架来开发，但是有时候也避免不了直接操作DOM。比如我在工作中，项目中的某一部分组件是通过npm来引入的其他组的组件，而在很多时候，我有需要动态的去个性化这个组件的样式，最直接的办法就是通过原生JavaScript获取到DOM元素，来进行样式的修改，这时候就会用到标签类型。​来看下面的例子：```jsdocument.querySelectorAll('.paper').forEach(item=>{constfirstPageHasAddEle=(item.firstChildasHTMLDivElement).classList.contains('add-ele')if(firstPageHasAddEle){item.removeChild(item.firstChildasChildNode);}})```>将item.firstChild断言成了HTMLDivElement类型，如果不断言，item.firstChild的类型就是ChildNode，而ChildNode类型中是不存在classList属性的，所以就就会报错，当我们把他断言成HTMLDivElement类型时，就不会报错了。很多时候，标签类型可以和断言（as）一起使用。​>>后面在removeChild时又使用了as断言，为什么呢？item.firstChild不是已经自动识别为ChildNode类型了吗？因为TS会认为，我们可能不能获取到类名为paper的元素，所以item.firstChild的类型就被推断为ChildNode|null，我们有时候比TS更懂我们定义的元素，知道页面一定存在paper元素，所以可以直接将item.firstChild断言成ChildNode类型。###标签属性类型>每个HTML标签都有自己的属性，比如Input框就有value、width、placeholder、max-length等属性，下面是Input框的属性类型定义：```tsxinterfaceInputHTMLAttributes<T>extendsHTMLAttributes<T>{accept?:string|undefinedalt?:string|undefinedautoComplete?:string|undefinedautoFocus?:boolean|undefinedcapture?:boolean|string|undefinedchecked?:boolean|undefinedcrossOrigin?:string|undefineddisabled?:boolean|undefinedenterKeyHint?:|'enter'|'done'|'go'|'next'|'previous'|'search'|'send'|undefinedform?:string|undefinedformAction?:string|undefinedformEncType?:string|undefinedformMethod?:string|undefinedformNoValidate?:boolean|undefinedformTarget?:string|undefinedheight?:number|string|undefinedlist?:string|undefinedmax?:number|string|undefinedmaxLength?:number|undefinedmin?:number|string|undefinedminLength?:number|undefinedmultiple?:boolean|undefinedname?:string|undefinedpattern?:string|undefinedplaceholder?:string|undefinedreadOnly?:boolean|undefinedrequired?:boolean|undefinedsize?:number|undefinedsrc?:string|undefinedstep?:number|string|undefinedtype?:string|undefinedvalue?:string|ReadonlyArray<string>|number|undefinedwidth?:number|string|undefinedonChange?:ChangeEventHandler<T>|undefined}```如果我们需要直接操作DOM，就可能会用到元素属性类型，常见的元素属性类型如下：-HTML属性类型：`HTMLAttributes`-按钮属性类型：`ButtonHTMLAttributes`-表单属性类型：`FormHTMLAttributes`-图片属性类型：`ImgHTMLAttributes`-输入框属性类型：`InputHTMLAttributes`-链接属性类型：`LinkHTMLAttributes`-meta属性类型：`MetaHTMLAttributes`-选择框属性类型：`SelectHTMLAttributes`-表格属性类型：`TableHTMLAttributes`-输入区属性类型：`TextareaHTMLAttributes`-视频属性类型：`VideoHTMLAttributes`-SVG属性类型：`SVGAttributes`-WebView属性类型：`WebViewHTMLAttributes`一般情况下，我们是很少需要在项目中显式的去定义标签属性的类型。如果子级去封装组件库的话，这些属性就能发挥它们的作用了。来看例子（来源于网络，仅供学习）：```tsximportReactfrom'react'importclassNamesfrom'classnames'exportenumButtonSize{Large='lg',Small='sm',}exportenumButtonType{Primary='primary',Default='default',Danger='danger',Link='link',}interfaceBaseButtonProps{className?:stringdisabled?:booleansize?:ButtonSizebtnType?:ButtonTypechildren:React.ReactNodehref?:string}typeNativeButtonProps=BaseButtonProps&React.ButtonHTMLAttributes<HTMLButtonElement>//使用交叉类型（&）获得我们自己定义的属性和原生button的属性typeAnchorButtonProps=BaseButtonProps&React.AnchorHTMLAttributes<HTMLAnchorElement>//使用交叉类型（&）获得我们自己定义的属性和原生a标签的属性exporttypeButtonProps=Partial<NativeButtonProps&AnchorButtonProps>//使用Partial<>使两种属性可选constButton:React.FC<ButtonProps>=(props)=>{const{disabled,className,size,btnType,children,href,...restProps}=propsconstclasses=classNames('btn',className,{[`btn-${btnType}`]:btnType,[`btn-${size}`]:size,disabled:btnType===ButtonType.Link&&disabled,//只有a标签才有disabled类名，button没有})if(btnType===ButtonType.Link&&href){return(<aclassName={classes}href={href}{...restProps}>{children}</a>)}else{return(<buttonclassName={classes}disabled={disabled}//button元素默认有disabled属性，所以即便没给他设置样式也会和普通button有一定区别{...restProps}>{children}</button>)}}Button.defaultProps={disabled:false,btnType:ButtonType.Default,}exportdefaultButton```这段代码就是用来封装一个buttom按钮，在button的基础上添加了一些自定义属性，比如上面将button的类型使用交叉类型（&）获得自定义属性和原生button属性：```tsxtypeNativeButtonProps=BaseButtonProps&React.ButtonHTMLAttributes<HTMLButtonElement>```可以看到，标签属性类型在封装组件库时还是很有用的，更多用途可以自己探索~##工具泛型在项目中使用一些工具泛型可以提高我们的开发效率，少写很多类型定义。下面来看看有哪些常见的工具泛型，以及其使用方式。###PartialPartial作用是将传入的属性变为可选项。适用于对类型结构不明确的情况。它使用了两个关键字：keyof和in，先来看看他们都是什么含义。keyof可以用来取得接口的所有key值：```tsxinterfaceIPerson{name:stringage:numberheight:number}typeT=keyofIPerson//T类型为：\"name\"|\"age\"|\"number\"```in关键字可以遍历枚举类型,：```tsxtypePerson='name'|'age'|'number'typeObj={[pinKeys]:any}//Obj类型为：{name:any,age:any,number:any}```keyof可以产生联合类型,in可以遍历枚举类型,所以经常一起使用,下面是Partial工具泛型的定义：```tsx/**-MakeallpropertiesinToptional-将T中的所有属性设置为可选*/typePartial<T>={[PinkeyofT]?:T[P]}```这里，keyofT获取T所有属性名,然后使用in进行遍历,将值赋给P,最后T[P]取得相应属性的值。中间的?就用来将属性设置为可选。使用示例如下：```tsxinterfaceIPerson{name:string;age:number;height:number;}constperson:Partial<IPerson>={name:\"zhangsan\";}```###Required>Required的作用是将传入的属性变为必选项，和上面的工具泛型恰好相反，其声明如下：```tsx/**-MakeallpropertiesinTrequired-将T中的所有属性设置为必选*/typeRequired<T>={[PinkeyofT]-?:T[P]}```可以看到，这里使用-?将属性设置为必选，可以理解为减去问号。适用形式和上面的Partial差不多：```tsxinterfaceIPerson{name?:string;age?:number;height?:number;}constperson:Required<IPerson>={name:\"zhangsan\";age:18;height:180;}```###Readonly>将T类型的所有属性设置为只读（readonly），构造出来类型的属性不能被再次赋值。Readonly的声明形式如下：```tsx/**-MakeallpropertiesinTreadonly*/typeReadonly<T>={readonly[PinkeyofT]:T[P];};使用示例如下：interfaceIPerson{name:string;age:number;}constperson:Readonly<IPerson>={name:\"zhangsan\",age:18}person.age=20;//Error:cannotreassignareadonlyproperty```可以看到，通过Readonly将IPerson的属性转化成了只读，不能再进行赋值操作。###Pick<T,KextendskeyofT>>从T类型中挑选部分属性K来构造新的类型。它的声明形式如下：```tsx/**-FromT,pickasetofpropertieswhosekeysareintheunionK*/typePick<T,KextendskeyofT>={[PinK]:T[P];};使用示例如下：interfaceIPerson{name:string;age:number;height:number;}constperson:Pick<IPerson,\"name\"|\"age\">={name:\"zhangsan\",age:18}```###Record<Kextendskeyofany,T>>Record用来构造一个类型，其属性名的类型为K，属性值的类型为T。这个工具泛型可用来将某个类型的属性映射到另一个类型上，下面是其声明形式：```tsx/**-ConstructatypewithasetofpropertiesKoftypeT*/typeRecord<Kextendskeyofany,T>={[PinK]:T}```使用示例如下：```tsxinterfaceIPageinfo{title:string}typeIPage='home'|'about'|'contact'constpage:Record<IPage,IPageinfo>={about:{title:'about'},contact:{title:'contact'},home:{title:'home'},}```###Exclude<T,U>Exclude就是从一个联合类型中排除掉属于另一个联合类型的子集，下面是其声明的形式：```tsx/**-ExcludefromTthosetypesthatareassignabletoU*/typeExclude<T,U>=TextendsU?never:T;使用示例如下：interfaceIPerson{name:string;age:number;height:number;}constperson:Exclude<IPerson,\"age\"|\"sex\">={name:\"zhangsan\";height:180;}```###Omit<T,Kextendskeyofany>上面的Pick和Exclude都是最基础基础的工具泛型，很多时候用Pick或者Exclude还不如直接写类型更直接。而Omit就基于这两个来做的一个更抽象的封装，它允许从一个对象中剔除若干个属性，剩下的就是需要的新类型。下面是它的声明形式：```tsx/**-ConstructatypewiththepropertiesofTexceptforthoseintypeK.*/typeOmit<T,Kextendskeyofany>=Pick<T,Exclude<keyofT,K>>;使用示例如下：interfaceIPerson{name:string;age:number;height:number;}constperson:Omit<IPerson,\"age\"|\"height\">={name:\"zhangsan\";}```###ReturnTypeReturnType会返回函数返回值的类型，其声明形式如下：```tsx/**-Obtainthereturntypeofafunctiontype*/typeReturnType<Textends(...args:any)=>any>=Textends(...args:any)=>inferR?R:any```使用示例如下：```tsxfunctionfoo(type):boolean{returntype===0}typeFooType=ReturnType<typeoffoo>```>使用typeof是为了获取foo的函数签名，等价于(type:any)=>boolean。##Axios封装>基于Promise的HTTP库，可以在浏览器和node.js中使用。Axios具备以下特性：-从浏览器中创建XMLHttpRequests-从node.js创建HTTP请求-支持PromiseAPI-拦截请求和响应-转换请求数据和响应数据-取消请求-自动转换JSON数据-客户端支持防御XSRFAxios的基本使用就不再多介绍了。为了更好地调用，做一些全局的拦截，通常会对Axios进行封装，下面就使用TypeScript对Axios进行简单封装，使其同时能够有很好的类型支持。Axios是自带声明文件的，所以我们无需额外的操作。​下面来看基本的封装：```tsximportaxios,{AxiosInstance,AxiosRequestConfig,AxiosPromise,AxiosResponse,}from'axios'//引入axios和定义在node_modules/axios/index.ts文件里的类型声明//定义接口请求类，用于创建axios请求实例classHttpRequest{//接收接口请求的基本路径constructor(publicbaseUrl:string){this.baseUrl=baseUrl}//调用接口时调用实例的这个方法，返回AxiosPromisepublicrequest(options:AxiosRequestConfig):AxiosPromise{//创建axios实例，它是函数，同时这个函数包含多个属性constinstance:AxiosInstance=axios.create()//合并基础路径和每个接口单独传入的配置，比如url、参数等options=this.mergeConfig(options)//调用interceptors方法使拦截器生效this.interceptors(instance,options.url)//返回AxiosPromisereturninstance(options)}//用于添加全局请求和响应拦截privateinterceptors(instance:AxiosInstance,url?:string){//请求和响应拦截}//用于合并基础路径配置和接口单独配置privatemergeConfig(options:AxiosRequestConfig):AxiosRequestConfig{returnObject.assign({baseURL:this.baseUrl},options)}}exportdefaultHttpRequest```通常baseUrl在开发环境的和生产环境的路径是不一样的，所以可以根据当前是开发环境还是生产环境做判断，应用不同的基础路径。这里要写在一个配置文件里：```tsxexportdefault{api:{devApiBaseUrl:'/test/api/xxx',proApiBaseUrl:'/api/xxx',},}```在上面的文件中引入这个配置：```tsximport{api:{devApiBaseUrl,proApiBaseUrl}}from'@/config';constapiBaseUrl=env.NODE_ENV==='production'?proApiBaseUrl:devApiBaseUrl;之后就可以将apiBaseUrl作为默认值传入HttpRequest的参数：classHttpRequest{constructor(publicbaseUrl:string=apiBaseUrl){this.baseUrl=baseUrl;}接下来可以完善一下拦截器类，在类中interceptors方法内添加请求拦截器和响应拦截器，实现对所有接口请求的统一处理：privateinterceptors(instance:AxiosInstance,url?:string){//请求拦截instance.interceptors.request.use((config:AxiosRequestConfig)=>{//接口请求的所有配置，可以在axios.defaults修改配置returnconfig},(error)=>{returnPromise.reject(error)})//响应拦截instance.interceptors.response.use((res:AxiosResponse)=>{const{data}=resconst{code,msg}=dataif(code!==0){console.error(msg)}returnres},(error)=>{returnPromise.reject(error)})}```到这里封装的就差不多了，一般服务端会将状态码、提示信息和数据封装在一起，然后作为数据返回，所以所有请求返回的数据格式都是一样的，所以就可以定义一个接口来指定返回的数据结构，可以定义一个接口：```tsexportinterfaceResponseData{code:numberdata?:anymsg:string}```接下来看看使用TypeScript封装的Axios该如何使用。可以先定义一个请求实例：```tsximportHttpRequestfrom'@/utils/axios'export*from'@/utils/axios'exportdefaultnewHttpRequest()```这里把请求类导入进来，默认导出这个类的实例。之后创建一个登陆接口请求方法：```tsximportaxios,{ResponseData}from'./index'import{AxiosPromise}from'axios'interfaceILogin{user:stringpassword:number|string}exportconstloginReq=(data:ILogin):AxiosPromise<ResponseData>=>{returnaxios.request({url:'/api/user/login',data,method:'POST',})}```这里封装登录请求方法loginReq，他的参数必须是我们定义的ILogin接口的类型。这个方法返回一个类型为AxiosPromise的Promise，AxiosPromise是axios声明文件内置的类型，可以传入一个泛型变量参数，用于指定返回的结果中data字段的类型。​接下来可以调用一下这个登录的接口：```tsximport{loginReq}from'@/api/user'constHome:FC=()=>{constlogin=(params)=>{loginReq(params).then((res)=>{console.log(res.data.code)})}}```通过这种方式，当我们调用loginReq接口时，就会提示我们，参数的类型是ILogin，需要传入几个参数。这样编写代码的体验就会好很多。##其他###importReact在React项目中使用TypeScript时，普通组件文件后缀为.tsx，公共方法文件后缀为.ts。在.tsx文件中导入React的方式如下：```tsximport*asReactfrom'react'import*asReactDOMfrom'react-dom'```这是一种面向未来的导入方式，如果想在项目中使用以下导入方式：```tsximportReactfrom'react'importReactDOMfrom'react-dom'```就需要在tsconfig.json配置文件中进行如下配置：```tsx\"compilerOptions\":{//允许默认从没有默认导出的模块导入。\"allowSyntheticDefaultImports\":true,}```###TypesorInterfaces？>在定义公共API时(比如编辑一个库）使用interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；>在定义组件属性（Props）和状态（State）时，建议使用type，因为type的约束性更强。>interface和type在ts中是两个不同的概念，但在React大部分使用的case中，interface和type可以达到相同的功能效果，type和interface最大的区别是：type类型不能二次编辑，而interface可以随时扩展：```tsinterfaceAnimal{name:string}//可以继续在原属性基础上，添加新属性：colorinterfaceAnimal{color:string}typeAnimal={name:string}//type类型不支持属性扩展//Error:Duplicateidentifier'Animal'typeAnimal={color:string}```>type对于联合类型是很有用的，比如：typeType=TypeA|TypeB。而interface更适合声明字典类行，然后定义或者扩展它。###懒加载类型>如果我们想在Reactrouter中使用懒加载，React也为我们提供了懒加载方法的类型，来看下面的例子：```tsxexportinterfaceRouteType{pathname:stringcomponent:LazyExoticComponent<any>exact:booleantitle?:stringicon?:stringchildren?:RouteType[]}exportconstAppRoutes:RouteType[]=[{pathname:'/login',component:lazy(()=>import('../views/Login/Login')),exact:true,},{pathname:'/404',component:lazy(()=>import('../views/404/404')),exact:true,},{pathname:'/',exact:false,component:lazy(()=>import('../views/Admin/Admin')),},]```下面是懒加载类型和lazy方法在声明文件中的定义：```tsxtypeLazyExoticComponent<TextendsComponentType<any>>=ExoticComponent<ComponentPropsWithRef<T>>&{readonly_result:T}functionlazy<TextendsComponentType<any>>(factory:()=>Promise<{default:T}>,):LazyExoticComponent<T>```###类型断言类型断言（TypeAssertion）可以用来手动指定一个值的类型。在React项目中，断言还是很有用的，。有时候推断出来的类型并不是真正的类型，很多时候我们可能会比TS更懂我们的代码，所以可以使用断言（使用as关键字）来定义一个值得类型。​来看下面的例子：```tsxconstgetLength=(target:string|number):number=>{if(target.length){//error类型\"string|number\"上不存在属性\"length\"returntarget.length//error类型\"number\"上不存在属性\"length\"}else{returntarget.toString().length}}```当TypeScript不确定一个联合类型的变量到底是哪个类型时，就只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数target和返回值的类型定义之后就会报错。这时就可以使用断言，将target的类型断言成string类型：```tsxconstgetStrLength=(target:string|number):number=>{if((targetasstring).length){return(targetasstring).length}else{returntarget.toString().length}}```需要注意，类型断言并不是类型转换，断言成一个联合类型中不存在的类型是不允许的。​再来看一个例子，在调用一个方法时传入参数：![](/.assets/img/2022-02-09-11-20-44.png)这里就提示我们这个参数可能是undefined，而通过业务知道这个值是一定存在的，所以就可以将它断言成数字：data?.subjectIdasnumber​除此之外，上面所说的标签类型、组件类型、时间类型都可以使用断言来指定给一些数据，还是要根据实际的业务场景来使用。​感悟：使用类型断言真的能解决项目中的很多报错~###枚举类型枚举类型在项目中的作用也是不可忽视的，使用枚举类型可以让代码的扩展性更好，当我想更改某属性值时，无需去全局更改这个属性，只要更改枚举中的值即可。通常情况下，最好新建一个文件专门来定义枚举值，便于引用","React\\typescript\\type\\index.md":"#ReactType```jsexporttypeReactNode=|React$Element<any>|ReactPortal|ReactText|ReactFragment|ReactProvider<any>|ReactConsumer<any>;exporttypeReactEmpty=null|void|boolean;exporttypeReactFragment=ReactEmpty|Iterable<React$Node>;exporttypeReactNodeList=ReactEmpty|React$Node;exporttypeReactText=string|number;exporttypeReactProvider<T>={$$typeof:Symbol|number,type:ReactProviderType<T>,key:null|string,ref:null,props:{value:T,children?:ReactNodeList,...},...};exporttypeReactProviderType<T>={$$typeof:Symbol|number,_context:ReactContext<T>,...};exporttypeReactConsumer<T>={$$typeof:Symbol|number,type:ReactContext<T>,key:null|string,ref:null,props:{children:(value:T)=>ReactNodeList,unstable_observedBits?:number,...},...};exporttypeReactContext<T>={$$typeof:Symbol|number,Consumer:ReactContext<T>,Provider:ReactProviderType<T>,_calculateChangedBits:((a:T,b:T)=>number)|null,_currentValue:T,_currentValue2:T,_threadCount:number,//DEVonly_currentRenderer?:Object|null,_currentRenderer2?:Object|null,//Thisvaluemaybeaddedbyapplicationcode//toimproveDEVtoolingdisplaynamesdisplayName?:string,...};exporttypeReactPortal={$$typeof:Symbol|number,key:null|string,containerInfo:any,children:ReactNodeList,//TODO:figureouttheAPIforcross-rendererimplementation.implementation:any,...};exporttypeRefObject={|current:any,|};exporttypeEventPriority=0|1|2;exportconstDiscreteEvent:EventPriority=0;exportconstUserBlockingEvent:EventPriority=1;exportconstContinuousEvent:EventPriority=2;exporttypeReactFundamentalComponentInstance<C,H>={|currentFiber:Object,instance:mixed,prevProps:null|Object,props:Object,impl:ReactFundamentalImpl<C,H>,state:Object,|};exporttypeReactFundamentalImpl<C,H>={displayName:string,reconcileChildren:boolean,getInitialState?:(props:Object)=>Object,getInstance:(context:C,props:Object,state:Object)=>H,getServerSideString?:(context:C,props:Object)=>string,getServerSideStringClose?:(context:C,props:Object)=>string,onMount:(context:C,instance:mixed,props:Object,state:Object)=>void,shouldUpdate?:(context:C,prevProps:null|Object,nextProps:Object,state:Object,)=>boolean,onUpdate?:(context:C,instance:mixed,prevProps:null|Object,nextProps:Object,state:Object,)=>void,onUnmount?:(context:C,instance:mixed,props:Object,state:Object,)=>void,onHydrate?:(context:C,props:Object,state:Object)=>boolean,onFocus?:(context:C,props:Object,state:Object)=>boolean,...};exporttypeReactFundamentalComponent<C,H>={|$$typeof:Symbol|number,impl:ReactFundamentalImpl<C,H>,|};exporttypeReactScope={|$$typeof:Symbol|number,|};exporttypeReactScopeQuery=(type:string,props:{[string]:mixed,...},instance:mixed,)=>boolean;exporttypeReactScopeInstance={|DO_NOT_USE_queryAllNodes(ReactScopeQuery):null|Array<Object>,DO_NOT_USE_queryFirstNode(ReactScopeQuery):null|Object,containsNode(Object):boolean,getChildContextValues:<T>(context:ReactContext<T>)=>Array<T>,|};//Mutablesourceversioncanbeanything(e.g.number,string,immutabledatastructure)//solongasitchangeseverytimeanypartofthesourcechanges.exporttypeMutableSourceVersion=$NonMaybeType<mixed>;exporttypeMutableSourceGetSnapshotFn<Source:$NonMaybeType<mixed>,Snapshot,>=(source:Source)=>Snapshot;exporttypeMutableSourceSubscribeFn<Source:$NonMaybeType<mixed>,Snapshot>=(source:Source,callback:(snapshot:Snapshot)=>void,)=>()=>void;exporttypeMutableSourceGetVersionFn=(source:$NonMaybeType<mixed>,)=>MutableSourceVersion;exporttypeMutableSource<Source:$NonMaybeType<mixed>>={|_source:Source,_getVersion:MutableSourceGetVersionFn,//Trackstheversionofthissourceatthetimeitwasmostrecentlyread.//Usedtodetermineifasourceissafetoreadfrombeforeithasbeensubscribedto.//Versionnumberisonlyusedduringmount,//sincethemechanismfordeterminingsafetyaftersubscriptionisexpirationtime.////Asaworkaroundtosupportmultipleconcurrentrenderers,//wecategorizesomerenderersasprimaryandothersassecondary.//Weonlyexpecttheretobetwoconcurrentrenderersatmost://ReactNative(primary)andFabric(secondary);//ReactDOM(primary)andReactART(secondary).//Secondaryrenderersstoretheircontextvaluesonseparatefields.//WeusethesameapproachforContext._workInProgressVersionPrimary:null|MutableSourceVersion,_workInProgressVersionSecondary:null|MutableSourceVersion,//DEVonly//Usedtodetectmultiplerenderersusingthesamemutablesource._currentPrimaryRenderer?:Object|null,_currentSecondaryRenderer?:Object|null,|};//ThesubsetofaThenablerequiredbythingsthrownbySuspense.//Thisdoesn'trequireavaluetobepassedtoeitherhandler.exportinterfaceWakeable{then(onFulfill:()=>mixed,onReject:()=>mixed):void|Wakeable;//SpecialflagtooptoutoftracinginteractionsacrossaSuspenseboundary.__reactDoNotTraceInteractions?:boolean;}//ThesubsetofaPromisethatReactAPIsrelyon.Thisresolvesavalue.//Thisdoesn'trequireareturnvalueneitherfromthehandlernorthe//thenfunction.exportinterfaceThenable<+R>{then<U>(onFulfill:(value:R)=>void|Thenable<U>|U,onReject:(error:mixed)=>void|Thenable<U>|U,):void|Thenable<U>;}```","React\\UmiJS\\index.md":"#UmiJS>[介绍|UmiJS](https://v2.umijs.org/zh/guide/#特性)##[umi](https://umijs.org/zh-CN/docs/getting-started)1.全局安装`dva+umi`1.dva:`npminstall-gumi`2.umi:`npminstall-gdva-cli`2.通过脚手架创建项目1.`mkdir[项目名]&&cd[项目名]`2.`npmcreateumi`3.```shell?Selecttheboilerplatetype(Usearrowkeys)ant-design-pro-Createprojectwithanlayout-onlyant-design-proboilerplate,usetogetherwithumiblock.❯app-Createprojectwithasimpleboilerplate,supporttypescript.block-Createaumiblock.library-Createalibrarywithumi.plugin-Createaumiplugin.```4.```shell?Doyouwanttousetypescript?(y/N)```5.```shell?Whatfunctionalitydoyouwanttoenable?(Press<space>toselect,<a>totoggleall,<i>toinvertselection)❯◯antd◯dva◯codesplitting◯dll```","React\\内置API\\React.children.map().md":"#React.children.map()>获取子组件进行拷贝子组件添加新属性以便生成新组件的操```tsxclassChildextendsComponent{componentDidMount(){console.log(React.Children.map(this.props.children,(item)=>{return[item,[item]]}),)}render(){return(<div>{React.Children.map(this.props.children,(item)=>[item,[item]])}</div>)}}classChildrenMapextendsComponent{constructor(props){super(props)}render(){return(<Child><div>1</div><div>2</div></Child>)}}exportdefaultChildrenMap```","React\\内置ts类型\\HTML标签类型.md":"#HTML标签类型>所有的HTML标签类型都定义在了`node_modules/@types/react/global.d.ts`##常见的大概有-`a`:`HTMLAnchorElement`-`body`:`HTMLBodyElement`-`br`:`HTMLBRElement`-`button`:`HTMLButtonElement`-`div`:`HTMLDivElement`-`h1`:`HTMLHeadingElement`-`h2`:`HTMLHeadingElement`-`h3`:`HTMLHeadingElement`-`html`:`HTMLHtmlElement`-`img`:`HTMLImageElement`-`input`:`HTMLInputElement`-`ul`:`HTMLUListElement`-`li`:`HTMLLIElement`-`link`:`HTMLLinkElement`-`p`:`HTMLParagraphElement`-`span`:`HTMLSpanElement`-`style`:`HTMLStyleElement`-`table`:`HTMLTableElement`-`tbody`:`HTMLTableSectionElement`-`video`:`HTMLVideoElement`-`audio`:`HTMLAudioElement`-`meta`:`HTMLMetaElement`-`form`:`HTMLFormElement`>然后每个标签都还有自己的属性类型，不过用的不多，一般在自己封装原生组件的库的时候会用到(比如antd的Radio组件)，简单了解下-HTML属性类型:`HTMLAttributes`-按钮属性类型:`ButtonHTMLAttributes`-表单属性类型:`FormHTMLAttributes`-图片属性类型:`ImgHTMLAttributes`-输入框属性类型:`InputHTMLAttributes`-链接属性类型:`LinkHTMLAttributes`-meta属性类型:`MetaHTMLAttributes`-选择框属性类型:`SelectHTMLAttributes`-表格属性类型:`TableHTMLAttributes`-输入区属性类型:`TextareaHTMLAttributes`-视频属性类型:`VideoHTMLAttributes`-SVG属性类型:`SVGAttributes`-WebView属性类型:`WebViewHTMLAttributes`","React\\内置ts类型\\index.md":"#React内置类型[事件处理](./%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.md)[HTML标签类型](./HTML%E6%A0%87%E7%AD%BE%E7%B1%BB%E5%9E%8B.md)##React.ReactNode和React.Element##ReactNode|undefined```tsxtypeReactNode=|ReactChild|ReactFragment|ReactPortal|boolean|null|undefined```>`typeReactFragment={}|ReactNodeArray;`:就是<>xxx</>或者`<React.Fragament>xxx<React.Fragament/>````tsxinterfaceReactPortalextendsReactElement{key:Key|nullchildren:ReactNode}```>就是ReactDOM.createPortal(child,container)这个API的返回值```tsexportfunctioncreatePortal(children:ReactNode,container:Element,key?:null|string,):ReactPortaltypeReactText=string|numbertypeReactChild=ReactElement|ReactText```>ReactNode是一个联合类型，囊括了ReactElement```tsxinterfaceReactElement<P=any,Textendsstring|JSXElementConstructor<any>=|string|JSXElementConstructor<any>,>{type:Tprops:Pkey:Key|null}```>写上**_(childasReactElement).props_**就不会报错```tsxfunctioncreateElement<Pextends{}>(type:FunctionComponent<P>|ComponentClass<P>|string,props?:(Attributes&P)|null,...children:ReactNode[]):ReactElement<P>```>ReactElement:createElement的返回值```tsx//DOMElements//TODO:generalizethistoeverythingin`keyofReactHTML`,notjust\"input\"functioncreateElement(type:'input',props?:|(InputHTMLAttributes<HTMLInputElement>&ClassAttributes<HTMLInputElement>)|null,...children:ReactNode[]):DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>,HTMLInputElement>functioncreateElement<PextendsHTMLAttributes<T>,TextendsHTMLElement>(type:keyofReactHTML,props?:(ClassAttributes<T>&P)|null,...children:ReactNode[]):DetailedReactHTMLElement<P,T>functioncreateElement<PextendsSVGAttributes<T>,TextendsSVGElement>(type:keyofReactSVG,props?:(ClassAttributes<T>&P)|null,...children:ReactNode[]):ReactSVGElementfunctioncreateElement<PextendsDOMAttributes<T>,TextendsElement>(type:string,props?:(ClassAttributes<T>&P)|null,...children:ReactNode[]):DOMElement<P,T>//CustomcomponentsfunctioncreateElement<Pextends{}>(type:FunctionComponent<P>,props?:(Attributes&P)|null,...children:ReactNode[]):FunctionComponentElement<P>functioncreateElement<Pextends{}>(type:ClassType<P,ClassicComponent<P,ComponentState>,ClassicComponentClass<P>>,props?:(ClassAttributes<ClassicComponent<P,ComponentState>>&P)|null,...children:ReactNode[]):CElement<P,ClassicComponent<P,ComponentState>>functioncreateElement<Pextends{},TextendsComponent<P,ComponentState>,CextendsComponentClass<P>,>(type:ClassType<P,T,C>,props?:(ClassAttributes<T>&P)|null,...children:ReactNode[]):CElement<P,T>functioncreateElement<Pextends{}>(type:FunctionComponent<P>|ComponentClass<P>|string,props?:(Attributes&P)|null,...children:ReactNode[]):ReactElement<P>```>-`DOMElement<P,T>，FunctionComponentElement啊，CElement<P,ClassicComponent<P,ComponentState>>`,都是extendsReactElement,所以得出`ReactElement`是由`React.createElement()`这个API创建出来的类型，根本上是一个Js对象，如上图所示，在Jsx里面以自定义组件的形式呈现，比如`<MyComponent/>`，这就是一个ReactElement，而`<div/>`，也是一个`ReactElement`>-被React渲染到浏览器上的东西，可以理解为VDOM上的每个节点，都是是ReactNode```tsxconstParent=()=>{return(<><div><Child/><div/></>)}constChild=()=>{return(<><div>我是孩子<div/></>)}ReactDOM.render(<Parent/>,document.getElementById('root'))```>React.FC的返回值是ReactElement```tsinterfaceFunctionComponent<P={}>{(props:PropsWithChildren<P>,context?:any):ReactElement<any,any>|nullpropTypes?:WeakValidationMap<P>|undefinedcontextTypes?:ValidationMap<any>|undefineddefaultProps?:Partial<P>|undefineddisplayName?:string|undefined}```>返回的类型是明确的ReactElement,看之前createElement源码部分，有对自定义组件的说明。(当然其实也可以理解为返回ReactNode,因为Element是Node的子集，但还是根据源码准确点好,因为可以注意类组件的render方法和函数声明方式写的组件，他们渲染的类型都是JSX.Element，也就是说JSX.Element==ReactElement)","React\\内置ts类型\\事件处理.md":"#事件处理>事件处理,event事件对象类型```tsxconstonChange=(e){console.log(e.target.value)}```>受控表单一般都会这么写是吧，但如果你不给e限定类型他就会报错，说e这个类型没有target嘛，这个好解决，cmd点进去看这些合成事件就能看到，大部分啥`ChangeEvent,MouseEvent`-剪切板事件对象`:ClipboardEvent<T=Element>`-拖拽事件对象:`DragEvent<T=Element>`-焦点事件对象:`FocusEvent<T=Element>`-表单事件对象:`FormEvent<T=Element>`-Change事件对象:`ChangeEvent<T=Element>`-键盘事件对象:`KeyboardEvent<T=Element>`-鼠标事件对象:`MouseEvent<T=Element,E=NativeMouseEvent>`-触摸事件对象:`TouchEvent<T=Element>`-滚轮事件对象:`WheelEvent<T=Element>`-动画事件对象:`AnimationEvent<T=Element>`-过渡事件对象:`TransitionEvent<T=Element>`就比如说我之前写受控表单的时候就是这么写的![](/.assets/img/2022-02-12-19-15-22.png)>处理表单嘛，所以泛型给的就是HTMLInputElement这里注意到，onChange这个合成事件的类型是啥？老长一串，哎，这也直接看简单的声明吧```tsxtypeEventHandler<EextendsSyntheticEvent<any>>={bivarianceHack(event:E):void}['bivarianceHack']typeReactEventHandler<T=Element>=EventHandler<SyntheticEvent<T>>//剪切板事件处理函数typeClipboardEventHandler<T=Element>=EventHandler<ClipboardEvent<T>>//复合事件处理函数typeCompositionEventHandler<T=Element>=EventHandler<CompositionEvent<T>>//拖拽事件处理函数typeDragEventHandler<T=Element>=EventHandler<DragEvent<T>>//焦点事件处理函数typeFocusEventHandler<T=Element>=EventHandler<FocusEvent<T>>//表单事件处理函数typeFormEventHandler<T=Element>=EventHandler<FormEvent<T>>//Change事件处理函数typeChangeEventHandler<T=Element>=EventHandler<ChangeEvent<T>>//键盘事件处理函数typeKeyboardEventHandler<T=Element>=EventHandler<KeyboardEvent<T>>//鼠标事件处理函数typeMouseEventHandler<T=Element>=EventHandler<MouseEvent<T>>//触屏事件处理函数typeTouchEventHandler<T=Element>=EventHandler<TouchEvent<T>>//指针事件处理函数typePointerEventHandler<T=Element>=EventHandler<PointerEvent<T>>//界面事件处理函数typeUIEventHandler<T=Element>=EventHandler<UIEvent<T>>//滚轮事件处理函数typeWheelEventHandler<T=Element>=EventHandler<WheelEvent<T>>//动画事件处理函数typeAnimationEventHandler<T=Element>=EventHandler<AnimationEvent<T>>//过渡事件处理函数typeTransitionEventHandler<T=Element>=EventHandler<TransitionEvent<T>>```>编译器一般会有提示，vscode是有的，就比如我们写onChange类型的时候写个Change,后面的EventHandler应该会自动弹出来，实在不行也就直接cmd点进去看源码算了。","React\\定时器.md":"#React实现定时器##class```tsimportReact,{Component}from'react'typeStateType={time:string,inter:number};typepropType={};exportdefaultclassTimerextendsComponent<propType,StateType>{constructor(props:any){super(props)this.state={time:newDate(+newDate()+8*3600*1000).toISOString().replace(/T/g,'').replace(/\\.[\\d]{3}Z/,''),inter:0}}componentWillMount(){/*this.inter=window.setInterval(()=>{this.setState({time:newDate(+newDate()+8*3600*1000).toISOString().replace(/T/g,'').replace(/\\.[\\d]{3}Z/,'')})},1000)*/this.setState({//主要此处的赋值必须是这样，暂时不知道还有没有别的实现方式//两层嵌套的setState，看着有点怪异inter:window.setInterval(()=>{this.setState({time:newDate(+newDate()+8*3600*1000).toISOString().replace(/T/g,'').replace(/\\.[\\d]{3}Z/,'')})})})}componentWillUnmount(){clearTimeout(this.state.inter)}render(){console.log(this.state.time)const{time}=this.statereturn<div><h2>{time}</h2></div>}}```##function###js```jsimportReact,{useState,useEffect}from'react'functionClock(){const[time,setTime]=useState(newDate(+newDate()+8*3600*1000).toISOString().replace(/T/g,'').replace(/\\.[\\d]{3}Z/,''),)//处理副作用部分useEffect(()=>{//定义定时器的引用consttimer=setInterval(()=>{setTime(newDate(+newDate()+8*3600*1000).toISOString().replace(/T/g,'').replace(/\\.[\\d]{3}Z/,''),)},1000)return()=>{//组件销毁时清除定时器引用clearInterval(timer)}//[]为空说明需要一直执行，没有依赖，有值的情况下是依赖值变化了才会执行到effect副作用},[])return<div>{time}</div>}exportdefaultClock```###ts```tsimportReact,{useState,useEffect}from\"react\";functionClock(){const[time,setTime]=useState(newDate(+newDate()+8*3600*1000).toISOString().replace(/T/g,\"\").replace(/\\.[\\d]{3}Z/,\"\"));//处理副作用部分useEffect(()=>{//定义定时器的引用,需要区分是nodejs的定时器还是浏览器的定时器consttimer:number=window.setInterval(()=>{setTime(newDate(+newDate()+8*3600*1000).toISOString().replace(/T/g,\"\").replace(/\\.[\\d]{3}Z/,\"\"));},1000);return()=>{//组件销毁时清除定时器引用clearInterval(timer);};//[]为空说明需要一直执行，没有依赖，有值的情况下是依赖值变化了才会执行到effect副作用},[]);return<div>{time}</div>;}exportdefaultClock;```","React\\工具包.md":"-[react-error-boundary](https://www.npmjs.com/package/react-error-boundary)-可重用的React错误边界组件。支持所有React渲染器（包括ReactDOM和ReactNative）。-[Sandpack](https://sandpack.codesandbox.io/docs)-在任何浏览器中运行任何JavaScript和Node.js应用程序。-[react-json-view](https://www.npmjs.com/package/react-json-view)-是一个React组件，用于显示和编辑javascript数组和JSON对象。-[webcontainers](https://webcontainers.io/guides/introduction#introduction)-是一个基于浏览器的运行时，用于完全在浏览器选项卡中执行Node.js应用程序和操作系统命令。以前需要云VM才能在WebContainers中执行用户代码的应用可以完全在客户端运行，与旧版云VM相比具有许多优势。","React\\懒加载.md":"#懒加载><https://www.cnblogs.com/forcheng/p/13132582.html>1.代码分割（1）为什么要进行代码分割？现在前端项目基本都采用打包技术，比如Webpack，JS逻辑代码打包后会产生一个bundle.js文件，而随着我们引用的第三方库越来越多或业务逻辑代码越来越复杂，相应打包好的bundle.js文件体积就会越来越大，因为需要先请求加载资源之后，才会渲染页面，这就会严重影响到页面的首屏加载。而为了解决这样的问题，避免大体积的代码包，我们则可以通过技术手段对代码包进行分割，能够创建多个包并在运行时动态地加载。现在像Webpack、Browserify等打包器都支持代码分割技术。（2）什么时候应该考虑进行代码分割？这里举一个平时开发中可能会遇到的场景，比如某个体积相对比较大的第三方库或插件（比如JS版的PDF预览库）只在单页应用（SPA）的某一个不是首页的页面使用了，这种情况就可以考虑代码分割，增加首屏的加载速度。2.React的懒加载示例代码：```jsximportReact,{Suspense}from'react'constOtherComponent=React.lazy(()=>import('./OtherComponent'))functionMyComponent(){return(<div><Suspensefallback={<div>Loading...</div>}><OtherComponent/></Suspense></div>)}```如上代码中，通过import()、React.lazy和Suspense共同一起实现了React的懒加载，也就是我们常说了运行时动态加载，即OtherComponent组件文件被拆分打包为一个新的包（bundle）文件，并且只会在OtherComponent组件渲染时，才会被下载到本地。那么上述中的代码拆分以及动态加载究竟是如何实现的呢？让我们来一起探究其原理是怎样的。import()原理import()函数是由TS39提出的一种动态加载模块的规范实现，其返回是一个promise。在浏览器宿主环境中一个import()的参考实现如下：```jsxfunctionimport(url){returnnewPromise((resolve,reject)=>{constscript=document.createElement(\"script\");consttempGlobal=\"__tempModuleLoadingVariable\"+Math.random().toString(32).substring(2);script.type=\"module\";script.textContent=`import*asmfrom\"${url}\";window.${tempGlobal}=m;`;script.onload=()=>{resolve(window[tempGlobal]);deletewindow[tempGlobal];script.remove();};script.onerror=()=>{reject(newError(\"FailedtoloadmodulescriptwithURL\"+url));deletewindow[tempGlobal];script.remove();};document.documentElement.appendChild(script);});}```当Webpack解析到该import()语法时，会自动进行代码分割。React.lazy原理以下React源码基于16.8.0版本React.lazy的源码实现如下：```tsxexportfunctionlazy<T,R>(ctor:()=>Thenable<T,R>):LazyComponent<T>{letlazyType={$$typeof:REACT_LAZY_TYPE,_ctor:ctor,//Reactusesthesefieldstostoretheresult._status:-1,_result:null,}returnlazyType}```可以看到其返回了一个LazyComponent对象。而对于LazyComponent对象的解析：```tsx...caseLazyComponent:{constelementType=workInProgress.elementType;returnmountLazyComponent(current,workInProgress,elementType,updateExpirationTime,renderExpirationTime,);}...functionmountLazyComponent(_current,workInProgress,elementType,updateExpirationTime,renderExpirationTime,){...letComponent=readLazyComponentType(elementType);...}//Pending=0,Resolved=1,Rejected=2exportfunctionreadLazyComponentType<T>(lazyComponent:LazyComponent<T>):T{conststatus=lazyComponent._status;constresult=lazyComponent._result;switch(status){caseResolved:{constComponent:T=result;returnComponent;}caseRejected:{consterror:mixed=result;throwerror;}casePending:{constthenable:Thenable<T,mixed>=result;throwthenable;}default:{//lazyComponent首次被渲染lazyComponent._status=Pending;constctor=lazyComponent._ctor;constthenable=ctor();thenable.then(moduleObject=>{if(lazyComponent._status===Pending){constdefaultExport=moduleObject.default;lazyComponent._status=Resolved;lazyComponent._result=defaultExport;}},error=>{if(lazyComponent._status===Pending){lazyComponent._status=Rejected;lazyComponent._result=error;}},);//Handlesynchronousthenables.switch(lazyComponent._status){caseResolved:returnlazyComponent._result;caseRejected:throwlazyComponent._result;}lazyComponent._result=thenable;throwthenable;}}}```注：如果readLazyComponentType函数多次处理同一个lazyComponent，则可能进入Pending、Rejected等case中。从上述代码中可以看出，对于最初React.lazy()所返回的LazyComponent对象，其\\_status默认是-1，所以首次渲染时，会进入readLazyComponentType函数中的default的逻辑，这里才会真正异步执行import(url)操作，由于并未等待，随后会检查模块是否Resolved，如果已经Resolved了（已经加载完毕）则直接返回moduleObject.default（动态加载的模块的默认导出），否则将通过throw将thenable抛出到上层。为什么要throw它？这就要涉及到Suspense的工作原理，我们接着往下分析。Suspense原理由于React捕获异常并处理的代码逻辑比较多，这里就不贴源码，感兴趣可以去看throwException中的逻辑，其中就包含了如何处理捕获的异常。简单描述一下处理过程，React捕获到异常之后，会判断异常是不是一个thenable，如果是则会找到SuspenseComponent，如果thenable处于pending状态，则会将其children都渲染成fallback的值，一旦thenable被resolve则SuspenseComponent的子组件会重新渲染一次。为了便于理解，我们也可以用componentDidCatch实现一个自己的Suspense组件，如下：```tsxclassSuspenseextendsReact.Component{state={promise:null,}componentDidCatch(err){//判断err是否是thenableif(err!==null&&typeoferr==='object'&&typeoferr.then==='function'){this.setState({promise:err},()=>{err.then(()=>{this.setState({promise:null,})})})}}render(){const{fallback,children}=this.propsconst{promise}=this.statereturn<>{promise?fallback:children}</>}}```","React\\状态管理\\dva\\api.md":"#dva_api##[#](https://dvajs.com/api/#输出文件)输出文件###[#](https://dvajs.com/api/#dva)dva默认输出文件。###[#](https://dvajs.com/api/#dva-router)dva/router默认输出[react-router](https://github.com/ReactTraining/react-router)接口，[react-router-redux](https://github.com/reactjs/react-router-redux)的接口通过属性routerRedux输出。比如：```jsimport{Router,Route,routerRedux}from'dva/router'```###[#](https://dvajs.com/api/#dva-fetch)dva/fetch异步请求库，输出[isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)的接口。不和dva强绑定，可以选择任意的请求库。###[#](https://dvajs.com/api/#dva-saga)dva/saga输出[redux-saga](https://github.com/yelouafi/redux-saga)的接口，主要用于用例的编写。（用例中需要用到effects）###[#](https://dvajs.com/api/#dva-dynamic)dva/dynamic解决组件动态加载问题的util方法。比如：```jsimportdynamicfrom'dva/dynamic'constUserPageComponent=dynamic({app,models:()=>[import('./models/users')],component:()=>import('./routes/UserPage'),})````opts`包含：-app:dva实例，加载models时需要-models:返回Promise数组的函数，Promise返回dvamodel-component：返回Promise的函数，Promise返回ReactComponent##[#](https://dvajs.com/api/#dva-api)dvaAPI###[#](https://dvajs.com/api/#app-dva-opts)`app=dva(opts)`创建应用，返回dva实例。(注：dva支持多实例)`opts`包含：-`history`：指定给路由用的history，默认是`hashHistory`-`initialState`：指定初始数据，优先级高于model中的state，默认是`{}`如果要配置history为`browserHistory`，可以这样：```jsimportcreateHistoryfrom'history/createBrowserHistory'constapp=dva({history:createHistory(),})```另外，出于易用性的考虑，`opts`里也可以配所有的[hooks](https://dvajs.com/api/#appusehooks)，下面包含全部的可配属性：```jsconstapp=dva({history,initialState,onError,onAction,onStateChange,onReducer,onEffect,onHmr,extraReducers,extraEnhancers,})```###[#](https://dvajs.com/api/#app-use-hooks)`app.use(hooks)`配置hooks或者注册插件。（插件最终返回的是hooks）比如注册[dva-loading](https://github.com/dvajs/dva-loading)插件的例子：```jsimportcreateLoadingfrom'dva-loading';...app.use(createLoading(opts));````hooks`包含：####[#](https://dvajs.com/api/#onerror-err-dispatch)`onError((err,dispatch)=>{})``effect`执行错误或`subscription`通过`done`主动抛错时触发，可用于管理全局出错状态。注意：`subscription`并没有加`try...catch`，所以有错误时需通过第二个参数`done`主动抛错。例子：```jsapp.model({subscriptions:{setup({dispatch},done){done(e)},},})```如果我们用antd，那么最简单的全局错误处理通常会这么做：```jsimport{message}from'antd'constapp=dva({onError(e){message.error(e.message,/*duration*/3)},})```####[#](https://dvajs.com/api/#onaction-fn-fn)`onAction(fn|fn[])`在action被dispatch时触发，用于注册redux中间件。支持函数或函数数组格式。例如我们要通过[redux-logger](https://github.com/evgenyrodionov/redux-logger)打印日志：```jsimportcreateLoggerfrom'redux-logger'constapp=dva({onAction:createLogger(opts),})```####[#](https://dvajs.com/api/#onstatechange-fn)`onStateChange(fn)``state`改变时触发，可用于同步`state`到localStorage，服务器端等。####[#](https://dvajs.com/api/#onreducer-fn)`onReducer(fn)`封装reducer执行。比如借助[redux-undo](https://github.com/omnidan/redux-undo)实现redo/undo：```jsimportundoablefrom'redux-undo';constapp=dva({onReducer:reducer=>{return(state,action)=>{constundoOpts={};constnewState=undoable(reducer,undoOpts)(state,action);//由于dva同步了routing数据，所以需要把这部分还原return{...newState,routing:newState.present.routing};},},});```####[#](https://dvajs.com/api/#oneffect-fn)`onEffect(fn)`封装effect执行。比如[dva-loading](https://github.com/dvajs/dva-loading)基于此实现了自动处理loading状态。####[#](https://dvajs.com/api/#onhmr-fn)`onHmr(fn)`热替换相关，目前用于[babel-plugin-dva-hmr](https://github.com/dvajs/babel-plugin-dva-hmr)。####[#](https://dvajs.com/api/#extrareducers)`extraReducers`指定额外的reducer，比如[redux-form](https://github.com/erikras/redux-form)需要指定额外的`form`reducer：```jsimport{reducerasformReducer}from'redux-form'constapp=dva({extraReducers:{form:formReducer,},})```####[#](https://dvajs.com/api/#extraenhancers)`extraEnhancers`指定额外的[StoreEnhancer](https://github.com/reactjs/redux/blob/master/docs/Glossary.md#store-enhancer)，比如结合[redux-persist](https://github.com/rt2zz/redux-persist)的使用：```jsimport{persistStore,autoRehydrate}from'redux-persist'constapp=dva({extraEnhancers:[autoRehydrate()],})persistStore(app._store)```###[#](https://dvajs.com/api/#app-model-model)`app.model(model)`注册model，详见[#Model](https://dvajs.com/api/#model)部分。###[#](https://dvajs.com/api/#app-unmodel-namespace)`app.unmodel(namespace)`取消model注册，清理reducers,effects和subscriptions。subscription如果没有返回unlisten函数，使用`app.unmodel`会给予警告⚠️。###[#](https://dvajs.com/api/#app-replacemodel-model)`app.replaceModel(model)`>只在app.start()之后可用替换model为新model，清理旧model的reducers,effects和subscriptions，但会保留旧的state状态，对于HMR非常有用。subscription如果没有返回unlisten函数，使用`app.unmodel`会给予警告⚠️。如果原来不存在相同namespace的model，那么执行`app.model`操作###[#](https://dvajs.com/api/#app-router-history-app-routerconfig)`app.router(({history,app})=>RouterConfig)`注册路由表。通常是这样的：```jsimport{Router,Route}from'dva/router'app.router(({history})=>{return(<Routerhistory={history}><Routepath='/'component={App}/></Router>)})```推荐把路由信息抽成一个单独的文件，这样结合[babel-plugin-dva-hmr](https://github.com/dvajs/babel-plugin-dva-hmr)可实现路由和组件的热加载，比如：```jsapp.router(require('./router'))```而有些场景可能不使用路由，比如多页应用，所以也可以传入返回JSX元素的函数。比如：```jsapp.router(()=><App/>)```###[#](https://dvajs.com/api/#app-start-selector)`app.start(selector?)`启动应用。`selector`可选，如果没有`selector`参数，会返回一个返回JSX元素的函数。```jsapp.start('#root')```那么什么时候不加`selector`？常见场景有测试、node端、react-native和i18n国际化支持。比如通过react-intl支持国际化的例子：```jsimport{IntlProvider}from'react-intl';...constApp=app.start();ReactDOM.render(<IntlProvider><App/></IntlProvider>,htmlElement);```##[#](https://dvajs.com/api/#model)Modelmodel是dva中最重要的概念。以下是典型的例子：```jsapp.model({namespace:'todo',state:[],reducers:{add(state,{payload:todo}){//保存数据到statereturn[...state,todo]},},effects:{*save({payload:todo},{put,call}){//调用saveTodoToServer，成功后触发`add`action保存到stateyieldcall(saveTodoToServer,todo)yieldput({type:'add',payload:todo})},},subscriptions:{setup({history,dispatch}){//监听history变化，当进入`/`时触发`load`actionreturnhistory.listen(({pathname})=>{if(pathname==='/'){dispatch({type:'load'})}})},},})```model包含5个属性：###[#](https://dvajs.com/api/#namespace)namespacemodel的命名空间，同时也是他在全局state上的属性，只能用字符串，不支持通过`.`的方式创建多层命名空间。###[#](https://dvajs.com/api/#state)state初始值，优先级低于传给`dva()`的`opts.initialState`。比如：```jsconstapp=dva({initialState:{count:1},})app.model({namespace:'count',state:0,})```此时，在`app.start()`后state.count为1。###[#](https://dvajs.com/api/#reducers)reducers以key/value格式定义reducer。用于处理同步操作，唯一可以修改`state`的地方。由`action`触发。格式为`(state,action)=>newState`或`[(state,action)=>newState,enhancer]`。详见：<https://github.com/dvajs/dva/blob/master/packages/dva-core/test/reducers.test.js>###[#](https://dvajs.com/api/#effects)effects以key/value格式定义effect。用于处理异步操作和业务逻辑，不直接修改`state`。由`action`触发，可以触发`action`，可以和服务器交互，可以获取全局`state`的数据等等。格式为`*(action,effects)=>void`或`[*(action,effects)=>void,{type}]`。type类型有：-`takeEvery`-`takeLatest`-`throttle`-`watcher`详见：<https://github.com/dvajs/dva/blob/master/packages/dva-core/test/effects.test.js>###[#](https://dvajs.com/api/#subscriptions)subscriptions以key/value格式定义subscription。subscription是订阅，用于订阅一个数据源，然后根据需要dispatch相应的action。在`app.start()`时被执行，数据源可以是当前的时间、服务器的websocket连接、keyboard输入、geolocation变化、history路由变化等等。格式为`({dispatch,history},done)=>unlistenFunction`。注意：如果要使用`app.unmodel()`，subscription必须返回unlisten方法，用于取消数据订阅。","React\\状态管理\\dva\\dva-basic.md":"#dva-basic>基于redux和redux-saga的数据流方案,简化开发,dav还额外内置react-router和fetch##dynamic(opts)>opts>>-app:dva实例,加载models时需要>-models:返回Promise数组的函数,Promise返回dvamodel>-component:返回Promise的函数,Promise返回ReactComponent```react//路由文件import{Router,Route}from'dva/router';importIndexPagefrom'./routes/IndexPage'importTodoListfrom'./routes/TodoList'functionRouterConfig({history}){return(<Routerhistory={history}><Routepath=\"/\"component={IndexPage}/><Routepath='/todoList'components={TodoList}/></Router>)}exportdefaultRouterConfig```改成```reactimport{Router,Switch,Route}from'dva/router'importdynamicfrom'dva/dynamic'functionRouterConfig({history,app}){constIndexPage=dynamic({app,component:()=>import('./routes/IndexPage'),})constUsers=dynamic({app,models:()=>[import('./models/users')],component:()=>import('./routes/Users'),})return(<Routerhistory={history}><Switch><Routeexactpath=\"/\"component={IndexPage}/><Routeexactpath=\"/users\"component={Users}/></Switch></Router>)}exportdefaultRouterConfig```##mock>模拟数据,模拟接口api的请求方式###在dva中的使用1在mock文件夹下创建```js//product.jsmodule.exports={'GET/api/product':{name:'高粱'},}//user.jsmodule.exports={'POST/api/login':(req,res)=>{res.send({msg:'登录成功',})},}```设置.roadhogrc.mock.js```js//1:一个一个引入exportdefault{...require(\"./mock/product\"),...require(\"./mock/product\"),....}//2.通过fs和path来引入mock文件夹下全部文件引入constmock={}fs.readdirSync(path.join(__dirname+'/mock')).forEach(function(file){if(file.match(/\\.js$/)){Object.assign(mock,require('./mock/'+file))}})exportdefaultmock```在service中定义请求方式```jsximportrequestfrom'../utils/request'exportfunctiongetProduct(){returnrequest('/api/product')}```在组件中使用```jsximport*asapifrom'../services/example';comonentDidMout(){api.getProduct().then(res=>console.log(res))}```###在dva中的使用21.在根目录的mock目录下新建一个文件’mockData.js’,写入下面代码```javascriptmodule.exports={'GET/api/mockData':(request,response)=>{console.log(request)response.send({msg:'登陆成功',})},}```2.在根目录下的`.roadhogrc.mock.js`文件中进行注册```javascriptexportdefault{...require('./mock/testMock'),}```3.在根目录下的src下的service目录下写一个请求方法```javascript//注册mock接口exportfunctionmockData(){returnrequest('/api/mockData')}1234```4.在页面中引入请求方法之后就能进行调用```javascriptimport*asapisfrom'../service/example'apis.mockData().then((res)=>{console.log(res)})12345```###在umi中的使用和dva中基本相同,只是不需要第二步###使用自己封装的请求方法进行调用(即不使用service)不需要第3步,将第四步代码替换为```javascriptfetch('/api/mockData').then((res)=>res.json()).then((data)=>console.log(data)).catch((err)=>({err}))1234```###续篇(response和request参数的说明)```javascriptRequestreq.baseUrl基础路由地址req.bodypost发送的数据解析出来的对象req.cookies客户端发送的cookies数据req.hostname主机地址去掉端口号req.ip查看客户端的ip地址req.ips代理的IP地址req.originalUrl对req.url的一个备份req.params在使用/:id/:name匹配paramsreq.path包含请求URL的路径部分req.protocolhttp或https协议req.query查询字符串解析出来的对象username=zhangsan&password=123{username:zhangsan}req.route当前匹配的路由正则表达式req.params获取路由匹配的参数req.get获取请求header里的参数req.is判断请求的是什么类型的文件req.param(key名称)用来获取某一个路由匹配的参数Responseres.headersSent查看http响应是否响应了http头res.append(名称,value)追加http响应头res.attachment(文件路径)响应文件请求res.cookie()设置cookieres.setHeader('Content-Type','text/html;charset=utf8')res.append('Content-Type','text/html;charset=utf8')res.append('hehe','1008')res.append('haha','1008')res.attachment('./xx.zip')//Content-Disposition:attachment;filename=\"xx.zip\"res.clearCookie(cookiename)删除cookieres.cookie('zhangsan','lisi')设置cookieres.cookie('zhangsan1','lisi2',{maxAge:900000,httpOnly:true,path:'/admin',secure:true,signed:true})res.clearCookie('zhangsan')res.download(文件的path路径)跟attachment类似用来处理文件下载的参数是文件地址res.endhttp模块自带的res.format()协商请求文件类型format匹配协商的文件类型res.format({'text/plain':function(){res.send('hey');},'text/html':function(){res.send('<p>hey</p>');},'application/json':function(){res.send({message:'hey'});},'default':function(){//logtherequestandrespondwith406res.status(406).send('NotAcceptable');}});res.get('key')获取响应header数据res.json()返回json数据会自动设置响应headerContent-type为json格式application/jsonres.json({xx:100})res.json({xx:100})jsonp利用的就是浏览器加载其他服务器的文件不会存在跨域问题ajax请求就会有跨域问题res.setHeader('Content-Type','text/javascript;charsert=utf8')res.end(`typeof${req.query.callback}=='function'?${req.query.callback}({aa:100}):null`)res.jsonp({aaa:100})重定向把访问的地址跳转到另一个地址上res.redirect(301,'/api/aes')expressjaderes.render('index',{title:\"hehe\",test:\"23\"})res.send('')发送数据可以是任意类型的数据res.sendFile()发送文件的res.sendStatus(200)设置发送时的状态码res.set('Content-Type','text/plain')//设置响应headerres.status(200)//设置状态码res.type('')//直接设置响应的文件类型res.type('pdf')res.send({aa:100})res.end('ok')res.end({aa:100})res.end('你好')res.end(req.get('Accept-Language'))res.json({is:req.is('text/html')})res.json({type:req.baseUrl,hostname:req.hostname,//ip:req.ip,//ips:req.ips,//route:req.route,ct:req.get('Accept'),cs:'22'})```##model对象>5个重要的属性:namespace,state,reducers,effects,subscriptions####namespace>-namespace:model的命名空间，同时也是他在全局state上的属性，只能用字符串，不支持通过`.`的方式创建多层命名空间####state>-state:reducer的初始值,优先级低于传输给dva()的``opts.initialState`>>-```tsx>constapp=dva({>//初始化state>initialState:{count:1},>})>app.model({>namespace:'count',>//初始化state>state:0,>})>>//在app.start()后state.count为1>```####reducers>-reducers:以key/value格式定义reducer,用于处理同步操作,**唯一可以修改state的地方**>-reducres中的return可以覆盖state原有的数据>-不能实现异步操作>>-格式:`(state,action)=>newState`或`[(state,action)=>newState,enhancer]`>-```jsx>namespace:'todo',>state:{>list:[]>},>//reducers写法>reducers:{>save(state,{payload:{list}}){>return{...state,list}>}>}>```####effects>-以`key/value`格式定义effect,用于处理异步操作的业务逻辑,>-可以实现异步操作,>-**不直接修改state**,可以通过put来触发reducers来修改modul中的state>-由action触发,可以触发action,可以和服务器交互,可以获取全局state的数据等>-格式:`*(action,effects)=>void`或`[*(action,effects)=>void,{type}]`>-type类型:>-takeEvery>-takeLatest>-throttle>-watcher>-effects>-put:用于触发action,常常用于通过触发reducer的方法来修改state>-`yieldput({type:'todos/add',payload:'LearnDva'})`>-call:用于调用异步逻辑,支持Promise>-`constresult=yieldcall(fetch,'/todos')`>-第一个参数:调用的函数>-第二个参数:你要传输的参数>-select:用于从state里获取数据>-`consttodos=yieldselect(state=>state.todos)`>-错误处理>>-全局错误处理>>-effects和subscriptions的抛错全部会走onErrorhook，所以可以在onError里统一处理错误>>```jsx>constapp=dva({>onError(e,dispatch){>console.log(e.message)>},>})>```>>-本地错误处理>>-对某些effects的错误进行特殊处理，需要在effect内部加trycatch。>>```jsx>app.model({>effects:{>*addRemote(){>try{>//YourCodeHere>}catch(e){>console.log(e.message)>}>},>},>})>//try{}catch{}finally{}>``````jsx//effects写法effects:{*addTodo({payload:value},{call,put,select}){//模拟网络请求constdata=yieldcall(todoService.query,value)console.log(data)lettempList=yieldselect(state=>state.todo.list)letlist=[]list=list.concat(tempList)consttempObj={}tempObj.title=valuetempObj.id=list.lengthtempObj.finished=falselist.push(tempObj)yieldput({type:'save',payload:{list}})},*toggle({payload:index},{call,put,select}){//模拟网络请求constdata=yieldcall(todoService.query,index)lettempList=yieldselect(state=>state.todo.list)letlist=[]list=list.concat(tempList)letobj=list[index]obj.finished=!obj.finishedyieldput({type:'save',payload:{list}})},*delete({payload:index},{call,put,select}){constdata=yieldcall(todoService.query,index)lettempList=yieldselect(state=>state.todo.list)letlist=[]list=list.concat(tempList)list.splice(index,1)yieldput({type:'save',payload:{list}})},*modify({payload:{value,index}},{call,put,select}){constdata=yieldcall(todoService.query,value)lettempList=yieldselect(state=>state.todo.list)letlist=[]list=list.concat(tempList)letobj=list[index]obj.title=valueyieldput({type:'save',payload:{list}})}}//组件中调用this.props.dispatch({type:'[namespaceName]/[effectsfuntionName]',payload:'[要传输的数据]'})```####subscriptions>-主要在model中实现事件监听,可以监听路由变化,鼠标,键盘,服务器,状态变化等>-以key/vallue格式定义subscriptions,subscriptions是订阅,用于订阅一个数据源,然后需要dispatch相应的action>-在app.start()被执行时,数据源可以是当前时候,服务器的websocket连接,keyboard输入,geolocation变化,history路由变化等>-格式`({dispatch,history},done)=>unlistenFunction`>-取消数据订阅:使用app.unmode(),subscription必须返回unlisten方法```jsx//subscriptions写法subscriptions:{setup({dispatch,history}){//监听路由的变化，请求页面数据returnhistory.listen(({pathname,search})=>{constquery=queryString.parse(search)letlist=[]if(pathname==='todoList'){dispatch({type:'save',payload:{list}})}})}}```路由监听```jsxsubscriptions:{setup({dispatch,history}){history.listen((pathname)=>{console.log(pathname)})}},```点击事件```jssubscriptions:{onClick({dispatch}){document.addEventListener('click',()=>{//这里表示当鼠标点击时就会触发里面的dispatch命令，这里的save就是reducers中的方法名dispatch(type:\"save\")})}),},```####connect>将路由的state传输给当前组件```jsimport{connect}from'dva';classIndexPageextendsReact.Component{render(){console.log(this.props)//可以拿到state.product里面的数据return(...)}}constmapStateProps=(state)=>{return{productList:state.product}}//将state.product的数据传输给IndexPage组件exportdefaultconnect(mapStateProps)(IndexPage);```##router###withRouter>这样子就不用父组件传输过来history对象,`this.props.history`也不会为空了```jsimport{withRouter}from\"dva/router\";classProductextendsReact.Component{...this.props.history.push(\"/\");//实现跳转到主页'/'...}exportdefaultwithRouter(Product);```###routerRedux```jsimport{routerRedux}from'dva/router';classProductextendsReact.Component{...this.props.history.dispatch(routerRedux.push(\"/\"));//实现跳转到主页'/'...}exportdefaultProduct;```##使用dva框架和直接使用redux写法的区别####用redux#####_actions.js文件_```tsxexportconstREQUEST_TODO='REQUEST_TODO'exportconstRESPONSE_TODO='RESPONSE_TODO'constrequest=(count)=>({type:REQUEST_TODO,payload:{loading:true,count},})constresponse=(count)=>({type:RESPONSE_TODO,payload:{loading:false,count},})exportconstfetch=(count)=>{return(dispatch)=>{dispatch(request(count))returnnewPromise((resolve)=>{setTimeout(()=>{resolve(count+1)},1000)}).then((data)=>{dispatch(response(data))})}}```#####_reducer.js文件_```dartimport{REQUEST_TODO,RESPONSE_TODO}from'./actions';exportdefault(state={loading:false,count:0},action)=>{switch(action.type){caseREQUEST_TODO:return{...state,...action.payload};caseRESPONSE_TODO:return{...state,...action.payload};default:returnstate;}}```#####_app.js文件_```jsximportReactfrom'react'import{bindActionCreators}from'redux'import{connect}from'react-redux'import*asactionsfrom'./actions'constApp=({fetch,count,loading})=>{return(<div>{loading?<div>loading...</div>:<div>{count}</div>}<buttononClick={()=>fetch(count)}>add</button></div>)}functionmapStateToProps(state){returnstate}functionmapDispatchToProps(dispatch){returnbindActionCreators(actions,dispatch)}exportdefaultconnect(mapStateToProps,mapDispatchToProps)(App)```#####_index.js文件_```jsximport{render}from'react-dom'import{createStore,applyMiddleware}from'redux'import{Provider}from'react-redux'importthunkMiddlewarefrom'redux-thunk'importreducerfrom'./app/reducer'importAppfrom'./app/app'conststore=createStore(reducer,applyMiddleware(thunkMiddleware))render(<Providerstore={store}><App/></Provider>,document.getElementById('app'),)```####使用dva#####_model.js文件_```tsxexportdefault{namespace:'demo',state:{loading:false,count:0,},reducers:{request(state,payload){return{...state,...payload}},response(state,payload){return{...state,...payload}},},effects:{*fetch(action,{put,call}){yieldput({type:'request',loading:true})letcount=yieldcall((count)=>{returnnewPromise((resolve)=>{setTimeout(()=>{resolve(count+1)},1000)})},action.count)yieldput({type:'response',loading:false,count,})},},}```#####_app.js文件_```jsximportReactfrom'react'import{connect}from'dva'constApp=({fetch,count,loading})=>{return(<div>{loading?<div>loading...</div>:<div>{count}</div>}<buttononClick={()=>fetch(count)}>add</button></div>)}functionmapStateToProps(state){returnstate.demo}functionmapDispatchToProps(dispatch){return{fetch(count){dispatch({type:'demo/fetch',count})},}}exportdefaultconnect(mapStateToProps,mapDispatchToProps)(App)```#####_index.js文件_```jsximportdvafrom'dva'importmodelfrom'./model'importAppfrom'./app'constapp=dva()app.use({})app.model(model)app.router(()=><App/>)app.start()```我们通过上面两种不同方式来实现一个异步的计数器的代码结构发现：1.**使用redux需要拆分出`action`模块和`reducer`模块**2.**dva将`action`和`reducer`封装到`model`中，异步流程采用Generator处理**","React\\状态管理\\dva\\dva-expand\\dva-tsx.md":"#dva-typescript>[相关资料](https://github.com/typescript-cheatsheets/react)>>[相关资料](https://github.com/zhongsp/TypeScript)##环境搭建全局安装```shellnpmitypescript-g```项目内部安装```shellnpmilinktypescriptnpmi--save-devts-loadersource-map-loadernpmi--save-dev@types/react@types/react-dom```根目录下添加tsconfig.json文件```json{\"compilerOptions\":{\"strictNullChecks\":true,\"moduleResolution\":\"node\",\"allowSyntheticDefaultImports\":true,\"experimentalDecorators\":true,\"jsx\":\"preserve\",\"noUnusedParameters\":true,\"noUnusedLocals\":true,\"target\":\"es6\",\"lib\":[\"dom\",\"es7\"]},\"exclude\":[\"node_modules\",\"lib\",\"es\"]}```demo```tsximport*asReactfrom'react'import{render}from'react-dom'interfaceIAppProps{}interfaceIAppState{}classAppextendsReact.Component<IAppProps,IAppState>{publicrender():JSX.Element{return<div>这是typescript了哦~</div>}}exportdefaultApp```>然后直接在路由页面吧该组件展示出去","React\\状态管理\\dva\\dva-expand\\优化.md":"#dva优化##引入dva后一直存在一个warning：Pleaseuse`require(\"history\").createHashHistory`insteadof>修改node_modules/dva/lib/index.js```js//var_createHashHistory=_interopRequireDefault(require(\"history/createHashHistory\"));//把这个改成下面的var_createHashHistory=_interopRequireDefault(require('history').createHashHistory,)```##简写多个models的引入```react//app.model(require('./models/example').default);//app.model(require('./models/a').default);//app.model(require('./models/b').default);//app.model(require('./models/c').default);//app.model(require('./models/d').default);//app.model(require('./models/e').default);//app.model(require('./models/f').default);```在models文件夹下建立一个,index.js```jsconstcontext=require.context('./',false,/\\.js$/).keys().filter((item)=>item!=='./index.js')constnewContext=context.map((it)=>it.slice(2))exportdefaultnewContext```然后在index.js下改成```react//3.Model//app.model(require('./models/example').default);//app.model(require('./models/products').default);//添加这个和models/index,可以实现添加多个model的简写require('./models').default.forEach(key=>app.model(require(`./models/${key}`).default))```","React\\状态管理\\dva\\extend.md":"#dva-extend##dva+antd>`npminstallantdbabel-plugin-import--save``.webpackrc`添加配置```json{+\"extraBabelPlugins\":[+[\"import\",{\"libraryName\":\"antd\",\"libraryDirectory\":\"es\",\"style\":\"css\"}]+]}```##使用less`.webpackrc`添加配置```jsdisableCSSModules:true,//1.{disableCSSModules:true,}//2.{+\"extraBabelPlugins\":[+[\"import\",{\"libraryName\":\"antd\",\"libraryDirectory\":\"es\",\"style\":\"css\",\"disableCSSModules\":true,}]+]}```","React\\状态管理\\dva\\快速上手.md":"#dva快速上手##[#](https://dvajs.com/guide/getting-started.html#安装-dva-cli)安装dva-cli通过npm安装dva-cli并确保版本是`0.9.1`或以上。```bash$npminstalldva-cli-g$dva-vdva-cliversion0.9.1```##[#](https://dvajs.com/guide/getting-started.html#创建新应用)创建新应用安装完dva-cli之后，就可以在命令行里访问到`dva`命令（[不能访问？](http://stackoverflow.com/questions/15054388/global-node-modules-not-installing-correctly-command-not-found)）。现在，你可以通过`dvanew`创建新应用。```bashdvanewdva-quickstart```这会创建`dva-quickstart`目录，包含项目初始化目录和文件，并提供开发服务器、构建脚本、数据mock服务、代理服务器等功能。然后我们`cd`进入`dva-quickstart`目录，并启动开发服务器：```bashcddva-quickstartnpmstart```几秒钟后，你会看到以下输出：```bashCompiledsuccessfully!Theappisrunningat:http://localhost:8000/Notethatthedevelopmentbuildisnotoptimized.Tocreateaproductionbuild,usenpmrunbuild.```在浏览器里打开<http://localhost:8000>，你会看到dva的欢迎界面。##[#](https://dvajs.com/guide/getting-started.html#使用-antd)使用antd通过npm安装`antd`和`babel-plugin-import`。`babel-plugin-import`是用来按需加载antd的脚本和样式的，详见[repo](https://github.com/ant-design/babel-plugin-import)。```bashnpminstallantdbabel-plugin-import--save```编辑`.webpackrc`，使`babel-plugin-import`插件生效。```diff{+\"extraBabelPlugins\":[+[\"import\",{\"libraryName\":\"antd\",\"libraryDirectory\":\"es\",\"style\":\"css\"}]+]}```>注：dva-cli基于roadhog实现build和dev，更多`.webpackrc`的配置详见[roadhog#配置](https://github.com/sorrycc/roadhog#配置)##[#](https://dvajs.com/guide/getting-started.html#定义路由)定义路由我们要写个应用来先显示产品列表。首先第一步是创建路由，路由可以想象成是组成应用的不同页面。新建routecomponent`routes/Products.js`，内容如下：```javascriptimportReactfrom'react'constProducts=(props)=><h2>ListofProducts</h2>exportdefaultProducts```添加路由信息到路由表，编辑`router.js`:```diff+importProductsfrom'./routes/Products';...+<Routepath=\"/products\"exactcomponent={Products}/>```然后在浏览器里打开<http://localhost:8000/#/products>，你应该能看到前面定义的`<h2>`标签。##[#](https://dvajs.com/guide/getting-started.html#编写-ui-component)编写UIComponent随着应用的发展，你会需要在多个页面分享UI元素(或在一个页面使用多次)，在dva里你可以把这部分抽成component。我们来编写一个`ProductList`component，这样就能在不同的地方显示产品列表了。新建`components/ProductList.js`文件：```javascriptimportReactfrom'react'importPropTypesfrom'prop-types'import{Table,Popconfirm,Button}from'antd'constProductList=({onDelete,products})=>{constcolumns=[{title:'Name',dataIndex:'name',},{title:'Actions',render:(text,record)=>{return(<Popconfirmtitle='Delete?'onConfirm={()=>onDelete(record.id)}><Button>Delete</Button></Popconfirm>)},},]return<TabledataSource={products}columns={columns}/>}ProductList.propTypes={onDelete:PropTypes.func.isRequired,products:PropTypes.array.isRequired,}exportdefaultProductList```##[#](https://dvajs.com/guide/getting-started.html#定义-model)定义Model完成UI后，现在开始处理数据和逻辑。dva通过model的概念把一个领域的模型管理起来，包含同步更新state的reducers，处理异步逻辑的effects，订阅数据源的subscriptions。新建model`models/products.js`：```javascriptexportdefault{namespace:'products',state:[],reducers:{delete(state,{payload:id}){returnstate.filter((item)=>item.id!==id)},},}```这个model里：-`namespace`表示在全局state上的key-`state`是初始值，在这里是空数组-`reducers`等同于redux里的reducer，接收action，同步更新state然后别忘记在`index.js`里载入他：```diff//3.Model+app.model(require('./models/products').default);```##[#](https://dvajs.com/guide/getting-started.html#connect-起来)connect起来到这里，我们已经单独完成了model和component，那么他们如何串联起来呢?dva提供了connect方法。如果你熟悉redux，这个connect就是react-redux的connect。编辑`routes/Products.js`，替换为以下内容：```javascriptimportReactfrom'react'import{connect}from'dva'importProductListfrom'../components/ProductList'constProducts=({dispatch,products})=>{functionhandleDelete(id){dispatch({type:'products/delete',payload:id,})}return(<div><h2>ListofProducts</h2><ProductListonDelete={handleDelete}products={products}/></div>)}//exportdefaultProducts;exportdefaultconnect(({products})=>({products,}))(Products)```最后，我们还需要一些初始数据让这个应用run起来。编辑`index.js`：```diff-constapp=dva();+constapp=dva({+initialState:{+products:[+{name:'dva',id:1},+{name:'antd',id:2},+],+},+});```刷新浏览器，应该能看到以下效果：<imgsrc=\"https://zos.alipayobjects.com/rmsportal/GQJeDDeUCSTRMMg.gif\"alt=\"img\"style=\"zoom:80%;\"/>##[#](https://dvajs.com/guide/getting-started.html#构建应用)构建应用完成开发并且在开发环境验证之后，就需要部署给我们的用户了。先执行下面的命令：```bashnpmrunbuild```几秒后，输出应该如下：```bash>@build/private/tmp/myapp>roadhogbuildCreatinganoptimizedproductionbuild...Compiledsuccessfully.Filesizesaftergzip:82.98KBdist/index.js270Bdist/index.css````build`命令会打包所有的资源，包含JavaScript,CSS,webfonts,images,html等。然后你可以在`dist/`目录下找到这些文件。","React\\状态管理\\mobx.md":"#Mobx##this找不到问题```tsx添加constructor(){makeObservable(this);}```##继承使用###父类```tsxclassfather{constructor(){makeObservable(this)}@action.boundfn(){}}```###子类```tsxclasssonextendsfather{constructor(){super()makeObservable(this)}@overridefn(){//这里就可以重写方法}}```","React\\状态管理\\redux\\index.md":"#Redux>[ReactRedux](https://react-redux.js.org/tutorials/quick-start)>>[Reactredux-saga使用详解](https://blog.csdn.net/ZYC88888/article/details/82730879)","React\\状态管理\\redux\\React_Redux_React-redux.md":"#React,Redux,React-Redux>React:负责组件的UI界面渲染>>Redux:数据处理中心>>React-Redux:连接组件和数据中心,就是和react和redux联系起来##react生命周期1.`getDefaultProps()`设置默认的props，es6中用`staticdefaultProps={}`设置组件的默认属性。在整个生命周期只执行一次。2.`getInitialState()`在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。3.`componentWillMount()`ajax数据的拉取操作，定时器的启动。组件初始化时调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。4.`render()`React最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。5.`componentDidMount()`动画的启动，输入框自动聚焦组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。二、在更新时也会触发5个钩子函数：2.`componentWillReceiveProps(nextProps)`组件初始化时不调用，组件接受新的props时调用。不管父组件传递给子组件的props有没有改变，都会触发。3.`shouldComponentUpdate(nextProps,nextState)`React性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。4.`componentWillUpdate(nextProps,nextState)`组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state5.`render()`不多说6.`componentDidUpdate()`组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。三、卸载钩子函数7.`componentWillUnmount()`定时器的清除组件将要卸载时调用，一些事件监听和定时器需要在此时清除。<imgsrc=\"https://images.gitee.com/uploads/images/2020/1118/114419_53fa0c37_7984151.png\"style=\"zoom:67%;\"/>##Redux>1.唯一数据源>2.状态只读>3.数据改变指定通过纯函数(reducer)完成###核心api>store,reducer,action####store![](https://images.gitee.com/uploads/images/2020/1118/114823_9f073716_7984151.png)>getState():存储的数据,状态树>>dispatch(action):分发action,并返回action,这是唯一能改变store中数据的方式>>subscribe(listener):注册一个监听者,store发生变化时候被调用####reducer<imgsrc=\"https://images.gitee.com/uploads/images/2020/1118/115210_465f7e83_7984151.png\"style=\"zoom:67%;\"/>","React\\状态管理\\redux\\redux-toolkit.md":"#ReduxToolkit>简化`redux`的使用##Api>-`configureStore()`>提供简化的配置选项和良好的默认值。它可以自动组合众多的reducers，添加用户提供的任何Redux中间件，默认情况下包括Redux-thunk(处理异步Action的中间件)，并支持使用ReduxDevTools扩展。>-`createReducer()`>创建reducer的action映射表而不必编写switch语句。自动使用immer库让你用正常的代码编写更简单的不可变更新，比如state.todos[3].completed=true。>-`createAction()`>为给定的操作类型字符串生成actioncreator函数>-`createSlice()`>根据传递的参数自动生成相应的actionCreator和reducer函数>-`createAsyncThunk()`>接受action字符串和返回Promise的函数，并生成分派的thunk函数>-`createEntityAdapter`>生成可重用的reducers和selectors来管理store中的数据,执行CRUD操作>-`createSelector()`>来自reselect库，被重新导出，用于state缓存，防止不必要的计算##安装使用>`npxcreate-react-appmy-app--templateredux`###配置组件和redux的热重载```jsimport{configureStore}from'@reduxjs/toolkit'importrootReducerfrom'./rootReducer'conststore=configureStore({reducer:rootReducer})if(process.env.NODE_ENV==='development'&&module.hot){module.hot.accept('./rootReducer',()=>{constnewRootReducer=require('./rootReducer').defaultstore.replaceReducer(newRootReducer)})}exporttypeAppDispatch=typeofstore.dispatchexportdefaultstore```###组件树热重载```jsimportReactfrom'react'importReactDOMfrom'react-dom'import{Provider}from'react-redux'importstorefrom'./app/store'import'./index.css'//这里把树根节点的渲染逻辑提取到render函数中以在webpack检测到文件改变之后进行热更新constrender=()=>{constApp=require('./app/App').defaultReactDOM.render(<Providerstore={store}><App/></Provider>,document.getElementById('root'),)}render()if(process.env.NODE_ENV==='development'&&module.hot){module.hot.accept('./app/App',render)}```###使用`useSelector()`和`useDispatch()`Hook来替代`connect()`>-传统的react应用在与redux进行连接时候是通过react-redux库的connect函数来传入mapState和mapDispatch函数来将redux中的state和action存储到组件的props中。>-react-redux新版已经支持useSelector,useDispatchHook，我们可以使用它们替代connect的写法。通过它们我们可以在纯函数组件中获取到store中的值并做到监测变化```jsimportReact,{useState}from'react'import{useSelector,useDispatch}from'react-redux'import{decrement,increment,incrementByAmount,incrementAsync,selectCount,}from'./counterSlice'importstylesfrom'./Counter.module.css'exportdefaultfunctionCounter(){constcount=useSelector(selectCount)constdispatch=useDispatch()const[incrementAmount,setIncrementAmount]=useState('2')return(<div><divclassName={styles.row}><buttonclassName={styles.button}aria-label='Incrementvalue'onClick={()=>dispatch(increment())}>+</button><spanclassName={styles.value}>{count}</span><buttonclassName={styles.button}aria-label='Decrementvalue'onClick={()=>dispatch(decrement())}>-</button></div><divclassName={styles.row}><inputclassName={styles.textbox}aria-label='Setincrementamount'value={incrementAmount}onChange={(e)=>setIncrementAmount(e.target.value)}/><buttonclassName={styles.button}onClick={()=>dispatch(incrementByAmount(Number(incrementAmount)||0))}>AddAmount</button><buttonclassName={styles.asyncButton}onClick={()=>dispatch(incrementAsync(Number(incrementAmount)||0))}>AddAsync</button></div></div>)}```###使用useEffectHook来执行异步逻辑```jsexportconstIssuesListPage=({org,repo,page=1,setJumpToPage,showIssueComments}:ILProps)=>{const[issuesResult,setIssues]=useState<IssuesResult>({pageLinks:null,pageCount:1,issues:[]})const[numIssues,setNumIssues]=useState<number>(-1)const[isLoading,setIsLoading]=useState<boolean>(false)const[issuesError,setIssuesError]=useState<Error|null>(null)const{issues,pageCount}=issuesResultuseEffect(()=>{asyncfunctionfetchEverything(){asyncfunctionfetchIssues(){constissuesResult=awaitgetIssues(org,repo,page)setIssues(issuesResult)}asyncfunctionfetchIssueCount(){constrepoDetails=awaitgetRepoDetails(org,repo)setNumIssues(repoDetails.open_issues_count)}try{awaitPromise.all([fetchIssues(),fetchIssueCount()])setIssuesError(null)}catch(err){console.error(err)setIssuesError(err)}finally{setIsLoading(false)}}setIsLoading(true)fetchEverything()},[org,repo,page])//omitrendering}```###createAsyncThunk的使用>参数>rtk提供的生成thunkactioncreator的工具函数>参数:>>1.type:actionType字符串(如users/requestStatus)，rtk会会基于此生成以下三个actioncreator>>`fulfilled:'users/requestStatus/fulfilled'`>>`rejected:'users/requestStatus/rejected'`>>`pending:'users/requestStatus/pending`>>-payloadCreator>一个回调函数，它应该返回一个包含一些异步逻辑结果的promise>payloadCreator的参数有两个:>>-arg>dispatchthunkactioncreator时候参入的参数值，如ids等需要参与AJAX的值>-thunkAPI对象>一个对象，包含通常传递给Reduxthunk函数的所有参数，以及其他选项>-dispatchstore的dispatch函数>-getStatestore的getState函数>-extra调用configureStore配置store时候传递给thunkmiddleware的额外参数>-requestId当次请求的唯一表示串>-signal取消标志，如果应用有其他地方标记这个请求应该取消则为true>-rejectWithValue工具函数,用于返回一个可以自定义payload被reject的Promise>>-options对象>>-condition:一个回调，如果需要，可用于跳过payloadcreator函数逻辑执行>-dispatchConditionRejection：如果condition()返回false，则默认行为是根本不分派任何动作。如果您仍然希望在thunk被取消时发送一个“rejected”操作，将此标志设置为true。###createAsyncThunk函数的返回值返回一个标准的Reduxthunkactioncreator。thunk动作创建器函数将为pending,fulfilled,rejected情况提供普通actioncreator，并将其作为嵌套字段附加。如上面的fetchUserById例子:通过调用createAsyncThunk会生成四对action,actioncreatorfetchUserById.pending，一个actioncreator，它分派一个’users/fetchByIdStatus/pending’操作fetchUserById.fulfilled一个分派’users/fetchByIdStatus/fulfilled’动作的actioncreatorfetchUserById.rejected:一个分派’users/fetchByIdStatus/rejected’动作的actioncreator要在reducer中处理这些action，请使用对象键表示法或“构建器回调”表示法引用createReducer或createSlice中的actioncreator。```jsconstreducer1=createReducer(initialState,{[fetchUserById.fulfilled]:(state,action)=>{},})constreducer2=createReducer(initialState,(builder)=>{builder.addCase(fetchUserById.fulfilled,(state,action)=>{})})constreducer3=createSlice({name:'users',initialState,reducers:{},extraReducers:{[fetchUserById.fulfilled]:(state,action)=>{},},})constreducer4=createSlice({name:'users',initialState,reducers:{},extraReducers:(builder)=>{builder.addCase(fetchUserById.fulfilled,(state,action)=>{})},})```###处理thunk的返回结果调用thunks时可能返回一个值。一个常见的用例是:从thunk返回一个promise，从组件中分派thunk，然后等待promise被解析，然后再做额外的工作:```jsconstonClick=()=>{dispatch(fetchUserById(userId)).then(()=>{//doadditionalwork})}```由createAsyncThunk生成的thunks将总是返回一个已解析的承诺，其中包含已实现的操作对象或被拒绝的操作对象，视情况而定。调用逻辑可能希望将这些操作视为最初的promise内容。reduxtoolkit导出一个unwrapResult函数，该函数可用于从操作中提取负载或错误，并适当地返回或抛出结果```jsimport{unwrapResult}from'@reduxjs/toolkit'//inthecomponentconstonClick=()=>{dispatch(fetchUserById(userId)).then(unwrapResult).then((originalPromiseResult)=>{}).catch((serializedError)=>{})}```如果您需要定制被reject操作的内容，您应该自己捕获任何错误，然后使用thunkAPI返回的rejectWithValue。执行returnrejectWithValue(errorPayload)将导致被reject的操作将该值作为action.payload使用```jsconstupdateUser=createAsyncThunk('users/update',async(userData,{rejectWithValue})=>{const{id,...fields}=userDatatry{constresponse=awaituserAPI.updateById(id,fields)returnresponse.data.user}catch(err){//Use`err.response.data`as`action.payload`fora`rejected`action,//byexplicitlyreturningitusingthe`rejectWithValue()`utilityreturnrejectWithValue(err.response.data)}},)```###请求的取消####请求前取消如果您需要在调用负载创建器之前取消一个thunk，您可以在负载创建器之后提供一个条件回调选项。回调函数将接收thunk参数和一个带有{getState,extra}的对象作为参数，并使用它们来决定是否继续。如果执行应该被取消，条件回调函数应该返回false```jsconstfetchUserById=createAsyncThunk('users/fetchByIdStatus',async(userId,thunkAPI)=>{constresponse=awaituserAPI.fetchById(userId)returnresponse.data},{condition:(userId,{getState,extra})=>{const{users}=getState()constfetchStatus=users.requests[userId]if(fetchStatus==='fulfilled'||fetchStatus==='loading'){//Alreadyfetchedorinprogress,don'tneedtore-fetchreturnfalse}},},)```####请求时取消如果你想在它完成之前取消运行的thunk，你可以使用dispatch返回的promise的abort方法```jsimport{fetchUserById}from'./slice'import{useAppDispatch}from'./store'importReactfrom'react'functionMyComponent(props){constdispatch=useAppDispatch()React.useEffect(()=>{//Dispatchingthethunkreturnsapromiseconstpromise=dispatch(fetchUserById(props.userId))return()=>{//`createAsyncThunk`attachesan`abort()`methodtothepromisepromise.abort()}},[props.userId])}```使用thunkAPI.signal取消网络请求现代浏览器的fetchapi已经提供了对中止信号的支持```jsimport{createAsyncThunk}from'@reduxjs/toolkit'constfetchUserById=createAsyncThunk('users/fetchById',async(userId,thunkAPI)=>{constresponse=awaitfetch(`https://reqres.in/api/users/${userId}`,{signal:thunkAPI.signal,})returnawaitresponse.json()},)```####检查取消状态你可以用这个中止属性定期检查thunk是否已中止，并在这种情况下停止代价高昂的长时间运行的工作```jsimport{createAsyncThunk}from'@reduxjs/toolkit'constreadStream=createAsyncThunk('readStream',async(stream,{signal})=>{constreader=stream.getReader()letdone=falseletresult=''while(!done){if(signal.aborted){thrownewError('stopthework,thishasbeenaborted!')}constread=awaitreader.read()result+=read.valuedone=read.done}returnresult},)```你也可以调用signal.addEventListener(‘abort’，callback)在调用promise.abort()时通知thunk内部的逻辑。例如，这可以与axiosCancelToken一起使用```jsimport{createAsyncThunk}from'@reduxjs/toolkit'importaxiosfrom'axios'constfetchUserById=createAsyncThunk('users/fetchById',async(userId,{signal})=>{constsource=axios.CancelToken.source()signal.addEventListener('abort',()=>{source.cancel()})constresponse=awaitaxios.get(`https://reqres.in/api/users/${userId}`,{cancelToken:source.token,})returnresponse.data},)```###createEntityAdapter生成一组预构建的reducer和selector的函数，用于对包含特定类型数据对象实例的规范化状态结构执行CRUD操作。这些reducer函数可以作为casereducer传递给createReducer和createSlice。它们也可以作为createReducer和createSlice内部的“突变”助手函数实例```jsimport{createEntityAdapter,createSlice,configureStore,}from'@reduxjs/toolkit'//Sincewedon'tprovide`selectId`,itdefaultstoassuming`entity.id`istherightfieldconstbooksAdapter=createEntityAdapter({//Keepthe\"allIDs\"arraysortedbasedonbooktitlessortComparer:(a,b)=>a.title.localeCompare(b.title),})constbooksSlice=createSlice({name:'books',initialState:booksAdapter.getInitialState({loading:'idle',}),reducers:{//Canpassadapterfunctionsdirectlyascasereducers.Becausewe'repassingthis//asavalue,`createSlice`willauto-generatethe`bookAdded`actiontype/creatorbookAdded:booksAdapter.addOne,booksLoading(state,action){if(state.loading==='idle'){state.loading='pending'}},booksReceived(state,action){if(state.loading==='pending'){//Or,callthemas\"mutating\"helpersinacasereducerbooksAdapter.setAll(state,action.payload)state.loading='idle'}},bookUpdated:booksAdapter.updateOne,},})const{bookAdded,booksLoading,booksReceived,bookUpdated}=booksSlice.actionsconststore=configureStore({reducer:{books:booksSlice.reducer,},})//Checktheinitialstate:console.log(store.getState().books)//{ids:[],entities:{},loading:'idle'}constbooksSelectors=booksAdapter.getSelectors((state)=>state.books)store.dispatch(bookAdded({id:'a',title:'First'}))console.log(store.getState().books)//{ids:[\"a\"],entities:{a:{id:\"a\",title:\"First\"}},loading:'idle'}store.dispatch(bookUpdated({id:'a',changes:{title:'First(altered)'}}))store.dispatch(booksLoading())console.log(store.getState().books)//{ids:[\"a\"],entities:{a:{id:\"a\",title:\"First(altered)\"}},loading:'pending'}store.dispatch(booksReceived([{id:'b',title:'Book3'},{id:'c',title:'Book2'},]),)console.log(booksSelectors.selectIds(store.getState()))//\"a\"wasremovedduetothe`setAll()`call//Sincethey'resortedbytitle,\"Book2\"comesbefore\"Book3\"//[\"c\",\"b\"]console.log(booksSelectors.selectAll(store.getState()))//Allbookentriesinsortedorder//[{id:\"c\",title:\"Book2\"},{id:\"b\",title:\"Book3\"}]```","Tool\\autohotkey\\autohotkey-config.md":"#autohotkey```#NoEnv;RecommendedforperformanceandcompatibilitywithfutureAutoHotkeyreleases.;#Warn;Enablewarningstoassistwithdetectingcommonerrors.SendModeInput;Recommendedfornewscriptsduetoitssuperiorspeedandreliability.SetWorkingDir%A_ScriptDir%;Ensuresaconsistentstartingdirectory.#w::;;这里的#->表示window键w->表示字母w键WinMinimize,A;;最小化当前窗口return!h::Send{Left}return!l::Send{Right}return!j::Send{Down}return!k::Send{Up}return;上下左右滚轮!u::Send{WheelDown}return!i::Send{WheelUp}return!y::Send{Wheelleft}return!o::Send{WheelRight}return;鼠标左击!-::SendEvent{Blind}{LButtondown}KeyWaitRCtrlSendEvent{Blind}{LButtonup}return;鼠标右击!=::SendEvent{Blind}{RButtondown}KeyWaitAppsKeySendEvent{Blind}{RButtonup}return;删除/退格!b::Send{BackSpace}return!m::Send{NumpadAdd}return!n::Send{NumpadSub}return!,::Send{=}return;其他快捷键;!space::{+};return;自用的按键映射$CapsLock::KeyWait,CapsLockIf(A_PriorKey=\"CapsLock\")SetCapsLockState,%GetKeyState(\"CapsLock\",\"T\")?\"Off\":\"On\"Return#If,GetKeyState(\"CapsLock\",\"P\")k::Upj::Downh::Leftl::Right1::Send#{1}2::Send#{2}3::Send#{3}4::Send#{4}5::Send#{5}6::Send#{6}7::Send#{7}8::Send#{8}9::Send#{9}^k::Send+{Up}^j::Send+{Down}^h::Send+{Left}^l::Send+{Right}w::Send^{Left}e::Send^{Right}u::Send^{z}g::Send{Enter}z::Send^{z}c::Send^{c}v::Send^{v}s::Send^{s}x::Send^{x}#w::Send^{w}Enter::Send{Esc}q::Send{Esc}Space::Send{=},::Home.::Endr::Send^{/}b::Send{BackSpace}d::Send{Delete}n::Send^{Backspace}m::Send^{Delete}```","Tool\\autohotkey\\index.md":"#AutoHotkey>[用于热键和宏的按键和鼠标/操纵杆按钮的列表(sourceforge.net)](http://ahkcn.sourceforge.net/docs/KeyList.htm)##自启动设>添加到`C:\\Users\\用户名\\AppData\\Roaming\\Microsoft\\Windows\\StartMenu\\Programs\\Startup`","Tool\\bat\\bat.md":"#Batch-几乎任何windows都可以直接运行-大小写不敏感-行前空格不敏感-编码格式采用`GB2312`正常(ANSI)","Tool\\bat\\bat_script.md":"#bat##脚本>例子,这是一个git提交的模板```shell@echooffset/pcommit=commit:titleautocommitrem调用git命令，如果没有找到git命令，说明环境变量未配置rem将git改成git安装目录下的git.exe也可以实现gitadd.gitcommit-m%commit%gitpushpause```##执行>1.`CMD`:文件名.bat>2.`powershell`:./文件名.bat>3.直接点击运行","Tool\\git\\gitee.md":"#码云的使用###提交没有显示贡献问题>问题1:提交后贡献度不显示>>原因1:本地git和码云帐号邮箱不一致>>解决1:将本地帐号调整一下>>查看当前git用户名：gitconfiguser.name>>查看当前git邮箱：gitconfiguser.email>>切换git用户名:gitconfig--globaluser.name\"YOURUSERNAME\">>切换git邮箱：gitconfig--globaluser.email\"YOUREMAIL\"##clone代码`gitclonegit@gitee.com:guanruihua/grh_note.git`##上传文件```gitgitadd.(上传全部文件)gitcommit-m\"备注\"(上传到缓冲区)gitpushoriginmaster(上传到云端)```##删除文件```rm'文件名'(删除文件)gitadd'文件名'(将删除文件的状态添加到暂存区)gitcommit-m'delete文件名'(将改文将状态上传到缓冲区)gitpush(上传到云端)```##删除文件夹```gitls(查看本地分支的文件)gitrmraindow-r-f(删除raindow文件夹及其所有文件)gitcommit-m\"deleteraindow\"(同步删除操作)gitpushoriginmaster(提交分支)```密钥对创建成功。指纹：F0A136C885F5A7438B624048CB2352B6BB958F9A##删除分支```gitgitbranch-a(查看所有分支)gitpushorigin--deleteHEAD(删除HEAD分支)```","Tool\\git\\type.md":"#CommitType##type用于说明commit的类别，只允许使用下面8个标识```shellbr:此项特别针对bug号，用于向测试反馈bug列表的bug修改情况feat：新功能（feature）fix：修补bugdocs：文档（documentation）style：格式（不影响代码运行的变动）opt:优化refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动revert:feat(pencil):add'graphiteWidth'option(撤销之前的commit)```##记录到Changelog```shelltype:feat/fix```","Tool\\git\\命令\\git.md":"#git##前言>工具:[TortoiseGit](https://gitee.com/enterprises?utm_source=baidu&utm_medium=sem&utm_term=110206&utm_campaign=enterprise&bd_vid=8015310045877046198)>>工作流程:工作目录->暂存区->GIT仓库![image](https://img-blog.csdnimg.cn/img_convert/b7c2d1149f813df1097f1888eb04e94f.png)##git常用指令【gitinit】：为当前项目创建一个本地仓库（即需要事先有一个创建好的项目）【gitclone[url]】：克隆一个仓库【gitstatus】：查看git的状态【gitadd./】：添加当前目录下的所有到“Stage”中【gitcommit】：提交“Stage”中的内容到本地仓库中【gitpulloriginmaster】：拉去远程仓库“origin”相应的分支到本地仓库中的master中，在push之前常常需要先pull一下最新的仓库【gitpulloriginmaster--allow-unrelated-histories】：如果本地与远程是两个独立的仓库，则在pull时需要指定其“允许无关的日志合并”，否则会保存【gitpushoriginmaster】：将本地仓库中的内容提交到远程仓库中（origin为远程分支的名字，master为当前分支的名字，应注意的是，该命令是不完全完整的，在实际使用中，如果是第一个提交到远程，应该使用的命令为【gitpush-uoriginmaster】，如果不是第一次，则直接使用【gitpush】即可）【gitremoteaddorigin[url]】：添加一个远程仓库连接，并为其命名为\"origin\"，当然也可以自定义其它的名字，但一般都命名为origin【gitremotermorigin】：删除一个名为\"origin\"的远程仓库连接【gitremoteset-urlorigin[url]】：修改\"origin\"的url（结合上面一个命令可以发现，想要修改远程仓库连接有两种方法：一种是先删除再添加，一种是直接修改）```shellgitstatus//查看代码状态gitcheckout[分支名称]//查看分支的状态gitadd.//添加修改gitcommit-m\"[描述]\"//添加到本地换成gitpushgitpush-uoriginmastergitconfiguser.name\"[username]\"//配置用户名gitconfiguser.email\"[eamil]\"//配置邮箱gitconfiguser.name//查看用户名gitconfiguser.email//查看用户邮箱``````shellgitinitgitadd.gitcommit-m'message'gitremoteaddorigin远程库地址gitpush-uoriginmain|master``````shellecho\"#note\">>README.mdgitinitgitaddREADME.mdgitcommit-m\"firstcommit\"gitbranch-Mmaingitremoteaddorigingit@github.com:guanruihua/note.gitgitpush-uoriginmain``````shellgitremoteaddorigingit@github.com:guanruihua/note.gitgitbranch-Mmaingitpush-uoriginmain```##建立远程仓库连接```shell#和远程仓库建立连接gitremoteaddoriginhttps://github.com/Jacob-xyb/Projiectgitremoteremoveoriginhttps://github.com/Jacob-xyb/Projiect#删除远程仓库```##提交###普通提交```shellgitcommit-m\"commit\"gitpush-uoriginmain|master``````shellgitadd.gitcommit-m\"描述\"gitpushorigin//提交到已经切换到分支```###强制提交```shell报错内容：Togithub.com:***/***![rejected]master->master(non-fast-forward)error:failedtopushsomerefsto‘git@github.com:***/***’hint:Updateswererejectedbecausethetipofyourcurrentbranchisbehindhint:itsremotecounterpart.Integratetheremotechanges(e.g.hint:‘gitpull…’)beforepushingagain.hint:Seethe‘Noteaboutfast-forwards’in‘gitpush--help’fordetails.``````shellgitpushoriginmaster-f```###提交到其他分支>首先要建立本地的分支，并切换到该分支上（本地建立完分支，默认是在master分支上）```shellgitbranchhello_git_branch//创建分支gitcheckouthello_git_branch//检查该分支gitpushoriginhello_git_branch//push到远程仓库上面```##git查看仓库信息```shellgitlog#查看日志信息gitreflog#查看一行日志gitremote-v#查看当前项目的远程git地址cat.git/HEAD#查看当前HEAD```查看系统config```gitconfig--system--list```查看当前用户（global）配置```gitconfig--global--list```查看当前仓库配置信息```gitconfig--local--list```##git更新代码到本地###正规流程```shellgitstatus（查看本地分支文件信息，确保更新时不产生冲突）gitcheckout–[filename]（若文件有修改，可以还原到最初状态;若文件需要更新到服务器上，应该先merge到服务器，再更新到本地）gitbranch（查看当前分支情况）gitcheckoutremotebranch(若分支为本地分支，则需切换到服务器的远程分支)gitpull```###快速流程```shellgitpull(一句命令搞定)gitbranch看看分支gitcheckoutaaa切换分支aaagitbranckaaa创建aaa分支gitchechout-baaa本地创建aaa分支，同时切换到aaa分支。只有提交的时候才会在服务端上创建一个分支```##git撤销用暂存区中的文件覆盖工作目录中的文件：`gitcheckout文件名字`从暂存区中删除文件：`gitrm--cached文件`将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：```shellgitreset--hardcommitID#恢复到指定ID版本gitreset--hardHEAD^#回退上一个版本gitreset--hardHEAD~1#回退上一个版本//～n就是回退n个版本```注意：如果将版本指针前置的话，指针后面的日志就会消失。删除远程仓库中的文件`gitrm-r--cached文件`修改提交的commit注释`gitcommit--amend`>参数讲解>`--mixed`>不删除工作空间改动代码，撤销commit，并且撤销gitadd.操作>>这个为默认参数，gitreset--mixedHEAD^和gitresetHEAD^效果是一样的。>>`--soft`>不删除工作空间改动代码，撤销commit，不撤销gitadd.>>`--hard`>删除工作空间改动代码，撤销commit，撤销gitadd.>>注意完成这个操作后，就恢复到了上一次的commit状态。##版本回退```shellgitadd.//提交到暂存去gitcommit-m\"描述\"//提交到本地分支gitpush-uoriginmaster//提交到远程服务器(第一个版本)...gitpushoriginmaster//修改项目后提交(第二个版本)gitadd.gitcommit-m\"描述\"gitpushoriginmaster//修改项目后提交(第三个版本)gitlog//查看历史提交记录gitlog--pretty=online//查看历史提交记录[减少多余信息]gitreset--hardHEAD^//回到上一个版本gitreset--hardHEAD~100//回退到100个版本前gitreflog//查看已经回退过的版本记录```##git分支分支细分主分支（master）：第一次向git仓库中提交更新记录时自动产生的一个分支。开发分支（develop）：作为开发的分支，基于master分支创建。功能分支（feature）：作为开发具体功能的分支，基于开发分支创建。查看本地和远程分支###查看本地分支（\\*为当前分支）gitbranch==gitbranch--list==gitbranch-l###查看本地和远程分支gitbranch--all==gitbranch-a###查看远程所有分支gitbranch--remote==gitbranch-r###切换分支gitcheckout分支名称###分支重命名gitbranch-m[oldName][newName]切换分支之前要保持当前暂存区完全干净，不然会出现错误。这是由于git的暂存区是所有分支共享的，因此，只要未提交(commit)的内容都会在所有分支上呈现。有时，我们还未完成当前分支的功能开发，但是又亟需在另一个分支上修改内容(如：修复一个BUG)。一种方式是通过“gitcommit”(提交)，解决这个问题。但在正常使用中，我们应该在完成某个功能的开发后才提交一个版本，而不是频繁的提交。这时，我们可以使用“gitstash”(储藏)来解决这个问题。###创建分支gitbranch分支名称#创建分支（基于所在分支创建）gitcheckout-bbranchNamecommitId#根据指定版本号创建分支####合并和删除分支#####合并gitmerge来源分支#合并分支（将来源分支合并到当前分支）#####删除gitbranch-d分支名称#删除本地分支（如果删除的分支没有被合并是不能删除的）gitbranch-D分支名称#强制删除本地分支gitpushorigin-d分支名称#删除远程分支[Git>v1.7.0](推荐)gitpushorigin:分支名称#删除远程分支(\":\"代表删除)#####暂时保存更改在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。使用场景：分支临时切gitstash#临时保存gitstashpop#恢复保存#####分支管理###将本地develop分支强制（-f）推送到远程mastergitpushorigindevelop:master-f###重置的方法gitcheckoutmaster#切换到旧分支gitreset--harddevelop#将本地的旧分支master重置成developgitpushoriginmaster--force#强制推送###删除远程分支`gitpushorigin--deletedevelop#删除远程仓库``gitpushorigin:develop#推送至服务器才行`##一台电脑同时使用gitee和github###创建sshkey```shell#进入用户目录下的.ssh文件夹下，路径会因你使用的操作系统不同而略有差异#没有这个文件夹也无所谓，直接运行下一句命令也可以cd~/.ssh#生成key，将邮件地址替换为你Gitee或者Github使用的邮件地址ssh-keygen-trsa-C\"xxx@xxx.com\"#giteeGeneratingpublic/privatersakeypair.Enterfileinwhichtosavethekey(/c/Users/your_user_name/.ssh/id_rsa):id_rsa_giteeEnterpassphrase(emptyfornopassphrase)://这里直接回车Entersamepassphraseagain://这里直接回车#github重复上过程,吧id_rsa_gitee改成id_rsa_github```###在gitee和github添加publickey```shellcd~/.sshcatid_rsa_gitee.pub//这里gitee的publickeycatid_rsa_github.pub//这里github的publickey```然后再分别添加到github和gitee的SSH###创建配置文件在.ssh文件夹创建config文件,添加内容区分两个sshkey```shell#giteeHostgitee.comHostNamegitee.comPreferredAuthenticationspublickeyIdentityFile~/.ssh/id_rsa_gitee#githubHostgithub.comHostNamegithub.comPreferredAuthenticationspublickeyIdentityFile~/.ssh/id_rsa_github```###测试连接是否正常```shellssh-Tgit@github.comHiguanruihua!You'vesuccessfullyauthenticated,butGitHubdoesnotprovideshellaccess.ssh-Tgit@gitee.comHigrh-gitee!You'vesuccessfullyauthenticated,butGITEE.COMdoesnotprovideshellaccess.```","Tool\\git\\命令\\index.md":"#命令","Tool\\git\\命令\\分支.md":"#分支##查看分支```shellgitbranch```##新建分支-在dev分支新建1个master分支不存在的文件-`-b`:创建并切换```shell#创建dev分支gitcheckout-bdev#等同于gitbranchdevgitcheckoutdev```##合并-合并分支```shell#切换到master分支gitcheckoutmaster#将dev分支合并到主分支master上gitmergedev```##删除分支```shell#删除dev分支gitbranch-ddev```","Tool\\git\\命令\\切换远程地址.md":"#切换远程地址##修改远程仓库地址【gitremoteset-urloriginURL】更换远程仓库地址，URL为新地址。##先删除远程仓库地址，然后再添加【gitremotermorigin】删除现有远程仓库【gitremoteaddoriginurl】添加新远程仓库##查看远程仓库的地址```shellgitremote-v```","Tool\\git\\命令\\删除分支.md":"#[`删除分支`]()##删除本地分支```gitgitbranch-dlocal_branch_name```##删除git中远程分支```gitgitpushremote_name-dremote_branch_name```","Tool\\git\\命令\\基于主线分支创建新娘分支.md":"#[`基于主线分支创建新娘分支`](/)主线分支：main基于主线分支创建的分支：feature①切换到主线分支：gitcheckoutmain②拉取主线分支最新的代码：gitpull--rebase③创建新分支并切换到该分支：gitcheckout-bfeature④推送新分支到远程仓库：gitpushoriginfeature-f⑤关联远程仓库gitbranch--set-upstream-to=origin/feature⑥尝试拉取验证：gitpull--rebase","Tool\\git\\命令\\指定版本创建分支.md":"#[`指定版本创建分支`]()1.显示日志`gitlog`2.在指定版本创建分支`gitbranch<分支名><SHA>`3.切换分支`gitcheckout<分支名>`4.推送分支`gitpush--set-upstreamorigin<分支名>`","Tool\\git\\命令\\推送代码时打tag.md":"#推送时打tag```shellgitadd.gitcommit-m\"更改注释\"gittagv1.0.5#或gittag-av1.0.5-m'myversion1.0.5'#查看taggittag#v1.0.5tag名gitpushoriginv1.0.5gitpullgitpush```","Tool\\git\\命令\\撤销commit.md":"#[`撤销commit`]()-修改了本地的代码，然后使用：```shellgitaddfilegitcommit-m'修改原因'```执行commit后，还没执行push时，想要撤销这次的commit解决方案：使用命令：`gitreset--softHEAD^`这样就成功撤销了commit，如果想要连着add也撤销的话，–soft改为–hard（删除工作空间的改动代码）。命令详解：HEAD^表示上一个版本，即上一次的commit，也可以写成HEAD~1如果进行两次的commit，想要都撤回，可以使用HEAD~2–soft不删除工作空间的改动代码，撤销commit，不撤销gitaddfile–hard删除工作空间的改动代码，撤销commit且撤销add#commit注释写错了，先要改一下注释，有其他方法也能实现`gitcommit--amend`这时候会进入vim编辑器，修改完成你要的注释后保存即可。","Tool\\git\\拉取某个文件.md":"#拉取某个文件-Git单独pull某个文件-命令：从主分支上拉去某个文件`gitcheckoutmaster--filepath`-例子：`gitcheckoutmaster--src/main/resources/mybatis/mappers/CategoryMapper.xml`-注意在“--”之后有一个空格，获取文件地址可以直接右键“copypath”选择相应的路径就可以了","Tool\\git\\提交pr.md":"#提交pr(pullrequest)##复制仓库>点击`fork`,就会在自己github上创建此仓库##克隆仓库>clone代码,或者用命令克隆仓库到本地##创建分支```bashgitcheckout-b[branchName]```##推送到远程库```bashgitadd.gitcommit-m\"[desc]\"gitpushorigin[branchName]```##创建拉取请求>github仓库点击`Compare&pullrequest`按钮##同步复刻`master`分支```bashgitcheckoutmaster#给原始仓库添加upstream仓库gitremoteaddupstream[HTTPS]```##获取原始仓库的变更>从原始仓库获取变更，所有提交到原始仓库的变更将会保存在本地的`upstream/master`分支中```bashgitfetchupstream```##合并变更```bashgitmergeupstream/master```##把变更推送到github```bashgitpushoriginmaster```##删除无用分支```bashgitbranch-d[BranchName]#删除github无用分支gitpushorigin--delete[BranchName]```","Tool\\git\\钩子\\index.md":"#Git钩子###钩子>钩子的全部放在`.git/hooks`下面，在新建一个项目仓库的时候，Git已经在这个文件夹下给我们生成了很多个`.sample`后缀的钩子，这些钩子只要把`.sample`去掉就可以运行了，我们可以在这些`sample`上面修改完成我们自己的钩子###客户端钩子>官网链接[钩子](https://git-scm.com/book/zh/v2/自定义-Git-Git-钩子#_git_hooks)客户端钩子很好理解，你`commit`之后想做其他事，比如说编译一下程序啥的，这里我就不多讲，主要由下面几个钩子组成-pre-commit提交之前-post-commit提交之后-pre-rebase变基之前-post-rewrite替换提交记录之后-pre-push推之前###服务端钩子服务端钩子就是你`push`之后的事情服务器要运行的脚步，有用推的步骤只有一个，所以钩子只有四个-pre-receive接受之前-update更新之前-post-update更新之后-post-receive接受之后服务器接收到客户端请求时，`pre-receive`先进行调用，如果返回值为非0就会拒绝推送，所以我们写钩子的时候一定要记住最后要返回0才能正常接收更新，`update`主要处理多分支推送，有的时候你一次更新，推三四个分支到服务器，`pre-receive`只会调用一次，`update`会对每个的分支调用一次，后面两个都很容易理解一般我们就是要在服务端更新代码之后运行脚步，所以我们要修改的就是`post-update`或者`post-receive`bash脚步大家都会写，但是大家可能会很陌生什么是Git服务端，接下来我们就来介绍一下Git服务端是什么###Git服务端大家一般使用Git都是使用的客户端，但是Git这个工具的确很强，它不但可以当做客户端，也可以当做服务端，为了让大家更好的理解Git服务端，我们先来拿本地文件做”服务器“首先我们先新建一个文件夹为`server`，在新建一个文件夹为`local`，假设文件夹都在`/root`文件夹下我们执行下面的命令生成服务器```cd/root/servergitinit--bare```只需要在`init`后面添加一个`--bare`选项告诉Git，Git就会帮我们生成一个空的“服务端”，我们可以查看一下文件，我们发现Git给我们生成下面几个文件夹，其中就有我们的hooks```branchesconfigdescriptionHEADhooksinfoobjectsrefs```但是服务端和客户端生成的位置不一样，客户端是给我们生成一个`.git`文件夹，里面放了这些文件夹，然而服务端直接将这些文件夹放在主目录了行我们已经生成了服务端的，接下来我们生成客户端的钩子```cd/root/localgitinit```很简单，同我们往常操作一样，我们这时候添加一个`README.md`然后`commit`一下准备开始往服务端推代码了在linux下直接执行下面命令就行echo“localupdate”>>README.mdgitaddREADME.mdgitcommit-m“AddReadME”接下来我们就要向”服务器“提交代码了，我们先添加本地文件作为远程服务器```gitremoteaddoriginfile:////root/server```然后直接推代码```gitpushoriginmaster```这样我们就向我们文件提交了代码，这时候我们回到我们”服务器“```cd/root/serverlsbranchesconfigdescriptionHEADhooksinfoobjectsrefs```我们惊奇的发现服务器并没有我们新建的`README.md`文件，原来Git服务端并不像SVN一样只保留一份代码大家共同修改，**Git服务端只是记录文件变化和分支变化**这里插一句我为什么会去了解Git钩子，由于一开始实现服务器自动更新我的FastProxyScan项目代码，但是我又不想使用`Github`钩子（push后发送http请求），太麻烦了，后来我一想干脆直接推到我的服务器上，但是推到服务器上的代码只是记录了分支和提交信息，不包含源文件，所以我只好在在服务器上部署这个项目，并添加一个服务器钩子，当服务器更新完成后，再用钩子把服务器上的项目代码更新###如何写服务器钩子通过上面对本地文件新建仓库，我们知道Git“服务端”新建很简单，我们一般接触比较多的是Github服务端，但是Git非常强大，他可以支持多种协议来连接“服务端”，比如说我们上面用到的本地文件（`file`协议），假如你用`ssh`连接远程服务器，你也可以使用类似`gitremoteaddoriginssh://username@ip/file/path`添加ssh远程仓库git支持的协议有ssh、http、https、file、git等协议，你只要确保你能连接上远程服务器就行，接下来我们谈谈如何写服务器钩子在使用`gitinit--bare`新建了一个Git服务端之后，在服务端文件下面有一个`hooks`文件夹，我们要做的就是把脚本放到`hooks`文件夹里面（当然你要确保它有执行权限），如果你更擅长写`Python`，`Ruby`那些脚步也可以，不过要确保前缀后后缀正确。这里要提到很重要的一点，由于在执行钩子的时候，环境变量`GIT_DIR`被设置为服务端当前目录，如果你像我一样想更新在另外一个文件夹下面的项目代码，你必须使用`usetGIT_DIR`清除变量名，否则只会更新服务端，而不会更新你的项目代码这里我提供一个模板文件名为`post-update`或者`post-receive````#!/bin/shcd/project/path/||exitunsetGIT_DIRgitpulloriginmasterexecgit-update-server-info```你只需修改项目文件路径和仓库名即可","Tool\\git\\错误\\index.md":"#giterror##gitpage`Error:Theprocess'/usr/bin/git'failedwithexitcode128`>我处理方法,添加补充README.md后就正常了##gitpushoriginHEAD:＜name-of-remote-branch＞```shellgitpushoriginHEAD:develop```>develop:分支名##解决error:Yourlocalchangestothefollowingfileswouldbeoverwrittenbymerge：XXXX###保留本地最新修改，并拉取仓库中忘记pull的代码到本地```shellgitstashgitpulloriginmastergitstashpop```###放弃本地代码，新修改的都不要了，退回上一版本，再拉取代码到本地```shellgitreset--hardgitpulloriginmaster```###对于本地的项目中修改不做任何理会，就需要用到Gitpull的强制覆盖```shellgitfetch--allgitreset--hardorigin/mastergitpull```","Tool\\git\\错误\\timeout.md":"#Timeout##git上传代码报错ssh:connecttohostgithub.comport22:Connectiontimedout解决办法当在远程库上设置了SSH之后还是报错连接超时，问题如下```bash$gitpushoriginmasterssh:connecttohostgithub.comport22:Connectiontimedoutfatal:Couldnotreadfromremoterepository.Pleasemakesureyouhavethecorrectaccessrightsandtherepositoryexists.```这个时候需要检查一下SSH是否能够连接成功，输入以下命令```bashssh-Tgit@github.com```稍等片刻如果继续报错，如下：```bashssh:connecttohostgithub.comport22:Connectiontimedout```则，可以使用一下解决办法打开存放ssh的目录```bashcd~/.sshls```查看是否存在`id_rsa_github.pub`,`id_rsa_github`,`known_hosts`三个文件，如果没有移步解决办法：如果存在，则新建config文件输入下面内容```bashHostgithub.comUserYourEmail@163.comHostnamessh.github.comPreferredAuthenticationspublickeyIdentityFile~/.ssh/id_rsaPort443```其中User后面为GitHub的账号名称创建方法：`vimconfig`然后编辑，最后:wq退出保存之后再次执行`\"ssh-Tgit@github.com\"`时，会出现如下提示，回车\"yes\"即可","Tool\\git\\错误\\未能对 git remote 进行身份验证.md":"#[`未能对gitremote进行身份验证`](https://stackoverflow.com/questions/47860772/gitlab-remote-http-basic-access-denied-and-fatal-authentication)-gitlab:运维升级后-账号密码也无法生效-使用publickey进行push,pull验证会报![](./.assets/未能对%20git%20remote%20进行身份验证-2024-03-12-10-44-48.png)##解决###使用accesstoken-不要使用您的GitLab密码，而是创建一个访问令牌并使用它代替您的密码1.在GitLab的右上角，转到个人资料→设置→访问令牌![](./.assets/未能对%20git%20remote%20进行身份验证-2024-03-12-10-51-54.png)2.创建新的个人访问令牌（检查api选项）![](./.assets/未能对%20git%20remote%20进行身份验证-2024-03-12-10-52-41.png)3.进行git操作(`gitclone.../gitpull/gitpush`)4.当系统要求您输入密码时，复制并粘贴访问令牌而不是您的GitLab密码","Tool\\idea.md":"#idea##快捷键|快捷键|输出||----------------|-----------------------------------------------||psvm|mainS函数||fori|for循环||sout|`System.out.println('')`||**Ctrl+P**|**显示方法参数**||**Ctrl+W**|**选择代码块，连续按会增加选择外层的代码块**||**Ctrl+Shift+W**|**与“Ctrl+W”相反，减少选择代码块**||**Ctrl+Alt+L**|**格式化代码**||**Ctrl+Alt+I**|**自动优化代码缩进**||**Ctrl+[\\|]**|**光标移动到代码块的起始\\|结束位置**||`Ctrl+alt+T`|选中的代码会被包含进要执行try…catch或其他语句中||`ctrl+shift+u`|大小写转换|##idea-vim###安裝ideaVim插件>setting/plugins:在idea中直接搜索插件`ideaVim`并安装####配置vim在`/home/`目录下创建`.ideavimrc`文件，如在windows系统中，则在`C:\\Users\\xxxx\\`下建在`.ideavimrc`中:```shell\"Vim的默认寄存器和系统剪贴板共享setclipboard+=unnamed\"leader:,快捷键前缀letmapleader=\",\"\"基础键位映射\"esc使用jk\"inoremapjk<esc>\"映射idea常用快捷键\"重命名nnoremap<leader>r:actionRenameElement<CR>\"格式化当前文件nnoremap<leader>f:actionReformatCode<CR><esc>\"quickjavadocnnoremap<leader>q:actionQuickJavaDoc<CR>\"映射到idea快捷键\"弹出输入框，可以跳到指定类nnoremap<Space>gc:actionGotoClass<CR>\"弹出输入框，跳转到指定操作nnoremap<Space>ga:actionGotoAction<CR>\"跳转到实现nnoremap<Space>gi:actionGotoImplementation<CR>\"跳转到指定的文件nnoremap<Space>gf:actionGotoFile<CR>\"跳转到方法的声明nnoremap<Space>gs:actionGotoSuperMethod<CR>\"跳转到测试\"nnoremap<Space>gt:actionGotoTest<CR>\"跳转到变量的声明nnoremap<Space>gS:actionGotoSymbol<CR>\"查找使用nnoremap<Space>fu:actionFindUsages<CR>\"显示使用nnoremap<Space>su:actionShowUsages<CR>\"前进，相当似于eclipse中的alt+方向右键\"nnoremapgf:actionForward<CR>\"后退，相当于eclipse中的alt+方向左键\"nnoremapgb:actionBack<CR>\"插件模拟\"surroundsetsurround\"multiple-cursorssetmultiple-cursors\"easyMotion模拟，额外依赖插件：AceJump,IdeaVim-EasyMotionseteasymotion\"注释插件模拟setcommentary```|快捷键|中文||--------|-------------------------------------------------------------------------------||ci\"|changeinside“,找到最近”“的位置，并删除”\"中内容||ci(、ci[|changeinside(，changeinside[||cit|catintag，可以直接编辑匹配的xml标签中的内容！||yi\"|yankinside\",复制\"\"中的所有内容||ya\"|yankaround\"复制整个字符串，包括双引号。||ysiw’|为光标下的单词包围上单引号,同理ysiw\"||cs’\"|将单引号变成双引号,changesurrounding’replace“”||cs\"(|将双引号变成圆括号’||gUw|大写||guw|小写||gc|打开或关闭注释.输入gcc打开或关闭某一行代码注释，gc2j打开或关闭两行代码注释||gC|块代码注释.输入gCi)注释括号()中的代码||gd|Gotodefinition,跳转到定义||gb|找出与光标下相同的下一个单词,并添加一个光标，接下来就可以同时修改||af|VISUAL模式命令,依据语法分析,将选择区域向外扩展||gh|等同于将鼠标移至光标所在单词,方便查看定义以及报错||gt|下一个文件||gT|上一个文件|","Tool\\PC\\search-tips.md":"#搜索技巧|说明|关键词|例子|结果||:------------|:-----------------------------:|:-----------------:|:--------------------:|||关键字用空格隔开|文献国内|||关键词|\"\"|\"电传\"|不会有“电话传真”之类||多个关键词|+|+电脑+电话+传真|内容一点有这三个关键字||排除干扰项|-|锤子-锤子手机|可以排除锤子手机||指定域名|site:域名+(空格)+关键字|site:zhihu.com抠脚|全是知乎的抠脚||指定文件格式|filetype:文件格式+(空格)+关键词|filtetype:pdf高数|||指定标题|intitle:+标题||||单关键字|intext:关键字||||过个关键字|allintext:关键字1关键字2||||网页url要包含|inurl:关键字|||","Tool\\PC\\window.md":"#window##计算机##卓越性能-`powercfg-duplicateschemee9a42b02-d5df-448d-aa00-03f14749eb61`###本地组策略编辑器-打开:`win+R`=>`gpedit.msc`=>确定-可以进去管理计算机的一些软件####删除服务>`scdeleteMySQL`[服务名,如果不知道可以去计算机管理处查看,复制服务名]###注册表管理器>打开:`win+R`=>`regedit`=>确定>>查看软件的注册表##输入法###U/V模式>`U`模式:`uyouyouyouyou`=>叕>>`V`模式:`v1024*1024`=>1048576###其他>`ctrl+shift+b`:输入法的表情包##键盘锁>`win+r`输入`osk`##模式>-卓越性能代码：>-打开powershell输入以下指令,然后可以去设置中找到打开>-“powercfg-duplicateschemee9a42b02-d5df-448d-aa00-03f14749eb61”>-上帝模式代码：>-新建一个文件夹,将名字命名为以下>-“GodMode.{ED7BA470-8E54-465E-825C-99712043E01C}”","Tool\\PC\\内网穿透.md":"#内网穿透>-[内网穿透-把自己的电脑部署为公网可访问的服务器\\_飞鸿先森的博客-CSDN博客](https://blog.csdn.net/Feihongxiansen/article/details/94480480)>>[下载-cpolar安全的内网穿透工具](https://www.cpolar.com/download)","Tool\\PC\\文件右键.md":"#文件右键##win11右键改win10```regadd\"HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\"/f/ve```##右键改回win11```regdelete\"HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\"/va/f```","Tool\\PC\\端口号占用处理.md":"#端口号占用处理```shell1.查看该端口被哪些进程占用netstat-ano|findstr[端口号]2.查看进程信息tasklist|findstr[pid]3.根据进程ID或进程名称杀进程taskkill/f/pid[pid]taskkill/f/im[进程名]```","Tool\\ps.md":"#ps##ps切圆形图###1.先用椭圆选框工具按钮,圈号需要的区域<imgsrc=\".assets/143327_5bfe86c4_7984151.png\"style=\"zoom:67%;\"/><imgsrc=\".assets/143422_7406aca5_7984151.png\"style=\"zoom:33%;\"/>###2.然后，左手按住键盘上“**Shift**”和“**Alt**”两个键，右手拖动**鼠标画出一个比较合适的圆形选区**，画好后用鼠标调整圆形选区的位置，使其刚好框住自己想要的圆形部分当然，也可以按住键盘上的“**shift**”键，拖动出一个正圆，不松开鼠标左键，继续按住“**space**”键，移动鼠标来改变正圆的位置。（注：_“Shift”键是为了画出正圆，而“Alt”键是为了将鼠标设定为所画圆圈的圆心，“Space”键是用来改变正在绘制图形位置的_)###3.按`ctrl+j`:以圆形选取内的图画新建一个图层","Tool\\ssl.md":"#[`ssl`]()>-[SSL证书生成器](https://zh.rakko.tools/tools/46/)>-[windows生成ssl证书，实现本地https访问](https://blog.csdn.net/qq243920161/article/details/119963501)","Tool\\svn\\svn.md":"#svn##常用概念>-repository(源代码库)：源代码工体提交的地方>-checkout（提取）：没有源代码,需要从repositorycheckout一份>-commit（提交）：当你修改了代码,你需要commit到repository>-update（更新）：当你已经checkout一份源码,可以update一下就可以和repository上的源代码同步,手上的代码就会有更新>如果两个程序员修改用一个文件,svn可以合并这两个程序员的改动>>如果修改的是同一行,svn会提交文件conflict冲突,需要手动确定##主要功能1.目录版本控制2.真实的版本历史3.自动提交4.纳入版本控管的元数据5.选择不同的网络层6.一致的数据处理方式7.有效的分支branch与标签tag8.hackability##安装把bin目录添加到path环境变量中##使用###冲突合并![image-20210617232336576](.assets/image-20210617232336576.png)方案一：1.放弃本地修改的，选择svnRevert的选项撤回本地代码，先更新服务器上的文件，然后在把我们要修改的添加上去，在提交。方案二：本地冲突合并解决(根据两人修改的东西对比）。1.打开冲突文件你会看到由小于号、等于号和大于号串组成的三个部分。\\*切记小于号、等于号和大于号串是冲突标记，并不是冲突的数据。2.其中小于号和等号之间的内容是你的修改，而等号和大于号之间的修改是其他人的修改，在明确了冲突的原因之后，我们已经知道怎么修改了，两个人的修改都是需要保留的。","Tool\\test\\index.md":"#测试##开放式Web应用程序安全项目>>安全测试工具<https://github.com/zaproxy/zaproxy><https://github.com/OWASP/CheatSheetSeries><https://www.hcl-software.com/appscan/products/appscan-standard>","Tool\\vim\\nvim.md":"#nvim##缓冲区>`:ls`>>会显示多个存文件>>:buffer编号/后面的路径名##窗口控制|描述|快捷键|补充||-----------------------------|--------------|----------------------------|---|---|---||关闭当前窗口|`Ctrl+wc`|关闭最后一改窗口`Ctrl+wq`||上下\\|左右分割当前文件|`Ctrl+ws|v`|||上下\\|左右打开一个新的文件|`:sp|:vspfilename`|||光标移动到上下左右屏幕|`Ctrl+wk|j|h|l`|||窗口移动上下左右移动窗口|`Ctrl+wK|J|H|L`||>最快的方法：>1改变高度：res+n（增加n行的高度)>>2.改变宽度：verticalres+n（增加n列的宽度）>>[n:可以使用+/-来表示添加或减少对应的列数]##Neovim和vim-plug安装>vim的插件管理器>>环境是windows10>>配置文件路径:`C:\\Users\\ruihuag\\AppData\\Local\\nvim`###安装包准备>[nvim](https://github.com/neovim/neovim/releases/tag/nightly):直接下载nvim-win64.zip>>[vim-plug](https://github.com/junegunn/vim-plug):要是无法下载`plug.vim`,可以选择下载整个vim-plug项目,里面有个文件就是`plug.vim`###开始安装>-neovim\\bin\\nvim-qt点击打开就可以开始使用>-把`neovim\\bin`添加到环境变量中>-在C:User\\用户名\\Appdata\\Local下创建nvim文件夹>-在nvim文件中创建autoload文件夹,plugged文件夹和`init.vim`(配置文件)>>-autoload:放`plug.vim`文件>-plugged:存放下载下来的vim插件>-init.vim:配置文件填写下面配置>>-```vim>callplug#begin('~/AppData/Local/nvim/plugged')>Plug'junegunn/vim-easy-align'>Plug'scrooloose/nerdtree'>callplug#end()>```>>-cmd控制台:输入`nvim`打开,在命令模式输入`:PlugInstall`安装插件##vim-plug使用>常用插件：[https://vimawesome.com](https://vimawesome.com/)##组件安装和卸载>安装>>-添加`Plug'插件名'`>-命令模式`:PlugInstall`>>卸载>>-删除添加的`Plug'插件名'`>-命令行模式`:PlugClean`,选择y就可以彻底删除插件##NERDTree文件树|描述|操作||--------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|------|---|---------------------------------|---|---|------------------||打开目录|`:NERDTree`|`<F8>`||目录操作|`m`:创建文件\\|删除文件\\|复制文件\\|移动文件等<br>P跳到根结点<br/>p跳到父结点<br/>K跳到当前目录下同级的第一个结点<br/>J跳到当前目录下同级的最一个结点||窗口移动|`ctrl+w`(两次)[向右切]<br/>`ctrl+w+h|j|k|l`[移动对应方向]<br/>`ctrl+h|j|k|l`[移动对应方向]||标签页|`[回车]`:新标签页打开<br>T:新标签打开,光标不跳转<br>`gt`:向右切<br>`gT`:向左切<br>`alt+[number]`:跳转到对应的标签页||分屏打开|`o`:打开文件<br>`i`:水平分屏打开<br/>`s`:垂直分屏打开<br/>[前加`g`:打开,但光标不跳转]|>```shell>!执行当前文件>O递归打开选中结点下的所有目录>x合拢选中结点的父目录>X递归合拢选中结点下的所有目录>eEditthecurrentdif>>C将选中目录或选中文件的父目录设为根结点>u将当前根结点的父目录设为根目录，并变成合拢原根结点>U将当前根结点的父目录设为根目录，但保持展开原根结点>r递归刷新选中目录>R递归刷新根结点>cd将CWD设为选中目录>>:tabnew[++opt选项]［＋cmd］文件建立对指定文件新的tab>:tabclose关闭当前的tab>:tabo关闭所有其他的tab>:tabs查看所有打开的tab>:tabp前一个tab>:tabn后一个tab>```##sandwich环绕字符编辑>`t`:html标签[`tp`:`<p>`]>>`b`:指代成对的符号[修改的时候]>>`选择区域`:`w`,`3w`,`$`,`W`,`0`,`f\"`[查找]>>`sa`:新增>>`sr`:修改>>`sd`:删除>-新增环绕字符:`sa`>-`sa[选择区域][符号|标签]`:给多个词加该符号>-`sa[选择区域][符号|标签]`:给多个词加该符号[不包括符号]>-可视化模式下,选择区域+`sa[符号|标签]`>-修改环绕字符:`sr`>-`srb[符号|]`:将成对符号修改成该符号>-`srbTp`:修改成`<p>`>-`srtth1`:修改成`<h1>`>-`srT)`:将标签修改成`()`>-删除环绕字符:`sd`>-`sdb`:删除引号或括号>-`sdt`:删除标签##vim-colorschemes颜色主题>colorschemes的github主页为：<https://github.com/flazz/vim-colorschemes>>在文档中找到`Using`，选择一种主题颜色命令模式输入其中一个可以切换主题```colorschemewombat``````colorschememolokai```##多光标vim-visual-multi>基本用法：>>-选择带的单词（如在崇高的文本/VS代码中）Ctrl-N`Ctrl-d`>-输入多个`CtrlN`选择多个单词，可以通过[]来移动光标选着,通过Q取消一个光标>-使用Ctrl-Down/Ctrl-Up>-一次选择一个字符Shift-Arrows>-按/获取下一个/上一次匹配nN>-按/选择下一个/上一个光标[]>-按跳过当前并获取下一次匹配q>-按以删除当前光标/选择Q>>两种主要模式：>>-在*光标模式下*，命令的工作方式与在正常模式下一样>-在*扩展模式下*，命令的工作方式与在可视模式下一样>-按下可切换[光标]和[扩展]模式Tab>>大多数vim命令都正常工作（运动、替换字符、更改大小写等）。此外，您还可以：r~>>-在游标上运行宏/ex/正常命令>-对齐光标>-转置选择>-使用正则表达式或从可视模式添加模式##联想>`ins-completion`###在当前文件获取整行快捷键：`<C-X><C-L>`###文件名快捷键：`<C-X><C-F>`###当前文件中的关键字快捷键：`<C-X><C-P>`或`<C-X><C-N>`###`complete`选项所指定的范围中的关键字快捷键：`<C-N>`或`<C-P>`###`dictionary`中的关键字快捷键：`<C-X><C-K>`假设你有一个`javascript.dict`文件，其内容如下：```PromiseProxyletclassextends```设置`:setdictionary+=/path/to/es6.dict`之后就可以用`<C-X><C-K>`来补全这些关键字了。","Tool\\vim\\space-vim.md":"#space-vim>官网:<https://spacevim.org/cn/use-vim-as-ide/>##windows配置>Windows下最快捷的安装方法是下载安装脚本[install.cmd](https://spacevim.org/cn/install.cmd)并运行。>>SpaceVim的默认配置文件为`~/.SpaceVim.d/init.toml`。下面为一简单的配置示例。如果需要查阅更多SpaceVim配置相关的信息，请阅读SpaceVim用户文档。```toml#这是一个基础的SpaceVim配置示例#所有的SpaceVim选项都列在[options]之下[options]#设置SpaceVim主题及背景，默认的主题是gruvbox，如果你需要使用更#多的主题，你可以载入colorscheme模块colorscheme=\"gruvbox\"#背景可以取值\"dark\"或\"light\"colorscheme_bg=\"dark\"#启用/禁用终端真色，在目前大多数终端下都是支持真色的，当然也有#一小部分终端不支持真色，如果你的SpaceVim颜色看上去比较怪异#可以禁用终端真色，将下面的值设为falseenable_guicolors=true#设置状态栏上分割符号形状，如果字体安装失败，可以将值设为\"nil\"以#禁用分割符号，默认为箭头\"arrow\"statusline_separator=\"nil\"statusline_iseparator=\"bar\"#设置顶部标签列表序号类型，有以下五种类型，分别是0-4#0:1➛➊#1:1➛➀#2:1➛⓵#3:1➛¹#4:1➛1buffer_index_type=4#显示/隐藏顶部标签栏上的文件类型图标，这一图标需要安装nerdfonts，#如果未能成功安装这一字体，可以隐藏图标enable_tabline_filetype_icon=true#是否在状态栏上显示当前模式，默认情况下，不显示Normal/Insert等#字样，只以颜色区分当前模式enable_statusline_mode=false#SpaceVim模块设置，主要包括启用/禁用模块#启用autocomplete模块，启用模块时，可以列出一些模块选项，并赋值，#关于模块的选项，请阅读各个模块的文档[[layers]]name=\"autocomplete\"auto-completion-return-key-behavior=\"complete\"auto-completion-tab-key-behavior=\"cycle\"#禁用shell模块，禁用模块时，需要加入enable=false[[layers]]name=\"shell\"enable=false#添加自定义插件[[custom_plugins]]repo=\"lilydjwg/colorizer\"merged=false```##常用快捷键>SPC:空格>>Leader:\\>>`:term`:打开终端>>`spcfS`:保存所有文件|快捷键|描述|快捷键|描述||----------------|------------------------------------|--------------------|--------------------------------------------||`SPC+[number]`|跳转到各个对应窗口编号的窗口|`Leader+[number]`|通过该快捷键对文件进行标记,并跳转到对应文件||`SPC+bf`|代码格式化|`SPC+Tap`|切换到文件目录||`gr`|跳转到前一个Tab,用于两个tab来回切换|##窗口常用操作>窗口切换:>>-小窗口多文件切换:`\\[number]`>-打开>-大窗口切换打开:`SPC+[number]`>-分屏打开:`sg`>-垂直分屏打开:`sv`>-关闭一个窗口`spcwd`>-关闭一个文件`spcbd`>>文件树操作:>>-切换文件树:`spcft`>-打开文件/目录:移动光标到指定的文件+回车>-打开目录:>-关闭`h`>-进入`L`##文件树中打开>如果只有一个可编辑窗口，则在该窗口中打开选择的文件，否则则需要指定窗口来打开文件|快捷键|功能描述||:--------------|:---------------||`l`/`<Enter>`|打开文件||`sg`|分屏打开文件||`sv`|垂直分屏打开文件|##基本操作|快捷键|功能描述||:----------------|:-----------------------------||`<Up>`|向上移动光标，不跳过折行||`<Down>`|向下移动光标，不跳过折行||`H`|移动光标至屏幕顶部||`L`|移动光标至屏幕底部||`<`|向左移动文本||`>`|向右移动文本||`}`|向前移动一个段落||`{`|向后移动一个段落||`Ctrl-f`|向下翻页(`Ctrl-f`/`Ctrl-d`)||`Ctrl-b`|向上翻页(`C-b`/`C-u`)||`Ctrl-e`|向下滚屏(`3Ctrl-e/j`)||`Ctrl-y`|向上滚屏(`3Ctrl-y/k`)||`Ctrl-Shift-Up`|向上移动当前行||`Ctrl-Shift-Down`|向下移动当前行|##他人笔记#自动更新[options]automatic_update=true#启动主题[options]colorscheme=\"molokai\"[[layers]]name=\"colorscheme\"#更新插件:SPUpdate#查看日志:SPDebugInfo!#界面元素切换##SPCtSPCt8高亮所有超过80列的字符SPCtf高亮临界列SPCthh高亮当前行SPCthi高亮代码对其线SPCthc高亮光标所在列SPCths启动语法高亮SPCtn显示隐藏行号SPCtb切换背景色SPCtc切换conceal模式SPCtp切换paste模式SPCttTab管理器SPCtmb电池SPCtmM文件类型SPCtmt时间SPCtmd日期SPCtmT状态栏SPCtmv版本控制SPCt8高亮指定列后的所有字符SPCtf高亮指定列字符SPCts语法检查SPCtS拼写检查##SPCTSPCT~显示/隐藏Buffer结尾/行首的~SPCTf显示隐藏边框SPCTm显示隐藏菜单SPCTt显示隐藏工具栏#切换windowSPC[1-9]#切换tag\\[1-9]gr跳前一个tag#搜索计数```1[layers]2name=\"incsearch\"```#状态栏分隔符```1[options]2statusline_separator='arrow'```#标签管理器o展开/关闭标签目录r重命名标签n新建标签N新建匿名标签x删除标签enter跳转到标签#文件树F3SPCftSPCfTN新建文件yy复制文件路径yY复制文件p粘贴.显示隐藏sv分屏sg分屏p预览文件i文件修改历史v快速查看><放大缩小>gx使用相关程序执行>'标记>V清除所有标记>Ctrl+r刷新#光标jkjhH屏幕顶部L屏幕底部>右移动文本><左移动文本>}后移动段落>{前移动段落>ctrl+f/d向下翻页>ctrl+b/u向上翻页>ctrl+e/j向下滚屏>ctrl+y/k向上滚屏>ctrl+c复制绝对路径>ctrl+x切换窗口文件>ctrl+shift+up向上移动当前行>ctrl+shift+down向下移动当前行#SPCxaSPCxa各种对其SPCxj各种对其#SPCxSPCxc统计单词SPCxdw删除空白SPCxgt翻译SPCxu小写SPCxU大写SPCxtc字符前提SPCxtC字符后提#文本插入SPCilllistSPCilpparaghSPCilssentenceSPCip1passwordSPCip2password2SPCip3password3SPCippeasypasswordSPCipnnumericalpasswordSPCiUUUIDSPCn+/-数字加减#注释SPC;进入注释操作模式SPCch隐藏/显示注释SPCcl注释/反注释当前行SPCcL注释行SPCcu反注释行SPCcp注释/反注释段落SPCcP注释段落SPCcs使用完美格式注释SPCct注释/反注释到行SPCcT注释到行SPCcy注释/反注释同时复制(TODO)SPCcY复制到未命名寄存器后注释SPCc$从光标位置开始注释当前行#语法树F2#WINDOWSPCw=windowSPCw.启用窗口临时快捷键SPCw在同一标签内进行窗口切换SPCw=对齐分离的窗口SPCwc进入阅读模式，浏览当前窗口(需要tools模块)SPCwC选择某一个窗口，并且进入阅读模式(需要tools模块)SPCwd删除一个窗口SPCwD选择一个窗口并关闭SPCwF新建一个新的标签页SPCwh移至左边窗口SPCwH将窗口向左移动SPCwj移至下方窗口SPCwJ将窗口向下移动SPCwk移至上方窗口SPCwK将窗口向上移动SPCwl移至右方窗口SPCwL将窗口向右移动SPCwm最大化/最小化窗口（最大化相当于关闭其它窗口）SPCwM选择窗口进行替换SPCwo按序切换标签页SPCwpm使用弹窗打开消息SPCwpp关闭当前弹窗窗口SPCwr顺序切换窗口SPCwR逆序切换窗口SPCws/-水平分割窗口SPCwS水平分割窗口，并切换至新窗口SPCwu恢复窗口布局SPCwU撤销恢复窗口布局SPCwv//垂直分离窗口SPCwV垂直分离窗口，并切换至新窗口SPCww切换至前一窗口SPCwW选择一个窗口#缓冲区SPC切换至前一缓冲区，常用于两个缓冲区来回切换SPCb.启用缓冲区临时快捷键SPCbb通过模糊搜索工具进行缓冲区切换，需要启用一个模糊搜索工具模块SPCbd删除当前缓冲区，但保留编辑窗口SPCbD选择一个窗口，并删除其缓冲区SPCbc删除其它已保存的缓冲区SPCbC-d删除其它所有缓冲区SPCbe清除当前缓冲区内容，需要手动确认SPCbh打开欢迎界面，等同于快捷键SPCasSPCbn切换至下一个缓冲区，排除特殊插件的缓冲区SPCbm打开消息缓冲区SPCbp切换至前一个缓冲区，排除特殊插件的缓冲区SPCbP使用系统剪切板内容替换当前缓冲区SPCbR从磁盘重新读取当前缓冲区所对应的文件SPCbw切换只读权限SPCbY将整个缓冲区复制到系统剪切板SPCbNh在左侧新建一个窗口，并在其中新建空白bufferSPCbNj在下方新建一个窗口，并在其中新建空白bufferSPCbNk在上方新建一个窗口，并在其中新建空白bufferSPCbNl在右侧新建一个窗口，并在其中新建空白bufferSPCbNn在当前窗口新建一个空白buffer#文件操作SPCf/使用find命令查找文件，支持参数提示SPCfb跳至文件书签SPCfCd修改文件编码unix->dosSPCfCu修改文件编码dos->unixSPCfD删除文件以及buffer，需要手动确认SPCff打开文件SPCfF打开光标下的文件SPCfo代开文件树，并定位到当前文件SPCfRrenamethecurrentfile(TODO)SPCfs/Ctrl-s保存文件(:w)SPCfW使用管理员模式保存SPCfS保存所有文件SPCfr打开文件历史SPCft切换侧栏文件树SPCfT打开文件树侧栏SPCfdWindows下显示/隐藏磁盘管理器SPCfy复制并显示当前文件的绝对路径#SPACEVIMSPCfvv复制并显示当前SpaceVim的版本SPCfvd打开SpaceVim的用户配置文件#错误处理SPCts切换语法检查器SPCec清除所有错误SPCehdescribeasyntaxcheckerSPCel切换显示错误/警告列表SPCen跳至下一错误SPCep跳至上一个错误SPCev验证语法检查器设置SPCe.错误暂态#quickfixql打开quickfix列表窗口qc清除quickfix列表qn跳到quickfix列表中下一个位置qp跳到quickfix列表中上一个位置#跳动到定义代码块```1gd```#关闭当前buffer```1Spacebd```","Tool\\vim\\vim-plug.md":"#vim配置##init.vim```callplug#begin('~/AppData/Local/nvim/plugged')Plug'scrooloose/nerdtree'\"文件树Plug'flazz/vim-colorschemes'\"主题Plug'jiangmiao/auto-pairs'\"成对插入符号Plug'pangloss/vim-javascript'\"代码高亮与显示缩进Plug'tpope/vim-commentary'\"备注Plug'mxw/vim-jsx'\"jsx语法包Plug'ap/vim-css-color'\"css颜色显示\"Plug'valloric/youcompleteme'\"代码提示Plug'mattn/emmet-vim'\"HTML补全Plug'posva/vim-vue'\"vue代码高亮Plug'scrooloose/syntastic'\"vue语法检查Plug'mxw/vim-jsx'\"jsx代码高亮Plug'neoclide/coc.nvim',{'branch':'release'}\"代码提示Plug'majutsushi/tagbar'\"预览代码结构Plug'machakann/vim-sandwich'\"环绕字符编辑(sandwich)\"Plug'marijnh/tern_for_vim'\"代码提示插件2,和上一个一起使用\"Plug'moll/vim-node'\"node的相关插件\"Plug'liuchengxu/vista.vim'\"\"Plug'tpope/vim-surround'\"添加、更改和删除标签callplug#end()\"*********************************************************************************\"代码提示coc.nvimletg:coc_global_extensions=['coc-json','coc-css','coc-html']\"*********************************************************************************\"分割窗口nnoremap<C-J><C-W><C-J>nnoremap<C-K><C-W><C-K>nnoremap<C-L><C-W><C-L>nnoremap<C-H><C-W><C-H>\"定义快捷键map<F8>:NERDTreeToggle<CR>\"文件树折叠nmap<F9>:TagbarToggle<CR>\"预览代码结构nmap<C-Z><CR>\"去掉这个快捷键,会导致我的机器卡死nmaplj^\"行首nmaplk$\"行末\"文件保存与退出nmapfw:w!<CR>\"强制保存nmapfq:q!<CR>\"强制保存与退出nmapfwq:wq!<CR>\"强制保存与退出\"代码折叠setfoldmethod=indent\"indent依缩进折叠；manual手动折叠；marker依标志折叠;syntax依语法折叠;expr依表达式折叠;diff折叠未被改动的行\"setfoldlevel=3nnoremap<space>zaletg:SimpylFold_docstring_preview=1letNERDTreeMapOpenInTab='<ENTER>'\"显示制图符setlistchars=tab:>-\"文件树\"自动打开autocmdvimenter*NERDTreeautocmdVimEnter*wincmdp\"vim设置\"*****************************************************************************\"VUE&React的配置auBufNewFile,BufRead*.html,*.js,*.vuesettabstop=2auBufNewFile,BufRead*.html,*.js,*.vuesetsofttabstop=2auBufNewFile,BufRead*.html,*.js,*.vuesetshiftwidth=2auBufNewFile,BufRead*.html,*.js,*.vuesetexpandtabauBufNewFile,BufRead*.html,*.js,*.vuesetautoindentauBufNewFile,BufRead*.html,*.js,*.vuesetfileformat=unixletg:syntastic_javascript_checkers=['eslint']\"配置eslint检查器letg:jsx_ext_required=0\"允许在普通JS文件中使用JSX\"*****************************************************************************colorschememolokai\"主题setfoldenablesetfdm=manual\"开启代码折叠\"添加js提示文件(补全)setdictionary+=C:/Users/ruihuag/AppData/Local/nvim/javascript.dictletg:ycm_min_num_of_chars_for_completion=3letg:ycm_autoclose_preview_window_after_completion=1letg:ycm_complete_in_comments=1letg:ycm_key_list_select_completion=['<c-n>','<Down>']letg:ycm_key_list_previous_completion=['<c-p>','<Up>']\"比较喜欢用tab来选择补全...\"function!MyTabFunction()\"letline=getline('.')\"letsubstr=strpart(line,-1,col('.')+1)\"letsubstr=matchstr(substr,\"[^\\t]*$\")\"ifstrlen(substr)==0\"return\"\\<tab>\"\"endif\"returnpumvisible()?\"\\<c-n>\":\"\\<c-x>\\<c-o>\"\"endfunction\"inoremap<tab><c-r>=MyTabFunction()<cr>\"****************************************************************************\"tap页切换\"alt+[number]:切换tap:nn<M-1>1gt:nn<M-2>2gt:nn<M-3>3gt:nn<M-4>4gt:nn<M-5>5gt:nn<M-6>6gt:nn<M-7>7gt:nn<M-8>8gt:nn<M-9>9gt:nn<M-0>:tablast<CR>\"****************************************************************************\"jsx语法包letg:jsx_ext_required=1letg:jsx_pragma_required=1letNERDTreeShowHidden=1\"显示隐藏文件settabstop=2setsofttabstop=4setshiftwidth=4setexpandtabsetautoindentsetfileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936settermencoding=utf-8setencoding=utf-8setnusetrelativenumber\"开启相对行数setclipboard=unnamed\"系统剪贴板letmapleader=';'\"定义leadersetbackspace=indent,eol,start\"backspace不能用时设置setnoswapfilesetclipboard=unnamed\"设置系统复制粘贴板sethlsearch\"搜索关键字高亮setincsearch\"输入搜索命令立即显示setencoding=utf-8setwrap\"主动换行setautoreadsetautowriteall\"让配置变更立即生效autocmdBufWritePost$MYVIMRCsource$MYVIMRC\"定义高亮highlightBadWhitespaceguifg=grayguibg=redctermfg=grayctermbg=redsetnobackup\"关闭.swp文件setnowritebackup\"auInsertLeave*.go,*.sh,*.pywrite\"退出插入模式指定类型的文件自动保存\"auInsertLeave*.js,*.jsonwrite\"****************************************************************************```##javascript.dict```#a#b#cconstconsoleclass#d#eexportextends#ffunction#g#h#iinfo#j#k#lloglet#mmodule#nnode#o#pPromiseProxy#q#rReactrequire()#s#t#u#vvarVue#w#x#y#z```","Tool\\vim\\vim.md":"#VIM>[Vim常用操作(juejin.cn)](https://juejin.cn/post/6847902217882746893)>编辑器>>-eclipsevim插件Vrapper>-修改快捷键windows->preferences->generals->keys>-输入vrapper然后就跨域修改vim快捷键了>-ctrl+b![](https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif)##常用指令|指令|描述||--------------------------------------------------------------------------------------------------------------|------------|---||`[数字]+指令`=>重复执行次数|||`:.,+n`=>指定当前行往下n行|||词单位移动右移动:`w|e`左移动:`b`|||文字最前:`^`行首:`0[零]`|||文字最后:`$`行末:`A`|||`ctrl-f`向后翻页`ctrl-b`向后翻页|||`zz`重绘屏幕，把当前行显示在窗口正中|||撤销:`u`,撤销上一个操作:`ctrl+r`|||首行`gg`,行末`G`|||全删:`ggdG`|||`ggVG`:全部复制|||`Ctrl-b`上一页，`Ctrl-f`下一页|||(:跳至上一句开头，**)**:跳至下一局开头<br/>**{**:上一段开头，**}**:下一段开头`[都是通过空行区分]`|||**H**将光标定位到屏幕的顶端**M**屏幕的中间**L**屏幕的底端|||`gv`重选上一次由可视模式选择的文本范围<br>`vi[符号]`:通过符号选择||###删除>行>>-从光标删除到行**末**`d$`>-从光标处删除到行**前**`d^`>-删除当行`dd`>-删除多行`*dd`[*:填行数]>-删除多词`d*[w/e]`>-`ci}`修改花括号内内容>-`dap`删除一个段落（以空行界定，段落后的空行也会删除）>>单词>>-`dw`从光标处删除至下一个单词的起始处(不保留单词间的空格)>-`de`从光标处删除至一个单词的末尾(就是会保留单词间的空格)###复制&粘贴>全部复制`ggVG`>>复制>>-单行复制`yy`>-多行复制`*yy`[*:填行数]>-选择部分复制`v`[进入可视模式]+通过光标移动选择要复制部分+`y`[复制]>>粘贴>>-粘贴到光标前`P`>-粘贴到光标后`p`>>将1-10行插入到第20行之后:`:1,10co20`=>(可以使用相对行数写法)##可视化模式###常用>`gv`重选上一次由可视模式选择的文本范围>>`vi[符号]`:通过符号选择>`v`:单字符模式>>`V`:行模式>>`ctrl+v`:列模式###选>**gv**重选上一次由可视模式选择的文本范围>>包含括号>>-**ab**选中括号中的内容>-**aB**选中{}括号中的内容>>不包含括号>>-**ib**选中括号中的内容>-**iB**选中{}中的内容>>通过符号选择>>-`vi+[符号]`高亮选中花括号中内容(符号可选:外逗号、单引号、双引号等也是一样的)>-**vi}**高亮选中花括号中内容>-**va}**高亮选中花括号及花括号中的内容。###操作>**U**选中块都转换成大写，**~**切换块中内容的大小写，>>**>**块右移，**<**块左移，>>**y**复制块，**d**删除块，**r**替换，**c**删除并进去插入模式>>-**I**和**A**进入插入模式，置光标于选块的开始和结尾(小写的不行)>-**o**跳转选中块的末端，**O**跳至首端##备注commentary|描述|操作||--------|---------------------------------------------------------------------------------------------------------------------||备注多行|visual模式选择要备注的代码内容输入`gc`||备注一行|直接在需要备注的行输入`gc`||替换指令|全部行首添加`//`:`:%s/^/\\/\\//g`<br/>在2-50行首添加`//`:`:2,50s/^/\\/\\//g`<br/>2-50行删除`//`:`:2,50s/^\\/\\///|##格式化代码>gg=G**将全部代码格式化**>>nG=mG**将第**n行到第**m**行的代码格式化>>自动缩进当前行指令`==`>>格式化当前光标接下来8行`8=`>>格式化选中行(v模式),再按`=`格式化代码代码段##文本转换>（1）**g~**反转大小写**gu**转小写**gU**转大写，（**gUU**当前行全传大写，还有**gUaW**[当前字]、**gUap**[当前段落]）>（2）~当前字符替换大小写##代码块折叠>`:setfoldmethod=manual`|指令(操作)|描述||----------|------------------------------------------|--------||zf56j|向下折叠56行||zf56G|创建从当前行起到56行的代码折叠||`zd`|`zo`|打开折叠||`zc`|再次折叠||zC|范围内所有嵌套的折叠点折叠||zO|对所在范围内所有嵌套的折叠点展开||zE|除去当前窗口所有折叠||zf%|折叠对应匹配的括号(要先移动到对应符号上)||zf|折叠选择的行[可视化模式下]||zfa(|折叠括号（比如()、[]、{}、><等）包围的区域||:mkview|保存当前的折叠状态||:loadview|载入记忆的折叠信息||||```text```##制表符号|指令|描述||------------------------------------------------------------|---------------------------|------------------|-----------------||`>>`||`<<`|可以缩进或缩出||`n>>`||`n<<`（n自然数）|可以缩进或缩出n次||visual状态,选定多行，用“n>或<n”(n为自然数)|缩进或缩出||：m,n>\\|\\|：m,n<(输入多个<\\|\\|>,就可移动对应对应数)|第m行到第n行左(右)移一个tab||:.,+3>|当前行往下及往下三行都右移|||||||##mark使用>`:mark标记名`:设置标签>>``标记名`:跳转到该标签##替换>c[number]motion>>`ce`:会进入插入模式|指令|描述||----|----------------------||`r`|替换当前光标选择的字符||`cw`|修改光标到该单词末尾|>`:s/old/new/g`:可以替换old为new>>`:#,#s/old/new/g`其中#,#代表的是替换操作的若干行中首尾两行的行号。>`:%s/old/new/g`则是替换整个文件中的每个匹配串。>`:%s/old/new/gc`会找到整个文件中的每个匹配串，并且对每个匹配串>提示是否进行替换。###替換（substitute）>```shell>:[range]s/pattern/string/[c,e,g,i]5.1>//我的常用写法>:.,+10s/pattern/string/g=>修改当前行往下十行>```|**range**|指的是範圍<br/>1,7指從第一行至第七行<br>a1,$指從第一行至最後一行，也可以%代表。還記得嗎？%是目前編輯的文章，#是前一次編輯的文章。||-----------|----------------------------------------------------------------------------------------------------------------------------------------||**pattern**|就是要被替換掉的字串，可以用regexp來表示。||**string**|將pattern由string所取代。||**c**|confirm，每次替換前會詢問。||**e**|不顯示error。||**g**|globe，不詢問，整行替換。||**i**|ignore不分大小寫。|>-`$`:最后一行>-`.`:第一行>-`%`:每一行>-当`/`是需要匹配的字符,可以使用`#`或`+`>-`:s#vivian/#sky/#替换当前行第一个vivian/为sky/`>-`:%s+/oradata/apras/+/user01/apras1+（使用+来替换/）：/oradata/apras/替换成/user01/apras1/````shell替换一行的字符:s/vivian/sky/替换当前行第一个vivian为sky:s/vivian/sky/g替换当前行所有vivian为sky替换第n行到最后一行$=>指向最后一行,若n位.则表示第一行开始:n,$s/vivian/sky/替换第n行开始到最后一行中每一行的第一个vivian为sky:n,$s/vivian/sky/g替换第n行开始到最后一行中每一行所有vivian为sky替换每一行的字符:%s/vivian/sky/（等同于:g/vivian/s//sky/）替换每一行的第一个vivian为sky:%s/vivian/sky/g（等同于:g/vivian/s//sky/g）替换每一行中所有vivian为sky可以使用#作为分隔符，此时中间出现的/不会作为分隔符:s#vivian/#sky/#替换当前行第一个vivian/为sky/:%s+/oradata/apras/+/user01/apras1+（使用+来替换/）：/oradata/apras/替换成/user01/apras1/:s/vivian/sky/替换当前行第一个vivian为sky:s/vivian/sky/g替换当前行所有vivian为sky:n,$s/vivian/sky/替换第n行开始到最后一行中每一行的第一个vivian为sky:n,$s/vivian/sky/g替换第n行开始到最后一行中每一行所有vivian为sky(n为数字，若n为.，表示从当前行开始到最后一行):%s/vivian/sky/（等同于:g/vivian/s//sky/）替换每一行的第一个vivian为sky:%s/vivian/sky/g（等同于:g/vivian/s//sky/g）替换每一行中所有vivian为sky可以使用#作为分隔符，此时中间出现的/不会作为分隔符:s#vivian/#sky/#替换当前行第一个vivian/为sky/利用:s命令可以实现字符串的替换。具体的用法包括：:s/str1/str2/用字符串str2替换行中首次出现的字符串str1:s/str1/str2/g用字符串str2替换行中所有出现的字符串str1:.,$s/str1/str2/g用字符串str2替换正文当前行到末尾所有出现的字符串str1:1,$s/str1/str2/g用字符串str2替换正文中所有出现的字符串str1:g/str1/s//str2/g功能同上从上述替换命令可以看到：g放在命令末尾，表示对搜索字符串的每次出现进行替换；不加g，表示只对搜索字符串的首次出现进行替换；g放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作。```###其他>换行:\\r##搜索类>`/+string`:以在当前文件中查找该字符串>>-`N`:上一个查找处>-`n`:下一个查找处##保存&退出>`!`:强制控制|命令|简单说明||:--:|:------------------------------------------------:||:w|保存,不退出||:wq|保存文件内容后退出,另外一种替代的方法是用ZZ命令。||ZZ|保存文件内容后退出||:q|在未做任何编辑处理而准备退出|##终端>-目前觉得不好用>>ter:打开终端>>exit退出##其他>3.输入:helpcmd可以找到关于cmd命令的帮助。>4.输入CTRL-WCTRL-W可以使您在窗口之间跳转。>5.输入:q以关闭帮助窗口>6.您可以创建一个vimrc启动脚本文件用来保存您偏好的设置。>7.当输入:命令时，按CTRL-D可以查看可能的补全结果。>按<TAB>可以使用一个补全。##浏览器vim>extension://aibcglbfblnogfjhbcmmpobjhnomhcdo/pages/options.html#commands>>-`o`:跳转到输入地址>-复制与window复制相通###网页滚动|指令|描述||----|------------||j|上滚||k|下滚||h|左滚||l|右滚||gg|滚到顶部||G|滚到底部||d|上滚半个页面||u|下滚半个页面|###常用指令|指令|描述||--------|--------------------------------||r|刷新页面||yy|复制当前链接||f|点击网页中的链接和按钮||t|新开一个页面||o[小写]|显示多功能搜索框||O[大写]|搜索混合内容,并在新的标签页打开||/|在业内查找模式||n|查找下一处||N|查找上一处||H|在历史记录后退||L|在历史记录中前进||K|切换到右边的标签页||J|切换到左边的标签页||g0|切换到最左侧的标签页||x|关闭标签||X|恢复最近关闭标签||<<\\|>>|左\\|右移动标签页|","Tool\\vscode\\api\\主题颜色.md":"#[`主题颜色`](https://code.visualstudio.com/api/references/theme-color)>-使用用户设置自定义活动的VisualStudioCode颜色主题。`workbench.colorCustomizations`>-翻译时间:`2022-11-2217:29:11````js{\"workbench.colorCustomizations\":{\"activityBar.background\":\"#00AA00\"}}```>注意:如果要使用现有颜色主题，请参阅颜色主题，您将了解如何通过“首选项:颜色主题”下拉列表（`Ctrl+K``Ctrl+T`）设置活动颜色主题。>主题颜色在Web视图中可用作CSS变量，并且有一个扩展可用于为它们提供智能感知。##颜色格式>-可以在RGB颜色模型中定义颜色值，并使用Alpha通道实现透明度。作为格式，支持以下十六进制表示法:`#RGB`，`#RGBA`，和`#RRGGBBAA`。R（红色）、G（绿色）、B（蓝色）和A（字母）是十六进制字符（0-9、a-f或A-F）。三位表示法（）是六位形式（）的较短版本，四位RGB表示法（）是八位形式（）的较短版本。例如是相同的颜色。#RGB#RGBA#RRGGBB#RRGGBBAA#RGB#RRGGBB#RGBA#RRGGBBAA#e35f#ee3355ff>-如果未定义alpha值，则默认为（不透明，无透明度）。如果设置为alpha，则颜色完全透明。ff00>-某些颜色不应不透明，以免覆盖其他注释。检查颜色说明以查看适用于哪些颜色##对比色对比度颜色通常仅针对高对比度主题设置。如果设置，它们会在UI中的项目周围添加额外的边框以增加对比度。contrastActiveBorder:活动元素周围多出边框，将它们与其他元素分开，对比度更高。contrastBorder:元素周围有额外的边框，以将它们与其他元素分开，以获得更大的对比度。##基色-`focusBorder`:聚焦元素的整体边框颜色。仅当未被组件覆盖时，才使用此颜色-`foreground`:整体前景色。仅当未被组件覆盖时，才使用此颜色-`disabledForeground`:禁用元素的整体前景。仅当未被组件覆盖时，才使用此颜色-`widget.shadow`:编辑器中的查找/替换等小部件的阴影颜色-`selection.background`:工作台中文本选择的背景色（对于输入字段或文本区域，不适用于编辑器和终端中的选择）-`descriptionForeground`:说明文本的前景色，提供附加信息，例如标签-`errorForeground`:错误消息的整体前景色（仅当未被组件覆盖时才使用此颜色）-`icon.foreground`:工作台中图标的默认颜色-`sash.hoverBorder`:可拖动窗框的悬停边框颜色##窗口边框>VSCode窗口边框的主题颜色。-`window.activeBorder`:活动（焦点）窗口的边框颜色。-`window.inactiveBorder`:非活动（未聚焦）窗口的边框颜色。##文本颜色>文本文档中的颜色，例如欢迎页面-`textBlockQuote.background`:文本中块引用的背景颜色-`textBlockQuote.border`:文本中块引号的边框颜色-`textCodeBlock.background`:文本中代码块的背景色-`textLink.activeForeground`:单击鼠标悬停时文本中链接的前景色-`textLink.foreground`:文本中链接的前景色-`textPreformat.foreground`:预设格式的文本段的前景色-`textSeparator.foreground`:文本分隔符的颜色##动作色>一组颜色，用于控制与整个工作台上的操作的交互-`toolbar.hoverBackground`:使用鼠标将鼠标悬停在操作上时的工具栏背景-`toolbar.hoverOutline`:使用鼠标将鼠标悬停在操作上时的工具栏轮廓-`toolbar.activeBackground`:将鼠标悬停在操作上时的工具栏背景##按钮控制>按钮微件的一组颜色，例如新窗口资源管理器中的“打开文件夹”按钮![](./.assets/主题颜色-2022-11-22-17-15-54.png)-`button.background`:按钮背景色-`button.foreground`:按钮前景色-`button.border`:按钮边框颜色-`button.separator`:按钮分隔符颜色-`button.hoverBackground`:悬停时按钮背景色-`button.secondaryForeground`:辅助按钮前景色-`button.secondaryBackground`:辅助按钮背景色-`button.secondaryHoverBackground`:悬停时辅助按钮背景色-`checkbox.background`:复选框小部件的背景颜色-`checkbox.foreground`:复选框构件的前景色-`checkbox.border`:复选框构件的边框颜色##下拉控件>所有下拉构件（例如在“集成终端”或“输出”面板中）的一组颜色。请注意，下拉控件目前未在macOS上使用![](./.assets/主题颜色-2022-11-22-17-23-04.png)-`dropdown.background`:下拉背景-`dropdown.listBackground`:下拉列表背景-`dropdown.border`:下拉边框-`dropdown.foreground`:下拉前景##输入控制>输入控件的颜色，例如在“搜索”视图或“查找/替换”对话框中![](./.assets/主题颜色-2022-11-22-17-23-57.png)-`input.background`:输入框背景-`input.border`:输入框边框-`input.foreground`:输入框前景-`input.placeholderForeground`:占位符文本的输入框前景色-`inputOption.activeBackground`:输入字段中已激活选项的背景颜色-`inputOption.activeBorder`:输入字段中已激活选项的边框颜色-`inputOption.activeForeground`:输入字段中已激活选项的前景色-`inputOption.hoverBackground`:输入字段中已激活选项的背景颜色-`inputValidation.errorBackground`:输入错误严重性的验证背景颜色-`inputValidation.errorForeground`:输入错误严重性的验证前景色-`inputValidation.errorBorder`:输入错误严重性的验证边框颜色-`inputValidation.infoBackground`:输入信息严重性的验证背景颜色-`inputValidation.infoForeground`:输入信息严重性的验证前景色-`inputValidation.infoBorder`:输入信息严重性的验证边框颜色-`inputValidation.warningBackground`:输入信息警告的验证背景颜色-`inputValidation.warningForeground`:输入验证前景色以表示警告严重性-`inputValidation.warningBorder`:输入警告严重性的验证边框颜色##滚动条控件-`scrollbar.shadow`:滚动条滑块阴影，指示视图已滚动-`scrollbarSlider.activeBackground`:单击时滚动条滑块背景颜色-`scrollbarSlider.background`:滚动条滑块背景色-`scrollbarSlider.hoverBackground`:悬停时滚动条滑块背景色##徽章>徽章是小信息标签，例如搜索结果计数-`badge.foreground`:徽章前景色-`badge.background`:徽章背景颜色##进度条`progressBar.background`:长时间运行的操作显示的进度条的背景色##列表和树>列表和树的颜色等，如文件资源管理器。活动列表/树具有键盘焦点，非活动列表/树没有-`list.activeSelectionBackground`:列表/树处于活动状态时所选项目的列表/树背景色-`list.activeSelectionForeground`:列表/树处于活动状态时所选项目的列表/树前景色-`list.activeSelectionIconForeground`:列表/树处于活动状态时所选项目的列表/树图标前景色。活动列表/树具有键盘焦点，非活动列表/树没有-`list.dropBackground`:使用鼠标移动项目时列表/树拖放背景-`list.focusBackground`:列表/树处于活动状态时焦点项目的列表/树背景颜色-`list.focusForeground`:列表/树处于活动状态时焦点项目的列表/树前景色。活动列表/树具有键盘焦点，非活动列表/树没有-`list.focusHighlightForeground`:在列表/树内搜索时，匹配项的列表/树前景色会突出显示活动焦点项目-`list.focusOutline`:列表/树处于活动状态时焦点项目的列表/树轮廓颜色。活动列表/树具有键盘焦点，非活动列表/树没有-`list.focusAndSelectionOutline`:当列表/树处于活动状态并选择时，焦点项目的列表/树轮廓颜色。活动列表/树具有键盘焦点，非活动列表/树没有-`list.highlightForeground`:在列表/树内搜索时匹配突出显示的列表/树前景色-`list.hoverBackground`:使用鼠标将鼠标悬停在项目上时的列表/树背景-`list.hoverForeground`:使用鼠标将鼠标悬停在项目上时的列表/树前景-`list.inactiveSelectionBackground`:列表/树处于非活动状态时所选项目的列表/树背景色-`list.inactiveSelectionForeground`:当列表/树处于非活动状态时，所选项目的列表/树前景色。活动列表/树具有键盘焦点，非活动列表/树没有-`list.inactiveSelectionIconForeground`:列表/树处于非活动状态时所选项目的列表/树图标前景色。活动列表/树具有键盘焦点，非活动列表/树没有-`list.inactiveFocusBackground`:当列表处于非活动状态时，焦点项目的列表背景色。活动列表具有键盘焦点，非活动列表没有。目前仅在列表中受支持-`list.inactiveFocusOutline`:列表/树处于非活动状态时焦点项目的列表/树轮廓颜色。活动列表/树具有键盘焦点，非活动列表/树没有-`list.invalidItemForeground`:无效项的列表/树前景色，例如资源管理器中未解析的根-`list.errorForeground`:包含错误的列表项的前景色-`list.warningForeground`:包含警告的列表项的前景色-`listFilterWidget.background`:列表/树在列表/树内搜索时过滤键入文本的背景颜色-`listFilterWidget.outline`:在列表/树内搜索时，列表/树过滤器小部件的键入文本的轮廓颜色-`listFilterWidget.noMatchesOutline`:在列表/树内搜索时未找到键入文本匹配项时的列表/树过滤器小部件的轮廓颜色-`listFilterWidget.shadow`:列表和树中类型过滤器小部件的缩减颜-`list.filterMatchBackground`:列表和树中筛选的匹配项的背景色-`list.filterMatchBorder`:列表和树中筛选的匹配项的边框颜色-`list.deemphasizedForeground`:取消强调的项目的列表/树前景色-`tree.indentGuidesStroke`:树构件的缩进参考线的描边颜色-`tree.tableColumnsBorder`:缩进参考线的树形描边颜色-`tree.tableOddRowsBackground`:奇数表行的背景色##活动栏>活动栏显示在工作台的最左侧或右侧，并允许在侧边栏的视图之间快速切换。-`activityBar.background`:活动栏背景色-`activityBar.dropBorder`:拖放活动栏项的反馈颜色。活动栏显示在最左侧或右侧，并允许在侧边栏的视图之间切换-`activityBar.foreground`:活动栏前景色（例如用于图标）-`activityBar.inactiveForeground`:活动栏项目处于非活动状态时的前景色-`activityBar.border`:活动栏边框颜色与侧边栏-`activityBarBadge.background`:活动通知徽章背景颜色-`activityBarBadge.foreground`:活动通知徽章前景色-`activityBar.activeBorder`:活动栏活动指示器边框颜色-`activityBar.activeBackground`:活动元素的活动栏可选背景色-`activityBar.activeFocusBorder`:活动项的活动栏焦点边框颜色-`activityBarItem.settingsProfilesForeground`:活动栏上设置配置文件条目的前景色-`activityBarItem.settingsProfilesHoverForeground`:悬停时活动栏上设置配置文件条目的前景色-`activityBarItem.settingsProfilesBackground`:活动栏上设置配置文件条目的背景色##侧边栏>侧边栏包含资源管理器和搜索等视图-`sideBar.background`:侧边栏背景颜色-`sideBar.foreground`:侧边栏前景色。侧边栏是资源管理器和搜索等视图的容器-`sideBar.border`:分隔编辑器一侧的侧边栏边框颜色-`sideBar.dropBackground`:拖放侧边栏部分的反馈颜色。颜色应具有透明度，以便侧边栏部分仍然可以发光-`sideBarTitle.foreground`:侧边栏标题前景色-`sideBarSectionHeader.background`:侧边栏部分标题背景颜色-`sideBarSectionHeader.foreground`:侧边栏部分标题前景色-`sideBarSectionHeader.border`:侧边栏部分标题边框颜色##小地图>小地图显示当前文件的缩小版本-`minimap.findMatchHighlight`:突出显示文件中搜索的匹配项的颜色-`minimap.selectionHighlight`:编辑器选择的高亮颜色-`minimap.errorHighlight`:突出显示编辑器中错误的颜色-`minimap.warningHighlight`:在编辑器中突出显示警告的颜色-`minimap.background`:小地图背景颜色-`minimap.selectionOccurrenceHighlight`:用于重复编辑器选择的小地图标记颜色-`minimap.foregroundOpacity`:小地图中渲染的前景元素的不透明度。例如，“#000000c0”将以75%的不透明度呈现元素-`minimapSlider.background`:小地图滑块背景色-`minimapSlider.hoverBackground`:悬停时的小地图滑块背景色-`minimapSlider.activeBackground`:点击时的小地图滑块背景色-`minimapGutter.addedBackground`:添加内容的小地图装订线颜色-`minimapGutter.modifiedBackground`:修改内容的小地图装订线颜色-`minimapGutter.deletedBackground`:已删除内容的小地图装订线颜色##编辑器组和选项卡>编辑器组是编辑器的容器。可以有许多编辑器组。选项卡是编辑器的容器。可以在一个编辑器组中打开多个选项卡编辑器组是编辑器的容器。可以有许多编辑器组。选项卡是编辑器的容器。可以在一个编辑器组中打开多个选项卡。-`editorGroup.border`:用于分隔多个编辑器组的颜色-![](./.assets/editorGroup-border.gif)-`editorGroup.dropBackground`:拖动编辑器时的背景色-![](./.assets/editorGroup-dropbackground.gif)-`editorGroupHeader.noTabsBackground`:禁用选项卡（设置）时编辑器组标题标题的背景色。`\"workbench.editor.showTabs\":false`-![](./.assets/editorgroupheader-notabsbackground.gif)-`editorGroupHeader.tabsBackground`:选项卡容器的背景色-![](./.assets/editorgroupheader-tabsbackground.gif)-`editorGroupHeader.tabsBorder`:启用选项卡时编辑器选项卡控件下方的边框颜色-![](./.assets/editorgroupheader-tabsborder.gif)-`editorGroupHeader.border`:编辑器组标题和编辑器之间的边框颜色（如果启用，则位于痕迹导航下方）-`editorGroup.emptyBackground`:空编辑器组的背景色-`editorGroup.focusedEmptyBorder`:获得焦点的空编辑器组的边框颜色-`editorGroup.dropIntoPromptForeground`:拖动文件时在编辑器上显示的文本的前景色。此文本通知用户可以按住shift键放入编辑器-`editorGroup.dropIntoPromptBackground`:拖动文件时在编辑器上显示的文本的背景色。此文本通知用户可以按住shift键放入编辑器-`editorGroup.dropIntoPromptBorder`:拖动文件时在编辑器上显示的文本的边框颜色。此文本通知用户可以按住shift键放入编辑器-`tab.activeBackground`:活动组中的活动选项卡背景色-`tab.unfocusedActiveBackground`:非活动编辑器组中的活动选项卡背景色-`tab.activeForeground`:活动组中的活动制表符前景色-`tab.border`:用于分隔制表符的边框-`tab.activeBorder`:活动选项卡的下边框-`tab.unfocusedActiveBorder`:非活动编辑器组中活动选项卡的下边框-`tab.activeBorderTop`:活动选项卡的上边框-`tab.unfocusedActiveBorderTop`:非活动编辑器组中活动选项卡的上边-`tab.lastPinnedBorder`:最后一个固定编辑器右侧的边框，用于与未固定的编辑器分开-`tab.inactiveBackground`:非活动选项卡背景色-`tab.unfocusedInactiveBackground`:非焦点组中的非活动选项卡背景-`tab.inactiveForeground`:活动组中的非活动制表符前景色-`tab.unfocusedActiveForeground`:非活动编辑器组中的活动选项卡前景色-`tab.unfocusedInactiveForeground`:非活动编辑器组中的非活动制表前景色-`tab.hoverBackground`:悬停时选项卡背景颜-`tab.unfocusedHoverBackground`:悬停时未聚焦组中的选项卡背景-`tab.hoverForeground`:悬停时选项卡前景-`tab.unfocusedHoverForeground`:悬停时在未对焦的组中使用前景色选项-`tab.hoverBorder`:悬停时突出显示标签页的边-`tab.unfocusedHoverBorder`:悬停时突出显示未聚焦组中的选项卡的边-`tab.activeModifiedBorder`:活动组中已修改（dirty）活动选项卡顶部的边框-`tab.inactiveModifiedBorder`:活动组中已修改（dirty）非活动选项卡顶部的边框-`tab.unfocusedActiveModifiedBorder`:未聚焦组中已修改（dirty）活动选项卡顶部的边框-`tab.unfocusedInactiveModifiedBorder`:未聚焦组中已修改（dirty）非活动选项卡顶部的边框-`editorPane.background`:编辑器窗格的背景色在居中的编辑器布局的左侧和右侧可见-`sideBySideEditor.horizontalBorder`:在编辑器组中从上到下并排显示时，用于将两个编辑器彼此分开的颜色-`sideBySideEditor.verticalBorder`:在编辑器组中从左到右并排显示时，用于将两个编辑器彼此分开的颜色##编辑器颜色>最突出的编辑器颜色是用于语法突出显示的标记颜色，并且基于安装的语言语法。这些颜色由颜色主题定义，但也可以使用设置进行自定义。有关更新颜色主题和可用令牌类型的详细信息，请参阅[自定义颜色主题](https://code.visualstudio.com/docs/getstarted/themes#_customizing-a-color-theme)。`editor.tokenColorCustomizations`###所有其他编辑器颜色-`editor.background`:编辑器背景色-`editor.foreground`:编辑器默认前景色-`editorLineNumber.foreground`:编辑器行号的颜色-`editorLineNumber.activeForeground`:活动编辑器行号的颜色-`editorCursor.background`:编辑器光标的背景色。允许自定义块光标重叠的字符的颜色-`editorCursor.foreground`:编辑器光标的颜色###选中高亮>选择一个或多个字符时，选择颜色可见。除了选择之外，还会突出显示具有相同内容的所有区域。![](./.assets/主题颜色-2022-11-22-20-48-16.png)-`editor.selectionBackground`:编辑器选择的颜色-`editor.selectionForeground`:所选文本的颜色以获得高对比度-`editor.inactiveSelectionBackground`:非活动编辑器中所选内容的颜色。颜色不得不透明，以免隐藏底层装饰-`editor.selectionHighlightBackground`:与所选内容相同的区域的颜色。颜色不得不透明，以免隐藏底层装饰-`editor.selectionHighlightBorder`:与所选内容相同的区域的边框颜色###选中单词高亮>当光标位于符号或单词内时，单词突出显示颜色可见。根据文件类型可用的语言支持，将突出显示所有匹配的引用和声明，并且读取和写入访问将获得不同的颜色。如果文档符号语言支持不可用，则回退到单词突出显示。![](./.assets/主题颜色-2022-11-22-20-50-39.png)-`editor.wordHighlightBackground`:读取访问期间符号的背景颜色，例如读取变量时。颜色不得不透明，以免隐藏底层装饰-`editor.wordHighlightBorder`:读取访问期间符号的边框颜色，例如读取变量时-`editor.wordHighlightStrongBackground`:写入访问期间符号的背景颜色，例如写入变量时。颜色不得不透明，以免隐藏底层装饰-`editor.wordHighlightStrongBorder`:写入访问期间符号的边框颜色，例如写入变量时###查找高亮>查找颜色取决于“查找/替换”对话框中的当前查找字符串![](./.assets/主题颜色-2022-11-22-20-52-03.png)-`editor.findMatchBackground`:当前搜索匹配项的颜色-`editor.findMatchHighlightBackground`:其他搜索匹配项的颜色。颜色不得不透明，以免隐藏底层装饰-`editor.findRangeHighlightBackground`:为限制搜索的范围着色（在查找小部件中启用“在所选内容中查找”）。颜色不得不透明，以免隐藏底层装饰-`editor.findMatchBorder`:当前搜索匹配项的边框颜色-`editor.findMatchHighlightBorder`:其他搜索匹配项的边框颜色-`editor.findRangeHighlightBorder`:边框颜色限制搜索的范围（在查找小部件中启用“在选择中查找”）###搜索编辑器>搜索编辑器颜色突出显示搜索编辑器中的结果。这可以与其他查找匹配项分开配置，以便在同一编辑器中更好地区分不同类别的匹配项。![](./.assets/主题颜色-2022-11-22-20-52-51.png)-`searchEditor.findMatchBackground`:编辑器结果的颜色-`searchEditor.findMatchBorder`:编辑器结果的边框颜色-`searchEditor.textInputBorder`:搜索编辑器文本输入框边框###悬浮高亮>悬停高亮显示显示在显示悬停的符号后面![](./.assets/主题颜色-2022-11-22-20-56-16.png)-`editor.hoverHighlightBackground`:突出显示显示悬停的字词下方。颜色不得不透明，以免隐藏底层装饰>当前线条通常显示为背景突出显示或边框（而不是两者）。![](./.assets/主题颜色-2022-11-22-20-56-59.png)-`editor.lineHighlightBackground`:光标位置处线条高亮显示的背景色-`editor.lineHighlightBorder`:光标位置处线条周围边框的背景色>统一码突出显示的颜色-`editorUnicodeHighlight.border`:用于突出显示unicode字符的边框颜色-`editorUnicodeHighlight.background`:用于突出显示unicode字符的背景色>单击链接时，链接颜色可见![](./.assets/主题颜色-2022-11-22-20-58-38.png)`editorLink.activeForeground`:活动链接的颜色>选择搜索结果时，范围突出显示可见![](./.assets/主题颜色-2022-11-22-20-59-12.png)-`editor.rangeHighlightBackground`:突出显示范围的背景色，由“快速打开”、“文件中的符号”和“查找”功能使用。颜色不得不透明，以免隐藏底层装饰-`editor.rangeHighlightBorder`:突出显示范围周围边框的背景色>通过诸如“转至定义”等命令导航到符号时，符号高亮显示可见-`editor.symbolHighlightBackground`:突出显示符号的背景颜色。颜色不得不透明，以免隐藏底层装饰-`editor.symbolHighlightBorder`:突出显示的符号周围边框的背景色>要查看编辑器空白，请启用切换渲染空白。-`editorWhitespace.foreground`:编辑器中空格字符的颜色>要查看编辑器缩进指南，请设置。\"editor.guides.indentation\":true\"editor.guides.highlightActiveIndentation\":true-`editorIndentGuide.background`:编辑器缩进参考线的颜色-`editorIndentGuide.activeBackground`:活动编辑器缩进参考线的颜色>要查看编辑器内联提示，请设置。\"editor.inlineSuggest.enabled\":true-`editorInlayHint.background`:内联提示的背景色-`editorInlayHint.foreground`:内联提示的前景色-`editorInlayHint.typeForeground`:类型的内联提示的前景色-`editorInlayHint.typeBackground`:类型的内联提示的背景色-`editorInlayHint.parameterForeground`:参数内联提示的前景色-`editorInlayHint.parameterBackground`:参数内联提示的背景色>要查看编辑器标尺，请使用\"editor.rulers\"-`editorRuler.foreground`:编辑器标尺的颜色-`editor.linkedEditingBackground`:编辑器处于链接编辑模式时的背景颜色代码镜头:![](./.assets/主题颜色-2022-11-22-21-01-15.png)-`editorCodeLens.foreground`:编辑器代码镜头的前景色灯泡:`editorLightBulb.foreground`:用于灯泡操作图标的颜色`editorLightBulbAutoFix.foreground`:用于灯泡自动修复操作图标的颜色###括号颜色![](./.assets/主题颜色-2022-11-22-20-28-01.png)-`editorBracketMatch.background`:匹配括号后面的背景色-`editorBracketMatch.border`:匹配括号框的颜色####支架对着色-`editorBracketHighlight.foreground1`:括号（1）的前景色。需要启用括号对着色-`editorBracketHighlight.foreground2`:括号（2）的前景色。需要启用括号对着色-`editorBracketHighlight.foreground3`:括号（3）的前景色。需要启用括号对着色-`editorBracketHighlight.foreground4`:括号（4）的前景色。需要启用括号对着色-`editorBracketHighlight.foreground5`:括号（5）的前景色。需要启用括号对着色-`editorBracketHighlight.foreground6`:方括号（6）的前景色。需要启用括号对着色-`editorBracketHighlight.unexpectedBracket.foreground`:意外括号的前景色####支架对导轨-`editorBracketPairGuide.activeBackground1`:活动支架对导轨的背景色（1）,需要启用支架对导轨-`editorBracketPairGuide.activeBackground2`:活动支架对导轨的背景色（2）,需要启用支架对导轨-`editorBracketPairGuide.activeBackground3`:主动支架对导轨的背景色（3）,需要启用支架对导轨-`editorBracketPairGuide.activeBackground4`:活动支架对导轨的背景色（4）,需要启用支架对导轨-`editorBracketPairGuide.activeBackground5`:活动支架对导轨的背景色（5）,需要启用支架对导轨-`editorBracketPairGuide.activeBackground6`:活动支架对导轨的背景色（6）,需要启用支架对导轨-`editorBracketPairGuide.background1`:非活动支架对导轨的背景颜色（1）,需要启用支架对导轨-`editorBracketPairGuide.background2`:非活动支架对导轨的背景颜色（2）,需要启用支架对导轨-`editorBracketPairGuide.background3`:非活动支架对导轨的背景色（3）,需要启用支架对导轨-`editorBracketPairGuide.background4`:非活动支架对导轨的背景色（4）,需要启用支架对导轨-`editorBracketPairGuide.background5`:非活动支架对导轨的背景色（5）,需要启用支架对导轨-`editorBracketPairGuide.background6`:非活动支架对导轨的背景色（6）,需要启用支架对导轨####折叠-`editor.foldBackground`:折叠范围的背景色。颜色不得不透明，以免隐藏底层装饰####概述标尺>此标尺位于编辑器右边缘的滚动条下方，用于概述编辑器中的装饰-`editorOverviewRuler.background`:编辑器概述标尺的背景色。仅在启用小地图并将其放置在编辑器右侧时使用-`editorOverviewRuler.border`:概览标尺边框的颜色-`editorOverviewRuler.findMatchForeground`:查找匹配项的概述标尺标记颜色。颜色不得不透明，以免隐藏底层装饰-`editorOverviewRuler.rangeHighlightForeground`:突出显示范围的概述标尺标记颜色，例如快速打开，文件中的符号和查找功能。颜色不得不透明，以免隐藏底层装饰-`editorOverviewRuler.selectionHighlightForeground`:用于选择高亮显示的概览标尺标记颜色。颜色不得不透明，以免隐藏底层装饰-`editorOverviewRuler.wordHighlightForeground`:符号高亮显示的概览标尺标记颜色。颜色不得不透明，以免隐藏底层装饰-`editorOverviewRuler.wordHighlightStrongForeground`:写入访问符号突出显示的概述标尺标记颜色。颜色不得不透明，以免隐藏底层装饰-`editorOverviewRuler.modifiedForeground`:已修改内容的概览标尺标记颜色-`editorOverviewRuler.addedForeground`:添加内容的概述标尺标记颜色-`editorOverviewRuler.deletedForeground`:已删除内容的概览标尺标记颜色-`editorOverviewRuler.errorForeground`:概述标尺标记颜色以显示错误-`editorOverviewRuler.warningForeground`:警告的概述标尺标记颜色-`editorOverviewRuler.infoForeground`:信息的概述标尺标记颜色-`editorOverviewRuler.bracketMatchForeground`:匹配方括号的概览标尺标记颜色####错误和警告-`editorError.foreground`:编辑器中错误波浪线的前景色-`editorError.border`:编辑器中错误框的边框颜色-`editorError.background`:编辑器中错误文本的背景色。颜色不得不透明，以免隐藏底层装饰-`editorWarning.foreground`:编辑器中警告波浪线的前景色-`editorWarning.border`:编辑器中警告框的边框颜色-`editorWarning.background`:编辑器中警告文本的背景色。颜色不得不透明，以免隐藏底层装饰-`editorInfo.foreground`:编辑器中信息波浪线的前景色-`editorInfo.border`:编辑器中信息框的边框颜色-`editorInfo.background`:编辑器中信息文本的背景色。颜色不得不透明，以免隐藏底层装饰-`editorHint.foreground`:编辑器中提示的前景色-`editorHint.border`:编辑器中提示框的边框颜色-`problemsErrorIcon.foreground`:用于问题错误图标的颜色-`problemsWarningIcon.foreground`:用于问题警告图标的颜色-`problemsInfoIcon.foreground`:用于问题信息图标的颜色####未使用的源代码-`editorUnnecessaryCode.border`:编辑器中不必要（未使用）源代码的边框颜色-`editorUnnecessaryCode.opacity`:编辑器中不必要（未使用）源代码的不透明度。例如，将以75%的不透明度呈现代码。对于高对比度主题，请使用主题颜色为不必要的代码添加下划线，而不是淡出它。``\"#000000c0\"\"editorUnnecessaryCode.border\"`####装订线包含字形边距和行号-`editorGutter.background`:编辑器装订线的背景色。装订线包含字形边距和行号-`editorGutter.modifiedBackground`:已修改线条的编辑器装订线背景色-`editorGutter.addedBackground`:添加的线条的编辑器装订线背景色-`editorGutter.deletedBackground`:删除线条的编辑器装订线背景色-`editorGutter.commentRangeForeground`:注释范围的编辑器装订线装饰颜色-`editorGutter.foldingControlForeground`:编辑器装订线中折叠控件的颜色####在查看拉取请求时可以看到编辑器注释小部件-`editorCommentsWidget.resolvedBorder`:边框和箭头的颜色，用于解决评论-`editorCommentsWidget.unresolvedBorder`:边框和箭头的颜色，用于未解决的评论-`editorCommentsWidget.rangeBackground`:注释范围的背景颜色-`editorCommentsWidget.rangeBorder`:注释范围的边框颜色-`editorCommentsWidget.rangeActiveBackground`:当前选定或悬停的评论范围的背景颜色-`editorCommentsWidget.rangeActiveBorder`:当前选定或悬停的注释范围的边框颜色##比较编辑器颜色>要为插入和删除的文本着色，请使用背景或边框颜色，但不能同时使用两者-`diffEditor.insertedTextBackground`:插入的文本的背景色。颜色不得不透明，以免隐藏底层装饰-`diffEditor.insertedTextBorder`:插入的文本的轮廓颜色-`diffEditor.removedTextBackground`:已删除文本的背景色。颜色不得不透明，以免隐藏底层装饰-`diffEditor.removedTextBorder`:已删除文本的轮廓颜色-`diffEditor.border`:两个文本编辑器之间的边框颜色-`diffEditor.diagonalFill`:比较编辑器对角线填充的颜色。对角线填充用于并排比较视图-`diffEditor.insertedLineBackground`:插入的线条的背景色。颜色不得不透明，以免隐藏底层装饰-`diffEditor.removedLineBackground`:已删除线条的背景色。颜色不得不透明，以免隐藏底层装饰-`diffEditorGutter.insertedLineBackground`:插入线条的边距的背景色-`diffEditorGutter.removedLineBackground`:删除线条的边距的背景色-`diffEditorOverview.insertedForeground`:插入内容的差异概述标尺前景-`diffEditorOverview.removedForeground`:已删除内容的差异概述标尺前景###编辑器微件颜色>“编辑器”微件显示在编辑器内容的前面。示例包括“查找/替换”对话框、建议微件和编辑器悬停-`editorWidget.foreground`:编辑器构件的前景色，例如查找/替换。-`editorWidget.background`:编辑器小部件的背景色，例如查找/替换。-`editorWidget.border`:编辑器构件的边框颜色，除非构件不包含边框或定义自己的边框颜色。-`editorWidget.resizeBorder`:编辑器微件大小调整栏的边框颜色。仅当构件选择具有调整边框大小且颜色未被微件覆盖时，才使用颜色。-`editorSuggestWidget.background`:建议微件的背景色。-`editorSuggestWidget.border`:建议微件的边框颜色。-`editorSuggestWidget.foreground`:建议微件的前景色。-`editorSuggestWidget.focusHighlightForeground`:聚焦项目时，建议微件中突出显示的匹配颜色。-`editorSuggestWidget.highlightForeground`:建议微件中匹配突出显示的颜色。-`editorSuggestWidget.selectedBackground`:建议微件中所选条目的背景色。-`editorSuggestWidget.selectedForeground`:建议构件中所选条目的前景色。-`editorSuggestWidget.selectedIconForeground`:建议微件中所选条目的图标前景色。-`editorSuggestWidgetStatus.foreground`:建议微件状态的前景色。-`editorHoverWidget.foreground`:编辑器悬停的前景色。-`editorHoverWidget.background`:编辑器悬停的背景色。-`editorHoverWidget.border`:编辑器悬停的边框颜色。-`editorHoverWidget.highlightForeground`:参数提示中活动项目的前景色。-`editorHoverWidget.statusBarBackground`:编辑器悬停状态栏的背景色。-`editorGhostText.border`:内联完成提供程序和建议预览显示的虚影文本的边框颜色。-`editorGhostText.background`:编辑器中虚影文本的背景色。-`editorGhostText.foreground`:内联完成提供程序和建议预览显示的虚影文本的前景色。-`editorStickyScroll.background`:编辑器粘滞滚动背景色-`editorStickyScrollHover.background`:悬停背景颜色上的编辑器粘滞滚动>“调试异常”小组件是一个速览视图，当调试在异常处停止时，该视图会显示在编辑器中。-`debugExceptionWidget.background`:异常小部件背景颜色。-`debugExceptionWidget.border`:异常小部件边框颜色。>导航到编辑器中的错误和警告时会显示编辑器标记视图（转到“下一个错误”或“警告”命令）。-`editorMarkerNavigation.background`:编辑器标记导航微件背景。-`editorMarkerNavigationError.background`:编辑器标记导航微件错误颜色。-`editorMarkerNavigationWarning.background`:编辑器标记导航微件警告颜色。-`editorMarkerNavigationInfo.background`:编辑器标记导航微件信息颜色。-`editorMarkerNavigationError.headerBackground`:编辑器标记导航小部件错误标题背景。-`editorMarkerNavigationWarning.headerBackground`:编辑器标记导航小部件警告标题背景。-`editorMarkerNavigationInfo.headerBackground`:编辑器标记导航微件信息标题背景。##速览视图颜色>速览视图用于将引用和声明显示为编辑器中的视图![](./.assets/主题颜色-2022-11-22-21-09-44.png)-`peekView.border`:速览视图边框和箭头的颜色-`peekViewEditor.background`:速览视图编辑器的背景色-`peekViewEditorGutter.background`:速览视图编辑器中装订线的背景色-`peekViewEditor.matchHighlightBackground`:在速览视图编辑器中匹配突出显示颜色-`peekViewEditor.matchHighlightBorder`:匹配速览视图编辑器中的高亮边框颜色-`peekViewResult.background`:速览视图结果列表的背景色-`peekViewResult.fileForeground`:速览视图结果列表中文件节点的前景色-`peekViewResult.lineForeground`:速览视图结果列表中线条节点的前景色-`peekViewResult.matchHighlightBackground`:匹配速览视图结果列表中的突出显示颜色-`peekViewResult.selectionBackground`:速览视图结果列表中所选条目的背景色-`peekViewResult.selectionForeground`:速览视图结果列表中所选条目的前景色-`peekViewTitle.background`:速览视图标题区域的背景色-`peekViewTitleDescription.foreground`:速览视图标题信息的颜色-`peekViewTitleLabel.foreground`:速览视图标题的颜色##合并冲突颜色>当编辑器包含特殊的差异范围时，将显示合并冲突修饰。![](./.assets/主题颜色-2022-11-22-21-11-44.png)-`merge.currentHeaderBackground`:内联合并冲突中的当前标头背景。颜色不得不透明，以免隐藏底层装饰-`merge.currentContentBackground`:内联合并冲突中的当前内容背景。颜色不得不透明，以免隐藏底层装饰-`merge.incomingHeaderBackground`:内联合并冲突中的传入标头背景。颜色不得不透明，以免隐藏底层装饰-`merge.incomingContentBackground`:内联合并冲突中的传入内容背景。颜色不得不透明，以免隐藏底层装饰-`merge.border`:标题上的边框颜色和内联合并中的拆分器冲突-`merge.commonContentBackground`:内联合并冲突中的常见祖先内容背景。颜色不得不透明，以免隐藏底层装饰-`merge.commonHeaderBackground`:内联合并冲突中的常见祖先标头背景。颜色不得不透明，以免隐藏底层装饰-`editorOverviewRuler.currentContentForeground`:内联合并冲突的当前概述标尺前景-`editorOverviewRuler.incomingContentForeground`:内联合并冲突的传入概述标尺前景-`editorOverviewRuler.commonContentForeground`:内联合并冲突的共同祖先概述标尺前景-`mergeEditor.change.background`:更改的背景色。-`mergeEditor.change.word.background`:单词的背景颜色发生变化。-`mergeEditor.conflict.unhandledUnfocused.border`:未处理的未聚焦冲突的边框颜色。-`mergeEditor.conflict.unhandledFocused.border`:未处理的焦点冲突的边框颜色。-`mergeEditor.conflict.handledUnfocused.border`:已处理的未聚焦冲突的边框颜色。-`mergeEditor.conflict.handledFocused.border`:已处理焦点冲突的边框颜色。-`mergeEditor.conflict.handled.minimapOverViewRuler`:输入1中更改的前景色。-`mergeEditor.conflict.unhandled.minimapOverViewRuler`:输入1中更改的前景色。-`mergeEditor.conflictingLines.background`:“冲突线”文本的背景。-`mergeEditor.changeBase.background`:基底变化的背景色。-`mergeEditor.changeBase.word.background`:单词的背景颜色在基数中发生变化。-`mergeEditor.conflict.input1.background`:输入1中装饰品的背景色。-`mergeEditor.conflict.input2.background`:输入2中装饰品的背景色。##面板颜色>面板显示在编辑器区域下方，包含输出和集成终端等视图。-`panel.background`:面板背景颜色-`panel.border`:面板边框颜色，用于将面板与编辑器分开-`panel.dropBorder`:拖放面板标题的反馈颜色。面板显示在编辑器区域下方，包含输出和集成终端等视图-`panelTitle.activeBorder`:活动面板标题的边框颜色-`panelTitle.activeForeground`:活动面板的标题颜色-`panelTitle.inactiveForeground`:非活动面板的标题颜色-`panelInput.border`:面板中输入的输入框边框-`panelSection.border`:在面板中水平堆叠多个视图时使用的面板部分边框颜色。面板显示在编辑器区域下方，包含输出和集成终端等视图-`panelSection.dropBackground`:拖放面板部分的反馈颜色。颜色应具有透明度，以便面板部分仍然可以发光。面板显示在编辑器区域下方，包含输出和集成终端等视图-`panelSectionHeader.background`:面板部分标题背景颜色。面板显示在编辑器区域下方，包含输出和集成终端等视图-`panelSectionHeader.foreground`:面板部分标题前景色。面板显示在编辑器区域下方，包含输出和集成终端等视图-`panelSectionHeader.border`:在面板中垂直堆叠多个视图时使用的面板部分标题边框颜色。面板显示在编辑器区域下方，包含输出和集成终端等视图##状态栏颜色>状态栏显示在工作台的底部-`statusBar.background`:标准状态栏背景色-`statusBar.foreground`:状态栏前景色-`statusBar.border`:分隔状态栏和编辑器的状态栏边框颜色-`statusBar.debuggingBackground`:调试程序时的状态栏背景色-`statusBar.debuggingForeground`:调试程序时的状态栏前景色-`statusBar.debuggingBorder`:状态栏边框颜色，用于在调试程序时分隔状态栏和编辑器-`statusBar.noFolderForeground`:未打开文件夹时的状态栏前景色-`statusBar.noFolderBackground`:未打开文件夹时的状态栏背景色-`statusBar.noFolderBorder`:状态栏边框颜色，未打开文件夹时分隔状态栏和编辑器-`statusBarItem.activeBackground`:单击时的状态栏项目背景色-`statusBarItem.hoverBackground`:悬停时的状态栏项目背景色-`statusBarItem.prominentForeground`:状态栏突出显示项目前景色-`statusBarItem.prominentBackground`:状态栏突出显示项目背景色-`statusBarItem.prominentHoverBackground`:悬停时状态栏突出显示项目背景颜色-`statusBarItem.remoteBackground`:状态栏上远程指示器的背景色-`statusBarItem.remoteForeground`:状态栏上远程指示器的前景色-`statusBarItem.errorBackground`:状态栏错误项背景色。错误项从其他状态栏条目中突出显示，以指示错误条件-`statusBarItem.errorForeground`:状态栏错误项目前景色。错误项从其他状态栏条目中突出显示，以指示错误条件-`statusBarItem.warningBackground`:状态栏警告项目背景色。警告项从其他状态栏条目中突出显示，以指示警告条件。状态栏显示在窗口底部-`statusBarItem.warningForeground`:状态栏警告项前景色。警告项从其他状态栏条目中突出显示，以指示警告条件。状态栏显示在窗口底部-`statusBarItem.compactHoverBackground`:将鼠标悬停在包含两个悬停器的项目上时的状态栏项目背景色。状态栏显示在窗口底部-`statusBarItem.focusBorder`:聚焦于键盘导航时的状态栏项目边框颜色。状态栏显示在窗口底部-`statusBar.focusBorder`:聚焦于键盘导航时的状态栏边框颜色。状态栏显示在窗口底部>突出显示的项目从其他状态栏条目中突出显示，以指示重要性。例如，切换Tab键移动焦点命令更改模式指示器。##标题栏颜色-`titleBar.activeBackground`:窗口处于活动状态时的标题栏背景-`titleBar.activeForeground`:窗口处于活动状态时的标题栏前景-`titleBar.inactiveBackground`:窗口处于非活动状态时的标题栏背景-`titleBar.inactiveForeground`:窗口处于非活动状态时的标题栏前景-`titleBar.border`:标题栏边框颜色##菜单栏颜色-`menubar.selectionForeground`:菜单栏中所选菜单项的前景色-`menubar.selectionBackground`:菜单栏中所选菜单项的背景色-`menubar.selectionBorder`:菜单栏中所选菜单项的边框颜色-`menu.foreground`:菜单项的前景色-`menu.background`:菜单项的背景色-`menu.selectionForeground`:菜单中所选菜单项的前景色-`menu.selectionBackground`:菜单中所选菜单项的背景色-`menu.selectionBorder`:菜单中所选菜单项的边框颜色-`menu.separatorBackground`:菜单中分隔符菜单项的颜色-`menu.border`:菜单的边框颜色##指挥中心颜色-`commandCenter.foreground`:指挥中心的前景色。-`commandCenter.activeForeground`:指挥中心的活动前景色。-`commandCenter.background`:指挥中心的背景色。-`commandCenter.activeBackground`:指挥中心的活动背景色。-`commandCenter.border`:指挥中心的边框颜色。-`commandCenter.inactiveForeground`:窗口处于非活动状态时命令中心的前景色。-`commandCenter.inactiveBorder`:窗口处于非活动状态时命令中心的边框颜色。##通知颜色>通知吐司从工作台的右下角向上滑动。![NotificationToasts](./.assets/主题颜色-2022-11-22-21-18-33.png)在通知中心打开后，它们将显示在带有标题的列表中:![NotificationCenter](./.assets/主题颜色-2022-11-22-21-19-02.png)-`notificationCenter.border`:通知中心边框颜色-`notificationCenterHeader.foreground`:通知中心页眉前景色-`notificationCenterHeader.background`:通知中心标题背景色-`notificationToast.border`:通知吐司边框颜色-`notifications.foreground`:通知前景色-`notifications.background`:通知背景色-`notifications.border`:通知边框颜色与通知中心中的其他通知分开-`notificationLink.foreground`:通知链接前景色-`notificationsErrorIcon.foreground`:用于通知错误图标的颜色-`notificationsWarningIcon.foreground`:用于通知警告图标的颜色-`notificationsInfoIcon.foreground`:用于通知信息图标的颜色##横幅颜色>横幅显示在标题栏下方，并在可见时跨越工作台的整个宽度-`banner.background`:横幅背景颜色-`banner.foreground`:横幅前景色-`banner.iconForeground`:横幅文本前面图标的颜色##扩展颜色-`extensionButton.prominentForeground`:扩展视图按钮前景色（例如“安装”按钮）-`extensionButton.prominentBackground`:扩展视图按钮背景色-`extensionButton.prominentHoverBackground`:扩展视图按钮背景悬停颜色-`extensionButton.background`:扩展操作的按钮背景色-`extensionButton.foreground`:扩展操作的按钮前景色-`extensionButton.hoverBackground`:扩展操作的按钮背景悬停颜色-`extensionButton.separator`:扩展操作的按钮分隔符颜色-`extensionBadge.remoteBackground`:扩展视图中远程徽章的背景颜色-`extensionBadge.remoteForeground`:扩展视图中远程锁屏提醒的前景色-`extensionIcon.starForeground`:扩展评级的图标颜色-`extensionIcon.verifiedForeground`:扩展程序验证发布者的图标颜色-`extensionIcon.preReleaseForeground`:预发布扩展的图标颜色-`extensionIcon.sponsorForeground`:扩展发起人的图标颜色##快速选择器颜色-`pickerGroup.border`:用于分组边框的快速选取器（快速打开）颜色-`pickerGroup.foreground`:用于标签分组的快速选取器（快速打开）颜色-`quickInput.background`:快速输入背景颜色。快速输入小部件是颜色主题选取器等视图的容器-`quickInput.foreground`:快速输入前景色。快速输入小部件是颜色主题选取器等视图的容器-`quickInputList.focusBackground`:焦点项目的快速选取器背景色-`quickInputList.focusForeground`:焦点项目的快速选取器前景色-`quickInputList.focusIconForeground`:焦点项目的快速选取器图标前景色-`quickInputTitle.background`:快速选取器标题背景颜色。快速选取器小组件是命令面板等选取器的容器##键绑定标签颜色>当存在与命令关联的键绑定时，将显示键绑定标签。可以在命令面板中看到键绑定标签的示例:![Keybindinglabel](./.assets/主题颜色-2022-11-22-21-21-57.png)键绑定标签的用法包括（但不限于）:-命令面板-键盘快捷键编辑器-键盘快捷键记录器模式-扩展市场页面的“功能贡献”部分以下自定义项可用:-`keybindingLabel.background`:键绑定标签背景颜色。键绑定标签用于表示键盘快捷键-`keybindingLabel.foreground`:键绑定标签前景色。键绑定标签用于表示键盘快捷键-`keybindingLabel.border`:键绑定标签边框颜色。键绑定标签用于表示键盘快捷键-`keybindingLabel.bottomBorder`:键绑定标签边框底部颜色。键绑定标签用于表示键盘快捷键##键盘快捷键表颜色-`keybindingTable.headerBackground`:键盘快捷键表格标题的背景色-`keybindingTable.rowsBackground`:键盘快捷键表交替行的背景色##集成端子颜色-`terminal.background`:集成终端视口的背景。-`terminal.border`:分隔终端内拆分窗格的边框的颜色。这默认为`panel.border`。-`terminal.foreground`:集成终端的默认前景色。-`terminal.ansiBlack`:终端中的“黑色”ANSI颜色。-`terminal.ansiBlue`:终端中的“蓝色”ANSI颜色。-`terminal.ansiBrightBlack`:终端中的“亮黑色”ANSI颜色。-`terminal.ansiBrightBlue`:终端中的“亮蓝色”ANSI颜色。-`terminal.ansiBrightCyan`:终端中的“亮青色”ANSI颜色。-`terminal.ansiBrightGreen`:终端中的“亮绿色”ANSI颜色。-`terminal.ansiBrightMagenta`:终端中的“亮洋红色”ANSI颜色。-`terminal.ansiBrightRed`:终端中的“亮红色”ANSI颜色。-`terminal.ansiBrightWhite`:终端中的“亮白色”ANSI颜色。-`terminal.ansiBrightYellow`:终端中的“亮黄色”ANSI颜色。-`terminal.ansiCyan`:终端中的“青色”ANSI颜色。-`terminal.ansiGreen`:终端中的“绿色”ANSI颜色。-`terminal.ansiMagenta`:终端中的“洋红色”ANSI颜色。-`terminal.ansiRed`:终端中的“红色”ANSI颜色。-`terminal.ansiWhite`:终端中的“白色”ANSI颜色。-`terminal.ansiYellow`:终端中的“黄色”ANSI颜色。-`terminal.selectionBackground`:终端的选择背景颜色。-`terminal.selectionForeground`:选择终端的前景色。当此值为null时，将保留选区前景并应用最小对比度功能。-`terminal.inactiveSelectionBackground`:终端没有焦点时的选择背景色。-`terminal.findMatchBackground`:终端中当前搜索匹配项的颜色。颜色不得不透明，以免隐藏底层终端内容。-`terminal.findMatchBorder`:终端中当前搜索匹配项的边框颜色。-`terminal.findMatchHighlightBackground`:终端中其他搜索匹配项的颜色。颜色不得不透明，以免隐藏底层终端内容。-`terminal.findMatchHighlightBorder`:终端中其他搜索匹配项的边框颜色。-`terminalCursor.background`:终端光标的背景色。允许自定义块光标重叠的字符的颜色。-`terminalCursor.foreground`:终端光标的前景色。-`terminal.dropBackground`:在终端顶部拖动时的背景色。颜色应具有透明度，以便终端内容物仍然可以发光。-`terminal.tab.activeBorder`:面板中终端选项卡一侧的边框。这默认为。`tab.activeBorder`-`terminalCommandDecoration.defaultBackground`:默认终端命令修饰背景色。-`terminalCommandDecoration.successBackground`:成功命令的终端命令装饰背景色。-`terminalCommandDecoration.errorBackground`:错误命令的终端命令修饰背景色。-`terminalOverviewRuler.cursorForeground`:概览标尺光标颜色。-`terminalOverviewRuler.findMatchForeground`:在终端中查找匹配项的概述标尺标记颜色。##调试颜色-`debugToolBar.background`:调试工具栏背景色。-`debugToolBar.border`:调试工具栏边框颜色。-`editor.stackFrameHighlightBackground`:编辑器中顶部堆栈帧高亮显示的背景色。-`editor.focusedStackFrameHighlightBackground`:编辑器中聚焦堆栈帧高亮显示的背景色。-`editor.inlineValuesForeground`:调试内联值文本的颜色。-`editor.inlineValuesBackground`:调试内联值背景的颜色。-`debugView.exceptionLabelForeground`:调试器因异常而中断时，“调用堆栈”视图中显示的标签的前景色-`debugView.exceptionLabelBackground`:调试器因异常而中断时在调用堆栈视图中显示的标签的背景色-`debugView.stateLabelForeground`:调用堆栈视图中标签的前景色，显示当前会话或线程的状态-`debugView.stateLabelBackground`:调用堆栈视图中标签的背景色，显示当前会话或线程的状态-`debugView.valueChangedHighlight`:用于突出显示调试视图中的值更改的颜色（即在变量视图中）-`debugTokenExpression.name`:调试视图（即“变量”或“监视”视图）中显示的令牌名称的前景色-`debugTokenExpression.value`:调试视图中显示的令牌值的前景色-`debugTokenExpression.string`:调试视图中字符串的前景色-`debugTokenExpression.boolean`:调试视图中布尔值的前景色-`debugTokenExpression.number`:调试视图中数字的前景色-`debugTokenExpression.error`:调试视图中表达式错误的前景色##测试颜色-`testing.iconFailed`:测试资源管理器中“失败”图标的颜色。-`testing.iconErrored`:测试资源管理器中“错误”图标的颜色。-`testing.iconPassed`:测试资源管理器中“通过”图标的颜色。-`testing.runAction`:编辑器中“运行”图标的颜色。-`testing.iconQueued`:测试资源管理器中“已排队”图标的颜色。-`testing.iconUnset`:测试资源管理器中“未设置”图标的颜色。-`testing.iconSkipped`:测试资源管理器中“跳过”图标的颜色。-`testing.peekBorder`:速览视图边框和箭头的颜色。-`testing.peekHeaderBackground`:速览视图边框和箭头的颜色。-`testing.message.error.decorationForeground`:在编辑器中以内联方式显示的测试错误消息的文本颜色。-`testing.message.error.lineBackground`:编辑器中以内联方式显示的错误消息旁边的边距颜色。-`testing.message.info.decorationForeground`:在编辑器中内联显示的测试信息消息的文本颜色。-`testing.message.info.lineBackground`:在编辑器中以内联方式显示的信息消息旁边的边距颜色。##欢迎页面颜色-`welcomePage.background`:欢迎页面的背景色-`welcomePage.progress.background`:欢迎页面进度条的前景色-`welcomePage.progress.foreground`:欢迎页面进度条的背景色-`welcomePage.tileBackground`:“入门”页面上磁贴的背景色-`welcomePage.tileHoverBackground`:将鼠标悬停在“入门”上的磁贴背景颜色-`welcomePage.tileShadow`:欢迎页面演练类别按钮的阴影颜色-`walkThrough.embeddedEditorBackground`:交互式操场上嵌入式编辑器的背景色##源代码管理颜色-`scm.providerBorder`:`SCM`提供程序分隔符边框。##吉特颜色-`gitDecoration.addedResourceForeground`:添加的Git资源的颜色。用于文件标签和SCM查看器。-`gitDecoration.modifiedResourceForeground`:修改后的Git资源的颜色。用于文件标签和SCM查看器。-`gitDecoration.deletedResourceForeground`:已删除Git资源的颜色。用于文件标签和SCM查看器。-`gitDecoration.renamedResourceForeground`:重命名或复制的Git资源的颜色。用于文件标签和SCM查看器。-`gitDecoration.stageModifiedResourceForeground`:分阶段修改git装饰的颜色。用于文件标签和SCM查看器。-`gitDecoration.stageDeletedResourceForeground`:分阶段删除git装饰的颜色。用于文件标签和SCM查看器。-`gitDecoration.untrackedResourceForeground`:未跟踪的Git资源的颜色。用于文件标签和SCM查看器。-`gitDecoration.ignoredResourceForeground`:忽略的Git资源的颜色。用于文件标签和SCM查看器。-`gitDecoration.conflictingResourceForeground`:冲突的Git资源的颜色。用于文件标签和SCM查看器。-`gitDecoration.submoduleResourceForeground`:子模块资源的颜色。##设置编辑器颜色>注意:这些颜色适用于可以使用命令打开的GUI设置编辑器。`Preferences:OpenSettings(UI)`-`settings.headerForeground`:节标题或活动标题的前景色。-`settings.modifiedItemIndicator`:指示已修改设置的行。-`settings.dropdownBackground`:下拉背景。-`settings.dropdownForeground`:下拉前景。-`settings.dropdownBorder`:下拉边框。-`settings.dropdownListBorder`:下拉列表边框。-`settings.checkboxBackground`:复选框背景。-`settings.checkboxForeground`:复选框前景。-`settings.checkboxBorder`:复选框边框。-`settings.rowHoverBackground`:悬停时设置行的背景色。-`settings.textInputBackground`:文本输入框背景。-`settings.textInputForeground`:文本输入框前景。-`settings.textInputBorder`:文本输入框边框。-`settings.numberInputBackground`:数字输入框背景。-`settings.numberInputForeground`:数字输入框前景。-`settings.numberInputBorder`:数字输入框边框。-`settings.focusedRowBackground`:焦点设置行的背景色。-`settings.focusedRowBorder`:行聚焦时行的上边框和下边框的颜色。-`settings.headerBorder`:标题容器边框的颜色。-`settings.sashBorder`:设置编辑器分割视图窗扇边框的颜色。##面包屑颜色痕迹导航的主题颜色:-`breadcrumb.foreground`:面包屑物品的颜色。-`breadcrumb.background`:面包屑项目的背景色。-`breadcrumb.focusForeground`:重点面包屑项目的颜色。-`breadcrumb.activeSelectionForeground`:所选痕迹导航项目的颜色。-`breadcrumbPicker.background`:痕迹导航项选取器的背景色。##代码段颜色片段的主题颜色:-`editor.snippetTabstopHighlightBackground`:突出显示代码段制表位的背景色-`editor.snippetTabstopHighlightBorder`:突出显示代码段制表位的边框颜色-`editor.snippetFinalTabstopHighlightBackground`:突出显示代码段的最后一个制表位的背景色-`editor.snippetFinalTabstopHighlightBorder`:突出显示代码段最后一个制表位的边框颜色##符号图标颜色显示在大纲视图、痕迹导航和建议微件中的符号图标的主题颜色:-`symbolIcon.arrayForeground`:数组符号的前景色-`symbolIcon.booleanForeground`:布尔符号的前景色-`symbolIcon.classForeground`:类符号的前景色-`symbolIcon.colorForeground`:颜色符号的前景色-`symbolIcon.constantForeground`:常量符号的前景色-`symbolIcon.constructorForeground`:构造函数符号的前景色-`symbolIcon.enumeratorForeground`:枚举器符号的前景色-`symbolIcon.enumeratorMemberForeground`:枚举器成员符号的前景色-`symbolIcon.eventForeground`:事件符号的前景色-`symbolIcon.fieldForeground`:字段符号的前景色-`symbolIcon.fileForeground`:文件元件的前景色-`symbolIcon.folderForeground`:文件夹元件的前景色-`symbolIcon.functionForeground`:函数符号的前景色-`symbolIcon.interfaceForeground`:界面符号的前景色-`symbolIcon.keyForeground`:关键符号的前景色-`symbolIcon.keywordForeground`:关键字符号的前景色-`symbolIcon.methodForeground`:方法符号的前景色-`symbolIcon.moduleForeground`:模块符号的前景色-`symbolIcon.namespaceForeground`:命名空间符号的前景色-`symbolIcon.nullForeground`:空符号的前景色-`symbolIcon.numberForeground`:数字符号的前景色-`symbolIcon.objectForeground`:对象符号的前景色-`symbolIcon.operatorForeground`:运算符符号的前景色-`symbolIcon.packageForeground`:包符号的前景色-`symbolIcon.propertyForeground`:属性符号的前景色-`symbolIcon.referenceForeground`:参考符号的前景色-`symbolIcon.snippetForeground`:代码段符号的前景色-`symbolIcon.stringForeground`:字符串符号的前景色-`symbolIcon.structForeground`:结构符号的前景色-`symbolIcon.textForeground`:文本符号的前景色-`symbolIcon.typeParameterForeground`:类型参数符号的前景色-`symbolIcon.unitForeground`:单位符号的前景色-`symbolIcon.variableForeground`:可变符号的前景色##调试图标颜色-`debugIcon.breakpointForeground`:断点的图标颜色-`debugIcon.breakpointDisabledForeground`:禁用断点的图标颜色-`debugIcon.breakpointUnverifiedForeground`:未经验证的断点的图标颜色-`debugIcon.breakpointCurrentStackframeForeground`:当前断点堆栈帧的图标颜色-`debugIcon.breakpointStackframeForeground`:所有断点堆栈帧的图标颜色-`debugIcon.startForeground`:用于开始调试的调试工具栏图标-`debugIcon.pauseForeground`:用于暂停的调试工具栏图标-`debugIcon.stopForeground`:停止的调试工具栏图标-`debugIcon.disconnectForeground`:用于断开连接的调试工具栏图标-`debugIcon.restartForeground`:用于重新启动的调试工具栏图标-`debugIcon.stepOverForeground`:用于跨步执行的调试工具栏图标-`debugIcon.stepIntoForeground`:用于单步执行的调试工具栏图标-`debugIcon.stepOutForeground`:用于跨步执行的调试工具栏图标-`debugIcon.continueForeground`:用于继续的调试工具栏图标-`debugIcon.stepBackForeground`:用于后退的调试工具栏图标-`debugConsole.infoForeground`:调试REPL控制台中信息消息的前景色-`debugConsole.warningForeground`:调试REPL控制台中警告消息的前景色-`debugConsole.errorForeground`:调试REPL控制台中错误消息的前景色-`debugConsole.sourceForeground`:调试REPL控制台中源文件名的前景色-`debugConsoleInputIcon.foreground`:调试控制台输入标记图标的前景色##笔记本颜色-`notebook.editorBackground`:笔记本背景色-`notebook.cellBorderColor`:笔记本单元格的边框颜色-`notebook.cellHoverBackground`:悬停单元格时单元格的背景色-`notebook.cellInsertionIndicator`:笔记本单元格插入指示器的颜色-`notebook.cellStatusBarItemHoverBackground`:笔记本单元格状态栏项目的背景色-`notebook.cellToolbarSeparator`:单元格底部工具栏中分隔符的颜-`notebook.cellEditorBackground`:笔记本单元格编辑器背景的颜-`notebook.focusedCellBackground`:聚焦单元格时单元格的背景色-`notebook.focusedCellBorder`:单元格聚焦时单元格焦点指示器边框的颜色-`notebook.focusedEditorBorder`:笔记本单元格编辑器边框的颜色-`notebook.inactiveFocusedCellBorder`:当主要焦点位于编辑器外部时，单元格聚焦时单元格的上边框和下边框的颜色-`notebook.inactiveSelectedCellBorder`:选择多个单元格时单元格边框的颜色-`notebook.outputContainerBackgroundColor`:笔记本输出容器背景的颜色-`notebook.outputContainerBorderColor`:笔记本输出容器的边框颜色-`notebook.selectedCellBackground`:选择单元格时单元格的背景色-`notebook.selectedCellBorder`:单元格处于选中状态但未聚焦时单元格的上边框和下边框的颜色-`notebook.symbolHighlightBackground`:突出显示单元格的背景-`notebookScrollbarSlider.activeBackground`:单击时笔记本滚动条滑块背景色-`notebookScrollbarSlider.background`:笔记本滚动条滑块背景色-`notebookScrollbarSlider.hoverBackground`:悬停时笔记本滚动条滑块背景色-`notebookStatusErrorIcon.foreground`:单元格状态栏中笔记本单元格的错误图标颜色-`notebookStatusRunningIcon.foreground`:单元格状态栏中笔记本单元格的运行图标颜色-`notebookStatusSuccessIcon.foreground`:单元格状态栏中笔记本单元格的成功图标颜色##图表颜色-`charts.foreground`:图表中文本的对比度颜色。-`charts.lines`:图表中线条的颜色。-`charts.red`:图表中红色元素的颜色。-`charts.blue`:图表中蓝色元素的颜色。-`charts.yellow`:图表中黄色元素的颜色。-`charts.orange`:图表中橙色元素的颜色。-`charts.green`:图表中绿色元素的颜色。-`charts.purple`:图表中紫色元素的颜色。##端口颜色-`ports.iconRunningProcessForeground`:具有关联正在运行的进程的端口的图标颜色##扩展颜色颜色ID也可以通过颜色贡献点的扩展来贡献。在设置和颜色主题定义文件中使用代码完成时，也会显示这些颜色。用户可以在扩展贡献选项卡中查看扩展定义的颜色。`workbench.colorCustomizations`","Tool\\vscode\\api\\常用.md":"#常用API##文件操作###读取指定文件```tsxconstdocument=awaitvscode.workspace.openTextDocument(uri)document.getText()```###写入指定文件```tsx//写入文件vscode.workspace.fs.writeFile(uri:Uri,content:Uint8Array):Thenable<void>;//Uri拼接vscode.Uri.joinPath(base:Uri,...pathSegments:string[]):Uri;//JS对象转Uint8ArrayBuffer.from(JSON.stringify({},null,2));```###打开指定文件```tsxvscode.window.showTextDocument(uri:Uri,options?:TextDocumentShowOptions):Thenable<TextEditor>;;```###读写系统剪切板```tsx//读取vscode.env.clipboard.readText():Thenable<string>;//写入vscode.env.clipboard.writeText(value:string):Thenable<void>;```##编辑器操作###获取当前激活编辑器```tsxconst{document,selection}=vscode.window.activeTextEditor;document.uri;//获取编辑文件Uridocument.getText();//获取编辑器文本内容document.getText(selection);//获取选中部分内容```##提示交互###设置底部状态栏消息```tsxvscode.window.setStatusBarMessage(text:string,hideAfterTimeout:number):Disposable;```###弹出底部消息提示```tsx//提示消息vscode.window.showInformationMessage(message:string):Thenable<string|undefined>;//警告消息vscode.window.showWarningMessage(message:string):Thenable<string|undefined>;//错误消息vscode.window.showErrorMessage(message:string):Thenable<string|undefined>;```##其他###执行指定命令```tsxvscode.commands.executeCommand('vscode.openWith',resource,editor);```","Tool\\vscode\\develop plugin\\error.md":"#兼容性##PersonalAccessTokens过期```shellERROR{\"$id\":\"1\",\"customProperties\":{\"Descriptor\":null,\"IdentityDisplayName\":null,\"Token\":null,\"RequestedPermissions\":0,\"NamespaceId\":\"00000000-0000-0000-0000-000000000000\"},\"innerException\":null,\"message\":\"AccessDenied:ThePersonalAccessTokenusedhasexpired.\",\"typeName\":\"Microsoft.VisualStudio.Services.Security.AccessCheckException,Microsoft.VisualStudio.Services.WebApi\",\"typeKey\":\"AccessCheckException\",\"errorCode\":0,\"eventId\":3000}You'reusinganexpiredPersonalAccessToken,pleasegetanewPAT.Moreinfo:<https://aka.ms/vscodepat>```![](./.assets/error-2024-04-07-16-40-44.png)-解决:去<https://dev.azure.com/>![](./.assets/error-2024-04-07-16-45-09.png)-查看Status是否过期,过期则通过Regenerate修改过期时间-再次发布即可##`pnpm`与`vsce`不兼容-切换为`yarn`,重新安装依赖-使用的命令后面添加`--no-yarn`,及可以正常发布和打包","Tool\\vscode\\develop plugin\\index.md":"#VSCode插件开发-[学习](https://blog.haoji.me/vscode-plugin-overview.html)>[YourFirstExtension|VisualStudioCodeExtensionAPI](https://code.visualstudio.com/api/get-started/your-first-extension)>>`npminstall-gyogenerator-code`##组件开发```shellyocode```###选择要开发的类型```NewExtension(TypeScript)//基于TS的插件NewExtension(JavaScript)//基于JS的插件NewColorTheme//颜色主题NewLanguageSupport//语言支持NewCodeSnippets//代码片段NewKeymap//键值映射NewExtensionPackNewLanuagePack(Localization)//语言包NewNotebookRenderer(TypeScript)```###填写对应信息1.插件的名称2.插件的id，最终会和你的开发者账号做拼接。比如大帅的开发者账号叫ezshine，最终会拼接为`ezshine.插件id`3.插件的介绍4.是否开启类型检查5.初始化git仓库（不是非要开启，以后手动开也行）6.选择使用npm还是yarn来管理依赖","Tool\\vscode\\develop plugin\\temp.md":"#VScodePlugin##配置>在`package.json````js{...\"contributes\":{//代码片段\"snippets\":[{\"language\":\"vue\",\"path\":\"./src/snippets/vue.json\"}],//活动页的Tab\"viewsContainers\":{\"activitybar\":[{\"id\":\"ruihuag-helper-icon\",\"title\":\"Helper\",\"icon\":\"./images/logo.png\"}]},//活动页菜单树\"views\":{\"ruihuag-helper-icon\":[{\"id\":\"c1\",\"name\":\"\"}]},//自定义命令\"commands\":[{\"command\":\"ruihuag-helper.nav\",\"title\":\"导航栏(ruihuag)\"},{\"command\":\"ruihuag-helper.progress\",\"title\":\"显示进度条\"}],\"menus\":{//文件内容右击菜单\"editor/context\":[{\"when\":\"editorFocus\",\"command\":\"ruihuag-helper.progress\",\"group\":\"navigation\"},{\"when\":\"editorFocus\",\"command\":\"ruihuag-helper.nav\",\"group\":\"navigation\"}],//编辑菜单\"editor/title\":[{\"when\":\"editorFocus\",\"command\":\"ruihuag-helper.nav\",\"group\":\"navigation\"},{\"when\":\"editorFocus\",\"command\":\"ruihuag-helper.progress\",\"group\":\"navigation\"}]}},...}```##注册相关事件等###constant.ts```tsexportconstnamespace='ruihuag-helper'```###hover.ts>鼠标悬浮提示信息```tsimportvscodefrom'vscode'importpathfrom'path'exportconsthover=vscode.languages.registerHoverProvider('javascript',{provideHover(document:any,position:any,token:any){constfileName=document.fileNameconstworkDir=path.dirname(fileName)constword=document.getText(document.getWordRangeAtPosition(position))//console.log(1,document)//console.log(2,position)//console.log(3,token)console.log(4,'这个就是悬停的文字',word)//支持markdown语法returnnewvscode.Hover(`###我就是返回的信息!1.第一项：-第一个元素-第二个元素2.第二项：-第一个元素-第二个元素`,)},})```###tree.ts```tsimport*asvscodefrom'vscode'constc1Tree={Snippets:{vue:{st:'script-template',stts:'script-template-ts',},},}constaNodeWithIdTreeDataProvider={getTreeItem:(el:any)=>{lettreeItem={}if(typeofel==='string'){treeItem={label:el,collapsibleState:0,tooltip:'hover:单纯的字符串',//id:newDate().getTime()}}else{treeItem={label:el._cc_key,collapsibleState:1,tooltip:'hover:可展开',//id:newDate().getTime()}}returntreeItem},getChildren:(el:any)=>{constarr=[]consttree=el||c1Treefor(letitemintree){constactiveItem=tree[item]if(typeofactiveItem!=='object'){arr.push(`${item}：${activeItem}`)}else{Object.defineProperty(activeItem,'_cc_key',{get:function(){returnitem},enumerable:false,})arr.push(activeItem)}}returnarr},}exportconsttree=vscode.window.createTreeView('c1',{treeDataProvider:aNodeWithIdTreeDataProvider,showCollapseAll:true,})```###progress.ts>带有状态的弹框```tsimport*asvscodefrom'vscode'import{namespace}from'./constant'exportconstprogress=vscode.commands.registerCommand(namespace+'.progress',function(){vscode.window.withProgress({location:vscode.ProgressLocation.Notification,title:'载入xxxx的进度...',cancellable:true,},(progress)=>{//初始化进度progress.report({increment:0})setTimeout(()=>{progress.report({increment:10,message:'在努力。。。.'})},1000)setTimeout(()=>{progress.report({increment:40,message:'马上了...'})},2000)setTimeout(()=>{progress.report({increment:50,message:'这就结束...'})},3000)constp=newPromise((resolve)=>{setTimeout(()=>{resolve({})},5000)})returnp},)},)```###navigation.ts>弹出信息框```tsimport*asvscodefrom'vscode'import{namespace}from'./constant'exportconstnav=vscode.commands.registerCommand(namespace+'.nav',function(){letday=newDate()day.setTime(day.getTime()+24*60*60*1000)letdate=day.getFullYear()+'-'+(day.getMonth()+1)+'-'+day.getDate()vscode.window.showInformationMessage(`明天是:${date}`)/**vscode.window.showInformationMessage('第一个demo弹出信息!')vscode.window.showWarningMessage('第一个警告信息')vscode.window.showErrorMessage('第一个错误信息!')*/},)```###extension.ts>事件挂载处```jsimport*asvscodefrom'vscode'import{nav}from'./navigation'import{progress}from'./progress'import{hover}from'./hover'import{tree}from'./tree'exportfunctionactivate(context:vscode.ExtensionContext){context.subscriptions.push(nav)context.subscriptions.push(tree)context.subscriptions.push(hover)context.subscriptions.push(progress)}exportfunctiondeactivate(){}```","Tool\\vscode\\develop plugin\\制作插件.md":"#vsocde插件开发```shellnpminstall-gyogenerator-codeyocode```![](./.assets/制作插件-2022-10-21-10-03-23.png)对应意思:-新的插件（Typescript）-新的插件（JavaScript）-新的主题颜色-新的语言支持-新的代码片段-新的键值绑定-新的插件包-新的语言包（本土化）```json{\"name\":\"test-extension\",//插件的名字\"displayName\":\"test-extension\",//在插件市场展示的名字\"description\":\"vscodeextensionsample\",//插件描述\"version\":\"0.0.1\",//插件版本\"engines\":{//最低支持vscode的版本\"vscode\":\"^1.52.0\"},\"categories\":[//插件的类别，用于在插件市场做区分\"Other\"],\"activationEvents\":[//插件激活的事件列表，可以有多个触发机制，所以是数组形式\"onCommand:test-extension.helloWorld\"//\"*\"//插件一开始就激活并注册事件],\"main\":\"./extension.js\",//插件主入口\"contributes\":{//贡献点，用于拓展插件功能的配置项，这里不会细讲，先用command举例\"commands\":[{\"command\":\"test-extension.helloWorld\",\"title\":\"HelloWorld\"}]},\"scripts\":{\"vscode:prepublish\":\"pnpmrunpackage\",\"compile\":\"webpack\",\"watch\":\"webpack--watch\",\"package\":\"webpack--modeproduction--devtoolhidden-source-map\",\"compile-tests\":\"tsc-p.--outDirout\",\"watch-tests\":\"tsc-p.-w--outDirout\",\"pretest\":\"pnpmruncompile-tests&&pnpmruncompile&&pnpmrunlint\",\"lint\":\"eslintsrc--extts\",\"test\":\"node./out/test/runTest.js\"},\"devDependencies\":{\"@types/vscode\":\"^1.72.0\",\"@types/glob\":\"^8.0.0\",\"@types/mocha\":\"^10.0.0\",\"@types/node\":\"16.x\",\"@typescript-eslint/eslint-plugin\":\"^5.38.1\",\"@typescript-eslint/parser\":\"^5.38.1\",\"eslint\":\"^8.24.0\",\"glob\":\"^8.0.3\",\"mocha\":\"^10.0.0\",\"typescript\":\"^4.8.4\",\"ts-loader\":\"^9.4.1\",\"webpack\":\"^5.74.0\",\"webpack-cli\":\"^4.10.0\",\"@vscode/test-electron\":\"^2.1.5\"}}```","Tool\\vscode\\develop plugin\\发布失效.md":"#[`发布失效`](/)```BASHvscepublish``````BASHINFOPublishing'ruihuag.ruihuagv0.0.11'...ERROR{\"$id\":\"1\",\"customProperties\":{\"Descriptor\":null,\"IdentityDisplayName\":null,\"Token\":null,\"RequestedPermissions\":0,\"NamespaceId\":\"000000000-0000-0000-0000-000000000000\"},\"innerException\":null,\"message\":\"AccessDenied:ThePersonalAccessTokenusedhasexpired.\",\"typeName\":\"Microsoft.VisualStudio.Services.Security.AccessCheckException,Microsoft.VisualStudio.Services.WebApi\",\"typeKey\":\"AccessCheckException\",\"errorCode\":0,\"eventId\":3000}```##重新生成token-dev.azure.com/![](./.assets/发布失效-2025-02-27-10-13-18.png)-复制好生成新token-`vscelogin<username>`-输入新token","Tool\\vscode\\plugin\\betterComments.md":"#BetterComments```shell//!红色的高亮注释//?蓝色的高亮注释//*绿色的高亮注释//todo橙色的高亮注释////灰色带删除线的注释//普通的注释/**//!红色的高亮注释//?蓝色的高亮注释//*绿色的高亮注释//todo橙色的高亮注释////灰色带删除线的注释*/```","Tool\\vscode\\plugin\\emmet.md":"#Emmet|符号|描述|||---------------------|----------|---||>|后代|||+|兄弟|||^|上级||()|分组||\\*|多个||$|自增||{}|文本|||#|id||.|class||[title=\"helloworld\"]|自定义属性|","Tool\\vscode\\question.md":"#VScode问题##Problemsloadingreference'<https://json.schemastore.org/package>':Unabletoloadschemafrom'<https://json.schemastore.org/package>':connectECONNREFUSED127.0.0.1:8890>由于本机的同源策略安全设置，不允许跨域访问资源，所有会将该请求的响应数据拦截>setting.json设置```js\"http.proxyAuthorization\":\"false\",```##CPU占用过高>rg.exe占用过高1.search.followSymlinks取消该配置项的勾选2.files.exclude添加``node_modules`,这样子就不会加载该文件夹,可以减少加载该导致的资源的浪费##vscode中CommentsarenotpermittedinJSON的解决办法>1.点击vscode右下角的==JSON==>>![img](.assets/20201226182440237.png)>>2.选择ConfigureFileAssociationfor'.json'>>![img](.assets/20201226182903753.png)>>3.输入json,选择JSONwithComments>>![img](.assets/20201226182923589.png)","Tool\\vscode\\vscode.md":"#vscode>[VisualStudioCodeExtensionAPI](https://code.visualstudio.com/api/references/extension-guidelines)##Launch>vscode调试react项目```json{//使用IntelliSense了解相关属性。//悬停以查看现有属性的描述。//欲了解更多信息，请访问:https://go.microsoft.com/fwlink/?linkid=830387\"version\":\"0.2.0\",\"configurations\":[{\"type\":\"chrome\",\"request\":\"launch\",\"name\":\"LaunchChromeagainstlocalhost\",\"url\":\"http://localhost:3000\",\"webRoot\":\"${workspaceRoot}\"}]}```##修改快捷键|快捷键|描述||--------------|--------||ctrl+alt+s|触发建议||alt+,|展开折叠||alt+.|折叠代码||||##窗口布局|快捷键|描述||---------------------|--------------------||`ctrl+shift+b`|活动栏的显隐(自定义)||<code>ctrl+`</code>|缩略图显隐(自定义)||`ctrl+shift+f`|全局搜索||`ctrl+shift+e`|定位到文件树||`ctrl+shift+x`|打开插件(拓展)||`ctrl+\\`|分屏打开当前文件|##光标|快捷键|描述||---------------------|--------------------||`ctrl+0`|将光标移动到文件树||`alt+[数字]`|切换当前窗口对应文件||`ctrl+[数字(非零)]`|切换分屏||`ctrl+shift+>`|通过大纲进行跳转|||||||##文件树>添加|快捷键|描述||------------------|------------|------||`ctrl+shift+e`|定位到文件树||`h|j`|文件树||`a`|新建文件||`A`|新建文件夹||`o`|打开文件||`ctrl+1`|分屏打开文件|##添加代码块>文件/首选项/用户片段```json{\"ReactComponent\":{\"prefix\":\"rc\",\"body\":[\"importReact,{Component}from'react'\",\"\",\"classIndexextendsComponent{\",\"\\trender(){\",\"\\t\\treturn(\",\"\\t\\t\\t<div>\",\"\\t\\t\\t\\tIndex\",\"\\t\\t\\t</div>\",\"\\t\\t)\",\"\\t}\",\"}\",\"\",\"exportdefaultIndex;\"],\"description\":\"reactcomponent\"},\"Reactfunction\":{\"prefix\":\"rf\",\"body\":[\"importReact,{Component}from'react'\",\"\",\"functionIndex(){\",\"\\treturn(\",\"\\t\\t<div>\",\"\\t\\t\\tIndex\",\"\\t\\t</div>\",\"\\t)\",\"}\",\"\",\"exportdefaultIndex;\"],\"description\":\"reactcomponent\"},\"Reactconst\":{\"prefix\":\"rco\",\"body\":[\"importReact,{Component}from'react'\",\"\",\"constIndex=()=>{\",\"\\treturn(\",\"\\t\\t<div>\",\"\\t\\t\\tIndex\",\"\\t\\t</div>\",\"\\t)\",\"}\",\"\",\"exportdefaultIndex;\"],\"description\":\"reactcomponent\"}}```##快捷键###主命令框|快捷键|描述||--------------------------|----------------------------------------------|--------|------------||`F1`或`ctrl+shift+p`|`ctrl+J`|ctrl+\\`|打开命令面板||`ctrl+p`|下拉菜单<br>再输入`>`进入ctrl+shift+p模式||`ctrl+k,ctrl+0[数字]`|折叠所有代码块||`ctrl+k,ctrl+j`|展示所有代码块||`ctrl+k,ctrl+f`|自动格式代码|###边界器与窗口管理|快捷键|描述||----------------|--------------------------------||ctrl+n|新建文件||ctrl+tap|文件之间切换||ctrl+shift+n|打开一个新的vscode编辑器||ctrl+w|关闭当前窗口||ctrl+shift+w|关闭当前vscode编辑器||ctrl+\\|切出一个新的编辑器窗口(最多三个)||ctrl+1/2/3|切换到3个便捷窗口|###代码编辑|快捷键|描述||----------------------------------------------|--------------------||shift+alt+f|代码格式化||alt+up或alt+down|向上或向下移动一行||shift+alt+up或shift+alt+down|向上或向下复制一行||ctrl+enter|在下方插入一行||ctrl+shift+enter|在前一行插入一行||alt+shift+鼠标左键或Ctrl+alt+down/up|多行编辑||Shift+Alt+Right和Shift+Alt+Left|扩展/缩小选取范围：||ctrl+delete|删除光标后面内容||Ctrl+u|回退上一个光标的操作||Ctrl+h|查找替换|###显示相关|快捷键|描述||----------------|--------------||ctrl+b|侧栏显示或隐藏||ctrl+shift+d|显示debug||ctrl+shift+u|显示output|##修改默认配置###自动保存`file->autoSave`或Ctrl+shift+p,输入auto###修改默认快捷键打开默认键盘快捷方式设置：**File**->**Preferences**->**KeyboardShortcuts**(中文界面时：“**文件**”->\"**首选项**\"->\"**键盘快捷方式**\")，或者：Alt+F->p->k->Enter，进入后如下图一所示。##修改上下左右快捷键```js//将键绑定放在此文件中以覆盖默认值[//ctrl+shift+/多行注释{\"key\":\"ctrl+shift+/\",\"command\":\"editor.action.blockComment\",\"when\":\"editorTextFocus\"},//上{\"key\":\"alt+k\",\"command\":\"cursorUp\",\"when\":\"textInputFocus\"},{\"key\":\"up\",\"command\":\"cursorUp\",\"when\":\"textInputFocus\"},//下{\"key\":\"alt+j\",\"command\":\"cursorDown\",\"when\":\"textInputFocus\"},{\"key\":\"down\",\"command\":\"cursorDown\",\"when\":\"textInputFocus\"},//左{\"key\":\"alt+h\",\"command\":\"cursorLeft\",\"when\":\"textInputFocus\"},{\"key\":\"left\",\"command\":\"cursorLeft\",\"when\":\"textInputFocus\"},//右{\"key\":\"alt+l\",\"command\":\"cursorRight\",\"when\":\"textInputFocus\"},{\"key\":\"right\",\"command\":\"cursorRight\",\"when\":\"textInputFocus\"},{\"key\":\"down\",\"command\":\"list.focusDown\",\"when\":\"listFocus&&!inputFocus\"},{\"key\":\"down\",\"command\":\"selectNextSuggestion\",\"when\":\"suggestWidgetMultipleSuggestions&&suggestWidgetVisible&&textInputFocus\"},{\"key\":\"alt+k\",\"command\":\"selectNextSuggestion\",\"when\":\"suggestWidgetMultipleSuggestions&&suggestWidgetVisible&&textInputFocus\"},{\"key\":\"up\",\"command\":\"selectPrevSuggestion\",\"when\":\"suggestWidgetMultipleSuggestions&&suggestWidgetVisible&&textInputFocus\"},k{\"key\":\"alt+i\",\"command\":\"selectPrevSuggestion\",\"when\":\"suggestWidgetMultipleSuggestions&&suggestWidgetVisible&&textInputFocus\"},]```##插件###React快速生成模板插件####VSCodeES7React/Redux/React-Native/JSsnippets>`CTRL+ALT+R`:查看快捷键>[_Windows_](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf):`Ctrl+P`然后输入`extinstalldsznajder.es7-react-js-snippets`####React|jPrefix|Method||:------|:------------------------------------------------------------------||`cwm→`|`componentWillMount=()=>{}`DEPRECATED!!!||`cdm→`|`componentDidMount=()=>{}`||`cwr→`|`componentWillReceiveProps=(nextProps)=>{}`DEPRECATED!!!||`scu→`|`shouldComponentUpdate=(nextProps,nextState)=>{}`||`cwup→`|`componentWillUpdate=(nextProps,nextState)=>{}`DEPRECATED!!!||`cdup→`|`componentDidUpdate=(prevProps,prevState)=>{}`||`cwun→`|`componentWillUnmount=()=>{}`|####PropTypes>格式要求:`[A].[B][C]`>>-`A`:`pt(PropTypes)`>-`B`:`a(array)`|`b(bool)`|`f(func)`|`n(number)`|`o(object)`|`s(string)`|`nd(node)`|`el(element)`|`i(instaneof(name))`|`e(oneof([name]))`|`et(oneOfType([name]))`|`ao(arrayOf(name))`|`oo(objectOf(name))`|`sh(shape({}))`|`any(any)`>-`C`:`r:isRequired`(非必要)>>特例:`ptypes:staticpropTypes={}`|Prefix|Method||:--------|:---------------------------------------||`pta→`|`PropTypes.array`||`ptar→`|`PropTypes.array.isRequired`||`ptb→`|`PropTypes.bool`||`ptbr→`|`PropTypes.bool.isRequired`||`ptf→`|`PropTypes.func`||`ptfr→`|`PropTypes.func.isRequired`||`ptn→`|`PropTypes.number`||`ptnr→`|`PropTypes.number.isRequired`||`pto→`|`PropTypes.object`||`ptor→`|`PropTypes.object.isRequired`||`pts→`|`PropTypes.string`||`ptsr→`|`PropTypes.string.isRequired`||`ptnd→`|`PropTypes.node`||`ptndr→`|`PropTypes.node.isRequired`||`ptel→`|`PropTypes.element`||`ptelr→`|`PropTypes.element.isRequired`||`pti→`k|`PropTypes.instanceOf(name)`||`ptir→`|`PropTypes.instanceOf(name).isRequired`||`pte→`|`PropTypes.oneOf([name])`||`pter→`|`PropTypes.oneOf([name]).isRequired`||`ptet→`|`PropTypes.oneOfType([name])`||`ptetr→`|`PropTypes.oneOfType([name]).isRequired`||`ptao→`|`PropTypes.arrayOf(name)`||`ptaor→`|`PropTypes.arrayOf(name).isRequired`||`ptoo→`|`PropTypes.objectOf(name)`||`ptoor→`|`PropTypes.objectOf(name).isRequired`||`ptsh→`|`PropTypes.shape({})`||`ptshr→`|`PropTypes.shape({}).isRequired`||`ptany→`|`PropTypes.any`||`ptypes→`|`staticpropTypes={}`|####Console|Prefix|Method||:-----|:------------------------------||`clg→`|`console.log(object)`||`clo→`|`console.log(\"object\",object)`||`ctm→`|`console.time(\"timeId\")`||`cte→`|`console.timeEnd(\"timeId\")`||`cer→`|`console.error(object)`||`cwa→`|`console.warn`||`cin→`|`console.info`|####ReactComponents>-第一个字母:>-`r`:react项目>-第二个字母:>-`f`:function组件>-`c`:class组件>-`af`:const定义组件>-第三个字母>>-`c`:定义处导出>>-`e`:结尾处导出>-第四个字母:>>-`p`:添加``PropTypes`组件#####`rcc````javascriptimportReact,{Component}from'react'exportdefaultclassFileNameextendsComponent{render(){return<div>$2</div>}}```#####`rce````javascriptimportReact,{Component}from'react'exportclassFileNameextendsComponent{render(){return<div>$2</div>}}exportdefault$1```#####`rcep````javascriptimportReact,{Component}from'react'importPropTypesfrom'prop-types'exportclassFileNameextendsComponent{staticpropTypes={}render(){return<div>$2</div>}}exportdefault$1```#####`rccp````javascriptimportReact,{Component}from'react'importPropTypesfrom'prop-types'exportdefaultclassFileNameextendsComponent{staticpropTypes={$2:$3,}render(){return<div>$4</div>}}```#####`rfcp````javascriptimportReactfrom'react'importPropTypesfrom'prop-types'function$1(props){return<div>$0</div>}$1.propTypes={}exportdefault$1```#####`rfc````javascriptimportReactfrom'react'exportdefaultfunction$1(){return<div>$0</div>}```#####`rfce````javascriptimportReactfrom'react'function$1(){return<div>$0</div>}exportdefault$1```#####`rafcp````javascriptimportReactfrom'react'importPropTypesfrom'prop-types'const$1=(props)=>{return<div>$0</div>}$1.propTypes={}exportdefault$1```#####`rafc````javascriptimportReactfrom'react'exportconst$1=()=>{return<div>$0</div>}```#####`rafce````javascriptimportReactfrom'react'const$1=()=>{return<div>$0</div>}exportdefault$1```###vscode&vim>vim提供了3个基本模式：normal，insert,visual![](https://upload-images.jianshu.io/upload_images/66696-5bc30a92ae0f73a6.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)","Tool\\vscode\\代码片段.md":"#代码片段###Variables：变量>`$name`或`${name:default}````txtTM_CURRENT_WORD：光标所处单词或空字符串TM_SELECTED_TEXT：当前选定的文本或空字符串TM_LINE_INDEX：行号（从零开始）TM_LINE_NUMBER：行号（从一开始）TM_FILENAME：当前文档的文件名TM_FILENAME_BASE：当前文档的文件名（不含后缀名）TM_DIRECTORY：当前文档所在目录TM_FILEPATH：当前文档的完整文件路径CLIPBOARD：当前剪贴板中内容CURRENT_YEAR:当前年份CURRENT_YEAR_SHORT:当前年份的后两位CURRENT_MONTH:格式化为两位数字的当前月份，如02CURRENT_MONTH_NAME:当前月份的全称，如JulyCURRENT_MONTH_NAME_SHORT:当前月份的简称，如JulCURRENT_DATE:当天月份第几天CURRENT_DAY_NAME:当天周几，如MondayCURRENT_DAY_NAME_SHORT:当天周几的简称，如MonCURRENT_HOUR:当前小时（24小时制）CURRENT_MINUTE:当前分钟CURRENT_SECOND:当前秒数```","Tool\\vscode\\格式化配置文件.md":"#.prettierrc.json>使用Eslint时，vscode格式化后的代码会补全分号及双引号，使得运行时报错。>.prettierrc.json文件可以配置格式化选项```cpp{\"semi\":false,//使用分号,默认true\"singleQuote\":true,//使用单引号,默认false(在jsx中配置无效,默认都是双引号)\"bracketSpacing\":true，//对象中的空格默认true\"tabWidth\":4，//tab缩进大小}！使用时删除注释```","Tool\\vscode\\正则替换.md":"#正则替换>\\*_’.’：通配符>‘+’:匹配一个或多个>‘?’:匹配0个或一个>‘_’:匹配0个或多个>‘._’:贪婪匹配（匹配到一个就会回溯）>'_?'非贪婪匹配（匹配到不回溯，一直匹配到结尾）>>捕获组：loadScript\\((._?),(._?)\\)>替换：loadScript($1,id,$2)>其中$1代表代表捕获组中第一个括号里匹配到的包裹内容>$2代表捕获组中第二个括号里匹配到的包裹内容##选择全部空行>`^\\s*(?=\\r?$)\\n`","Tool\\vscode\\配置参数.md":"#配置参数-`${currentFileName}`：带有ext的当前文件名-`${currentFileNameWithoutExt}`：不带ext的当前文件名-`${currentFileDir}`：包含当前编辑文件的目录的路径-`${projectRoot}`：在vscode中打开的项目的路径","Tool\\windows_Terminal.md":"#Terminal##常用指令|指令|描述||------------------------|----------------------------------|----------------||`ls`|查看当前目录下的文件和文件夹||`dir`|和`ls`一样||`mkdir`|创建文件夹||`echo'hello'>index.txt`|创建一个文件,里面的内容为'hello'||`cls`|清理控制台||`ctrl+|-`|放大\\|缩小字体||`ctrl+shift+t`|新建tap||`ctrl+tap`|tap页面切换||`ctrl+shift+n`|新建窗口|##分屏>`shiftalt+|-`:水平|垂直分屏>>`alt+方向键`:光标移动到对应的窗口>>`alt+shift+[方向键]`:改变窗口的大小>>`alt+shift+d`:复制打开窗格>>`ctrl+shift+w`:关闭当前分屏##配置文件```json//ThisfilewasinitiallygeneratedbyWindowsTerminal1.4.3243.0//Itshouldstillbeusableinnewerversions,butnewerversionsmighthaveadditional//settings,helptext,orchangesthatyouwillnotseeunlessyouclearthisfile//andletusgenerateanewoneforyou.//Toviewthedefaultsettings,hold\"alt\"whileclickingonthe\"Settings\"button.//Fordocumentationonthesesettings,see:https://aka.ms/terminal-documentation{\"$schema\":\"https://aka.ms/terminal-profiles-schema\",\"defaultProfile\":\"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\",\"colorScheme\":\"COLORSCHEMENAME\",//Youcanaddmoreglobalapplicationsettingshere.//Tolearnmoreaboutglobalsettings,visithttps://aka.ms/terminal-global-settings//Ifenabled,selectionsareautomaticallycopiedtoyourclipboard.\"copyOnSelect\":false,//Ifenabled,formatteddataisalsocopiedtoyourclipboard\"copyFormatting\":false,//Aprofilespecifiesacommandtoexecutepairedwithinformationabouthowitshouldlookandfeel.//Eachoneofthemwillappearinthe'NewTab'dropdown,//andcanbeinvokedfromthecommandlinewith`wt.exe-pxxx`//Tolearnmoreaboutprofiles,visithttps://aka.ms/terminal-profile-settings\"profiles\":{\"defaults\":{//Putsettingsherethatyouwanttoapplytoallprofiles.},\"list\":[{//Makechangesheretothepowershell.exeprofile.\"guid\":\"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\",\"name\":\"WindowsPowerShell\",\"commandline\":\"powershell.exe\",\"hidden\":false},{//Makechangesheretothecmd.exeprofile.\"guid\":\"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\",\"name\":\"CommandPrompt\",\"commandline\":\"cmd.exe\",\"hidden\":false},{\"guid\":\"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\",\"hidden\":false,\"name\":\"AzureCloudShell\",\"source\":\"Windows.Terminal.Azure\"}]},//Addcustomcolorschemestothisarray.//Tolearnmoreaboutcolorschemes,visithttps://aka.ms/terminal-color-schemes\"schemes\":[{\"name\":\"Campbell\",\"cursorColor\":\"#FFFFFF\",\"selectionBackground\":\"#FFFFFF\",\"background\":\"#0C0C0C\",\"foreground\":\"#CCCCCC\",\"black\":\"#0C0C0C\",\"blue\":\"#0037DA\",\"cyan\":\"#3A96DD\",\"green\":\"#13A10E\",\"purple\":\"#881798\",\"red\":\"#C50F1F\",\"white\":\"#CCCCCC\",\"yellow\":\"#C19C00\",\"brightBlack\":\"#767676\",\"brightBlue\":\"#3B78FF\",\"brightCyan\":\"#61D6D6\",\"brightGreen\":\"#16C60C\",\"brightPurple\":\"#B4009E\",\"brightRed\":\"#E74856\",\"brightWhite\":\"#F2F2F2\",\"brightYellow\":\"#F9F1A5\"}],//Addcustomactionsandkeybindingstothisarray.//Tounbindakeycombinationfromyourdefaults.json,setthecommandto\"unbound\".//Tolearnmoreaboutactionsandkeybindings,visithttps://aka.ms/terminal-keybindings\"actions\":[//CopyandpasteareboundtoCtrl+Shift+CandCtrl+Shift+Vinyourdefaults.json.//ThesetwolinesadditionallybindthemtoCtrl+CandCtrl+V.//Tolearnmoreaboutselection,visithttps://aka.ms/terminal-selection{\"command\":{\"action\":\"copy\",\"singleLine\":false},\"keys\":\"ctrl+c\"},{\"command\":\"paste\",\"keys\":\"ctrl+v\"},//PressCtrl+Shift+Ftoopenthesearchbox{\"command\":\"find\",\"keys\":\"ctrl+shift+f\"},//PressAlt+Shift+Dtoopenanewpane.//-\"split\":\"auto\"makesthispaneopeninthedirectionthatprovidesthemostsurfacearea.//-\"splitMode\":\"duplicate\"makesthenewpaneusethefocusedpane'sprofile.//Tolearnmoreaboutpanes,visithttps://aka.ms/terminal-panes{\"command\":{\"action\":\"splitPane\",\"split\":\"auto\",\"splitMode\":\"duplicate\"},\"keys\":\"alt+shift+d\"},{\"command\":{\"action\":\"splitPane\",\"split\":\"vertical\"},\"keys\":\"alt+shift+plus\"},{\"command\":{\"action\":\"splitPane\",\"split\":\"horizontal\"},\"keys\":\"alt+shift+-\"},{\"command\":{\"action\":\"splitPane\",\"split\":\"auto\"},\"keys\":\"alt+shift+|\"},{\"command\":{\"action\":\"moveFocus\",\"direction\":\"down\"},\"keys\":\"alt+down\"},{\"command\":{\"action\":\"moveFocus\",\"direction\":\"left\"},\"keys\":\"alt+left\"},{\"command\":{\"action\":\"moveFocus\",\"direction\":\"right\"},\"keys\":\"alt+right\"},{\"command\":{\"action\":\"moveFocus\",\"direction\":\"up\"},\"keys\":\"alt+up\"},{\"command\":{\"action\":\"resizePane\",\"direction\":\"down\"},\"keys\":\"alt+shift+down\"},{\"command\":{\"action\":\"resizePane\",\"direction\":\"left\"},\"keys\":\"alt+shift+left\"},{\"command\":{\"action\":\"resizePane\",\"direction\":\"right\"},\"keys\":\"alt+shift+right\"},{\"command\":{\"action\":\"resizePane\",\"direction\":\"up\"},\"keys\":\"alt+shift+up\"},{\"command\":\"closePane\",\"keys\":\"ctrl+shift+w\"}]}```","vue\\api\\component.md":"#[`component`](https://cn.vuejs.org/api/general.html#definecomponent)##defineComponent>定义`vue`组件###type```ts//选项语法functiondefineComponent(component:ComponentOptions):ComponentConstructor//函数语法(需要3.3+)functiondefineComponent(setup:ComponentOptions['setup'],extraOptions?:ComponentOptions,):()=>any```##defineAsyncComponent>-定义异步组件>-懒加载###type```tsfunctiondefineAsyncComponent(source:AsyncComponentLoader|AsyncComponentOptions,):ComponenttypeAsyncComponentLoader=()=>Promise<Component>interfaceAsyncComponentOptions{/***可为异步加载函数*/loader:AsyncComponentLoaderloadingComponent?:ComponenterrorComponent?:Componentdelay?:numbertimeout?:numbersuspensible?:booleanonError?:(error:Error,retry:()=>void,fail:()=>void,attempts:number,)=>any}```##defineCustomElement>-定义参数和`defineComponent`相同###type```tsfunctiondefineCustomElement(component:|(ComponentOptions&{styles?:string[]})|ComponentOptions['setup'],):{new(props?:object):HTMLElement}```###非常规>`customElements.define()`注册自定义元素构造器####eg```tsimport{defineCustomElement}from'vue'constMyVueElement=defineCustomElement({/*组件选项*/})//注册自定义元素customElements.define('my-vue-element',MyVueElement)```","vue\\api\\nextTick.md":"#[`nextTick`](https://cn.vuejs.org/api/general.html#nexttick)>-等待下一次DOM更新刷新##type```tsfunctionnextTick(callback?:()=>void):Promise<void>```#eg```html<scriptsetup>import{ref,nextTick}from'vue'constcount=ref(0)asyncfunctionincrement(){count.value++//DOM还未更新console.log(document.getElementById('counter').textContent)//0awaitnextTick()//DOM此时已经更新console.log(document.getElementById('counter').textContent)//1}</script><template><buttonid=\"counter\"@click=\"increment\">{{count}}</button></template>```","vue\\begin.md":"#创建项目##vue2>1.安装vue脚手架:`npminstall-g@vue/cli`[最新版]>2.创建项目`vuecreatehello-world`>3.根据需要选择对应的依赖>4.`cdhello-world`>5.`npmrunserve`","vue\\element.md":"#[element](https://element.eleme.cn/#/zh-CN/component/dialog)>[官网](https://element.eleme.cn/#/zh-CN/component/dialog)","vue\\eslint\\err.md":"#vue使用eslint报错##Unexpectedtabcharacter(no-tabs)1.在创建项目的时候`UseESlinttolintyourcode?(Y/n)`这里选no2.在`.eslintrc.js`中在`rules`:加入一行`\"no-tabs\":\"off\"`3.在文件中添加`/*eslint-disable*/`","vue\\extend\\vue-expand.md":"#vue-expand##设计项目结构1.路由层`router`2.静态文件层`assets`3.页面结构层`views`4.组件结构层`components`5.全局状态管理层`store`6.功能逻辑处理层`util`7.常量管理层`constants`8.在`Vue`项目中还可以引入更多的配置如混入层`mixins`、过滤层`filtters`等。###数据请求methods中ORactions中一般项目中对于数据请求的方式都是基于`methods`钩子或其他生命周期钩子中调用请求方法，也存在一些项目中是通过发送一个`disptach`异步请求方法在`actions`中调用请求函数。使用后者的说法是便于统一管理请求接口，并对请求返回的数据进行统一的管理。综合以上两种做法，可以优化项目中的请求方式，若请求接口发出后返回的数据需要在多个页面或多个不同的组件中共享和使用，则推荐在需要发请求的函数中`dispath`触发，在`actions`中发送请求，返回的数据保存在全局状态管理`state`中。`methods`中发送请求方式：```javascriptgetGraphicCode(){letvm=this;api.login.getCheckCode({type:'2'}).then(res=>{if(res.code==='000'){vm.graphicCode='data:image/png;base64,'+res.data.img;vm.imgId=res.data.imgId;}else{vm.$message.error(res.msg);}})}````actions`中发送请求方式：```javascriptfindAllRoles({commit}){returnnewPromise((resolve,reject)=>{api.systemAccount.findAllRoles().then(response=>{if(response.code===\"000\"&&response.success){commit(MUTATIONS_TYPE.AllROLES,response.data)resolve(response);}else{reject(newError(response.code,response.msg))}})})},```###登录与权限管理`token`验证是目前大部分前后端分离的`Web`项目做登录验证比较常见的方法。前端通过发送账号和密码或账号和验证码给到后端后，后端验证通过会返回一个唯一的`token`作为该用户的登录凭证，在之后的每个请求当中，请求头中都需带上这个`token`作为后端的登录校验。`token`有过期的机制，可以在请求拦截中做逻辑判断处理，若当前时间接近了过期时间，则通过更新`token`的接口请求更新`token`，在之后的请求中带上新的`token`。以此循环，若用户过长时间无操作，则可认为用户为离线状态，在用户之后的第一次请求时，由于`token`已经过期，访问后端接口会发生错误，根据后端返回的错误状态码作为判断，将系统定向至登录页面。通过带有`token`请求头的请求方法，后端可以判断到是哪一个用户，前端也可以通过获取权限接口获得该用户的权限列表，根据权限列表做一份路由映射表，如果后端返回的数据结构与前端的路由设置的数据结构不同，此时还需编写此映射路由的业务功能函数。如果该用户拥有此路由权限，则通过在全局路由监控中`router.beforeEach`进行`router`中的`addRoutes`方法将有权限的路由配置添加到路由当中，侧边栏也可根据路由列表中的`meta`字段中关键字的判断进行相应的渲染。如果权限的颗粒度小到一个按钮，则可根据后端返回的权限列表映射出的权限参数，通过`v-if`进行判断该功能组件是否渲染。在路由管理中通过`router.beforeEach`钩子中判断当前的路由权限是否为空，是的话则可执行获取权限路由的接口：```javascriptstore.dispatch('getUserInfoAndAuthorityInfo').then((res)=>{//根据后端返回的路由权限格式转成前端路由配置格式constrolesRoute=setAsyncRouterMap(res.menuList,asyncRouterMap,mainChildrenAsyncRoutes,)store.commit(Vue.VUEX_TYPES.ROLESROUTE,rolesRoute)//添加路由router.addRoutes(rolesRoute)next({...to})}).catch(()=>{Message.error('验证失败')next('/login')})```###常量枚举值管理在项目当中对关键的常量枚举值进行管理是非常有必要的。比如在项目当中后端用某个状态码`1`代表账号为启用状态，如果在项目当中多次使用`===1`去判断账号是否为启用状态，当需要更改这个状态码的时候，对于前端来说是一件十分麻烦的事情，所以可以通过把`1`赋值给一个常量，在项目代码中引用这个常量，如果需要更改状态码的时候，则直接改变这个赋值给常量枚举值的状态码即可，常量的配置也可提醒开发人员此参数不可轻易修改，便于项目的维护和统一管理。一般常量枚举值的管理写在`constants`层中，常量的变量名使用大写字母编写。状态枚举值得配置如下：```javascript/***账号状态对照表*\"0\"未启用NOTUSED_CODE*\"1\"已启用ENABLE_CODE*\"2\"已停用DISABLE_CODE*/constNOTUSED_CODE='0'constENABLE_CODE='1'constDISABLE_CODE='2'constACCOUNT_TYPE={[NOTUSED_CODE]:'未启用',[ENABLE_CODE]:'已启用',[DISABLE_CODE]:'已停用',}exportdefaultObject.freeze({NOTUSED_CODE,ENABLE_CODE,DISABLE_CODE,ACCOUNT_TYPE,})```###组件设计前端项目当中可以把展示组件分为两部分，分别为页面组件和功能组件。对于页面组件，常用于展现页面的整体内容，承担着业务逻辑的正常运行，与业务比较有强的耦合性。功能组件是用于展现和处理某一单一或某一模块的功能，功能组件并不关心页面的业务逻辑，充当着一个函数的作用，只要有输入便有对应的输出，并可在多个页面组件或功能组件中被调用。综上，在设计页面组件的时候，不仅应该考虑该组件能够正常的完成业务的功能，还要考虑其是否能够脱离业务成为一个功能组件，对于内容比较多的页面组件，可以在其同级目录下新建多个子页面组件共同构建。在设计功能组件时，需考虑组件的布局、逻辑、视图，功能组件的设计难度在于其要考虑到满足不断更新的需求变化，可扩展性，灵活性是设计的一大挑战。页面组件目录格式如下：![image.png](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a3e0791dd74af5838f4359dca00746~tplv-k3u1fbpfcp-zoom-1.image)###必要的开发文档或注释项目的开发文档可编写为md文件格式存放于项目的根目录，一份好的开发文档能够对项目的背景进行介绍，说明项目的结构和开发的步骤，更有利于其他开发人员参与或接手项目。对于项目当中使用到的与业务功能耦合的逻辑函数，较为复杂的，编写函数的介绍以及使用方法，做好边界条件判断，示范输入数据以及对应的输出结果，可在项目中新建`docs`文件夹存放开发过程中的使用文档。对于非复杂功能的业务逻辑函数或非业务逻辑函数，可直接在定义函数之前编写注释，说明函数作用功能，以及对应的输入和输入参数的类型。>每次的开发过程都可当做是一个学习和总结经验的过程，对比以往的代码，我们可以思考代码结构是否能设计得更加完善，逻辑函数是否清晰且考虑边界条件，性能是否可以更加的优化。##常用webpack配置###**vue-lic3脚手架（vue.config.js）**####publicPath类型：String默认：'/'部署应用包时的基本URL。默认情况下，VueCLI会假设你的应用是被部署在一个域名的根路径上，例如<https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/>这个值也可以被设置为空字符串('')或是相对路径('./')，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似Cordovahybrid应用的文件系统中。####productionSourceMap类型：booleanmoren：true不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积>注Sourcemap的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便####assetsDir放置生成的静态资源(js、css、img、fonts)的(相对于outputDir的)目录,默认是'',####indexPath指定生成的index.html的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是'index.html'####lintOnSave是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用####css```jscss:{//是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，extract:true,sourceMap:false,//效果同上modules:false,//为所有的CSS及其预处理文件开启CSSModules。//这个选项不会影响`*.vue`文件。},```####devServer本地开发服务器配置```jsdevServer:{//配置开发服务器host:\"0.0.0.0\",//是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果hot:true,//服务启动端口port:\"8080\",//是否自动打开浏览器默认为falseopen:false,//配置http代理proxy:{\"/api\":{//如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在jajx中使用/api/api1路径,其请求路径会解析//http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;target:\"http://192.168.0.118:9999\",//是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意changeOrigin:true,pathRewrite:{//把多余的路径置为''\"api\":\"\"}},\"/api2\":{//可以配置多个代理，匹配上那个就使用哪种解析方式target:\"http://api2\",//...}}},```####pluginOptions这是一个不进行任何schema验证的对象，因此它可以用来传递任何第三方插件选项，例如：```js{//定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了'style-resources-loader':{preProcessor:'less',patterns:['./src/assets/public.less']}}```####chainWebpack是一个函数，会接收一个基于webpack-chain的ChainableConfig实例。允许对内部的webpack配置进行更细粒度的修改。例如：```jschainWebpack(config){//添加一个路径别名假设有在assets/img/menu/目录下有十张图片，如果全路径require(\"/assets/img/menu/img1.png\")//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了config.resolve.alias//添加多个别名支持链式调用.set(\"assets\",path.join(__dirname,\"/src/assets\")).set(\"img\",path.join(__dirname,\"/src/assets/img/menu\"))//引入图片时只需require(\"img/img1.png\");即可}```##组件传值####父传子通过props传递```父组件：<childvalue='传递的数据'/>子组件:props['value'],接收数据,接受之后使用和data中定义数据使用方式一样```####子传父在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。```父组件：<child@receive='receive'/>子组件:this.$emit('receive','传递的数据')```####兄弟组件传值-通过中央通信letbus=newVue()>A：methods:{函数{bus.$emit(‘自定义事件名’，数据)}发送>B：created（）{bus.$on(‘A发送过来的自定义事件名’，函数)}进行数据接收-通过vuex##**v-forkey的作用**当Vue用v-for正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一key属性。key属性的类型只能为string或者number类型。key的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。##**Vue的双向数据绑定原理**vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:①在自身实例化时往属性订阅器(dep)里面添加自己②自身必须有一个update()方法③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)->数据model变更的双向绑定效果。##vue-loader>vue文件加载器,跟template/js/style转换为js模块##Vue-typeScript###环境搭建```shellvuecreatetypescript-app&cdtypescript-app&npmrunserve```###Main####基于类的组件```typescript//Typescriptcode<scriptlang=\"ts\">//这里指定是typescriptimport{Component,Vue}from\"vue-property-decorator\"@ComponentexportdefaultclassHelloWorldextendsVue{//coding...}//显式地使用name属性@Component({name:'HelloWorld',})</script>//Javascriptcode<script>exportdefault{name:'helloWorld',}</script>```####引入组件```javascript//typescript<template><divclass=\"main\"><Project/></div></template><scriptlang='ts'>import{Component,Vue}from'vue-property-decorator'importProjectfrom'@/components/Project.vue'@Component({commponents:{Project}})exportdefaultclassHelloWorldextendsVue{//coding...}</script>//javascript<template><divclass=\"main\"><Project/></div></template><script>importProjectfrom'@/components/Project.vue'exportdefaulf{name:'HelloWordl',components:{Project}}</script>```####Data,props,computed,methods,watchers,emit#####Data```javascript//Typescript@ComponentexportdefaultclassHelloWorldextendsVue{privatemsg:string='guanruihua'privatelist:Array<object>=[{name:'ruihua',age:'23',},{name:'ruihua',age:'30',}]}//javascriptexportdefault{data(){return{msg:'guanruihua',list:[{name:'ruihau',age:'23',},{name:'ruihua',age:'30'}]}}}```#####props```javascript//typescriptimport{Component,Prop,Vue}from'vue-property-decorator'@ComponentexportdefaultclassHelloWorldextendsVue{@Prop()readonlymsg!:string@Prop({default:'ruihua'})readonlyname:string@Prop({required:true})readonlyage:number@Prop(String)readonlyaddress:string@Prop({require:false,type:String,default:'Developer'})readonlyjob:string}//javascriptprops:{msg,name:{default:'ruihua'},age:{require:true,},address:{type:String},job:{require:false,type:String,default:'Developer'}}```####Computed```javascript//TypescriptexportdefaultclassHelloWorldextendsVue{getfullName():string{returnthis.firstName+''+this.lastName}setfullName(newValue:string){letnames=newValue.split('')this.firstName=names[0]this.lastName=names[names.lenght-1]}}//javascriptexportdefault{fullName(){returnthis.firstName+''+this.lastName}}exportdefault{fullName(){get:function(){returnthis.firstName+''+this.lastName}set:function(newValue){letnames=newValue.split('')this.firstName=names[0]this.lastName=names[names.lenght-1]}}}```####methods```javascript//TypescriptexportdefaultclassHelloWorldextendsVue{publicFn():void{console.log(this.addNum(4,2))}publicaddNum(num1:number,num2:number):number{returnnum1+num2}}//javascriptexportdefault{methods:{Fn(){console.log(this.addNum(4,2))},addNum(num1,num2){returnnum1+num2}}}```####wetchers```javascript//typescript@Watch('name')//监听的变量名称nameChange(newVal:string){this.name=newVal}@Watch('project',{immediate:true,deep:true})projectChanged(newVal:Person,oldVal:Person){//dosomething}//javascriptwatch:{person:{handler:'projectChanged',immediate:true,deep:true}},methods:{projectChanged:(newVal,oldVal){//dosomething}}```","vue\\extend\\vue-question.md":"#VUE-QUESTION##Vue提示报错警告\"TypeError:handler.callisnotafunction\">组件中声明了未定义的方法，或者只声明了钩子函数，并未使用。##`vue/cle3`项目运行报错`sockjs-node/info`解决方案###控制台报错```shellgethttp://localhost:8080/sockjs-node/info?t=1462183700002net::ERR_CONNECTION_REFUSED[WDS]Disconnected!gethttp://localhost:8080/sockjs-node/info?t=1462183700002net::ERR_CONNECTION_REFUSED[WDS]Disconnected!gethttp://localhost:8080/sockjs-node/info?t=1462183700002net::ERR_CONNECTION_REFUSED[WDS]Disconnected!...```###解决方案####1.注释法顾名思义，找到依赖包中的源码，将其注释：1.进入路径`/node_modules/sockjs-client/dist/sockjs.js`2.代码1605行注释掉：```javascripttry{//self.xhr.send(payload);//本行注释}catch(e){self.emit('finish',0,'')self._cleanup(false)}```3.重启项目####2.配置`vue.config``vue.config.js`中的`module.exports`中添加如下，然后重启：```javascriptdevServer:{proxy:'http://localhost:8080',public:'192.168.xxx.xxx:8080'//本地ip}```","vue\\extend\\父子通信.md":"#父子组件通信##子组件调用父组件的方法###this.$parent.event>直接在子组件中通过this.$parent.event来调用父组件的方法父组件```vue<template><div><child></child></div></template><script>importchildfrom'./components/dam/child'exportdefault{components:{child,},methods:{fatherMethod(){console.log('测试')},},}</script>```子组件```vue<template><div><button@click=\"childMethod()\">点击</button></div></template><script>exportdefault{methods:{childMethod(){this.$parent.fatherMethod()},},}</script>```###$emit>在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。父组件```vue<template><div><child@fatherMethod=\"fatherMethod\"></child></div></template><script>importchildfrom'~/components/dam/child'exportdefault{components:{child,},methods:{fatherMethod(){console.log('测试')},},}</script>```子组件```vue<template><div><button@click=\"childMethod()\">点击</button></div></template><script>exportdefault{methods:{childMethod(){this.$emit('fatherMethod')},},}</script>```###父组件把方法传入子组件>父组件把方法传入子组件中，在子组件里直接调用这个方法父组件```vue<template><div><child:fatherMethod=\"fatherMethod\"></child></div></template><script>importchildfrom'~/components/dam/child'exportdefault{components:{child,},methods:{fatherMethod(){console.log('测试')},},}</script>```子组件```vue<template><div><button@click=\"childMethod()\">点击</button></div></template><script>exportdefault{props:{fatherMethod:{type:Function,default:null,},},methods:{childMethod(){if(this.fatherMethod){this.fatherMethod()}},},}</script>```子组件更简便的写法```vue<template><div><button@click=\"fatherMethod()\">点击</button></div></template><script>exportdefault{props:{fatherMethod:{type:Function,default:null,},},methods:{},}</script>```","vue\\package.md":"#package##vue-virtual-scroll-list><https://github.com/tangbc/vue-virtual-scroll-list>","vue\\props.md":"#props##子组件绑定props###通过对象挂载属性```html<template><div><buttonv-bind=\"rest\">btn</button></div></template><scriptsetup>import{useAttrs}from'vue'/***若没有<div>,就不需要这样子操作,vue会属性透传*///eslint-disable-next-lineconst{cname,change,...rest}=useAttrs()</script>```###$attrs```html<template><divv-model=\"$attrs\"></template>```##useAttrs```html<template><divv-model=\"attrs\"/></template><scriptsetup>import{useAttrs}from'vue'constattrs=useAttrs</script>```","vue\\question\\sockjs-node.md":"#vue项目报错<http://localhost:8080/sockjs-node/info?t=xxxx，解决办法，亲测绝对有效>##方法一:修改node_modules文件>找到/node_modules/sockjs-client/dist/sockjs.js>>找到代码的1606行，并注释掉```jstry{//self.xhr.send(payload);//注释这一行}catch(e){self.emit('finish',0,'')self._cleanup(false)}```##方法二>其实造成这个原因是：网络环境变更（如切换wifi导致开发服务器的IP地址更换），服务器不知道如何确定访问源，就有可能造成上述情况。>>**解决办法**：如果是开发环境，重新npmrunserve,重启项目即可解决问题。如果是生产环境，很大可能是应该是域名和ip映射出问题，检查重新配置域名和ip映射就可以了。","vue\\UI组件\\index.md":"","vue\\UI组件\\制作UI组件.md":"#开发UI组件>参考视频https://www.bilibili.com/video/BV1nJ411V75n>>[hucongcong/heima-uui(github.com)](https://github.com/hucongcong/heima-uui)>>[构建目标|VueCLI(vuejs.org)](https://cli.vuejs.org/zh/guide/build-targets.html#库)>>仿制Element-UI组件的文件目录##开发准备>使用vue脚手架创建项目###修改文件目录>创建>>-packages:组件的文件夹>-index.js:写成注册packages组件的的方法>-.npmignore:npm提交忽略目录>-vue.config.js:修改webpack的打包方法>>修改>>-src=>examples####packages/index.js```js//整个包的入口//定义install方法，接收Vue作为参数。如果使用use注册插件，则所有的组件都将被注册//统一导出//导入颜色选择器组件importButtonfrom'./button'...//存储组件列表constcomponents=[Button,]constinstall=function(Vue){//全局注册所有的组件components.forEach((item)=>{Vue.component(item.name,item)})}//判断是否是直接引入文件,如果是，就不用调用Vue.use()if(typeofwindow!=='undefined'&&window.Vue){install(window.Vue)}exportdefault{install}```####.npmignore```#忽略目录examples/packages/public/#忽略指定文件vue.config.jsbabel.config.js*.map.gitignore```####vue.config.js```jsconstpath=require('path')module.exports={pages:{index:{//修改项目的入口文件entry:'examples/main.js',template:'public/index.html',filename:'index.html',},},//扩展webpack配置，使packages加入编译chainWebpack:(config)=>{config.module.rule('js').include.add(path.resolve(__dirname,'packages')).end().use('babel').loader('babel-loader').tap((options)=>{//修改它的选项...returnoptions})},}```###其他修改####添加构建dist指令```json{...\"scripts\":{\"serve\":\"vue-cli-serviceserve\",\"build\":\"vue-cli-servicebuild\",\"lib\":\"vue-cli-servicebuild--targetlibpackages/index.js\"}...}```##发布```npmnpmloginnpmpublish```##使用main.js```jsimportRHUIfrom'rh-vue-ui'import'rh-vue-ui/dist/rh-vue-ui.css'```使用```vue<RH-Button>我是按钮</RH-Button>```","vue\\vue-basis.md":"#Vue-basis>用户构建用户界面的渐进式框架,与其他大象框架不同的是,Vue被设计为可以自底向上层应用,Vue的核心库值关视图,便于与第三方库或基友的项目整合`Object.freeze()`，这会阻止修改现有的property，也意味着响应系统无法再*追踪*变化。##生命周期<imgsrc=\".assets/lifecycle.png\"style=\"zoom:50%;\"/>###创建阶段>1.`newVue()`:`varvm=newVue({});`表示创建一个Vue对象(实例)>2.`Init(Events&Lifecycle)`:对象初始化,在新建的对象身上,具备了一些生命周期相关的函数(生命周期的钩子函数)和默认的事件,其他组件还没有创建(data,methods,filter等都没有创建出来)>-执行`Init(Event&Lifecycle)`之后,钩子函数都被创建出来,马上调研生命周期函数`beforeCreate`,data和methods等组件都还没有创建出来>3.`Init(injections&reactivity)`:对象初始化的后期阶段。执行生命周期函数`created`，data和methods都已经被初始化好了。>4.`Init`对象初始化完成阶段执行完毕后,通过对元素及其模板进行判断,系统开始编辑模板,将Vue代码的指令进行执行,然后再内存中生成一个编辑好的模板字符串,最终改模板字符串渲染为内存中的DOM>-只在内存中渲染好了模板,并没有见模板挂载到页面中去,该阶段完成后执行`beforeMount`方法>5.`Createvm`:该阶段是将内存中编译好的模板,替换到浏览器的页面中,该阶段执行的是mounted方法>-只要`mounted`方法执行完后,就标识整个Vue对象已经初始化完毕,真实脱离创建阶段进入运行阶段,可以开始操作页面上DOM节点###运行阶段>6.VirtualDOM:该阶段会根据data中的最新数据,重新渲染出一份最新的DOM树,DOM树更新后悔把最新的DOM数重新渲染到页面中,这时候完成了使用模型Model去渲染视图View>-常使用两个函数beforeUpdate和updated,会根据data数据变化,可重复多次执行>-`beforeUpdate`方法执行的时候,页面显示的数据还是以前的数据,但是data中保存的是更新后的>-`update`函数执行的时候,页面和data的数据以及保持同步,都是最新的数据###对象销毁>7.`Teardown(拆卸)`:对象销毁阶段,当该对象实例运行完成后,达到独享销毁的条件,执行`beforeDestroy`函数,该函数执行标志的这对象从运行状态进入到了销毁的阶段>-当`beforeDestroy`函数执行的时候,对象身上所有的组件data,methods,filter,directive的等组件都还处于可用状态(对象只是步入到了销毁的阶段,还没有销毁),该函数执行完毕后,对象正式销毁.>8.`Destroy`:对象已经销毁了,data,methodsfilter,directive等组件都不可用了###生命周期的钩子函数beforeCreatecreatedbeforeMountmountedbeforeUpdateupdatedbeforeDestroydestroyed##指定端口运行-在根目录新建配置文件`vue.config.js`;-配置文件内容```jsmodule.exports={devServer:{//项目运行时候的端口号port:8000,},}```##computed和watch####计算属性computed-支持缓存，只有依赖数据发生改变，才会重新进行计算-不支持异步，当computed内有异步操作时无效，无法监听数据的变化-computed属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值-如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed-如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。####侦听属性watch-不支持缓存，数据变，直接会触发相应的操作；-watch支持异步；-监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；-当一个属性发生变化时，需要执行对应的操作；一对多；-监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：>immediate：组件加载立即触发回调函数执行```jswatch:{firstName:{handler(newName,oldName){this.fullName=newName+''+this.lastName;},//代表在wacth里声明了firstName这个方法之后立即执行handler方法immediate:true}}```>deep:deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的handler```jswatch:{obj:{handler(newName,oldName){console.log('obj.achanged');},immediate:true,deep:true}}```优化：我们可以使用字符串的形式监听```jswatch:{'obj.a':{handler(newName,oldName){console.log('obj.achanged');},immediate:true,//deep:true}}```这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。###**prop验证，和默认值**我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告```props:{visible:{default:true,type:Boolean,required:true},},```##指令###vue自带指令1.###v-cloak-解决插值表达式的闪烁问题-网速等问题可能显示出双花括号,加载完毕后才会转换成动态赋予的值```js先定义好样式[v-cloak]{display:none;}再在标签中引用<pv-cloak>{{str}}</p>//不适用v-cloak可能会出现{{}}```2.###v-text1.```js<pv-text='str'></p>```2.可以插入内容3.###v-html1.```js<pv-text='str'></p>```2.不建议使用,容易受到xss攻击3.可以插入html的片段,可以得到浏览器的解析4.插值表达式与v-text/v-html的区别1.对元素中已经存在的值,只有插值表达式能够将原有的值保留,在原有的已经存在的值的基础上添加动态数据2.v-text/v-html不能够保留标签原有的的内容,不会出现页面闪烁的问题5.v-bind:1.单向数据绑定2.将data中的信息动态赋予给标签的属性或者变量值中3.只能实现数据的单向绑定,从模型(M)绑定到视图(V),使用VM将数据去渲染视图,但是我们无法通过该形式实现数据的双向绑定4.简写\":\"5.```js<pv-bind:title=\"str\"></p><pv-bind:title=\"str+'拼接'\"\"></p>```6.使用class演示```js:class=\"[class1,class2,class3...]\"三目运算符操作以上数组:class=\"[boolean?'trueClass':'falseClass',...]\"使用对象(json)来表达以上三目运算符的操作:class=\"[{'style_class':flag}]\"```7.常用的使用方式1.直接为元素的属性进行绑定操作2.使用简化后的方式,将v-bind去除,直接使用:用来厎元素中的额外属性进行绑定6.v-on:1.简写:\"@\"2.v-on:click=\"fun\"相当于原生的onclick=\"fun()\"7.v-model:1.双向数据绑定2.只能运用在表单元素中3.和data数据是实现双向绑定4.`v-model=\"str\"`8.v-for>-key:提供一个有效的辨识指定元素>-key属性值只能为数值或字符串>-key一定要v-bind绑定>-值必须是记录中的唯一标识1.遍历字符串数组-`<pv-for=\"(item,index)inarrayList\":key=index>{{item}}</p>`2.遍历对象数组-`<pv-for=\"(item,index)inarrayList\":key=index>{{item.id}}---{{item.name}}</p>`3.遍历对象的属性和属性值-`(value[属性值],key(属性名))in对象`-`<pv-for=\"(value,key,index)inarrayList\":key=index>{{value}}</p>`4.遍历整形数字-`<pv-for=\"indexin10\":key=index>{{index}}</p>`9.v-show,v-if,v-else-if,v-else-v-xxx=\"true\":展示元素内容(创建该元素)false:去除该元素-v-if=\"true\":创建条件元素false:去除该元素-每次切换true都会重新创建元素,降低元素的效率-v-show=\"true\":展现条件元素false:隐藏该元素-频繁切换boolean建议使用###自定义全局指令>-自定义全局指令:`Vue.directive()`>-定义时候不用加\"v-\",使用时候才用>-`bind,inserted,update`是vue对象生命周期相关函数>-bind:操作元素样式(css)>-inserted:操作元素行为(js)>-update:元素更新```js;<divid='app'><inputtype='text'v-dt/></div>Vue.directive('dt',{//绑定时,就可以触发//还没有插入到dom//binding是传递过来的数据,即v-dt=\"数据\"bind:function(el,binding){el.style.color='red'},//inserted函数,表示元素插入到dom中,inserted:function(el){},//表示元素更新时候触发,可以随时触发update:function(el){},})varvm=newVue({el:'#app',data:{str:'str',},})```##修饰符###键盘修饰符在JavaScript事件中除了前面所说的事件，还有键盘事件，也经常需要监测常见的键值。在Vue中允许`v-on`在监听键盘事件时添加关键修饰符。记住所有的`keyCode`比较困难，所以Vue为最常用的键盘事件提供了别名：-**`.enter`**：回车键-**`.tab`**：制表键-**`.delete`**：含`delete`和`backspace`键-**`.esc`**：返回键-**`.space`**:空格键-**`.up`**：向上键-**`.down`**：向下键-**`.left`**：向左键-**`.right`**：向右键###鼠标修饰符鼠标修饰符用来限制处理程序监听特定的滑鼠按键。常见的有：-**`.left`**：鼠标左键-**`.middle`**：鼠标中间滚轮-**`.right`**：鼠标右键###修饰键可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应：-**`.ctrl`**-**`.alt`**-**`.shift`**-**`.meta`**###事件修饰符a.stop:阻止事件的冒泡机制(点击内层事件会触发外层的点击事件)a.prevent:阻止默认行为c.capture:事件会优先触发,如果加在最外层的事件会往里冒泡d.self:阻止自身冒泡行为的行为,(它不会真正阻止冒泡行为)```text案例:div>div>button1.在内层加入.stop修饰符点击button,只会触发事件冒泡到内层事件2.在内层加入.self修饰符点击button,在事件冒泡过程,不会触发.self的事件```e.once:只会触发一次事件处理函数,>.once需要结合.prevent来使用>>语法:@click.prevent.once####自定义私有指令>-在指定vm对象中定义,值针对vm对象描述的元素生效的指令,>-其他vm对象不能使用该指令```js<divid=\"app\"><inputtype=\"text\"v-dt/></div>Vue.directive(\"dt\",{//绑定时,就可以触发//还没有插入到dom//binding是传递过来的数据,即v-dt=\"数据\"bind:function(el,binding){el.style.color=\"red\";},//inserted函数,表示元素插入到dom中,inserted:function(el){},//表示元素更新时候触发,可以随时触发update:function(el){}})varvm=newVue({el:\"#app\",data:{str:\"str\"},directives:{\"dt\":{bind:function(el,binding){}inserted:function(el){}update:function(el){}}}})```##过滤器>-就是通过输入数据,能够及时对数据进行处理并返回一个数据结果的简单函数>-复用性>-系统会先查找私有再找全局过滤器###全局过滤器>-所有VM对象都能共此案使用的过滤器>>-```js>单个过滤器的使用><p>{{str|myfilter}}</p>><script>>Vue.filter(\"myfilter\",function(value){>....>returnoutValue;>})>varvm=newVue({>el:\"app\",>data:{>str:\"aaa\">}>>})></script>>>连续使用多个过滤器><p>{{str|myfilter1|myfilter2|...}}</p>>```###私有过滤器>-在VM对象定义过滤器>-只能在vm对象中作用>>-```js><p>{{str|myfilter}}</p>><script>>Vue.filter(\"myfilter\",function(value){>....>returnoutValue;>})>varvm=newVue({>el:\"app\",>data:{>str:\"aaa\">},>filters:{>myfilter1:function(value){>....>returnoutValue;>}>}>>})></script>>```##vue对ajax的支持###vue-resource####getthis.$http.get(\"请求路径\",\"请求参数\").then(\"回调函数\")//拿数据data.body.keythis.$http.get(\"请求路径\",\"请求参数\").then(function(data){...}))####postthis.$http.get(\"请求路径?name=data\",\"请求参数\").then(function(data){...}))this.$http.get(\"请求路径\",{name:data},{emulateJSON:true}).then(function(data){...}))###axios>一个基于Promise的HTTP请求客户端,用来发出请求,官方推荐####get```jsaxios({method:\"get\",url:\"url\",params:{\"name\":\"data\"},//传递参数}).then(function(result){console.log(result.data.key)})//使用箭头函数axios({method:\"get\",url:\"url\"}).then(result=>{console.log(result.data.key)})axios.get(\"url\",{params:{\"name\":\"data\"}).then(result=>{console.log(result.data.key);})```####post```js//使用箭头函数axios({method:\"post\",url:\"url\",params:{\"key\":\"data\"}}).then(result=>{console.log(result.data.key)})axios.post(\"url\",\"key=data\".then(result=>{console.log(result.data.key);})```##跨域请求的处理jsonp来处理```jsthis.$http.jsonp('http://localhost:8080/projectName/getData.do').then((result)=>{data=result.body})```##Vue动画<imgsrc=\".assets/transition.png\"style=\"zoom:50%;\"/>Enter(信息进入阶段)v-enter:进去前v-enter-active:进入过程v-enter-to:进去后Leave(信息离开阶段)v-leave:离开前v-leave-active:离开过程v-leave-to:离开后```html<transition><pv-show=\"flag\">aaa</p></transition><style>.v-enter,.v-leave-to{opacity:0;transform:opacity;}.v-enter-active,.v-leave-active{transition:all0.8sease;}</style>```通过name来给指定元素添加特效```html<transitionname=\"tran1\"><pv-show=\"flag\">aaa</p></transition><style>.tran1-enter,.tran1-leave-to{opacity:0;transform:opacity;}.tran1-enter-active,.tran1-leave-active{transition:all0.8sease;}</style>```##其他@keyup=\"fn\":敲键盘之后就会触发@change=\"fn\":数据改变就会触发","vue\\vue-router.md":"#vue-router#vue-router-基础>-[官网](https://router.vuejs.org/zh/)>-[API](https://router.vuejs.org/zh/api/#router-link)##router和route的区别>route为当前router跳转对象里面可以获取name、path、query、params等>router为VueRouter实例，想要导航到不同URL，则使用router.push方法##一个Router###HTML>-router-link,router-view,to```html<scriptsrc=\"https://unpkg.com/vue/dist/vue.js\"></script><scriptsrc=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script><divid=\"app\"><h1>HelloApp!</h1><p><!--使用router-link组件来导航.--><!--通过传入`to`属性指定链接.--><!--<router-link>默认会被渲染成一个`<a>`标签--><router-linkto=\"/foo\">GotoFoo</router-link><router-linkto=\"/bar\">GotoBar</router-link></p><!--路由出口--><!--路由匹配到的组件将渲染在这里--><router-view></router-view></div>```###JavaScript```js//0.如果使用模块化机制编程，导入Vue和VueRouter，要调用Vue.use(VueRouter)//1.定义(路由)组件。//可以从其他文件import进来constFoo={template:'<div>foo</div>'}constBar={template:'<div>bar</div>'}//2.定义路由//每个路由应该映射一个组件。其中\"component\"可以是//通过Vue.extend()创建的组件构造器，//或者，只是一个组件配置对象。//我们晚点再讨论嵌套路由。constroutes=[{path:'/foo',component:Foo},{path:'/bar',component:Bar},]//3.创建router实例，然后传`routes`配置//你还可以传别的配置参数,不过先这么简单着吧。constrouter=newVueRouter({routes,//(缩写)相当于routes:routes})//4.创建和挂载根实例。//记得要通过router配置参数注入路由，//从而让整个应用都有路由功能constapp=newVue({router,}).$mount('#app')//现在，应用已经启动了！```###Home.vue>-注入路由器后>-this.$router:访问路由器>-this.$route:访问当前路由```vueexportdefault{computed:{username(){//我们很快就会看到`params`是什么returnthis.$route.params.username}},methods:{goBack(){window.history.length>1?this.$router.go(-1):this.$router.push('/')}}}```##动态路由>-$route.params>-beforeRouteUpdate>-this.$route.>-this.$route.params.pathMatch###动态路由匹配```jsconstUser={template:'<div>{{$route.params.id}}</div>',}constrouter=newVueRouter({routes:[//动态路径参数以冒号开头//`/user/foo`和`/user/bar`都会映射到相同的路由{path:'/user/:id',component:User},],})```>-$route.params>>|模式|匹配路径|$route.params|>|----------------------------|-------------------|------------------------------------|>|/user/:username|/user/evan|{username:'evan'}|>|/user/:usrname/post/:post_id|/user/evan/post/123|{username:'evan',post_id:'123'}|###响应路由参数的变化>-当使用路由,从/user/foo导航到/user/bar,原来的组件实例会被复用,比起两个路由都渲染同个组件,比起销毁再创建,复用则显得更加高效>>-但是复用意味着生命周期钩子不会再被调用>-复用组件可以使用watch(检测变化)$route对象>>-```js>constUser={>template:`...`,>watch:{>$route(to,from){>//对路由变化做出响应....>},>},>}>```>>-2.2引入beforeRouteUpdate导航守卫>>-```js>constUser={>template:'...',>beforeRouteUpdate(to,from,next){>//next();放行>},>}>```###捕获所有路由或404Notfound路由>-通配符\\*,pathMatch:匹配的部分>>-path:'\\*'匹配所有路径>-path:'/user-\\*'=>匹配'/user-'开头的任意路径>-```js>//给出一个路由{path:'/user-*'}>this.$router.push('/user-admin')>this.$route.params.pathMatch//'admin'>//给出一个路由{path:'*'}>this.$router.push('/non-existing')>this.$route.params.pathMatch//'/non-existing'>```##嵌套路由>-router-view```html<divid=\"app\"><router-view></router-view></div>``````jsconstUser={template:`<divclass='user'><h2>User{{$route.params.id}}</h2><router-view></router-view></div>`,}constrouter=newVueRouter({routes:[{path:'/user/:id',component:User,children:[{//当/user/:id/profile匹配成功，//UserProfile会被渲染在User的<router-view>中path:'profile',component:UserProfile,},{//当/user/:id/posts匹配成功//UserPosts会被渲染在User的<router-view>中path:'posts',component:UserPosts,},],},],})```##编程式的导航###router.push>-router.push(lacation,onComplate?,onAbort?)等同于<router-link:to='....'>>-params,query```js//字符串router.push('home')//对象router.push({path:'home'})//命名的路由router.push({name:'user',params:{userId:'123'}})//带查询参数，变成/register?plan=privaterouter.push({path:'register',query:{plan:'private'}})constuserId='123'router.push({name:'user',params:{userId}})//->/user/123router.push({path:`/user/${userId}`})//->/user/123//这里的params不生效router.push({path:'/user',params:{userId}})//->/user```###router.replace>-`router.replace(location,onComplete?,onAbort?)`>-替换掉当前history,不会向history添加新的记录>-例如一个用户资料到另一个,/users/1=>/users/2```js<router-link:to=\"...\"replace></router-link>//等同于router.replace(...)```###router.go(n)>-在history记录中向前或后退多少步>-类似window.history.go(n)```js//在浏览器记录中前进一步，等同于history.forward()router.go(1)//后退一步记录，等同于history.back()router.go(-1)//前进3步记录router.go(3)//如果history记录不够用，那就默默地失败呗router.go(-100)router.go(100)```##命名路由>-通过一个名称来标识路由```jsconstrouter=newVueRouter({routes:[{path:'/user/:userId',name:'user',component:User}]})<router-link:to=\"{name:'user',params:{userId:123}}\">User</router-link>router.push({name:'user',params:{userId:123}})```##命名视图>-同时(同级)展示多个视图,而且不是嵌套```html<router-viewclass=\"viewone\"></router-view><router-viewclass=\"viewtwo\"name=\"a\"></router-view><router-viewclass=\"viewthree\"name=\"b\"></router-view>//默认是default``````jsconstrouter=newVueRouter({routes:[{path:'/',components:{default:Foo,a:Bar,b:Baz,},},],})```###嵌套命名视图```/settings/emails/settings/profile+-----------------------------------++------------------------------+|UserSettings||UserSettings||+-----+-------------------------+||+-----+--------------------+|||Nav|UserEmailsSubscriptions||+------------>||Nav|UserProfile||||+-------------------------+|||+--------------------+|||||||||UserProfilePreview|||+-----+-------------------------+||+-----+--------------------+|+-----------------------------------++------------------------------+```>-Nav:常规组件>-UserSetting:视图组件>-`UserEmailsSubscriptions`,`UserProfile`,`UserProfilePreview`是嵌套的视图组件```html<!--UserSettings.vue--><div><h1>UserSettings</h1><NavBar/><router-view/><router-viewname=\"helper\"/></div>``````js{path:'/settings',//你也可以在顶级路由就配置命名视图component:UserSettings,children:[{path:'emails',component:UserEmailsSubscriptions},{path:'profile',components:{default:UserProfile,helper:UserProfilePreview}}]}```##重定向和别名###重定向>-/a重定向到/b```jsconstrouter=newVueRouter({routes:[{path:'/a',redirect:'/b'},{path:'/a',redirect:{name:'foo'}},{path:'/a',redirect:(to)=>{//方法接收目标路由作为参数//return重定向的字符串路径/路径对象},},],})```###别名>-`/a`的别名是`/b`，意味着，当用户访问`/b`时，URL会保持为`/b`，但是路由匹配则为`/a`，就像用户访问`/a`一样。```jsconstrouter=newVueRouter({routes:[{path:'/a',component:A,alias:'/b'}],})```##路由组件传参>-$route会使之其对应的路由形成高度耦合,从而使组件只能在某些URL上是使用,限制其灵活性###取代$route的耦合```jsconstUser={template:'<div>User{{$route.params.id}}</div>',}constrouter=newVueRouter({routes:[{path:'/user/:id',component:User}],})```使用props解耦```jsconstUser={props:['id'],template:'<div>User{{id}}</div>',}constrouter=newVueRouter({routes:[{path:'/user/:id',component:User,props:true},//对于包含命名视图的路由，你必须分别为每个命名视图添加`props`选项：{path:'/user/:id',components:{default:User,sidebar:Sidebar},props:{default:true,sidebar:false},},],})```###布尔模式>props被设置成true,route.params将会被设置为组件属性###对象模式>props是一个对象,他会被按照原样设置为组件属性.当props是静态的时候有用```jsconstrouter=newVueRouter({routes:[{path:'/promotion/from-newsletter',component:Promotion,props:{newsletterPopup:false},},],})```###函数模式>创建一个函数返回props,这样子就可以将参数转换成另一种类型,将静态值与基于路由的值结合等```jsconstrouter=newVueRouter({routes:[{paht:'/search',component:SearchUser,props:(route)=>({query:route.query.q}),},],})//当URL为/search?q=vue会将{query;'vue'}作为属性传递给SearchUser组件```##HTML5History模式>-vue-router默认hash模式:模拟一个完整的URL,当URL改变时,页面不后悔重新加载,>-history模式,URL就像正常的url,例如<http://yoursite.com/user/id>>-需要后台正确的配置```jsconstrouter=newVueRouter({mode:'history',routes:[{path:'*',component:NotFoundComponent}],})```#vue-rotuer-进阶##导航守卫>-参数或查询的改变不会进去或离开导航守卫>-可以通过观察$route对象来应对这些变化,或beforeRouteUpdate的组件类守卫###全局前置守卫```jsconstrouter=newVueRouter({...})router.beforeEach((to,from,next)=>{//...})```>-to:Route:即将要进入的目标>-from:Rotue:当前导航正要离开的路由>-next:Function:>-next():进行管道中的下一个钩子.如果全部钩子执行网,则导航状态就是confirmed(确认)>-next(false):中断当前的导航.如果浏览器的URL改变了,可能是用户手动或者浏览器后退按钮,URL地址会重置到from路由对应的地址>-next('/')或next({path:'/'}):跳转到一个不同的地址,当前的导航被中断,然后进行一个新的导航>-且可以设置replace:true,name:'home'等>-next(error):(2.4.0+)如果传入next的参数是一个Error实例,则导航会被终止且该错误会被传递给rotuer.onError()注册过的回调```jsrouter.beforeEach((to,from,next)=>{if(to.name!=='Login'&&!isAuthenticated)next({name:'Login'})//如果用户未能验证用户,则next会被调用两次next()})```###全局解析守卫>2.3.0+>>-router.beforeResolve注册一个全局守卫,>-和router.beforeEach类似>-区别>-在导航确认之前,同时在所有组件内守卫和异步路由组件被解析之后,解析守卫就被调用###全局后置钩子```jsrouter.afterEach((to,from)=>{//...})```###路由独享的守卫>直接在路由配置直接定义beforeEnter守卫```jsconstrouter=newVueRouter({routes:[{path:'/foo',component:Foo,beforeEnter:(to,from,next)=>{//...},},],})```###组件内的守卫>-beforeRouteEnter>-beforeRouteUpdate(2.2+)>-beforeRouteLeave```jsconstFoo={template:`...`,beforeRouteEnter(to,from,next){//在渲染该组件的对应路由被confirm前调用//不！能！获取组件实例`this`//可以通过next(vm=>{/*通过`vm`访问实例*/})//因为当守卫执行前，组件实例还没被创建},beforeRouteUpdate(to,from,next){//在当前路由改变，但是该组件被复用时调用//举例来说，对于一个带有动态参数的路径/foo/:id，在/foo/1和/foo/2之间跳转的时候，//由于会渲染同样的Foo组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。//可以访问组件实例`this`},beforeRouteLeave(to,from,next){//导航离开该组件的对应路由时调用//可以访问组件实例`this`},}```###完整导航解析流程>1.导航被触发>2.在失活的组件调用beforeRouteLeave守卫>3.调用全局的beforeEach守卫>4.在重用的组件里面调用beforeRouteUpdate守卫(2.2+)>5.在路由配置里调用beforeEnter>6.解析异步路由组件>7.在被激活的组件里面调用beforeRouteEnter>8.调用全局的beforeResolve守卫(2.5+)>9.导航被确认>10.调用全局afterEach钩子>11.触发DOM更新>12.调用beforeRouteEnter守卫中传给next的回调函数,创建好的组件实例会作为调用函数的参数传入##路由元信息>定义路由的时候可以通过配置meta字段```jsconstrouter=newVueRouter({routes:[{path:'/foo',component:Foo,children:[{path:'bar',component:Bar,//ametafieldmeta:{requiresAuth:true},},],},],})``````jsrouter.beforeEach((to,from,next)=>{if(to.matched.some((record)=>record.meta.requiresAuth)){//thisrouterequiresauth,checkifloggedin//ifnot,redirecttologinpage.if(!auth.loggedIn()){next({path:'/login',query:{redirect:to.fullPath},})}else{next()}}else{next()//确保一定要调用next()}})```##过渡特效```html//使用动态的transitionname<transition:name=\"transitionName\"><router-view></router-view></transition>//接着在父组件内//watch$route决定使用哪种过渡watch:{'$route'(to,from){consttoDepth=to.path.split('/').lengthconstfromDepth=from.path.split('/').lengththis.transitionName=toDepth<fromDepth?'slide-right':'slide-left'}}```##数据获取###导航完成后获取数据```html<template><divclass=\"post\"><divv-if=\"loading\"class=\"loading\">Loading...</div><divv-if=\"error\"class=\"error\">{{error}}</div><divv-if=\"post\"class=\"content\"><h2>{{post.title}}</h2><p>{{post.body}}</p></div></div></template>``````jsexportdefault{data(){return{loading:false,post:null,error:null,}},created(){//组件创建完后获取数据，//此时data已经被observed了this.fetchData()},watch:{//如果路由有变化，会再次执行该方法$route:'fetchData',},methods:{fetchData(){this.error=this.post=nullthis.loading=true//replacegetPostwithyourdatafetchingutil/APIwrappergetPost(this.$route.params.id,(err,post)=>{this.loading=falseif(err){this.error=err.toString()}else{this.post=post}})},},}```###导航完成前获取数据```jsexportdefault{data(){return{post:null,error:null,}},beforeRouteEnter(to,from,next){getPost(to.params.id,(err,post)=>{next((vm)=>vm.setData(err,post))})},//路由改变前，组件就已经渲染完了//逻辑稍稍不同beforeRouteUpdate(to,from,next){this.post=nullgetPost(to.params.id,(err,post)=>{this.setData(err,post)next()})},methods:{setData(err,post){if(err){this.error=err.toString()}else{this.post=post}},},}```##滚动行为>-只支持history.pushState的浏览器中可用```jsconstrouter=newVueRouter({routes:[...],scrollBehavior(to,from,savedPosition){//savePosition当且仅当popsate导航到(浏览器的前进/后退按钮触发)时才可用//return期望滚动到哪个的位置//{x:number,y:number}//{selector:string,offset?:{x:number,y:number}}(offset只在2.6.0+支持)}})``````js//异步滚动scrollBehavior(to,from,savedPosition){returnnewPromise((resolve,reject)=>{setTimeout(()=>{resolve({x:0,y:0})},500)})}```##路由懒加载>-当路由被访问的时候才加载对应组件,这样子就更加高效结合Vue的异步组件和Webpack的代码分割功能```constFoo=()=>Promise.resolve({/*组件定义对象*/});//Webpack2中,动态import语法来一定代码分块点(splitpoint)import('./Foo.vue')```>注:使用Babel需要添加syntax-dynamic-import插件,才能使Babel可以正确地解析语法```constFoo=()=>import('./Foo.vue')constrouter=newVueRouter({routes:[{path:'/foo',component:Foo}]})```###把组件按组分块有时候我们想把某个路由下的所有组件都打包在同个异步块(chunk)中。只需要使用[命名chunk](https://webpack.js.org/guides/code-splitting-require/#chunkname)，一个特殊的注释语法来提供chunkname(需要Webpack>2.4)。```jsconstFoo=()=>import(/*webpackChunkName:\"group-foo\"*/'./Foo.vue')constBar=()=>import(/*webpackChunkName:\"group-foo\"*/'./Bar.vue')constBaz=()=>import(/*webpackChunkName:\"group-foo\"*/'./Baz.vue')```Webpack会将任何一个异步模块与相同的块名称组合到相同的异步块中。","vue\\vuex.md":"#vuex>状态管理模式来纪中管理状态或信息##使用vuexstore.js```jsimportVuefrom'vue'importVuexfrom'vuex'Vue.use(Vuex)exportdefaultnewVuex.Store({state:{count:1,msg:'msg',},mutations:{},action:{},})```app.js```jsexportdefault{data(){return{msg:'hello',}},computed:{count(){returnthis.$store.state.count//获取单个状态},},}```##Statestore.js```jsimportVuefrom'vue'importVuexfrom'vuex'Vue.use(Vuex)exportdefaultnewVuex.Store({state:{count:0,msg:'msg',},})```app.vue```jsimport{mapState}from'vuex'exportdefualt{data(){msg:'grh',}//方法一computed:mapState({msg(){returnthis.msg+'hello';},msg2(state){returnstate.msg;}})//方法二:使用解构符号...computed:{...mapState(['count','msg']);}}```##Getterstore.js```jsimportVuefrom'vue'importVuexfrom'vuex'Vue.use(Vuex)exportdefaultnewVuex.Store({state:{count:0,msg:'msg',list:[1,2,3,4],},getters:{modifyArr(state){returnstate.list.filter((item,index,arr)=>{returnitem%2==0})},},})```app.js```jsexportdefault{//方法一computed:{list(){returnthis.$store.getters.modifyArr;}}//方法二:mapGetterscomputed:{...mapGetters(['modifyArr'])...mapGetters({getList:'modifyArr'})//指定别名}}```##Mutation>-可以修改store里面的状态>-必须是**同步函数**>-最好在store中先初始化所需要的属性>-当需要添加属性时,使用Vue.set(obj,'newProp',123)或用新的对象替换老对象>>-```js>mutation:{>addNewState(state,payload){>Vue.set(state,'newProp','添加一个新的值');>//另外一个种>this.replaceStae({...state,newProp:'添加一个新值!'})>}>}>>methods:{>addNewProp(){>this.$store.commit('addNewState',{});>}>newMsg(){>returnthis.$store.state.newProp||'还没有添加新值';>}>}>``````jsimport{mapMutation}from'vuex'methods:{add(){this.$store.commit('add');},reduce(){this.$store.commit('reduce');},loadAdd(){this.$store.commit('loadAdd',100)this.$store.commit('loadAdd',{extraCount:100})//传输额外的参数this.$store.commit({type:'addLoad'extraCount:100},{})//将多个写在一个上},//mapMutationusing...mapMutations(['increment',//将`this.increment`映射为'this.$store.commit(increment)''incrementBy',//将'this.incrementBy(amount)'映射为'this.$store.commit('incrementBy',amount)'])//取别名...mapMutations([add:'increment',get:'incrementBy',])}//store.jsmutations:{add(state){state.count++;},reduce(state){state.count--;},loadAdd(state,payload){//提交载荷，额外参数state.count+=payload;},},```##Action>-可以自行异步操作,>-类似于Mutation>-不可以直接修改state```jsactions:{changeProduct(context,payload){//这个context是一个与store实例具有相同方法和属性的对象//调用mutation里的changeProduct方法//context.commit('changeProduct',{change:'ship'});//改成异步方式//setTimeout(()=>{//context.commit('changeProduct',{change:'ship'});//},1500)//使用载荷lettemp='ship+'+payload.extraInfo;setTimeout(()=>{context.commit('changeProduct',{change:temp});},1500)}}methods:{selectProduct(){//this.$store.dispatch('changeProduct')//载荷方式分发//this.$store.dispatch('changeProduct',{//extraInfo:'sportcar'//})//或者这种this.$store.dispatch({type:'changeProduct',extraInfo:'->sportcar'})}},```利用Promise```jsstate:{userInfo:{name:'guan',age:23,}},mutation:{changeInfo(state,payload){state.userInfo.name='ruihua'}},actions:{changeInfo(context,payload){returnnewPromise((resolve,reject)=>{setTimeout(()=>{context.commit('changeInfo');resolove();},2000)})}}//app.jsdata(){return{status:'nochanged',}},methods:{modifyInfo(){this.$store.dispatch('changeInfo')}}```action可以相互调用```jsactions:{actionA({commit}){returnnewPromise((resolve,reject)=>{setTimeout(()=>{commit('someMutation')resolve()},1000)})},actionB({dispatch,commit}){returndispatch('actionA').then(()=>{//调用了actionAcommit('someOtherMutation')})}}```##Module###分模块管理方法```js//先定义两个模块constmoduleA={state:{name:'guan',age:'23'},mutations:{},getters:{},action:{},}constmoduleB={state:{name:'rui',age:'22'},mutations:{},getters:{},action:{},}//在Vuex里面声明模块exportdefaultnewVuex.Store({modules:{ma:moduleA,mb:moduleB},state:{...//其他状态},})//app.vuecompute:{msg(){returnthis.$store.mb;//{name:'rui',age:'22'}}}```###命名空间模块```jsexportconstmoduleC={namespaced:true,state:{name:'moduleC',desc:'这是模块C，用来测试命名空间的！',list:[1,2,3,4]},getters:{filterList(state){returnstate.list.filter((item,index,arrSelf)=>{returnitem%2!==0;});}},mutations:{modifyName(state,payload){state.name=payload.newName;}},actions:{}}//store.jsimport{moduleC}from'./module_c.js';exportdefaultnewVuex.Store({modules:{mc:moduleC},})methods:{modify(){//this.$store.commit('mc/modifyName',{//newName:'命名空间模块C'//})this.$store.commit({type:'mc/modifyName',newName:'命名空间模块C'})}}//命名空间发生改变后,mapState,mapGetters,mapMutations,mapActions用法改变//1....mapState('mc',['name','age']);...mapState('mc',{name(state){returnstate.name;},age(state){returnstate.age;}})//2.使用createNamespacedHelpers创建基于某个命名空间辅助函数import{createNamespacedHelpers}from'vuex';const{mapState,mapMutations}=createNamespacedHelpers('mc');``````vue<script>import{mapGetters,mapState,mapMutations,mapActions}from'vuex'exportdefault{computed:{...mapState('loginStore',['text','num']),},methods:{//这里的loginStore是命名空间...mapGetters('loginStore',['getData']),...mapMutations('loginStore',['add']),...mapActions('loginStore',['addAction']),}</script>```##vuex与v-model对数据处理```js<inputv-model=\"message\">computed:{message:{get(){returnthis.$store.state.obj.message},set(value){this.$store.commit('updateMessage',value)}}}mutations:{updateMessage(state,message){state.obj.message=message}}```","vue\\二次封装\\event.md":"#[`event`](https://juejin.cn/post/7275261996860866615#heading-3)-继承第三方组件Event事件-`$listeners`:在vue3已经被移除,合并到`$attrs`中```html<!--vue2--><el-inputv-bind=\"$attrs\"v-on=\"$listeners\"></el-input><!--vue3--><el-inputv-bind=\"$attrs\"></el-input>```","vue\\二次封装\\method.md":"#[`method`](https://juejin.cn/post/7275261996860866615#heading-3)###vue3```html<template><divclass=\"my-table\"><el-tableref=\"table\"></el-table></div></template><scriptlang=\"ts\"setup>import{ref,onMounted}from'vue'import{ElTable}from'element-plus'consttable=ref();onMounted(()=>{constentries=Object.entries(table.value);for(const[method,fn]ofentries){expose[method]=fn;}});defineExpose(expose);```##vue2```html<template><divclass=\"my-table\"><el-tableref=\"el-table\"></el-table></div></template><script>exportdefault{mounted(){this.extendMethod()},methods:{extendMethod(){constrefMethod=Object.entries(this.$refs['el-table'])for(const[key,value]ofrefMethod){if(!(key.includes('$')||key.includes('_'))){this[key]=value}}},};</script>```","vue\\二次封装\\slot.md":"#[`slot`](https://juejin.cn/post/7275261996860866615#heading-3)##vue3```html<template><divclass=\"my-input\"><el-inputv-model=\"childSelectedValue\"v-bind=\"attrs\"v-on=\"$listeners\"><template#[slotName]=\"slotProps\"v-for=\"(slot,slotName)in$slots\"><slot:name=\"slotName\"v-bind=\"slotProps\"></slot></template></el-input></div></template>```##vue2```html<template><divclass=\"my-input\"><el-inputv-model=\"childSelectedValue\"v-bind=\"attrs\"v-on=\"$listeners\"><!--遍历子组件非作用域插槽，并对父组件暴露--><templatev-for=\"(index,name)in$slots\"v-slot:[name]><slot:name=\"name\"/></template><!--遍历子组件作用域插槽，并对父组件暴露--><templatev-for=\"(index,name)in$scopedSlots\"v-slot:[name]=\"data\"><slot:name=\"name\"v-bind=\"data\"></slot></template></el-input></div></template>```","vue\\二次封装\\v-model.md":"#[`v-model`](https://juejin.cn/post/7275261996860866615#heading-3)##vue3```html<!--父组件--><template><my-inputv-model=\"msg\"></my-input><!--等同于--><my-input:modelValue=\"msg\"@update:modelValue=\"msg=$event\"></my-input></template><scriptsetuplang=\"ts\">import{ref}from'vue'constmsg=ref('hello')</script><!--子组件--><template><el-input:modelValue=\"modelValue\"@update:modelValue=\"handleValueChange\"></el-input></template><scriptsetuplang=\"ts\">constprops=defineProps({modelValue:{type:String,default:'',},})constemit=defineEmits(['update:modelValue'])consthandleValueChange=(value)=>{emit('update:modelValue',value)}</script>```##vue2```html<!--子组件--><template><div><inputtype=\"text\":value=\"value\"@input=\"$emit('input',$event.target.value)\"/></div></template><script>exportdefault{props:{value:String,//默认接收一个名为value的prop},}</script>```-使用```html<!--父组件--><my-inputv-model=\"msg\"></my-input>//等同于<my-input:value=\"msg\"@input=\"msg=$event\"></my-input>```","vue\\二次封装\\属性.md":"#[`属性`](https://juejin.cn/post/7275261996860866615#heading-3)```html<MyInput:size=\"inputSize\":name=\"userName\":clearable=\"clearable\"></MyInput>```##根节点还是原组件-一般用于给第三方组件设置属性默认值```html<template><!--<el-inputv-bind=\"$attrs\"></el-input>--><!--v-bind=\"$attrs\"可以省略--><el-inputv-bind=\"$attrs\"></el-input></template><scriptsetup>defineOptions({name:'MyInput'//或不设置//继承属性inheritAttrs:true})</script>```##defineOptions,过滤属性-重写第三方组件部分功能```html<template><divclass=\"my-input\"><el-inputv-bind=\"filteredAttrs\"></el-input><!--如果不希望过滤掉某些属性可以直接使用$attrs--><el-inputv-bind=\"$attrs\"></el-input></div></template><scriptsetup>import{useAttrs,computed,ref}from'vue'import{ElInput}from'element-plus'defineOptions({name:'MyInput',//禁止透传,通过useAttrs获取inheritAttrs:false,})//接收name，其余属性都会被透传给el-inputdefineProps({name:String,})//如果我们不希望透传某些属性比如class,我们可以通过useAttrs来实现constattrs=useAttrs()constfilteredAttrs=computed(()=>{return{...attrs,class:undefined}})</script>```","vue\\二次封装\\节点ref.md":"#[`节点ref`](https://juejin.cn/post/7275261996860866615#heading-3)-问题:封装后无法获取被封装组件的事例-解决:通过二次封装时候,使用`defineExpose`暴露被封装组件属性```html<template><el-inputref=\"childRef\"v-bind=\"$attrs\"></el-input></template><scriptsetup>import{onMounted,reactive,ref}from'vue';/*defineOptions参考插件https://vue-macros.sxzz.moe/macros/define-options.html或者参考官网对setup中设置name的解释https://cn.vuejs.org/api/options-misc.html#name*/defineOptions({name:'myInput'});constchildRef=ref();constoptions=reactive<{[K:string]:any}>({});onMounted(()=>{constentries=Object.entries(childRef.value);for(let[key,value]ofentries){if(!value||typeofvalue!=='function'){continue;}options[key]=value;}});//暴露全部方法defineExpose(options);</script>```","vue\\文件相关\\index.md":"#文件相关>[Vue项目导入导出csv文件](https://www.cnblogs.com/wjw1014/p/13150412.html)>>[前端vue表格数据导出Excel文件实现](https://www.cnblogs.com/zhaoxiaobei/p/10912432.html)","vue\\特性\\children.md":"#vue获取和react的children```html<scriptsetup>import{getCurrentInstance}from'vue'constinst=getCurrentInstance()constchildren=inst.slots.default()</script>```","vue\\特性\\属性透传.md":"#[`属性透传`](https://cn.vuejs.org/guide/components/attrs.html#class-and-style-merging)-Attributes继承```html<!--<MyButton>的模板--><buttonclass=\"btn\">clickme</button><!--使用--><MyButtonclass=\"large\"/><!--渲染结果--><buttonclass=\"btnlarge\">clickme</button>```>`class`就会合并##关闭继承```html<scriptsetup>defineOptions({inheritAttrs:false,})//...setup逻辑</script>```","vue\\语法糖\\slot\\作用域插槽.md":"#[`作用域插槽`](https://cn.vuejs.org/guide/components/slots.html#scoped-slots)![](./.assets/作用域插槽-2023-10-13-17-24-48.png)-传入渲染`<MyComponent/>`里的`slot`的属性的模板##egFancyList.vue```html<scriptsetup>import{ref}from'vue'constprops=defineProps(['api-url','per-page'])constitems=ref([])//mockremotedatafetchingsetTimeout(()=>{items.value=[{body:'ScopedSlotsGuide',username:'EvanYou',likes:20},{body:'VueTutorial',username:'NataliaTepluhina',likes:10},]},1000)</script><template><ul><liv-if=\"!items.length\">Loading...</li><liv-for=\"iteminitems\"><slotname=\"item\"v-bind=\"item\"/></li></ul></template><stylescoped>ul{list-style-type:none;padding:5px;background:linear-gradient(315deg,#42d39225%,#647eff);}li{padding:5px20px;margin:10px;background:#fff;}</style>``````html<!--使用--><scriptsetup>importFancyListfrom'./FancyList.vue'</script><template><FancyListapi-url=\"url\":per-page=\"10\"><template#item=\"{body,username,likes}\"><divclass=\"item\"><p>{{body}}</p><pclass=\"meta\">by{{username}}|{{likes}}likes</p></div></template></FancyList></template><stylescoped>.meta{font-size:0.8em;color:#42b883;}</style>```![](./.assets/作用域插槽-2023-10-13-17-42-28.png)","vue\\语法糖\\slot\\具名插槽.md":"#[`具名插槽`](https://cn.vuejs.org/guide/components/slots.html#named-slots)-默认命名:`default`-简写:`v-slot:name`=>`#name`![](./.assets/具名插槽-2023-10-13-17-05-25.png)```html<!--组件--><divclass=\"container\"><header><slotname=\"header\"></slot></header><main><slot></slot></main><footer><slotname=\"footer\"></slot></footer></div><!--使用组件--><BaseLayout><template#header><h1>Heremightbeapagetitle</h1></template><template#default><p>Aparagraphforthemaincontent.</p><p>Andanotherone.</p></template><template#footer><p>Here'ssomecontactinfo</p></template></BaseLayout><!--使用组件(简写)--><BaseLayout><template#header><h1>Heremightbeapagetitle</h1></template><!--隐式的默认插槽--><p>Aparagraphforthemaincontent.</p><p>Andanotherone.</p><template#footer><p>Here'ssomecontactinfo</p></template></BaseLayout><!--渲染结果--><divclass=\"container\"><header><h1>Heremightbeapagetitle</h1></header><main><p>Aparagraphforthemaincontent.</p><p>Andanotherone.</p></main><footer><p>Here'ssomecontactinfo</p></footer></div>```-当组件同时接受默认插槽和具名插槽,`#default`会隐性转换为默认的插槽的内容","vue\\语法糖\\slot\\基础使用.md":"#[`slot`](https://cn.vuejs.org/guide/components/slots.html)>-类似`react`的`children`##基础使用```html<!--FancyButton组件--><buttonclass=\"fancy-btn\"><slot></slot><!--插槽出口--></button><!--使用--><FancyButton>Clickme!<!--插槽内容--></FancyButton><!--渲染--><buttonclass=\"fancy-btn\">Clickme!</button>```##默认值```html<buttontype=\"submit\"><slot>Submit<!--默认内容--></slot></button>```","vue\\语法糖\\依赖注入.md":"#[`依赖注入`](https://cn.vuejs.org/guide/components/provide-inject.html)-跨层级传输```html<scriptsetup>import{provide}from'vue'provide(/*注入名*/'message',/*值*/'hello!')</script><scriptsetup>import{inject}from'vue'constmessage=inject('message')</script>```","vue\\语法糖\\监听.md":"#[`监听`]()##API```tswatch(WatcherSource,Callback,[WatchOptions])typeWatcherSource<T>=Ref<T>|(()=>T)typeCallback=(newValue,oldValue)=>voidinterfaceWatchOptionsextendsWatchEffectOptions{deep?:boolean//默认：falseimmediate?:boolean//默认：falseflush?:string//默认：'pre'}```-`WatcherSource`:监听数据源-`Callback`:回调函数-`WatchOptions`:-`deep`:对响应式对象深度监听-`immediate`:初始化立即执行回调函数-`flush`:-`pre`:渲染前-`post`:渲染之后-`sync`:值发生改变```jsconstname=ref('xyy')constage=ref(18)watch(name,(name,prevName)=>{console.log('newName',name,'oldName',prevName)})watch([name,age],([name,age],[prevName,prevAge])=>{console.log('newName',name,'oldName',prevName)console.log('newAge',age,'oldAge',prevAge)})//orwatch(()=>[name,age],([name,age],[prevName,prevAge])=>{console.log('newName',name,'oldName',prevName)console.log('newAge',age,'oldAge',prevAge)},)```","跨端\\Electron\\index.md":"#Electron-[桌面悬浮球](https://juejin.cn/post/7460779695833333811)><https://juejin.cn/post/7084126780390375461>>快速搭建桌面应用>>[快速入门|Electron(electronjs.org)](https://www.electronjs.org/docs/tutorial/quick-start)>>[Electron桌面环境集成\\_w3cschool](https://www.w3cschool.cn/electronmanual/lz4y1ql3.html)shell:通过电脑的默认浏览器打开链接","跨端\\Electron\\问题.md":"#electron问题杀毒软件破坏检查防止debug调试客户端崩溃报告提升客户端启动速度性能监测分析延迟加载模块滚动条样式统一browserWindow错误监听browserWindowa标签，打开默认浏览器electron-中无法使用-jquery、requirejs、meteor、angularjs。electron-bridge代理设置系统版本比较(mac)多窗口管理类似vscode无缝升级安装杀毒软件破坏检查对于内部的一些核心的文件，可以通过白名单机制，来查看文件是否存在，如果不存在则报告软件被破坏，直接退出。```jsconstgetBinaryFileCheckList=()=>{constdir=[];//比如network-interface这个包是必须的。constnetwork=require.resolve(\"network-interface/package\"),dir.push(network);returndir;}constbinaryFileCheckList=getBinaryFileCheckList();<!--检查-->for(lete=0;e<binaryFileCheckList.length;e++){constn=binaryFileCheckList[e];if(!fs.existsSync(n)){dialog.showErrorBox(\"启动失败\",\"应用文件损坏，可能是杀毒软件导致，请重新下载安装\");//直接exitelectronApp.exit(1);break}}```##防止debug调试需要检查argv的参数上是否存在chrome调试的关键词例如inspect或者debugging等。```jsconstrunWithDebug=process.argv.find((e)=>e.includes('--inspect')||e.includes('--inspect-brk')||e.includes('--remote-debugging-port'),)if(runWithDebug){//直接退出。electronApp.quit()}```##客户端崩溃报告可以借助第三方插件来辅助客户端崩溃报告@sentry/electron中文文档<https://www.yuque.com/lizhiyao/dxydance/sentry-javascript-readme-cn>##提升客户端启动速度提升客户端的启动速度有好几个方面去着手。###使用V8缓存数据electorn使用V8引擎运行js，V8运行js时，需要先进行解析和编译，再执行代码。其中，解析和编译过程消耗时间多，经常导致性能瓶颈。而V8缓存功能，可以将编译后的字节码缓存起来，省去下一次解析、编译的时间。使用v8-compile-cache缓存编译插件的代码v8-compile-cache的使用非常简单，在需要缓存的代码中，添加一行代码即可：`require('v8-compile-cache')`v8-compile-cache默认缓存到临时文件夹<os.tmpdir()>/v8-compile-cache-<V8_VERSION>下，电脑重启后，该文件会被清除掉。如果希望缓存永久化，可以通过环境变量process.env.V8_COMPILE_CACHE_CACHE_DIR来指定缓存文件夹，避免电脑重启后删除。另外，如果希望项目的不同版本对应的缓存不同，可以在文件夹名中加入代码版本号（或其他唯一标识），以此保证缓存和项目版本完全对应。当然，这也意味着项目的多个版本有多份缓存。为了不占用过多磁盘空间，在程序退出时，我们需要删除其他版本的缓存。###性能监测分析主进程，可以用v8-inspect-profiler进行性能监测。生成的.cpuprofile文件，可以用devtools上的JavascriptProfiler进行分析。如果用fork等方法启动了子进程，也可以用相同的方法监测，只需要设置不同的监测端口。v8-inspect-profiler设置启动命令，添加参数--inspect=${port}，设置主进程的v8调试端口。```js//package.json{\"name\":\"test\",\"version\":\"1.0.0\",\"main\":\"main.js\",\"devDependencies\":{\"electron\":\"9.2.1\"},\"scripts\":{\"start\":\"electron.--inspect=5222\"},\"dependencies\":{\"v8-inspect-profiler\":\"^0.0.20\"}}```###延迟加载模块项目的一些依赖模块，是在特定功能触发时才需要使用。所以，没有必要在应用启动时立刻加载，可以在方法调用时再加载。优化前```js//导入模块constxxx=require('xxx');exportfunctionshare(){...//执行依赖的方法xxx()}```优化后```jsexportfunctionshare(){//导入模块constxxx=require('xxx');...//执行依赖的方法xxx()}```##滚动条样式统一>对于window和macOs系统里面,默认的滚动轴的宽度是不一样的，先获取滚动轴宽度```jsfunctiongetScrollbarWidth(){constdiv=document.createElement('div')div.style.visibility='hidden'div.style.width='100px'document.body.appendChild(div)constoffsetWidth=div.offsetWidthdiv.style.overflow='scroll'constchildDiv=document.createElement('div')childDiv.style.width='100%'div.appendChild(childDiv)constchildOffsetWidth=childDiv.offsetWidthdiv.parentNode.removeChild(div)returnoffsetWidth-childOffsetWidth}```然后根据getScrollbarWidth做不同设置。例如：```js<!--滚动条上的滚动滑块-->::-webkit-scrollbar-thumb{background-color:rgba(180,180,180,0.2);border-radius:8px;}::-webkit-scrollbar-thumb:hover{background-color:rgba(180,180,180,0.5);}<!--滚动条轨道-->::-webkit-scrollbar-track{border-radius:8px;}<!--整个滚动条-->::-webkit-scrollbar{width:8px;height:8px;}document.onreadystatechange=(()=>{if(\"interactive\"===document.readyState){//处理逻辑}})```##browserWindow错误监听>主要是监听unhandledrejection和error事件###error```jswindow.addEventListener('error',(error)=>{constmessage={message:error.message,source:error.source,lineno:error.lineno,colno:error.colno,stack:error.error&&error.error.stack,href:window.location.href,}//通过ipcRender发送到主进程进行日志记录。ipcRenderer.send('weblog',n)},false,)```###unhandledrejection```jswindow.addEventListener('unhandledrejection',(error)=>{if(!error.reason){return;}constmessage={message:error.reason.message,stack:error.reason.stack,href:window.location.href}<!--通过ipcRender发送到主进程进行日志记录。-->ipcRenderer.send(\"weblog\",n)},false)```##browserWindowa标签，打开默认浏览器业务上面，一般会在browserWindow页面上面，会存在a标签，这个时候，如果在electron容器里面，就需要做拦截，并通过默认浏览器打开。```jsdocument.addEventListener('click',(event)=>{consttarget=event.targetif(target.nodeName==='A'){if(event.defaultPrevented){return}if(location.hostname){event.preventDefault()}if(target.href){shell.openExternal(target.href)}}},false,)```暴露一个全局的打开浏览器的方法```jswindow.openExternalLink=(r)=>{shell.openExternal(r)}```##无法使用->>因为Electron在运行环境中引入了Node.js，所以在DOM中有一些额外的变量，比如module、exports和require。这导致了许多库不能正常运行，因为它们也需要将同名的变量加入运行环境中。>>1.一种就是通过配置webPreferences.nodeIntegration为false，通过禁用node.js>2.通过在electron-bridge.js里面最头部deletewindow.require;,deletewindow.exports;,deletewindow.module;方式a```js//在主进程中const{BrowserWindow}=require('electron')constwin=newBrowserWindow(format@@webPreferences:{nodeIntegration:false}})win.show()``````html<head><script>window.nodeRequire=requiredeletewindow.requiredeletewindow.exportsdeletewindow.module</script><scripttype=\"text/javascript\"src=\"jquery.js\"></script></head>```###electron-bridge>通过bridge向browserWindow注入electron额外的api```jsconst{ipcRenderer:ipcRenderer,shell:shell,remote:remote,clipboard:clipboard}=require(\"electron\"),```<!--process里面参数-->```jsconstprocessStaticValues=_.pick(process,['arch','argv','argv0','execArgv','execPath','helperExecPath','platform','type','version','versions',])module.exports=()=>({ipcRenderer:ipcRenderer,//ipcrenderershell:shell,//shellremote:remote,//clipboard:clipboard,process:{...processStaticValues,hang:()=>{process.hang()},crash:()=>{process.crash()},cwd:()=>{process.cwd()},},})```##代理设置对于代理设置，一般有两种模式：PACHTTPPAC直接输入地址Protocol://IP:PortHTTP对于HTTP模式下，有HTTPSOCKS4SOCKS5输入Protocol://IP:Port系统版本比较(mac)推荐使用semver来。多窗口管理推荐electron-windows,支持动态创建窗口。地址类似vscode无缝升级安装大体思路：先挂载dmg,找到挂载目录,在mac下是/Volumes目录下;删除/Applications下的app,将/Volumes下的app拷贝到/Applications目录下;再卸载dmg;重启应用即可,该方法可实现类似无缝更新的效果。主要借助于hdiutil实现的、主要分为六个步骤：>whichhdiutil>hdiutileject[/Volumes/appDisplayNamelatestVersion]>hdiutilattach[latestDmgPath]>mv[localAppPath][tempdir]>cp-R[latestapppath][localapppath]>hdiutileject[/Volumes/appDisplayNamelatestVersion]>whichhdiutil>查看hdiutil可执行文件是否存在。>>hdiutileject[/Volumes/appDisplayNamelatestVersion]>卸载[/Volumes/appDisplayNamelatestVersion]下面的文件。>>hdiutilattach[latestDmgPath]>安装dmg文件>>mv[localAppPath][tempdir]>将旧的本地app目录移动到tempDir目录中。>>cp-R[latestapppath][localapppath]>将latestapppath文件下的所有文件，都复制到原本的app目录下面。>>hdiutileject[/Volumes/appDisplayNamelatestVersion]>再次卸载[/Volumes/appDisplayNamelatestVersion]下面的文件>>每一步下来，如果都成功了，则成功了。实例代码。```jsconstpath=require('path')constos=require('os')const{waitUntil,spawnAsync}=require('../../utils')const{existsSync}=require('original-fs')constgetMacOSAppPath=()=>{constsep=path.sepconstexecPathList=process.execPath.split(sep)constindex=execPathList.findIndex((t)=>'Applications'===t)returnexecPathList.slice(0,index+2).join(sep)}module.exports=async(app)=>{const{appDisplayName}=app.configconst{latestVersion,latestDmgPath}=app.updateInfo//constmacOsAppPath=getMacOSAppPath()//tempdirconsttempDir=path.join(os.tmpdir(),String(newDate().getTime()))constappDisplayNameVolumesDir=path.join('/Volumes',`${appDisplayName}${latestVersion}`,)//constlatestAppPath=path.join(appDisplayNameVolumesDir,`${appDisplayName}.app`,)//step1whichhdiutil///usr/bin/hdiutiltry{consthdiutilResult=awaitspawnAsync('which',['hdiutil'])if(!hdiutilResult.includes('/bin/hdiutil')){thrownewError('hdiutilnotfound')}}catch(e){app.logger.warn(e)return{success:false,type:'dmg-install-failed',}}//step2hdiutilejectappDisplayNameVolumesDirtry{awaitspawnAsync('hdiutil',['eject',appDisplayNameVolumesDir])}catch(e){e.customMessage='[InstallMacOSDmgError]step2volumeexists'app.logger.warn(e)}finally{constresult=awaitwaitUntil(()=>!existsSync(latestAppPath),{ms:300,retryTime:5,})if(!result){app.logger.warn('[InstallMacOSDmgError]step2volumeexists')return{success:false,}}}//step3hdiutilattachlatestDmgPathtry{awaitspawnAsync('hdiutil',['attach',latestDmgPath])}catch(e){e.customMessage='[InstallMacOSDmgError]step3hdiutilattacherror'app.logger.warn(e)}finally{constresult=awaitwaitUntil(()=>!existsSync(latestAppPath),{ms:300,retryTime:5,})if(!result){app.logger.warn('[InstallMacOSDmgError]step3hdiutilattachfail')return{success:false,}}}//step4mvtry{awaitspawnAsync('mv',[macOsAppPath,tempDir])}catch(e){e.customMessage='[InstallMacOSDmgError]step4mvtotmppatherror'app.logger.warn(e)}finally{constresult=awaitwaitUntil(()=>!existsSync(tempDir),{ms:300,retryTime:5,})if(!result){app.logger.warn('[InstallMacOSDmgError]step4cptotmppathfail')return{success:false,type:'dmg-install-failed',}}}//step5try{awaitspawnAsync('cp',['-R',latestAppPath,macOsAppPath])}catch(e){e.customMessage='[InstallMacOSDmgError]step5cptoapperror'app.logger.warn(e)}finally{constresult=awaitwaitUntil(()=>!existsSync(macOsAppPath),{ms:300,retryTime:5,})if(!result){app.logger.warn('[InstallMacOSDmgError]step5cptoappfail')awaitspawnAsync('mv',[tempDir,macOsAppPath])return{success:false,type:'dmg-install-failed',}}}//step6try{awaitspawnAsync('hdiutil',['eject',appDisplayNameVolumesDir])}catch(e){e.customMessage='[InstallMacOSDmgError]step6hdiutilejectfail'app.logger.warn(e)}return{success:true,}}```","跨端\\error\\Permission denied.linux.md":"#[`Permissiondenied`](/)##-bash:./[name]:Permissiondenied-文件权限不足-用户权限不足```shellsudochmod-R777[文件夹/目录]```","跨端\\Flutter\\环境搭建.md":"#环境搭建><https://zhuanlan.zhihu.com/p/367097967>><https://github.com/flutter/flutter/issues/98170>><https://github.com/flutter/flutter/issues/98170>><https://blog.csdn.net/ouhuanquan/article/details/123134340>>需要C++,Android环境,Flutter环境##flutterdoctor>检查环境是否成功##flutterdoctor--android-licenses>生成证书","跨端\\index.md":"#跨端-单个可执行应用程序##EnigmaVirtualBox-非开源,需要购买##[nexe](https://github.com/nexe/nexe)-只支持将Node.js应用程序打包成Windows和Linux平台的可执行文件-不支持macOS##[pkg](https://www.npmjs.com/package/pkg)-<https://github.com/vercel/pkg-fetch/releases>-打包mac签名过不了-<https://github.com/vercel/pkg>![](./.assets/README-2025-03-10-16-31-00.png)##SEA/postject<https://nodejs.org/api/single-executable-applications.html><https://github.com/nodejs/postject>##node-packer-<https://github.com/pmq20/node-packer>-lastupdate5yearsago##[ncc](https://github.com/vercel/ncc)-需要nodejs运行##[boxednode](https://www.npmjs.com/package/boxednode)-属pkg二次封装#跨端##[electron](https://www.npmjs.com/package/electron)-<https://cloud.baidu.com/article/3005755>##nwjs##[tauri](https://tauri.app/plugin/autostart/)","跨端\\pkg\\error.md":"#Mac平台下如何制作pkg安装包<https://blog.csdn.net/new9232/article/details/131734812>","跨端\\pkg\\index.md":"#pkg<https://www.npmjs.com/package/pkg/v/4.3.8?activeTab=readme>```shellnpminstall-gpkgnpxpkgdemo.js--targetsnode18-win-x64,node18-linux-x64,node18-macos-x64--output=dist/```","跨端\\React-Native\\index.md":"#React-Native><https://blog.csdn.net/qq_40259641/article/details/100115329>><https://reactnative.cn/docs/environment-sectup>><https://docs.microsoft.com/zh-cn/windows/dev-environment/javascript/react-native-for-android>##环境配置问题><https://reactnative.cn/docs/environment-setup>","跨端\\SEA.md":"#SEA-node内置把js脚本打包成exe执行文件-<https://nodejs.org/api/single-executable-applications.html>","跨端\\修改exe文件信息.md":"#修改exe文件信息-测试脚本,pkg打包js脚本##pkg+rcedit-会导致里面js脚本执行失败-`Pkg:Errorreadingfromfile.`-npm包,exe程序##pkg+ResourceHacker-会导致里面js脚本执行失败##sea+ResourceHacker-可以正常执行##sea+rcedit-执行会卡住","跨端\\小程序\\Taro\\文档\\基础.md":"","跨端\\小程序\\Taro\\文档\\框架.md":"","跨端\\小程序\\Taro\\文档\\路由.md":"#路由##`Taro.switchTab(option)`>跳转到tabBar页面，并关闭其他所有非tabBar页面>>支持情况：微信小程序,H5,ReactNative###类型`(option:Option)=>Promise<TaroGeneral.CallbackResult>`###Option|参数|类型|必填|说明||--------|-------------------------------------------|:--:|------------------------------------------------------------------------------------------||url|string|是|需要跳转的tabBar页面的路径（需在app.json的tabBar字段定义的页面），路径后不能带参数。||complete|`(res:TaroGeneral.CallbackResult)=>void`|否|接口调用结束的回调函数（调用成功、失败都会执行）||fail|`(res:TaroGeneral.CallbackResult)=>void`|否|接口调用失败的回调函数||success|`(res:TaroGeneral.CallbackResult)=>void`|否|接口调用成功的回调函数|```js{\"tabBar\":{\"list\":[{\"pagePath\":\"index\",\"text\":\"首页\"},{\"pagePath\":\"other\",\"text\":\"其他\"}]}}``````jsTaro.switchTab({url:'/index',})```","跨端\\小程序\\Taro\\问题.md":"#小程序开发问题>多端小程序框架>[Hooks|Taro文档(jd.com)](https://taro-docs.jd.com/taro/docs/hooks)><https://cloud.tencent.com/developer/article/1820510>><https://github.com/NervJS/taro/issues/7302>><https://github.com/flutter/flutter/issues/98170>##tabBar切换失败问题>平台:微信小程序>需要清理缓存和dist文件,重新生成,不然会有切换失败##Taro-UI问题>2022-04-1509:50:04Taro@3不支持使用Taro-ui@2,Taro-ui@3还没有正式版>Taro-ui引入index.scss错误问题>安装tao-ui时,如果出现报错，可以尝试更换taro-ui版本，因为目前taroui2.+和taro3.+版本不兼容,使用以下命令可解决>`npminstalltaro-ui@3.0.0-alpha.3`","跨端\\小程序\\微信小程序\\api\\web-view.md":"#web-view>组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面。个人类型与海外类型的小程序暂不支持使用>个人版只可以在开发者工具预览,手机预览失败","跨端\\小程序\\微信小程序\\webview.md":"#web-view>-个人类型与海外类型的小程序暂不支持使用>-基础库版本需要1.6.4及以上>-使用web-view会覆盖掉其他组件，并充满屏幕，所以只能单独使用##","跨端\\小程序\\微信小程序\\云函数.md":"#云函数##添加第三方包>如果`npminstallpackage`等命令失败>可以直接修改package.json,添加对应的包,部署时候不用部署node_modules即可","跨端\\小程序\\微信小程序\\开放信息\\UnionID.md":"#UnionID>需要微信开放平台绑定了小程序才有##机制>如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过UnionID来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的UnionID是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。##获取途径-绑定了开发者帐号的小程序，可以通过以下途径获取UnionID。-开发者可以直接通过`wx.login+code2Session`获取到该用户`UnionID`，无须用户授权。-小程序端调用云函数时，可在云函数中通过`Cloud.getWXContext`获取`UnionID`。-用户在小程序（暂不支持小游戏）中支付完成后，开发者可以直接通过`getPaidUnionId`接口获取该用户的`UnionID`，无需用户授权。注意：本接口仅在用户支付完成后的5分钟内有效，请开发者妥善处理。##微信开放平台绑定小程序流程>登录微信开放平台—管理中心—小程序—绑定小程序![](./.assets/UnionID-2022-04-24-09-59-31.png)","跨端\\小程序\\微信小程序\\微信小程序_basic.md":"#微信小程序>[小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)##搭建环境>申请AppID>>编辑器->选择小程序->点击+;>>自行创建项目+填入appid,不选择云开发,然后点击新建###目录结构```basic├─pages│├─index//对应每个页面内部必须包含以下四个文件││index.js//页面逻辑││index.json//页面配置││index.wxml//页面结构││index.wxss//页面样式│└─logs│logs.js│logs.json│logs.wxml│logs.wxss└─utils//工具类│util.js│app.js//描述小程序整体逻辑│app.json//小程序公共配置│app.wxss//小程序公共样式│project.config.json//项目配置文件│sitemap.json/***需要注意的是page中4个文件必须同名**/```##小程序配置>小程序根目录下的`app.json`文件用来对微信小程序进行**全局配置**```json{//配置小程序默认启动页\"entryPagePath\":\"pages/logs/logs\",//对应小程序中的每一个页面,如果没有entryPagePath,pages中的第一项为启动页\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{//导航栏背景颜色\"navigationBarBackgroundColor\":\"#ccc\",//导航栏文字颜色whiteblack\"navigationBarTextStyle\":\"white\",//导航栏文字内容\"navigationBarTitleText\":\"wx\",//下拉loading样式darklight;需要配置下面这个配置才能开启\"backgroundTextStyle\":\"dark\",//是否开启全局的下拉刷新\"enablePullDownRefresh\":true,//导航栏样式custom,default;custom以上配置全部失效,只保留右上角胶囊,topBar需要自己写样式定义\"navigationStyle\":\"custom\"},\"tabBar\":{//tabBar文字颜色\"color\":\"#444\",//tabBar文字选中颜色\"selectedColor\":\"#f1f1f1\",//tabBar背景颜色\"backgroundColor\":\"#fff\",//tabBar上边框颜色\"borderStyle\":\"#ccc\",//最多配置5个tab,最少2个\"list\":[//必须在pages中存在\"pagePath\":\"pages/index/index\",//tab名字\"text\":\"homePage\",//建议大小81*81不支持网络图片\"iconPath\":\"\",\"selectedIconPath\":\"\"]}}```>每一个小程序页面也可以使用`.json`文件对本页面的窗口表现进行配置页面配置项会覆盖`app.json`的`window`中相同的配置项>>[页面配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)##WXML语法###数据绑定>WXML中的动态数据均来自对应Page的data;数据绑定使用双大括号语法与Vue基本一致,但是也有些许不同,简单总结一下就是小程序中的页面里面所有的表达式都应在\\{\\{变量\\}\\}内部去做```html<view>{{message}}</view><!--绑定动态属性还是要用大括号--><viewclass=\"item-{{id}}\"></view>Page({data:{message:\"helloworld\",id:123}})```###[列表渲染](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html)```html<!--小程序内部会自动生成item和index--><viewwx:for=\"{{list}}\"wx:key=\"{{index}}\"><text>{{item.uname}}--{{item.uage}}</text></view>Page({data:{list:[{uname:'zs',uage:23},{uname:'ls',uage:24},{uname:'we',uage:25},{uname:'mz',uage:26}]}})```###条件渲染```html<viewwx:if=\"{{isShow}}\">是否渲染</view><viewwx:elif=\"{{!isShow}}\">分支判断</view><viewwx:else>否则</view>```##WXSS>WXSS(WeiXinStyleSheets)是一套样式语言，用于描述WXML的组件样式;>>WXSS具有CSS的大部分特性,为了更适合小程序开发,对CSS也做了对应的扩充和修改**尺寸单位(rpx)样式导入(@import)**##生命周期>小程序的生命周期分为三种,分别是`app``page``component`这里咱们只说一下前面的两种###App-`onLaunch`:监听小程序初始化-`onShow`:小程序启动时和后台切回前台的时候被调用-`onHide`:小程序切入到后台时调用```App({onLaunch(){console.log('onLaunch...');},onShow(){console.log('onShow...');},onHide(){console.log('onHide...');}})```###Page-`onLoad`:页面加载时触发,一个页面只会调用一次,可以在onLoad的参数中获取当前打开页面所携带的参数-`onShow`:页面显示时和切入前台时被调用-`onReady`:页面初次渲染完成时触发只调用一次类似于vue中的`Mounted`-`onHide`:页面隐藏和切入后台时调用,如`wx.navgationTo`或tab切换-`onUnload`:页面卸载时触发,如`wx.redirectTo`或`wx.navigationBack`到其他页面时```Page({//默认获取到的是空对象,如果传递有参数就是参数对象onLoad(params){console.log(params);},onShow(){console.log('page--onShow...');},onReady(){console.log('page--onReady...');},onHide(){console.log('page--onHide...');},onUnload(){console.log('page--onUnload...');}})```>App和Page之间的顺序为>>启动时:App`onLaunch``onShow`Page`onLoad``onShow``onReady`>>切后台:Page`onHide`App`onHide`>>切前台:App`onShow`Page`onShow`##事件```js;<buttontype='primary'bindtap='clickMe'>clickme</button>Page({clickMe(event){console.log(event)},})```##组件>个人理解这个组件可以理解为微信又基于一些HTML做了二次封装;这里内容比较多,但是大部分都不是很难,直接放链接吧,建议文档反复观看并实践[戳这里](https://developers.weixin.qq.com/miniprogram/dev/component/)##API>微信提供的接口还是比较多的这里也不说了详情看这里[👉](https://developers.weixin.qq.com/miniprogram/dev/api/base/wx.canIUse.html)###路由>介绍三个比较个人认为比较常用的api详细看这里[👉](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html)```jsPage({clickHandle(){//关闭当前页面,跳转到应用某个页面不能到tabBar页面wx.redirectTo({url:'/pages/index/index',})//保留当前页面,跳转到应用内某个页面不能到tabBar页面wx:navigateTo({url:'/pages/index/index',})//关闭当前页面,返回上一级或多级页面wx.navigateBack({delta:1,//数字大小代表回退几个页面})},})```##数据设置>在小程序中设置数据一定要使用`setData`方法设置-直接修改`this.data`而不调用`setData`是无法改变页面状态的,还会造成数据不一致-仅支持设置可JSON化的数据-单次设置的数据不能超过`1024KB`-不要把`data`中的任一数据设置为`undefined`,可能存在诡异的**bug**```js;<inputtype='text'bindinput='input'/>//双向绑定示例Page({data:{value:'',},input(event){this.setData({value:event.detail.value,})},})```##数据库>[mongoDB](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/capabilities.html#数据库)创建了一个`cloud-demo`的collection并且添加了一些数据下面我们读取一下试试![03](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2469b00725549a9a1d3c8077aa6cfc9~tplv-k3u1fbpfcp-zoom-1.image)```jsPage({onLoad(){//初始化数据库constdb=wx.cloud.database()db.collection('cloud-demo').get().then((res)=>console.log(res))//除了promise也可以使用回调函数db.collection('cloud-demo').get({success:function(res){console.log(res)},})},})```>这里给大家说一个小坑;有可能你们读取到的是一个空的数组,这是因为你创建的`collection`有权限问题;大家可以选择对应的`collection`然后勾选上方的**数据权限**然后选择对应的选线即可;##存储>云开发提供一块存储空间,提供上传文件到云端带权限管理的云端下载功能,可以使用小程序和云函数通过API使用云存储功能;这里我个人理解就像是一个静态资源服务器,可以用来存储一些图片等等;演示的话就暂时先演示小程序的上传下载吧```js;<buttontype='primary'bindtap='upload'>点击上传</button>Page({//上传文件upload(){wx.cloud.uploadFile({cloudPath:'这是填云控制台中存储模块下面的路径',filePath:'/images/create-collection.png',success(res){console.log(res)},})},//下载文件download(){wx.downloadFile({url:'https://xxx.png',//res中会包含tempPath找了半天没能保存到本地工程中的api都是保存到手机的尴尬success(res){console.log(res)},})},})```##云函数>云函数(云端运行的函数)功能独立,只需要编写函数代码并部署到云端可在小程序调用,同时云函数之间也可以互相调用;>>云函数写法与javascript写法基本一致,代码运行在云端的Node.js环境中,可以在这个环境中进行网络请求等操作,还可以通过云函数后端SDK搭配使用多种服务,比如使用云函数SDK中提供的数据库和存储API进行数据和存储的操作;>>云开发的原函数的独特优势在于与微信鉴权的无缝整合,当小程序调用云函数时,云函数的传入参数中会被注入小程序用户的openid,开发者无需校验openid的正确性因为微信已经完成了这部分鉴权,开发者可以直接使用openid;###云函数简单示例>找到项目根目录,在根目录上右键,右键菜单中选择新建Node.js云函数,名字符合规范即可,然后进入刚才新建的云函数中的index.js文件中-`wx-server-sdk`:帮助云函数中操作数据库,存储以及调用其他云函数的微信提供的库-`event`:触发云函数的事件,当小程序调用时event就是小程序调用云函数时传入的参数,外加后端自动注入的小程序用户的openid和appid-`context`:包含此处的调用信息和运行状态,可以用来了解服务运行的状态```js//云函数入口文件constcloud=require('wx-server-sdk')cloud.init()//云函数入口函数exports.main=async(event,context)=>{constwxContext=cloud.getWXContext()return{//比如这里我们顺便加个小功能sum:event.a+event.b,event,openid:wxContext.OPENID,appid:wxContext.APPID,unionid:wxContext.UNIONID,}}```云函数书写完成后,一定要记得鼠标右键在云函数目录上选择上传将云函数打包后在进行测试;>小程序中调用云函数```jsPage({onShow(){wx.cloud.callFunction({name:'testDemo',//云函数名称,文件夹名称,data:{//传入的参数a:1,b:2,},success(res){//结果集是放到result中的console.log(res.result)},})//也可以使用promise方式wx.cloud.callFunction({name:'testDemo',//云函数名称,文件夹名称,data:{//传入的参数a:1,b:2,},}).then((res)=>console.log(res.result))},})```当然还提供了很多的功能,这里就不细说了大家看文档比如**异步返回结果****使用npm****使用wx-server-sdk**大家可以重点先看下[戳这里](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html#云函数)##todoListDemo-实现了item的新增删除和更新使用了云函数的增删改这里查询就直接写到本地了-实现了获取个人信息>个人总结,感觉小程序写着好不方便,有点小坑,不过还是建议大家看一下,熟悉一下微信原生开发,毕竟小程序这个东西就是微信先出来的,下一步准备总结一些uni-app相关内容,个人感觉这个要好好看看了毕竟工作中相信大家很少写原生的小程序,肯定都是基于mpvue或者uni-app这些类vue框架或者类react框架去完成的工作;下面看一下效果吧![代码地址🤞](https://gitee.com/shuqingxuTest/wx-todo-list)##项目演示![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f64760e6b7ea463bb762fd6829f3f4ad~tplv-k3u1fbpfcp-watermark.image)","跨端\\小程序\\微信小程序\\获取用户信息.md":"#获取用户信息>[小程序用户头像昵称获取规则调整公告](https://developers.weixin.qq.com/community/develop/doc/00022c683e8a80b29bed2142b56c01)```tsxTaro.getUserProfile({lang:'zh_CN',desc:'获取你的昵称,头像,地区及性别',success:(res)=>{//console.log(\"userInfo:\",res.userInfo)constuserInfo=res.userInfo||{}//_this.handleUserInfo(userInfo)},fail:()=>{console.log('您拒绝了请求')return},})```","跨端\\小程序\\微信小程序\\错误\\600002.md":"#600002错误##情况1：未设置合法域名解决方法:请在微信公众平台登录小程序后台设置。##情况2：设置了合法域名，开发工具仍然报错解决方法:在右上角点击详情，之后刷新一下项目配置，看看有无域名信息，如果有了，清除全部缓存重新编译小程序，如果还是没有请确认是否设置合法域名。![](./.assets/60002-2022-07-28-09-54-25.png)##情况3：设置了合法域名，开发工具不报，真机调试和体验版报这种情况一般开发工具正常运行，真机调试和体验版不行，因为之前使用过真机调试和发布体验版，在测试机上留下缓存解决方法:手机微信下拉找到最近使用的小程序，长按之后拖到底部删除，然后重新尝试真机调试和体验版。##情况4：设置了合法域名，到哪都报错，清缓存也没用解决方法:请确认访问该域名时，是否会出现重定向，将重定向域名添加进合法域名##情况5：设置了合法域名（含重定向），到哪都报错，清缓存也没用解决方法:请确认访问该域名是否是三级域名，请设置为一级或二级域名##情况6：以上所有解决方案都不行解决方法:请在微信小程序平台反馈bug"}